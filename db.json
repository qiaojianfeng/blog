{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/algolia.svg","path":"img/algolia.svg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1616683660965},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"9a94875cbf4c27fbe2e63da0496242addc6d2876","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1616683667605},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1616683667605},{"_id":"source/_posts/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e5-91-a8-e8-be-b9-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8.md","hash":"1aa7b4ade9831e3369f1f60ddc28914ee2a8b2e4","modified":1568257175936},{"_id":"source/.DS_Store","hash":"c35289386a0d24035888f848a6dd06d542112cc2","modified":1616687701222},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1616683896269},{"_id":"source/_posts/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e5-9f-ba-e7-a1-80-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8.md","hash":"b8ee9f6cf47f382ac6234dd64570b65478853663","modified":1568257189360},{"_id":"source/_posts/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e7-ac-ac-e4-b8-89-e6-96-b9-e5-ba-93-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8.md","hash":"c4fa14c0944afbf2e06668a785c40686b0f41167","modified":1568257193939},{"_id":"source/_posts/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86css-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8.md","hash":"311b061b44c96acace6e57ec2e613cea1aa9bb1c","modified":1568257199996},{"_id":"source/_posts/2019-e7-a5-9e-e5-89-a7-e6-8e-a8-e8-8d-90-e8-b1-86-e7-93-a3-e8-af-84-e5-88-869-3-e3-80-8a-e7-88-b1-ef-bc-8c-e6-ad-bb-e4-ba-a1-e5-92-8c-e6-9c-ba-e5-99-a8-e4-ba-ba-e3-80-8b.md","hash":"416368953998e53422a288ce576772ccb10ef0dd","modified":1568101568739},{"_id":"source/_posts/204.md","hash":"c5b3ce1c9c1eb29c979d07a46a8a76747d50bca1","modified":1568101568740},{"_id":"source/_posts/console-e5-af-b9-e8-b1-a1-e4-b8-8e-e6-8e-a7-e5-88-b6-e5-8f-b0-e8-af-a6-e8-a7-a3.md","hash":"c6df0be13ebe352666a514e6007dfc395edc181d","modified":1568101568741},{"_id":"source/_posts/e3-80-90-e8-8b-b9-e6-9e-9ccms-v10-e3-80-91-e4-bb-bf-e4-bc-98-e9-85-b7-e6-a8-a1-e6-9d-bfpc-e5-ae-8c-e7-be-8e-e4-bf-ae-e5-a4-8d-e7-89-88.md","hash":"dc0039b76e1685433d6fe5bd16ef8ab6e6f7cc91","modified":1568101568737},{"_id":"source/_posts/e3-80-90-e8-a7-86-e9-a2-91-e3-80-918-e5-a4-a9-e4-bb-8e-e5-b0-8f-e7-99-bd-e5-88-b0-e5-a4-a7-e7-a5-9e-e8-9c-95-e5-8f-98-e7-a7-98-e7-b1-8d-e4-b9-8bphotoshop.md","hash":"7fe0aa436483f14f63b20c91ea4bb99373ffc2a6","modified":1568171135448},{"_id":"source/_posts/e4-b8-80-e6-96-87-e6-90-9e-e5-ae-9a-e5-89-8d-e7-ab-af-jenkins-e8-87-aa-e5-8a-a8-e5-8c-96-e9-83-a8-e7-bd-b2.md","hash":"64e2c0bd9c16a4172ec8b8d03b0b574a3e4ebf47","modified":1568101568741},{"_id":"source/_posts/e4-bc-a0-e8-af-b4-e4-b8-ad-e5-9b-be-e7-89-87-e9-98-b2-e7-9b-97-e9-93-be-e7-9a-84-e7-88-b1-e6-81-a8-e6-83-85-e4-bb-87.md","hash":"8db4a7725684ee574c45f227df8f52a61a7c976d","modified":1568101568740},{"_id":"source/_posts/e5-85-a5-e9-97-a8-e7-af-87-e5-a6-82-e4-bd-95-e7-94-a8javascript-e5-ae-9e-e7-8e-b0-e4-b8-80-e4-b8-aa-e6-a8-a1-e6-9d-bf-e5-bc-95-e6-93-8e.md","hash":"bce1cc16f2c5372c068b811bd94c47e486436649","modified":1568101568737},{"_id":"source/_posts/e5-85-b3-e4-ba-8ewordpress-e4-b8-bb-e9-a2-98vieu-e4-bb-a5-e5-8f-8a-e5-85-b6-e4-bb-96-e4-b8-bb-e9-a2-98-e4-be-a7-e6-a0-8fcss-e6-a0-b7-e5-bc-8f-e6-a1-86-e9-85-8d-e7-bd-ae-e6-95-99-e7-a8-8b.md","hash":"68527dc0b4331b82ffa7d05f5cb3d0451d891c43","modified":1568171559702},{"_id":"source/_posts/e5-88-86-e4-ba-ab-e4-b8-80-e4-b8-8bsass-e5-a4-84-e7-90-86-e7-9a-84-e6-9b-b4-e9-ab-98-e7-ba-a7-e5-aa-92-e4-bd-93-e6-9f-a5-e8-af-a2.md","hash":"f4c024162919359f5c0126165b4f2ecc0291e2c0","modified":1568101568737},{"_id":"source/_posts/e5-88-86-e4-ba-ab-e7-bd-91-e7-bb-9c-e5-b0-8f-e6-b8-b8-e6-88-8f-e5-90-88-e9-9b-86-e6-98-9f-e7-9b-8a-e6-89-8b-e6-9c-ba-e7-94-b5-e8-84-91-e5-b0-8f-e6-b8-b8-e6-88-8f-e5-b9-b3-e5-8f-b0-e7-bd-91-e9-a1-b5.md","hash":"c183e84506720817dcd5831a0c2f56489f3c83c4","modified":1568191593010},{"_id":"source/_posts/e5-88-86-e6-9e-90-e5-be-ae-e4-bf-a1-e5-85-ac-e4-bc-97-e5-8f-b7-localstorage-e7-bc-93-e5-ad-98-e6-9c-ba-e5-88-b6.md","hash":"1415368062077a30577df0785cd7cc632df1affc","modified":1568101568740},{"_id":"source/_posts/e5-89-8d-e7-ab-af-e5-b0-8f-e7-99-bd-e5-85-a5-e9-97-a8-e4-b9-8b-e5-86-8d-e5-ad-a6javascript-e4-b8-80.md","hash":"2ca45330c9a5107391f2c6ae3c64996d533dc54b","modified":1568101568737},{"_id":"source/_posts/e5-89-8d-e7-ab-af-e5-b0-8f-e7-99-bd-e5-85-a5-e9-97-a8-e4-b9-8b-e5-86-8d-e5-ad-a6javascript-e4-ba-8c.md","hash":"8e6fc9058676897fe19efe18cad22cd9050247c3","modified":1568101568737},{"_id":"source/_posts/e5-93-aa-e5-90-92-e4-b9-8b-e9-ad-94-e7-ab-a5-e9-99-8d-e4-b8-96-e9-ab-98-e6-b8-85-e5-9c-a8-e7-ba-bf-e6-92-ad-e6-94-be-hd-e9-ab-98-e6-b8-85.md","hash":"c41a193ff593411e561e9be98f2cb5ede504986b","modified":1568101568741},{"_id":"source/_posts/e5-9b-bd-e5-a4-96cloudflare-e5-85-8d-e8-b4-b9cdn-e5-8a-a0-e9-80-9f-e5-8f-8a-e9-98-b2-e6-8a-a4-e6-b3-a8-e5-86-8c-e4-bd-bf-e7-94-a8-e6-95-99-e7-a8-8b.md","hash":"48218bfb47d12fb3fa0d1a5fe0613bc0f66e5a54","modified":1568171168389},{"_id":"source/_posts/e5-a4-8d-e4-bb-87-e8-80-85-e8-81-94-e7-9b-9f4-ef-bc-9a-e7-bb-88-e5-b1-80-e4-b9-8b-e6-88-98bd4k-e8-8b-b1-e8-af-ad-e5-ae-98-e6-96-b9-e7-89-b9-e6-95-88-e4-b8-ad-e8-8b-b1-e5-8f-8c-e5-ad-97-e7-99-be.md","hash":"7a2647aea36c4ad6af5b43e186171fade45bfb0c","modified":1568101568741},{"_id":"source/_posts/e5-a4-a7-e5-9e-8b-e9-a1-b9-e7-9b-ae-e5-89-8d-e7-ab-af-e6-9e-b6-e6-9e-84-e8-af-a6-e8-b0-88.md","hash":"f744bdd0788a2676750555444621e48c21b14fe2","modified":1568101568739},{"_id":"source/_posts/e5-a6-82-e6-ad-a4-e7-81-ab-e7-88-86-e7-9a-84-e8-87-aa-e8-b5-b0-e6-a3-8b-e6-89-8b-e6-b8-b8-ef-bc-8c-e5-81-9a-e5-be-97-e7-a9-b6-e7-ab-9f-e6-80-8e-e4-b9-88-e6-a0-b7-ef-bc-9f.md","hash":"24531876eeb21424569773ea274376f675b51bdb","modified":1568101568737},{"_id":"source/_posts/e5-b0-8f-e6-b6-b4-e7-86-8a-e6-bc-ab-e7-94-bbcms-e5-bc-80-e6-ba-90-e5-85-8d-e8-b4-b9-e7-9a-84-e9-87-87-e9-9b-86-e6-bc-ab-e7-94-bb-e8-bf-9e-e8-bd-bd-e7-b3-bb-e7-bb-9f-ef-bc-8c-e5-b8-a6-e9-87-87.md","hash":"d9ba785c53e6532d78a42a68e3e22c30eaf9f1f0","modified":1568101568736},{"_id":"source/_posts/e5-bc-80-e5-8f-91linux-e8-bf-90-e7-bb-b4-e4-ba-ba-e5-91-98-e6-9c-80-e5-b8-b8-e7-94-a8166-e4-b8-aa-e5-91-bd-e4-bb-a4-e6-b1-87-e6-80-bb.md","hash":"d7c941c3a480dc1f0fdd0e1770208d870adb942d","modified":1568101568741},{"_id":"source/_posts/e6-83-8a-e5-a5-87-e9-98-9f-e9-95-bfbd1080p-e8-b6-85-e6-b8-85-e7-89-b9-e6-95-88-e4-b8-ad-e6-96-87-e5-ad-97-e5-b9-95-e8-bf-85-e9-9b-b7-e5-9c-a8-e7-ba-bf-e4-b8-8b-e8-bd-bd.md","hash":"a144bff8ed6044a3a135a6754ff49796b9ce7fcf","modified":1568101568739},{"_id":"source/_posts/e6-83-8a-e9-ad-82-e7-94-b5-e5-bd-b1-e9-99-a2-1080p-e8-b6-85-e6-b8-85mp4.md","hash":"a6eaadd91c8e4b6988bc294393a7432da37cba78","modified":1568101568740},{"_id":"source/_posts/e6-89-8b-e6-91-b8-e6-89-8b-e6-95-99-e4-bd-a0-e6-92-b8-e4-b8-80-e4-b8-aa-e8-84-9a-e6-89-8b-e6-9e-b6.md","hash":"8f13b1e7f97886bd5d3f63a89e70ba39248bd4a1","modified":1568101568741},{"_id":"source/_posts/e6-95-99-e4-bd-a0-e5-bf-ab-e9-80-9f-e6-92-b8-e4-b8-80-e4-b8-aa-e5-85-8d-e8-b4-b9https-e8-af-81-e4-b9-a6.md","hash":"77ba25619125eab8bc89254569b8909d1e02ed9c","modified":1568101568738},{"_id":"source/_posts/e6-95-99-e4-bd-a0-e6-90-ad-e5-bb-ba-e4-b8-80-e5-a5-97-e5-b1-9e-e4-ba-8e-e8-87-aa-e5-b7-b1-e7-9a-84-e8-a7-86-e9-a2-91-e7-bd-91-e7-ab-99-e5-b0-8f-e7-99-bd-e6-95-99-e7-a8-8b-e5-a4-a7-e7-a5-9e-e7-bb-95.md","hash":"f7a019a8a03154ff90aa6c160e590b27908ee758","modified":1568101568739},{"_id":"source/_posts/e6-96-b0-e6-b8-b8-e6-b4-be-e6-9c-ac-e5-91-a8-e4-b8-8d-e5-ae-b9-e9-94-99-e8-bf-87-e7-9a-84-5-e6-ac-be-e6-96-b0-e6-b8-b8-e6-88-8f.md","hash":"8ee5f5b57b1d0a86086bebecbdd151fb3dd943e1","modified":1568101568739},{"_id":"source/_posts/e6-9c-80-e6-96-b0-e7-89-88-xyplayer-e6-99-ba-e8-83-bd-e8-a7-a3-e6-9e-90-x3-8-e6-ad-a3-e5-bc-8f-e7-89-88-e5-88-86-e4-ba-ab.md","hash":"dc0dc4099cebe8d2ff664f8d3665418c8c483ed2","modified":1568171584788},{"_id":"source/_posts/e6-9c-80-e6-96-b0-e7-9f-a5-e5-ae-87-e8-87-aa-e5-8a-a8-e5-8f-91-e5-8d-a1-e7-b3-bb-e7-bb-9f-e6-ba-90-e7-a0-81-e5-b7-b2-e9-9b-86-e6-88-90-e5-bd-a9-e8-99-b9-e6-98-93-e6-94-af-e4-bb-98.md","hash":"3d915c7b74c95da5819a8f2c5e8e042159565c07","modified":1568191575092},{"_id":"source/_posts/e6-9c-80-e9-95-bf-e4-b8-80-e6-9e-aa-hdtc-e5-9b-bd-e8-af-ad-e4-b8-ad-e5-ad-97-e7-89-88-e6-9c-80-e6-96-b0-e4-b8-8a-e6-9e-b6.md","hash":"3aa1560a3401e2e7d75f7fb37f4b4badb5e5e86a","modified":1568191204865},{"_id":"source/_posts/e6-9c-89-e4-ba-86-e8-bf-99-e4-bb-bd-e4-b8-8a-e7-8f-ad-e6-91-b8-e9-b1-bc-e6-8c-87-e5-8d-97-ef-bc-8c-e4-b8-8d-e7-94-a8-e5-86-8d-e6-80-95-e5-b7-a5-e4-bd-9c-e3-80-8c-e5-88-92-e6-b0-b4-e3-80-8d-e8-a2-ab.md","hash":"1fdb8b565904b5a24723bbfb8bc59a9d094dada2","modified":1568101568738},{"_id":"source/_posts/e6-9e-81-e9-80-9f-e7-89-88-e8-b0-b7-e6-ad-8c-e8-ae-bf-e9-97-ae-e5-8a-a9-e6-89-8bv2-3-0-e7-a0-b4-e8-a7-a3-e7-89-88.md","hash":"5cf9339c8ac4d4a9e3b6d4d40151063e9d95fbe8","modified":1568190630159},{"_id":"source/_posts/e6-a0-87-e7-ad-be-e9-a1-b5-e7-ae-a1-e7-90-86-e3-80-81-e9-9a-90-e7-a7-81-e4-bf-9d-e6-8a-a4-e3-80-81-e5-88-92-e8-af-8d-e6-90-9c-e7-b4-a2-e8-bf-99-10-e6-ac-be-e6-96-b0-e6-89-a9.md","hash":"8e58aa4372220de7ea826071759f4603748451da","modified":1568171270066},{"_id":"source/_posts/e8-8b-8f-e9-86-92grace8-0-e5-8e-bb-e6-8e-88-e6-9d-83-e7-a0-b4-e8-a7-a3-e7-89-88-wordpress-e4-b8-bb-e9-a2-98.md","hash":"bd09daa0c6551f194e7dcb9bb0c54cc59562bc1c","modified":1568171285117},{"_id":"source/_posts/e8-8b-b9-e6-9e-9c-e5-85-ac-e5-b8-83-2019-e5-b9-b4-e5-ba-a6-e8-ae-be-e8-ae-a1-e5-a4-a7-e5-a5-96-ef-bc-8c-e8-bf-99-9-e6-ac-be-app-e6-98-af-e4-bb-8a-e5-b9-b4-e7-9a-84-e8-b5-a2-e5-ae-b6.md","hash":"edb05db3b5ab34b4270b3a5956b0505632953a0f","modified":1568171291779},{"_id":"source/_posts/e8-8b-b9-e6-9e-9ccms-e7-a8-8b-e5-ba-8f-e6-9c-80-e6-96-b0-e6-ba-90-e7-a0-81-e8-8e-b7-e5-8f-96-e5-8f-8a-e8-a7-86-e9-a2-91-e8-a7-a3-e6-9e-90-e6-8e-a5-e5-8f-a3-e5-88-86-e4-ba-ab.md","hash":"6713de13df5e9954243ba037b94b14309a0db953","modified":1568191549769},{"_id":"source/_posts/e8-8b-b9-e6-9e-9ccmsv10-e5-b9-95-e4-b9-94-e9-85-b7-e9-bb-91-e6-a8-a1-e6-9d-bf-e5-85-8d-e6-8e-88-e6-9d-83-e7-a0-b4-e8-a7-a3-e7-89-88.md","hash":"4646e63294eab94317fa964d39ef74a4dcae89b8","modified":1568101568737},{"_id":"source/_posts/e8-a7-a3-e5-86-b3vue-e5-8d-95-e9-a1-b5-e9-9d-a2-e5-ba-94-e7-94-a8-e5-9c-a8-e5-be-ae-e4-bf-a1-e7-ad-89app-e9-87-8c-e9-9d-a2-e6-97-a0-e6-b3-95-e8-ae-be-e7-bd-aetitle-e9-97-ae-e9-a2-98.md","hash":"3e5536a882249f1b552a62ecb2a2226459e00eee","modified":1568101568741},{"_id":"source/_posts/e8-af-b4-e8-af-b4-e5-88-b0-e5-ba-95-e4-bb-80-e4-b9-88-e6-98-af-bt-e7-a7-8d-e5-ad-90.md","hash":"ba4df6ff90051dad7f7a8345826aae3bd1bd306e","modified":1568101568740},{"_id":"source/_posts/e9-a6-96-e6-b6-82-e7-ae-80-e7-ba-a6seo-e6-a8-a1-e6-9d-bf-ef-bc-8c-e5-8e-bb-e9-a6-96-e9-a1-b5-e5-b9-bf-e5-91-8a-e8-84-9a-e6-9c-ac.md","hash":"9e53a63e5af7e8844620d3253fdbbe3b5f864404","modified":1568171310666},{"_id":"source/_posts/eslint-e9-85-8d-e7-bd-ae-e5-8f-82-e8-80-83-e4-b8-ad-e6-96-87-e8-a7-a3-e9-87-8a.md","hash":"4628f0bb8a1f9a6d1bd397d5a9310b9cc24e8578","modified":1568101568740},{"_id":"source/_posts/git-e5-ad-a6-e4-b9-a0-e5-86-8d-e5-85-a5-e9-97-a8-e5-91-bd-e4-bb-a4-e6-b8-85-e5-8d-95.md","hash":"d8ae868a8d241cbbc1088cb45134d1bde081997f","modified":1568101568740},{"_id":"source/_posts/git-e5-ad-a6-e4-b9-a0-e5-86-8d-e5-85-a5-e9-97-a8-e5-9f-ba-e7-a1-80-e7-af-87.md","hash":"fc72968652c5dcb3901fe2db74ff328b125f8f73","modified":1568101568740},{"_id":"source/_posts/git日常操作.md","hash":"25646566a9cc571e5021cdfc9f0255129bb1d3a0","modified":1578983972220},{"_id":"source/_posts/ios-13-e4-b8-8d-e5-8f-aa-e6-9c-89-e6-b7-b1-e8-89-b2-e6-a8-a1-e5-bc-8f-ef-bc-8c-e8-bf-99-15-e4-b8-aa-e6-96-b0-e5-8a-9f-e8-83-bd-e5-90-8c-e6-a0-b7-e5-80-bc-e5-be-97-e5-85-b3-e6-b3-a8.md","hash":"45b59feaa5c1bbbb1d90996758c0022d7a8d2f9a","modified":1568171320179},{"_id":"source/_posts/ios-ef-bc-88-e8-8b-b9-e6-9e-9c-ef-bc-89-e9-92-89-e9-92-89-e8-99-9a-e6-8b-9f-e4-bd-8d-e7-bd-ae-e6-89-93-e5-8d-a1-e6-96-b9-e6-b3-95.md","hash":"b2c14e4857a45f2ea4bf7b23c1a56d6fda440d55","modified":1568101568740},{"_id":"source/_posts/javascript-e9-94-99-e8-af-af-e6-9c-ba-e5-88-b6-e5-a4-84-e7-90-86.md","hash":"f8c18780538e2eee01e0588569518e16611ca0ab","modified":1568101568740},{"_id":"source/_posts/mongo-e5-85-a5-e9-97-a8-1-e5-8e-9f-e7-90-86.md","hash":"7c9049f72ee8c2ed3411bd8a569367f7f73c27da","modified":1568101568737},{"_id":"source/_posts/mongo-e5-85-a5-e9-97-a8-2-e5-9f-ba-e6-9c-ac-e6-93-8d-e4-bd-9c.md","hash":"56de3181a83e27a6559a4899419cd6c25335c66a","modified":1568101568737},{"_id":"source/_posts/nodecache-e5-85-8d-e5-a4-87-e6-a1-88cdn-e6-b3-a8-e5-86-8cz-e5-8d-b3-e9-80-811t-e5-85-8d-e8-b4-b9-e5-8a-a0-e9-80-9f-e6-b5-81-e9-87-8f.md","hash":"653f05aaf87da52edb5f247bc3c1932c284f4a89","modified":1568101568740},{"_id":"source/_posts/office2019-e5-85-89-e7-9b-98-e9-95-9c-e5-83-8f-e4-b8-8b-e8-bd-bd.md","hash":"a3433f5f9f375c422c2b9e6eec64511f9c94b893","modified":1568171333882},{"_id":"source/_posts/vip-e5-bd-b1-e8-a7-86app-e6-ba-90-e7-a0-81-ef-bc-8c-e5-b8-a6-e5-95-86-e5-9f-8e-e7-b3-bb-e7-bb-9f-ef-bc-8c-e5-ae-89-e5-8d-93-e8-8b-b9-e6-9e-9c-e5-8f-8c-e7-ab-af-ef-bc-8c-e5-85-a8-e6-96-b0-e7-9a-84.md","hash":"889051fff3ab768a46cb955a18c6c3e9559d9186","modified":1568171343861},{"_id":"source/_posts/vue-mini-player-e5-9f-ba-e4-ba-8evue-e7-9a-84-e4-b8-80-e4-b8-aa-e8-bd-bb-e9-87-8f-e7-ba-a7html5-e8-a7-86-e9-a2-91-e6-92-ad-e6-94-be-e5-99-a8.md","hash":"3ee64a333fcdee61e2c12ed83e9377ad7f7a86a0","modified":1568101568741},{"_id":"source/_posts/vue-router源码了解一下.md","hash":"aa9ebc643d571aef34b4d91f3c9f54cbd9e70fa8","modified":1584005397115},{"_id":"source/_posts/vue响应式更新个人实现.md","hash":"2c0f6b837b9583219e7ad9bc851123fdf1602ca4","modified":1577695718357},{"_id":"source/_posts/web-e5-ae-9e-e7-8e-b0-e5-89-8d-e5-90-8e-e7-ab-af-e5-88-86-e7-a6-bb-ef-bc-8c-e5-89-8d-e5-90-8e-e7-ab-af-e8-a7-a3-e8-80-a6.md","hash":"75746a7181f4bcda01b8c334377c1430d8f8bf21","modified":1568101568741},{"_id":"source/_posts/wordpress-e7-99-be-e5-ba-a6-e7-86-8a-e6-8e-8c-e5-8f-b7-e5-8e-9f-e5-88-9b-e6-8e-a8-e9-80-81-e6-8f-92-e4-bb-b6-ef-bc-9afanly-submit-e4-b8-8b-e8-bd-bd.md","hash":"c55e95cb4d171ab8193789cb58f85fc230fea4d9","modified":1568101568740},{"_id":"source/_posts/wordpress.md","hash":"b8047926730d27af571bff421ff9390992a8da16","modified":1568171362738},{"_id":"source/_posts/一般插件开发规范结构.md","hash":"058f03bd9b7431e3a5069f0063d90479bf5d8515","modified":1569411756099},{"_id":"source/_posts/了解一些HTTP协议相关知识.md","hash":"e68736874fb9d39ad5c0609fb34ab1aaa59c3ca7","modified":1578038635613},{"_id":"source/_posts/使徒行者-在线播放.md","hash":"3989d6a9b2ed646dbba3398500cba1e9f867883b","modified":1578454373414},{"_id":"source/_posts/前端问答.md","hash":"75de907cd05fd99487db8b1bae96570a1964defc","modified":1568288401495},{"_id":"source/_posts/前端问答2.md","hash":"9f69d7c50f5b6d53bbf14cf60ae6d29010256daa","modified":1570708067228},{"_id":"source/_posts/微信小程序云开发初体验.md","hash":"575c8b7a75391cfab551b16b54a7eddc93425998","modified":1574244152738},{"_id":"source/_posts/理解RESTful没有那么难.md","hash":"0c7c5190b744b11ca0b43c021c3837f28cb98585","modified":1574404921152},{"_id":"source/_posts/电影-中国机长.md","hash":"1b8ebb96c130e81862d007932084c2df42479d10","modified":1570767533859},{"_id":"source/_posts/蜘蛛侠-英雄远征.md","hash":"3cbbe0c3c17f49f176845f5f97a63a9c107a18ec","modified":1568717047855},{"_id":"source/_posts/高清在线直播-1.md","hash":"5a595f69bb8ccbb0a5d2364ae6c18d5c3db9608d","modified":1578455419159},{"_id":"source/_posts/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86javascript-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8.md","hash":"78abd09b5cc9900b71021fdadf0d97f44c21f179","modified":1568257204026},{"_id":"themes/butterfly/LICENSE","hash":"1128f8f91104ba9ef98d37eea6523a888dcfa5de","modified":1616682757297},{"_id":"themes/butterfly/README.md","hash":"32ada08cfe64b38f8d5ac5de31cfb92956ff407c","modified":1616682757297},{"_id":"themes/butterfly/README_CN.md","hash":"dc38de6a558b66e05188fc62c5047ec982a74ff3","modified":1616682757297},{"_id":"themes/butterfly/package.json","hash":"b643828c091aff404262dea3ae0b9301c5260634","modified":1616682757328},{"_id":"themes/butterfly/.github/stale.yml","hash":"05a55a87fa7f122c59683e41c8b2e37e79f688f0","modified":1616682757296},{"_id":"themes/butterfly/languages/default.yml","hash":"7ca673fb629ea74f5ba5e75b4f0f95248cfb5090","modified":1616682757298},{"_id":"themes/butterfly/_config.yml","hash":"f94af3be4a1fdd401dde66a462c53b071c8fe39a","modified":1616682757298},{"_id":"themes/butterfly/layout/404.pug","hash":"58cfa5985e58e10c97a9f8a9dc354f1c766154b3","modified":1616682757298},{"_id":"themes/butterfly/layout/archive.pug","hash":"bd62286afb64a51c97e800c5945620d51605d5fa","modified":1616682757299},{"_id":"themes/butterfly/languages/en.yml","hash":"cd333235ff1648a6bf58dfafc81f2c57672a15a5","modified":1616682757298},{"_id":"themes/butterfly/layout/category.pug","hash":"60c1b795b6e227b5dd81963b51d29d1b81d0bf49","modified":1616682757299},{"_id":"themes/butterfly/layout/index.pug","hash":"e1c3146834c16e6077406180858add0a8183875a","modified":1616682757327},{"_id":"themes/butterfly/layout/page.pug","hash":"82aa988527a11835e7ac86ce4f23b8cd20014dfa","modified":1616682757327},{"_id":"themes/butterfly/layout/post.pug","hash":"8d398c8925182699d9f2b9f1b727f06228488312","modified":1616682757328},{"_id":"themes/butterfly/layout/tag.pug","hash":"0440f42569df2676273c026a92384fa7729bc4e9","modified":1616682757328},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"741e522b2387f94764a73844e7b084cc7e927c54","modified":1616682757298},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"79a50c40d9f5463f1fa42aa870ac6b8b84540412","modified":1616682757298},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"476802922b774b679225102ac30a9d9183394701","modified":1616682757295},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"eff495eb1584cf4586e33c76e8b2fa6a469a179b","modified":1616682757296},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"4156224c47bfc2482281ac4e4df701c30476ff00","modified":1616682757299},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"02390a5b6ae1f57497b22ba2e6be9f13cfb7acac","modified":1616682757299},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"76d672c91f6bb6f20c6936e05067c42f7917ac61","modified":1616682757303},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"aa105ea4eaecc951f7474b549b6ac0095a5fab1f","modified":1616682757299},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"ec7ba875aaa2b95ab9d8256bd21c1e006bbe2820","modified":1616682757306},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"2b34e587030516afe2faf1a8cb20aebaead012f1","modified":1616682757307},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"2d0453adf92a3fd3466cf0793f14685d17b8b51d","modified":1616682757307},{"_id":"themes/butterfly/scripts/events/init.js","hash":"43b245c308797c2d62cb70429a85f1a05d3395ab","modified":1616682757329},{"_id":"themes/butterfly/scripts/events/404.js","hash":"3c30dbd8b910ce7d8d7d8353cf2266cbc5d8775d","modified":1616682757329},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"d575137c8779e50422c2416f4d0832fdea346ee6","modified":1616682757329},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"e9cf275c362d8634f093e63068da7ed1e53c7600","modified":1616682757330},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"9821872007cf57efae4b728dc575ef9d004547bb","modified":1616682757330},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"2ec66513d5322f185d2071acc052978ba9415a8e","modified":1616682757331},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"e00efdb5d02bc5c6eb4159e498af69fa61a7dbb9","modified":1616682757331},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"81459adf885a15c6e9784bc2275c07efe67ab0b4","modified":1616682757331},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"1da73cd47b78c6dbc3f04ce500d6cc5711c94412","modified":1616682757332},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"0d8ba6120dce617a2a1fbc9167572db2ee9f22ef","modified":1616682757332},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"e75283267f3a4773e6d803593d557e218396f260","modified":1616682757333},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"94826ea6bcc4d2304199adae12c4e2b272caf529","modified":1616682757333},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"f33858ffb9e88191e644796e11d2f901eb332308","modified":1616682757333},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"a43ee2c7871bdd93cb6beb804429e404570f7929","modified":1616682757334},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"35f073021db93699fcac9ef351e26c59c31aadf7","modified":1616682757334},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"c16c6eb058af2b36bcd583b2591076c7ebdd51ad","modified":1616682757334},{"_id":"themes/butterfly/source/css/index.styl","hash":"861998e4ac67a59529a8245a9130d68f826c9c12","modified":1616682757352},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"6c6e415623d0fd39da016d9e353bb4f5cca444f5","modified":1616682757334},{"_id":"themes/butterfly/source/css/var.styl","hash":"40c3f64422205a24e68ce1ad8fe8163f24fdd525","modified":1616682757352},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"f6867a2f0417fe89a0f2008730ee19dd38422021","modified":1616682757296},{"_id":"themes/butterfly/source/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1616682757355},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"05857c2f265246d8de00e31037f2720709540c09","modified":1616682757296},{"_id":"themes/butterfly/source/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1616682757353},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1616682757353},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"44d231314d4bfffdb93096c1fa18d05de7293267","modified":1616682757302},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"24370508ee87f14418e8f06e9d79ad8c52a342c4","modified":1616682757302},{"_id":"themes/butterfly/source/js/main.js","hash":"8b670bed658cf879e37a12d9fda064cf4b55cc3f","modified":1616682757360},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1616682757361},{"_id":"themes/butterfly/source/js/utils.js","hash":"41481019ef510c74e744f4f7ec4d0a13b5ccc04c","modified":1616682757362},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"c205b9fd72b2fe19e6d15c5b5ab0fb38c653032e","modified":1616682757303},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"92f81a437c9db49f7ebcf608bc09488ecdb55a21","modified":1616682757303},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"0d953e51d04a9294a64153c89c20f491a9ec42d4","modified":1616682757303},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"6c41f49a3e682067533dd9384e6e4511fc3a1349","modified":1616682757300},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"90d01b88d0f406d00184960b1afe9230aec2ebe6","modified":1616682757300},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"4def0aab9e2172ad1f29abd1535d8e08ff23aa0b","modified":1616682757300},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"798dbbe9146e8e2379b39a49acf8c8a1eeabb8fb","modified":1616682757300},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"95a37e92b39c44bcbea4be7e29ddb3921c5b8220","modified":1616682757301},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"d16ad2ee0ff5751fd7f8a5ce1b83935518674977","modified":1616682757301},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"e55f8bdb876d5429a908498db1307b94094c0d06","modified":1616682757301},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"3d492cfe645d37c94d30512e0b230b0a09913148","modified":1616682757301},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"62cf37e28795d8b68a0e850ec8c94987b9e08db5","modified":1616682757302},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"4cfcf0100e37ce91864703cd44f1cb99cb5493ea","modified":1616682757304},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"5276937fbcceb9d62879dc47be880cd469a27349","modified":1616682757304},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"68dfd3c6a0f00b3ffc0333c81e165b4626f7425f","modified":1616682757304},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"6058de23612ab1ed17d2ad93f5866d5f745135f0","modified":1616682757305},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"1f30952fed73dec21b42e2e30b7fe2e84618d2e4","modified":1616682757305},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"dbec869c62135695495703a29ad7655e9965d461","modified":1616682757305},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"45f0d36b1ac686b5984909dae55d3c522f549c3a","modified":1616682757305},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"93d4ebc7dc8228c7a10ddeb5a553d0dcdabbe145","modified":1616682757306},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"88e3b611b03149665e4113cfa39595c1a3fca7e5","modified":1616682757306},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"edebe930a2e3c4a4de5a35b9c1b1409cdd401372","modified":1616682757307},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"292646dfab135973b09f0fa9e3931e83da2ed30e","modified":1616682757307},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"b9d54a01d7c2a7a183cb7209e99430ce7fea1fe3","modified":1616682757314},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d5fec7dedc52ab23865fb4db002755e9bdaadc9f","modified":1616682757319},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"5e3c9d25298ae3025b59dd4cb080259c0f8fab78","modified":1616682757320},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"1fbecfd299068f90d727f0c8c65e2a792fa6e3e2","modified":1616682757320},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"d50e5c22cd6bc3c378bc581918136746cfa3447f","modified":1616682757322},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"60dc48a7b5d89c2a49123c3fc5893ab9c57dd225","modified":1616682757323},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"3d8e3706a056389176f55dd21956aabc78046761","modified":1616682757323},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"86897010fe71503e239887fd8f6a4f5851737be9","modified":1616682757324},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"3e4e83a41a444f7454ff682620369a8af1f960c9","modified":1616682757324},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"d1a416d0a8a7916d0b1a41d73adc66f8c811e493","modified":1616682757324},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"36b368516b5a746be84a6aa08767ee24d220d509","modified":1616682757325},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"ae9336bf31cdad08ff586ead4295912a96563c76","modified":1616682757325},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"e356f916ceb28702812d8f66c1fea0ae75eece47","modified":1616682757325},{"_id":"themes/butterfly/layout/includes/widget/card_self.pug","hash":"a1b2f5575b6804c5c4b9288db143b5164cbbd289","modified":1616682757326},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"438aea3e713ed16b7559b9a80a9c5ec0221263df","modified":1616682757326},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"0612aaee878f33ea8d3da0293c7dc3b6cd871466","modified":1616682757326},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"9e91f2543ab39815309268d07ae248a78887acf9","modified":1616682757327},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"eda47f3e807a466ba8275627ea936c5100c43818","modified":1616682757336},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"6ba9dcda7ff1ceda4e07c8c08517259e8b7dbcd5","modified":1616682757336},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"ce3d0c8984c8a46e3c8e1727806bb4d37ff3e2d4","modified":1616682757338},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"fa7a4c1685f391d60ed863e869b9604b59746c27","modified":1616682757340},{"_id":"themes/butterfly/source/css/_layout/404.styl","hash":"d6548e332e6e57e2a7ba2eb53cdd838c3cd1846d","modified":1616682757340},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"6317bc18152e474b8faa7994fc5fbc3c9e455a84","modified":1616682757340},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"29f48f9370f245e6e575b5836bccf47eb5688d8b","modified":1616682757340},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"f1b63892baafa48ab872bc79671d57aafd511f6c","modified":1616682757341},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"dd8cdf639ba2b726437c77fa7aa8d5edbabe8f9b","modified":1616682757341},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"b09e3a834ab8389f731bee5703b86e8aea27cda8","modified":1616682757342},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"7d18a7be9cfea65091de3ef00014063d2d649912","modified":1616682757342},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"90fe01c968696a9f791cb2b84fca621cbbb56f47","modified":1616682757342},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"e639219e12069f9a71c8f325364a8f656454b999","modified":1616682757343},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"0551c5893d1589a3d17ce161e50ecb1d724cc6e8","modified":1616682757343},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"ea1ba40dd5954c2ed718a126336fb7f94da4e66f","modified":1616682757343},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"7a072589e6097dbe942783131964f2372fdf1eb6","modified":1616682757343},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"7a6e1f21173022a3a1f18a62785cdd657a1af0a1","modified":1616682757344},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"788a28f68e29fad5328dc03be2f3268324281652","modified":1616682757344},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"d7717ce0c061b2471bf1a366c1a81158af266417","modified":1616682757344},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"c2d35443807a121e20c7ac3c1caa50f848bacd59","modified":1616682757345},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"6874adc2e276443f354bbe50d0072e9bec37243c","modified":1616682757345},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"e554549f0a0ae85362f0b0e8687981741f486f6b","modified":1616682757345},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a6f8637e90e44e23338209d4a3438e3e67766971","modified":1616682757346},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"d60b7a94a7adeac489b8c1afdf7e679994829742","modified":1616682757346},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"7c4152162a03aa8331a783df5695e4ebbb816a8c","modified":1616682757346},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9a881c031f463c486bd25248c2814fd09f97892b","modified":1616682757347},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"6b05ca4409d2dc09e123af4e0af9f9d0f7142b73","modified":1616682757348},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"89e744abc5e41f4855e7b87b13b854f4ec4ffc0e","modified":1616682757348},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"51f2bd03a2d0787911d0c090fb555a664b3fac8b","modified":1616682757348},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"a7fc7624a8d893bdf9444f14154484c29c790e99","modified":1616682757348},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"53ecae272e16223a436c497abbf25dd5f0fc4aaa","modified":1616682757349},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"d0386ba6d8d63afc72b9673e8f3e89df6446ffc2","modified":1616682757349},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"21964fdd6d74ffbea519418bab65024aee5f3736","modified":1616682757349},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"df9d405c33a9a68946b530410f64096bcb72560c","modified":1616682757349},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"86fee274a62f7f034547342930f445c47378eb55","modified":1616682757350},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"1756791581c0ec51cb03353a09dac4778d944349","modified":1616682757351},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"2c18a1c9604af475b4749def8f1959df88d8b276","modified":1616682757351},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1616682757360},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"d85c3737b5c9548553a78b757a7698df126a52cf","modified":1616682757308},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1616682757361},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"7848ec58c6ec03243abf80a3b22b4dc10f3edf53","modified":1616682757308},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"e3bf847553515174f6085df982f0623e9783db7a","modified":1616682757308},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"ef1b2b5b980d6aeaa5d06b97d1afc9644b155a16","modified":1616682757308},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"bba9871f446c10ffcc8fa9023f5a2eb701a86bae","modified":1616682757309},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"76c061a16d7e5935f02acd27c6cdb4933c642b97","modified":1616682757309},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"481cd5053bafb1a19f623554a27d3aa077ea59c3","modified":1616682757309},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"76634112c64023177260d1317ae39cef2a68e35f","modified":1616682757309},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"cfe63e7d26a6665df6aa32ca90868ad48e05ec04","modified":1616682757310},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"d1d2474420bf4edc2e43ccdff6f92b8b082143df","modified":1616682757310},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"24a926756c2300b9c561aaab6bd3a71fdd16e16d","modified":1616682757310},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"3f05f8311ae559d768ee3d0925e84ed767c314d3","modified":1616682757310},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"f617cacf5d1e8335abba96ee1ce4b79c17411e1e","modified":1616682757311},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"b2fb4af74d54f1daa39d4afc321d38a2a72e0ddd","modified":1616682757311},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"353ebd0bdecdfde6dee32c3aa208cc87c72b15c0","modified":1616682757311},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"0b7571919e8ad51285deda56a1868fccf8c563d7","modified":1616682757312},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"da9813f8dc0d388869c15413cf056012cfb69e1a","modified":1616682757312},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"bafb3d5710824caa59a56017afb058fd2b4eac65","modified":1616682757312},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"52ea8aa26b84d3ad38ae28cdf0f163e9ca8dced7","modified":1616682757312},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"16378d8646ea3f4ac99c18f0296dd85b13f9d775","modified":1616682757313},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"b871ea208e36398b4d668db9a9a0b61c79415381","modified":1616682757313},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"2b45fe09d5b591dca156b76dae99981f8d8e1c61","modified":1616682757314},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"87b097f791f56ca17319657de7901853b798555d","modified":1616682757314},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"b8ae5fd7d74e1edcef21f5004fc96147e064d219","modified":1616682757315},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"21b7ec96c606823d3d72e72775495ef77502b4cb","modified":1616682757315},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"4afc12ce42d067fa4012039aa444343a36f73599","modified":1616682757315},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"3f3a3cd8bea2103dedd754f767aca5cb84d5f586","modified":1616682757315},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"9820d731bb66a1d9c2e0083361d0c99c68c93fdf","modified":1616682757316},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"a13246714c9b9c6d6e5093f131a57bb49d653940","modified":1616682757316},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"18dcf05ab58107bbff426376aef2577f59583fc2","modified":1616682757316},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"cb38ffe911023092a90a28f2ba8317a92b22cd0c","modified":1616682757317},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"59b4c26a827ace5a54855881d199977103ff6f50","modified":1616682757318},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"9657b1b08ff3f98e49ca250ed47a81b8b202ac7a","modified":1616682757319},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"d8f59e94eafc669c49349561dc5bbea3915aecb7","modified":1616682757320},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"da3b9437d061ee68dbc383057db5c73034c49605","modified":1616682757321},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"613280d61b8ab9612014ec016ae3d3698d36fd1a","modified":1616682757321},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"2980f1889226ca981aa23b8eb1853fde26dcf89a","modified":1616682757321},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"309f51bc5302e72fc469d54c577fbcfe57fb07a8","modified":1616682757322},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4c4a9c15215ae8ac5eadb0e086b278f76db9ee92","modified":1616682757322},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"006acc91ce25fc7c7d778ca043e970f57dc46b83","modified":1616682757322},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"8c0726fb8d9a497d2f900b0be2845efaa68e3d87","modified":1616682757338},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"89cbcc8e087788ecec18b5fa58710afacdb7d080","modified":1616682757338},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"5972c61f5125068cbe0af279a0c93a54847fdc3b","modified":1616682757339},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"e0e7065124ef0d99f8322a47bc47838982e04ad0","modified":1616682757339},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"8970cc1916c982b64a1478792b2822d1d31e276d","modified":1616682757339},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1616682757357},{"_id":"themes/butterfly/source/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1616682757358},{"_id":"public/2020/01/14/vue-router源码了解一下/index.html","hash":"00f2a0f8e40d9a37dbec265439af38b66a42c086","modified":1616686275926},{"_id":"public/2020/01/13/git日常操作/index.html","hash":"5f251c53aa76e026fafe8ec2f47a0d6bffc1cbae","modified":1616686275926},{"_id":"public/2020/01/08/高清在线直播-1/index.html","hash":"2ce1ec88d456ce71e9b8935e168852acb0a026a7","modified":1616686275926},{"_id":"public/2019/12/30/了解一些HTTP协议相关知识/index.html","hash":"0c8d17a1404b9b1e38978fffcbff40f26860d7c4","modified":1616686275926},{"_id":"public/2019/11/22/vue响应式更新个人实现/index.html","hash":"2050150ce4260e0095123e537a8cddf045591a24","modified":1616686275926},{"_id":"public/2019/11/21/理解RESTful没有那么难/index.html","hash":"bde7a2f754103dd4b983a46f5f64b3dfe2df4a8d","modified":1616686275926},{"_id":"public/2019/11/20/微信小程序云开发初体验/index.html","hash":"148ce6ba043424271a4084e52ffa83181dcfb72d","modified":1616686275926},{"_id":"public/2019/10/11/电影-中国机长/index.html","hash":"4b46bce9db006cf22f8a947bc9948d6024dd1d84","modified":1616686275926},{"_id":"public/2019/09/28/使徒行者-在线播放/index.html","hash":"73456d3b58b09f67b526d270fda04e849d16be5a","modified":1616686275926},{"_id":"public/2019/09/25/一般插件开发规范结构/index.html","hash":"055476a6ec60c025e25fe5f232e52adcef50045e","modified":1616686275926},{"_id":"public/2019/09/17/前端问答2/index.html","hash":"18e42cfdb1a6f58535c1a17ab1bd7d1b08484c00","modified":1616686275926},{"_id":"public/2019/09/17/蜘蛛侠-英雄远征/index.html","hash":"23afa404398c6978326b5d0cc743a5d24513166d","modified":1616686275926},{"_id":"public/2019/09/11/前端问答/index.html","hash":"faf8cc33f19ea9916af5d3fdee8ac578f940667f","modified":1616686275926},{"_id":"public/2019/09/06/e6-9e-81-e9-80-9f-e7-89-88-e8-b0-b7-e6-ad-8c-e8-ae-bf-e9-97-ae-e5-8a-a9-e6-89-8bv2-3-0-e7-a0-b4-e8-a7-a3-e7-89-88/index.html","hash":"835c4a514e9aa2ffddfbb41229192a8b5890aa0a","modified":1616686275926},{"_id":"public/2019/09/06/e6-9c-80-e9-95-bf-e4-b8-80-e6-9e-aa-hdtc-e5-9b-bd-e8-af-ad-e4-b8-ad-e5-ad-97-e7-89-88-e6-9c-80-e6-96-b0-e4-b8-8a-e6-9e-b6/index.html","hash":"be8563f96351ac884bd4b0d65dc608f6b7915d1f","modified":1616686275926},{"_id":"public/2019/09/02/e8-8b-b9-e6-9e-9ccms-e7-a8-8b-e5-ba-8f-e6-9c-80-e6-96-b0-e6-ba-90-e7-a0-81-e8-8e-b7-e5-8f-96-e5-8f-8a-e8-a7-86-e9-a2-91-e8-a7-a3-e6-9e-90-e6-8e-a5-e5-8f-a3-e5-88-86-e4-ba-ab/index.html","hash":"bb9e2a37ccd72ab99f793361bca7db4cacce4ea0","modified":1616686275926},{"_id":"public/2019/09/02/e6-9c-80-e6-96-b0-e7-9f-a5-e5-ae-87-e8-87-aa-e5-8a-a8-e5-8f-91-e5-8d-a1-e7-b3-bb-e7-bb-9f-e6-ba-90-e7-a0-81-e5-b7-b2-e9-9b-86-e6-88-90-e5-bd-a9-e8-99-b9-e6-98-93-e6-94-af-e4-bb-98/index.html","hash":"d91e2bf5e123aa855b6ea43c3ffd776c15d4cfed","modified":1616686275926},{"_id":"public/2019/09/02/e5-88-86-e4-ba-ab-e7-bd-91-e7-bb-9c-e5-b0-8f-e6-b8-b8-e6-88-8f-e5-90-88-e9-9b-86-e6-98-9f-e7-9b-8a-e6-89-8b-e6-9c-ba-e7-94-b5-e8-84-91-e5-b0-8f-e6-b8-b8-e6-88-8f-e5-b9-b3-e5-8f-b0-e7-bd-91-e9-a1-b5/index.html","hash":"cc945fc9f2804fa5afe27d5e3ff06f2c754752c8","modified":1616686275926},{"_id":"public/2019/08/30/e5-bc-80-e5-8f-91linux-e8-bf-90-e7-bb-b4-e4-ba-ba-e5-91-98-e6-9c-80-e5-b8-b8-e7-94-a8166-e4-b8-aa-e5-91-bd-e4-bb-a4-e6-b1-87-e6-80-bb/index.html","hash":"bbc636bebb3e8cd2584501b3afe2a90f78589bc8","modified":1616686275926},{"_id":"public/2019/08/30/e4-b8-80-e6-96-87-e6-90-9e-e5-ae-9a-e5-89-8d-e7-ab-af-jenkins-e8-87-aa-e5-8a-a8-e5-8c-96-e9-83-a8-e7-bd-b2/index.html","hash":"0afe7237a25d1531442ee273a13ce2309e322265","modified":1616686275926},{"_id":"public/2019/08/29/e5-85-b3-e4-ba-8ewordpress-e4-b8-bb-e9-a2-98vieu-e4-bb-a5-e5-8f-8a-e5-85-b6-e4-bb-96-e4-b8-bb-e9-a2-98-e4-be-a7-e6-a0-8fcss-e6-a0-b7-e5-bc-8f-e6-a1-86-e9-85-8d-e7-bd-ae-e6-95-99-e7-a8-8b/index.html","hash":"8702c35e3ed3d5cf842257085a42bd386618a9b5","modified":1616686275926},{"_id":"public/2019/08/27/e5-a4-8d-e4-bb-87-e8-80-85-e8-81-94-e7-9b-9f4-ef-bc-9a-e7-bb-88-e5-b1-80-e4-b9-8b-e6-88-98bd4k-e8-8b-b1-e8-af-ad-e5-ae-98-e6-96-b9-e7-89-b9-e6-95-88-e4-b8-ad-e8-8b-b1-e5-8f-8c-e5-ad-97-e7-99-be/index.html","hash":"674ed0f69bb06969fa1b850b51787a40957b4a57","modified":1616686275926},{"_id":"public/2019/08/21/e9-a6-96-e6-b6-82-e7-ae-80-e7-ba-a6seo-e6-a8-a1-e6-9d-bf-ef-bc-8c-e5-8e-bb-e9-a6-96-e9-a1-b5-e5-b9-bf-e5-91-8a-e8-84-9a-e6-9c-ac/index.html","hash":"6288c2126b65bc27cfc74c17add8a585c607ba75","modified":1616686275926},{"_id":"public/2019/08/14/e5-9b-bd-e5-a4-96cloudflare-e5-85-8d-e8-b4-b9cdn-e5-8a-a0-e9-80-9f-e5-8f-8a-e9-98-b2-e6-8a-a4-e6-b3-a8-e5-86-8c-e4-bd-bf-e7-94-a8-e6-95-99-e7-a8-8b/index.html","hash":"664c075d5f4034c797f2fff6e7e7b497e05912e0","modified":1616686275926},{"_id":"public/2019/08/09/e6-89-8b-e6-91-b8-e6-89-8b-e6-95-99-e4-bd-a0-e6-92-b8-e4-b8-80-e4-b8-aa-e8-84-9a-e6-89-8b-e6-9e-b6/index.html","hash":"846f0709ae766649ba43b74c2009d2207b5f21ab","modified":1616686275926},{"_id":"public/2019/08/09/web-e5-ae-9e-e7-8e-b0-e5-89-8d-e5-90-8e-e7-ab-af-e5-88-86-e7-a6-bb-ef-bc-8c-e5-89-8d-e5-90-8e-e7-ab-af-e8-a7-a3-e8-80-a6/index.html","hash":"664f098961839b8cd14728d6b81bc93dd2bdd72d","modified":1616686275926},{"_id":"public/2019/07/29/e5-93-aa-e5-90-92-e4-b9-8b-e9-ad-94-e7-ab-a5-e9-99-8d-e4-b8-96-e9-ab-98-e6-b8-85-e5-9c-a8-e7-ba-bf-e6-92-ad-e6-94-be-hd-e9-ab-98-e6-b8-85/index.html","hash":"ad1053d46466d929e659b7d84cb3ba909ee4d749","modified":1616686275926},{"_id":"public/2019/07/26/e8-a7-a3-e5-86-b3vue-e5-8d-95-e9-a1-b5-e9-9d-a2-e5-ba-94-e7-94-a8-e5-9c-a8-e5-be-ae-e4-bf-a1-e7-ad-89app-e9-87-8c-e9-9d-a2-e6-97-a0-e6-b3-95-e8-ae-be-e7-bd-aetitle-e9-97-ae-e9-a2-98/index.html","hash":"4bfa07059e4e913183ccca7c0b61cba982f24097","modified":1616686275926},{"_id":"public/2019/07/26/vue-mini-player-e5-9f-ba-e4-ba-8evue-e7-9a-84-e4-b8-80-e4-b8-aa-e8-bd-bb-e9-87-8f-e7-ba-a7html5-e8-a7-86-e9-a2-91-e6-92-ad-e6-94-be-e5-99-a8/index.html","hash":"0fd8fb69934a6820dfb024aeea373f2725191fb7","modified":1616686275926},{"_id":"public/2019/07/18/console-e5-af-b9-e8-b1-a1-e4-b8-8e-e6-8e-a7-e5-88-b6-e5-8f-b0-e8-af-a6-e8-a7-a3/index.html","hash":"edfd871dd25707a12118aa35e4cdc3d8a70011a4","modified":1616686275926},{"_id":"public/2019/07/18/javascript-e9-94-99-e8-af-af-e6-9c-ba-e5-88-b6-e5-a4-84-e7-90-86/index.html","hash":"5fae7f2f8bdf6c7657b9da3fedf6c4824c04f6b9","modified":1616686275926},{"_id":"public/2019/07/12/e5-88-86-e6-9e-90-e5-be-ae-e4-bf-a1-e5-85-ac-e4-bc-97-e5-8f-b7-localstorage-e7-bc-93-e5-ad-98-e6-9c-ba-e5-88-b6/index.html","hash":"d7997f2bf7f11c2a9f4703f1df7abd6930f30a29","modified":1616686275926},{"_id":"public/2019/07/11/e3-80-90-e8-a7-86-e9-a2-91-e3-80-918-e5-a4-a9-e4-bb-8e-e5-b0-8f-e7-99-bd-e5-88-b0-e5-a4-a7-e7-a5-9e-e8-9c-95-e5-8f-98-e7-a7-98-e7-b1-8d-e4-b9-8bphotoshop/index.html","hash":"01c2489019a91f7e787075e13a488446f27b6135","modified":1616686275926},{"_id":"public/2019/07/11/e6-83-8a-e9-ad-82-e7-94-b5-e5-bd-b1-e9-99-a2-1080p-e8-b6-85-e6-b8-85mp4/index.html","hash":"e2e4c905409be748ff17df8689156a855c20bf21","modified":1616686275926},{"_id":"public/2019/07/11/ios-ef-bc-88-e8-8b-b9-e6-9e-9c-ef-bc-89-e9-92-89-e9-92-89-e8-99-9a-e6-8b-9f-e4-bd-8d-e7-bd-ae-e6-89-93-e5-8d-a1-e6-96-b9-e6-b3-95/index.html","hash":"c4c93e5e1dd83358c7243574cc8a3412cbf0a3ff","modified":1616686275926},{"_id":"public/2019/07/11/nodecache-e5-85-8d-e5-a4-87-e6-a1-88cdn-e6-b3-a8-e5-86-8cz-e5-8d-b3-e9-80-811t-e5-85-8d-e8-b4-b9-e5-8a-a0-e9-80-9f-e6-b5-81-e9-87-8f/index.html","hash":"98297149e09b7e2c540cde099b52836ed3b8d060","modified":1616686275926},{"_id":"public/2019/07/09/e8-8b-8f-e9-86-92grace8-0-e5-8e-bb-e6-8e-88-e6-9d-83-e7-a0-b4-e8-a7-a3-e7-89-88-wordpress-e4-b8-bb-e9-a2-98/index.html","hash":"6328a84fe2c323c54f83da88833dde75f5cc59b8","modified":1616686275926},{"_id":"public/2019/07/05/git-e5-ad-a6-e4-b9-a0-e5-86-8d-e5-85-a5-e9-97-a8-e5-91-bd-e4-bb-a4-e6-b8-85-e5-8d-95/index.html","hash":"86f3235afc6b887284fead3c8b0fed3569ddecb2","modified":1616686275926},{"_id":"public/2019/07/05/git-e5-ad-a6-e4-b9-a0-e5-86-8d-e5-85-a5-e9-97-a8-e5-9f-ba-e7-a1-80-e7-af-87/index.html","hash":"71e59f17d9aeab1bdd4f49f373b2fb1007fb1edc","modified":1616686275926},{"_id":"public/2019/07/05/wordpress-e7-99-be-e5-ba-a6-e7-86-8a-e6-8e-8c-e5-8f-b7-e5-8e-9f-e5-88-9b-e6-8e-a8-e9-80-81-e6-8f-92-e4-bb-b6-ef-bc-9afanly-submit-e4-b8-8b-e8-bd-bd/index.html","hash":"a24a2b558e338e900240f7b8c88f544d0daa5df0","modified":1616686275926},{"_id":"public/2019/07/05/office2019-e5-85-89-e7-9b-98-e9-95-9c-e5-83-8f-e4-b8-8b-e8-bd-bd/index.html","hash":"36e6fb3a8ab6f98c51adbc4e73ab31d3bbccb50e","modified":1616686275926},{"_id":"public/2019/07/05/204/index.html","hash":"e90b77e853bf3835b5518b315cfd9dbb7342697c","modified":1616686275926},{"_id":"public/2019/07/05/e8-af-b4-e8-af-b4-e5-88-b0-e5-ba-95-e4-bb-80-e4-b9-88-e6-98-af-bt-e7-a7-8d-e5-ad-90/index.html","hash":"a7d3b8f48e64f1b8d476059c2f269748c859864d","modified":1616686275926},{"_id":"public/2019/06/26/eslint-e9-85-8d-e7-bd-ae-e5-8f-82-e8-80-83-e4-b8-ad-e6-96-87-e8-a7-a3-e9-87-8a/index.html","hash":"4853472de146d2b32d15cb4cec41e5827bf93450","modified":1616686275926},{"_id":"public/2019/06/24/e6-96-b0-e6-b8-b8-e6-b4-be-e6-9c-ac-e5-91-a8-e4-b8-8d-e5-ae-b9-e9-94-99-e8-bf-87-e7-9a-84-5-e6-ac-be-e6-96-b0-e6-b8-b8-e6-88-8f/index.html","hash":"ec3e0125f3b55789c2b4c60d513eaec59cc40b0a","modified":1616686275926},{"_id":"public/2019/06/24/e5-a4-a7-e5-9e-8b-e9-a1-b9-e7-9b-ae-e5-89-8d-e7-ab-af-e6-9e-b6-e6-9e-84-e8-af-a6-e8-b0-88/index.html","hash":"e828092676056eae1d6a9a300e4a029fa6212087","modified":1616686275926},{"_id":"public/2019/06/24/2019-e7-a5-9e-e5-89-a7-e6-8e-a8-e8-8d-90-e8-b1-86-e7-93-a3-e8-af-84-e5-88-869-3-e3-80-8a-e7-88-b1-ef-bc-8c-e6-ad-bb-e4-ba-a1-e5-92-8c-e6-9c-ba-e5-99-a8-e4-ba-ba-e3-80-8b/index.html","hash":"69d6599f74f8e88a5e1aa3c8653c3297962a349b","modified":1616686275926},{"_id":"public/2019/06/22/e6-83-8a-e5-a5-87-e9-98-9f-e9-95-bfbd1080p-e8-b6-85-e6-b8-85-e7-89-b9-e6-95-88-e4-b8-ad-e6-96-87-e5-ad-97-e5-b9-95-e8-bf-85-e9-9b-b7-e5-9c-a8-e7-ba-bf-e4-b8-8b-e8-bd-bd/index.html","hash":"15fcb59936feff83064edc54f8eaec2009cacf56","modified":1616686275926},{"_id":"public/2019/06/22/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e5-91-a8-e8-be-b9-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8/index.html","hash":"836c84bf42f86e22efda6bfd8ea0d2da534c446d","modified":1616686275926},{"_id":"public/2019/06/22/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e7-ac-ac-e4-b8-89-e6-96-b9-e5-ba-93-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8/index.html","hash":"119abda178c38c066d3339004d6186d7145e880b","modified":1616686275926},{"_id":"public/2019/06/22/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86javascript-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8/index.html","hash":"bb3b2e189952cb7f43c0dda435131ff8953edf9a","modified":1616686275926},{"_id":"public/2019/06/22/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86css-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8/index.html","hash":"9e54311bf2b15eac7a26eab3afc5204e26d8d858","modified":1616686275926},{"_id":"public/2019/06/22/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e5-9f-ba-e7-a1-80-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8/index.html","hash":"8416334995592ab3a54577af43cd7295884a623c","modified":1616686275926},{"_id":"public/2019/06/22/e6-9c-89-e4-ba-86-e8-bf-99-e4-bb-bd-e4-b8-8a-e7-8f-ad-e6-91-b8-e9-b1-bc-e6-8c-87-e5-8d-97-ef-bc-8c-e4-b8-8d-e7-94-a8-e5-86-8d-e6-80-95-e5-b7-a5-e4-bd-9c-e3-80-8c-e5-88-92-e6-b0-b4-e3-80-8d-e8-a2-ab/index.html","hash":"7b6e12f3e17e20b5e190c110a28beac80210a3ec","modified":1616686275926},{"_id":"public/2019/06/22/e6-95-99-e4-bd-a0-e5-bf-ab-e9-80-9f-e6-92-b8-e4-b8-80-e4-b8-aa-e5-85-8d-e8-b4-b9https-e8-af-81-e4-b9-a6/index.html","hash":"7d9c4590d832a69ab734df45eb79db2faad3a4de","modified":1616686275926},{"_id":"public/2019/06/22/mongo-e5-85-a5-e9-97-a8-2-e5-9f-ba-e6-9c-ac-e6-93-8d-e4-bd-9c/index.html","hash":"680c2764668008653a0e113fd93831ad12905dac","modified":1616686275926},{"_id":"public/2019/06/22/mongo-e5-85-a5-e9-97-a8-1-e5-8e-9f-e7-90-86/index.html","hash":"0ab81a8ea9c3cf0c12a6134415114404995e736e","modified":1616686275926},{"_id":"public/2019/06/22/e3-80-90-e8-8b-b9-e6-9e-9ccms-v10-e3-80-91-e4-bb-bf-e4-bc-98-e9-85-b7-e6-a8-a1-e6-9d-bfpc-e5-ae-8c-e7-be-8e-e4-bf-ae-e5-a4-8d-e7-89-88/index.html","hash":"5b0bd4ecde2865b90230f27de5b9f030299c63e8","modified":1616686275926},{"_id":"public/2019/06/22/e6-95-99-e4-bd-a0-e6-90-ad-e5-bb-ba-e4-b8-80-e5-a5-97-e5-b1-9e-e4-ba-8e-e8-87-aa-e5-b7-b1-e7-9a-84-e8-a7-86-e9-a2-91-e7-bd-91-e7-ab-99-e5-b0-8f-e7-99-bd-e6-95-99-e7-a8-8b-e5-a4-a7-e7-a5-9e-e7-bb-95/index.html","hash":"1c9e8fb6fa740a95ed3d9f090d7ad19bef1f91e4","modified":1616686275926},{"_id":"public/2019/06/22/e5-85-a5-e9-97-a8-e7-af-87-e5-a6-82-e4-bd-95-e7-94-a8javascript-e5-ae-9e-e7-8e-b0-e4-b8-80-e4-b8-aa-e6-a8-a1-e6-9d-bf-e5-bc-95-e6-93-8e/index.html","hash":"41e0aecf06f56d0d86178d54320ff797be76b967","modified":1616686275926},{"_id":"public/2019/06/22/e5-a6-82-e6-ad-a4-e7-81-ab-e7-88-86-e7-9a-84-e8-87-aa-e8-b5-b0-e6-a3-8b-e6-89-8b-e6-b8-b8-ef-bc-8c-e5-81-9a-e5-be-97-e7-a9-b6-e7-ab-9f-e6-80-8e-e4-b9-88-e6-a0-b7-ef-bc-9f/index.html","hash":"4bce9c7bdb2aaf5b2835cac6a73492ba6bff246f","modified":1616686275926},{"_id":"public/2019/06/22/e6-9c-80-e6-96-b0-e7-89-88-xyplayer-e6-99-ba-e8-83-bd-e8-a7-a3-e6-9e-90-x3-8-e6-ad-a3-e5-bc-8f-e7-89-88-e5-88-86-e4-ba-ab/index.html","hash":"216a623076e8423af8e1f9d00bc1683d0dbd5cb8","modified":1616686275926},{"_id":"public/2019/06/22/e8-8b-b9-e6-9e-9ccmsv10-e5-b9-95-e4-b9-94-e9-85-b7-e9-bb-91-e6-a8-a1-e6-9d-bf-e5-85-8d-e6-8e-88-e6-9d-83-e7-a0-b4-e8-a7-a3-e7-89-88/index.html","hash":"09a5cc06eb1f9b8db78dd72dcc0b4437b65c5c46","modified":1616686275926},{"_id":"public/2019/06/22/e5-88-86-e4-ba-ab-e4-b8-80-e4-b8-8bsass-e5-a4-84-e7-90-86-e7-9a-84-e6-9b-b4-e9-ab-98-e7-ba-a7-e5-aa-92-e4-bd-93-e6-9f-a5-e8-af-a2/index.html","hash":"aa4b79193e3d149768d3a881a3ae533e9dbcfe94","modified":1616686275926},{"_id":"public/2019/06/22/vip-e5-bd-b1-e8-a7-86app-e6-ba-90-e7-a0-81-ef-bc-8c-e5-b8-a6-e5-95-86-e5-9f-8e-e7-b3-bb-e7-bb-9f-ef-bc-8c-e5-ae-89-e5-8d-93-e8-8b-b9-e6-9e-9c-e5-8f-8c-e7-ab-af-ef-bc-8c-e5-85-a8-e6-96-b0-e7-9a-84/index.html","hash":"e2782ab178d296e88f5f6eb7790cf20be2f8aa1e","modified":1616686275926},{"_id":"public/2019/06/22/e5-89-8d-e7-ab-af-e5-b0-8f-e7-99-bd-e5-85-a5-e9-97-a8-e4-b9-8b-e5-86-8d-e5-ad-a6javascript-e4-ba-8c/index.html","hash":"fd3a654a36349dd10bf7e6b8d273b835f676e21d","modified":1616686275926},{"_id":"public/2019/06/22/e6-a0-87-e7-ad-be-e9-a1-b5-e7-ae-a1-e7-90-86-e3-80-81-e9-9a-90-e7-a7-81-e4-bf-9d-e6-8a-a4-e3-80-81-e5-88-92-e8-af-8d-e6-90-9c-e7-b4-a2-e8-bf-99-10-e6-ac-be-e6-96-b0-e6-89-a9/index.html","hash":"6102fcd551c79a21cd0bda59a635e0e36139dbfe","modified":1616686275926},{"_id":"public/2019/06/22/e5-89-8d-e7-ab-af-e5-b0-8f-e7-99-bd-e5-85-a5-e9-97-a8-e4-b9-8b-e5-86-8d-e5-ad-a6javascript-e4-b8-80/index.html","hash":"e56b3aff63cc8dc0a15f5d5938c6a7a337bf717c","modified":1616686275926},{"_id":"public/2019/06/22/ios-13-e4-b8-8d-e5-8f-aa-e6-9c-89-e6-b7-b1-e8-89-b2-e6-a8-a1-e5-bc-8f-ef-bc-8c-e8-bf-99-15-e4-b8-aa-e6-96-b0-e5-8a-9f-e8-83-bd-e5-90-8c-e6-a0-b7-e5-80-bc-e5-be-97-e5-85-b3-e6-b3-a8/index.html","hash":"a09c5808cfe03394c94b6f00a9a13c238d29030e","modified":1616686275926},{"_id":"public/2019/06/22/e4-bc-a0-e8-af-b4-e4-b8-ad-e5-9b-be-e7-89-87-e9-98-b2-e7-9b-97-e9-93-be-e7-9a-84-e7-88-b1-e6-81-a8-e6-83-85-e4-bb-87/index.html","hash":"04c3296d97b484ab4673fae996cb7e0a526e3f64","modified":1616686275926},{"_id":"public/2019/06/22/e5-b0-8f-e6-b6-b4-e7-86-8a-e6-bc-ab-e7-94-bbcms-e5-bc-80-e6-ba-90-e5-85-8d-e8-b4-b9-e7-9a-84-e9-87-87-e9-9b-86-e6-bc-ab-e7-94-bb-e8-bf-9e-e8-bd-bd-e7-b3-bb-e7-bb-9f-ef-bc-8c-e5-b8-a6-e9-87-87/index.html","hash":"77a776bc2e79397774254c302d1dbed53dbe7062","modified":1616686275926},{"_id":"public/2019/06/20/wordpress/index.html","hash":"ed7acf9d923e1df5df1bdfe963d0ec75c49b5bbc","modified":1616686275926},{"_id":"public/2019/06/20/e8-8b-b9-e6-9e-9c-e5-85-ac-e5-b8-83-2019-e5-b9-b4-e5-ba-a6-e8-ae-be-e8-ae-a1-e5-a4-a7-e5-a5-96-ef-bc-8c-e8-bf-99-9-e6-ac-be-app-e6-98-af-e4-bb-8a-e5-b9-b4-e7-9a-84-e8-b5-a2-e5-ae-b6/index.html","hash":"7f2cd254dcf49eaacc2eaaf202e9412d2647f113","modified":1616686275926},{"_id":"public/tags/电影/index.html","hash":"fb84046dffcb40569ae70ac4755bf6cc3c263a30","modified":1616686275926},{"_id":"public/tags/高清/index.html","hash":"f2faa5a38358e424b287c311568f353759d0cb3f","modified":1616686275926},{"_id":"public/tags/影视/index.html","hash":"eb4942ac5ed10dbdd4b9ad06dc62a6f9a303cd16","modified":1616686275926},{"_id":"public/tags/JavaScript/index.html","hash":"07f21ce013abe963afcb09c1e2e37f50ba8ccd05","modified":1616686275926},{"_id":"public/tags/前端/index.html","hash":"7511429ce68e1e7fb2f42926af72c79eb617ac41","modified":1616686275926},{"_id":"public/tags/学习资源/index.html","hash":"16a2049774c9b143dc8670d6484c7502e8696fda","modified":1616686275926},{"_id":"public/tags/前端，盗链/index.html","hash":"dc208c7d6e657f886c321afd3245bfc8b5863820","modified":1616686275926},{"_id":"public/tags/scss/index.html","hash":"88e95c48909d0cb7385825b10adaab3d7b09dac6","modified":1616686275926},{"_id":"public/tags/小游戏/index.html","hash":"e3c380bde6626b222c657265f6bde4fba820f3f9","modified":1616686275926},{"_id":"public/tags/源码/index.html","hash":"5820a01f1c4fa09aec7c9f6d700a0400300a2d92","modified":1616686275926},{"_id":"public/tags/前端，JavaScript/index.html","hash":"cf3889ca0de4dcefda0ad8937cc9a51521791394","modified":1616686275926},{"_id":"public/tags/热门影视/index.html","hash":"4658c02171c2c9db99f00bf3e726e4dec1d1bddf","modified":1616686275926},{"_id":"public/tags/CDN/index.html","hash":"e02ec340a01ed0763f05ecfa8fa38d43f2ef115a","modified":1616686275926},{"_id":"public/tags/复仇者联盟/index.html","hash":"9d8f0c1328be69652ad89dbf936d3058f2da6327","modified":1616686275926},{"_id":"public/tags/电影资源/index.html","hash":"e476fd65c40165de73d0d614f69f2391d79fe1a5","modified":1616686275926},{"_id":"public/tags/Linux/index.html","hash":"060dde0e8b1e867ded8923781ff3d49ca13f95ca","modified":1616686275926},{"_id":"public/tags/漫威/index.html","hash":"c5910ea0d17cb061ae1c81e12bff51a5d4cf6282","modified":1616686275926},{"_id":"public/tags/科幻/index.html","hash":"53a8700a40bc9b31165faf5d048c9f185ac9d0b2","modified":1616686275926},{"_id":"public/tags/游戏/index.html","hash":"507063aa8a0f52aa34004af04c6305bee3179346","modified":1616686275926},{"_id":"public/tags/解析，免费VIP/index.html","hash":"78750ea5e30aea285c1fafdfdcbbc7938db1a8cb","modified":1616686275926},{"_id":"public/tags/发卡系统/index.html","hash":"79337e43dc5d6b9fabcd9d6a786ad637fd00413e","modified":1616686275926},{"_id":"public/tags/在线播放/index.html","hash":"750073c2e39da4b834cf08fb7d1eaf8c3f211780","modified":1616686275926},{"_id":"public/tags/Chrome/index.html","hash":"c8aac4eeb1d2cb04888025ece34557be02a6857a","modified":1616686275926},{"_id":"public/tags/插件/index.html","hash":"dd431cf07cdd44aa23cb0fc1b688da5d1fc5b5d4","modified":1616686275926},{"_id":"public/tags/破解/index.html","hash":"cae200d4b7704079609ac22bc306757a098972ac","modified":1616686275926},{"_id":"public/tags/资源/index.html","hash":"7959b8dd789cd77da03c472f8d1c0331a5ad154e","modified":1616686275926},{"_id":"public/tags/Maccms/index.html","hash":"28a9a1f5ccc4358c39aab80342476005f300ff85","modified":1616686275926},{"_id":"public/tags/V10/index.html","hash":"687ba683d21adeb54fe91f05bb9426906ae8e20f","modified":1616686275926},{"_id":"public/tags/解析接口/index.html","hash":"7cf8cf18fedc5d88a5b78731e00e391cf1a0708c","modified":1616686275926},{"_id":"public/tags/Vue/index.html","hash":"3d0b6f88e9a4efff626546a01d710bb5a03c5185","modified":1616686275926},{"_id":"public/tags/开源/index.html","hash":"e08ddc089b3268e018835ef6a80b38c5036eb657","modified":1616686275926},{"_id":"public/tags/vue-titles/index.html","hash":"66d5c7955c6fe82adba93c437cd8cb460a4c0fd8","modified":1616686275926},{"_id":"public/tags/BT/index.html","hash":"6cb99392448e3eba33371159f84a7da4068a7068","modified":1616686275926},{"_id":"public/tags/种子/index.html","hash":"94afb1d4c957c6f9ed1dbab1265b8853eb2de5cf","modified":1616686275926},{"_id":"public/tags/maccms10/index.html","hash":"22efbeda65eee420a82f1c4d2c47232d046b83d4","modified":1616686275926},{"_id":"public/tags/模板/index.html","hash":"b42d74cb068b9186040ba564b02555d86f38cacb","modified":1616686275926},{"_id":"public/tags/eslint/index.html","hash":"afa26f457d3634f358172d0615d545549d369cb2","modified":1616686275926},{"_id":"public/tags/JavaScrip/index.html","hash":"0d1e2b2a70ff3940e3d5b654fcffa4756aec13d0","modified":1616686275926},{"_id":"public/tags/vue-cli/index.html","hash":"97c9c07363fc1f8b290a8380f0c141d7ddefe958","modified":1616686275926},{"_id":"public/tags/Git/index.html","hash":"d7385d8ada7b50c1ecab69c6591e26f3c49ea290","modified":1616686275926},{"_id":"public/tags/技巧/index.html","hash":"b5ecf00e044896f40492d65e1e0bae62cf8ee510","modified":1616686275926},{"_id":"public/tags/Microsoft-office/index.html","hash":"547fe796381db634b526fab74d63ab6d7e0744e5","modified":1616686275926},{"_id":"public/tags/player/index.html","hash":"0d8b6b2f06742c36f40c39cf96844e069ba0ba94","modified":1616686275926},{"_id":"public/tags/video-player/index.html","hash":"666466d635c99d1d1793675a00c83d5fa17cac42","modified":1616686275926},{"_id":"public/tags/开源-GitHub-Vue/index.html","hash":"2b67b095880f3b13fc07c1754e3087d553bb91a9","modified":1616686275926},{"_id":"public/tags/WordPress/index.html","hash":"43555aab46cce459517f345f76d8c7633d8644d5","modified":1616686275926},{"_id":"public/tags/微信小程序/index.html","hash":"f32abec3f83907c9eda68d6daf0a490d958cd5ac","modified":1616686275926},{"_id":"public/tags/云开发/index.html","hash":"f50a888d4eb732651786de7dfb9af1807d7146c8","modified":1616686275926},{"_id":"public/tags/在线影视/index.html","hash":"0b4a7f9b5bc5dba6e03451d70b6e62bf966b4d33","modified":1616686275926},{"_id":"public/tags/面试题/index.html","hash":"d685671094b6695eb81b2c25e59a6ce4d8bcfa3c","modified":1616686275926},{"_id":"public/tags/类库/index.html","hash":"0060b1e74d9b98591a5da9d28b34de7b1bb0b02b","modified":1616686275926},{"_id":"public/tags/CSS/index.html","hash":"72602f1febaf12fe2d80bec504a85e8a0698eaec","modified":1616686275926},{"_id":"public/tags/大型前端发布架构/index.html","hash":"a5f6dd4eb030ddd116027a7dec1f5ec19a79d55d","modified":1616686275926},{"_id":"public/tags/前端架构/index.html","hash":"490aac14205044cc994905a4506694870b0d6767","modified":1616686275926},{"_id":"public/tags/iOS，软件更新/index.html","hash":"11fce17cf560ba16a0c0790016895a1cd2838838","modified":1616686275926},{"_id":"public/index.html","hash":"82b48b9e4a26d8e40d894cb98a25567240569279","modified":1616686275926},{"_id":"public/page/2/index.html","hash":"fe55c33d41f26fcfa05690c2cd2bba20d081b260","modified":1616686275926},{"_id":"public/page/3/index.html","hash":"3f5014647c1485ee7499c82028694665f4a685d0","modified":1616686275926},{"_id":"public/page/4/index.html","hash":"56325b00ab334745cd2da37f5fc3c3c6feedd1d0","modified":1616686275926},{"_id":"public/page/5/index.html","hash":"86caa727223dca83df9cddc6c708b5fdbf792303","modified":1616686275926},{"_id":"public/page/6/index.html","hash":"7692fafc229332e8f2df41e2a95fc8258ec4b17d","modified":1616686275926},{"_id":"public/page/7/index.html","hash":"1bc2d374062212f8a94234bf3c8984432d0b3115","modified":1616686275926},{"_id":"public/page/8/index.html","hash":"9ca3f553209f67aa5205c93269e7ea1348129dd9","modified":1616686275926},{"_id":"public/page/9/index.html","hash":"bf8d3c5cfcb8f26dac0683084a7ea05681ae6149","modified":1616686275926},{"_id":"public/page/10/index.html","hash":"0d8ba7592d043dcc002fe9438d473acd3d794f43","modified":1616686275926},{"_id":"public/page/11/index.html","hash":"94e8e3f64b88ae04b5b217f94af6e423503ed1c3","modified":1616686275926},{"_id":"public/page/13/index.html","hash":"612f69a5faf98b9d60e35301ec8a1a73e49b286f","modified":1616686275926},{"_id":"public/page/12/index.html","hash":"c18d3e272d9c45c8bb088269f3499dbe2e27101d","modified":1616686275926},{"_id":"public/page/14/index.html","hash":"eeac1ce5dce1f6b211e1bcc9d17502718d336dd8","modified":1616686275926},{"_id":"public/page/15/index.html","hash":"c1ad1e0d16a905b9955bd21390e86bc138bd545d","modified":1616686275926},{"_id":"public/categories/影视资源/index.html","hash":"433f3ecc734c6ca189ecd09341ca9df10e4c9a0c","modified":1616686275926},{"_id":"public/categories/影视资源/page/2/index.html","hash":"761230fcce0480d8f5dbd2c061201884a5b9401b","modified":1616686275926},{"_id":"public/categories/大前端/index.html","hash":"7a47dcfb4321f41839675d2c6126c6385ed49384","modified":1616686275926},{"_id":"public/categories/大前端/page/2/index.html","hash":"f5e2de9e93aa3a939e738e8e4de51fce4273eb3f","modified":1616686275926},{"_id":"public/categories/大前端/page/3/index.html","hash":"bd2f4559dfc9e350ae4f25d48ec10805d3963a34","modified":1616686275926},{"_id":"public/categories/精选资源/index.html","hash":"fb10ae5d40d331796b0a5f15e7621fc61f62f59d","modified":1616686275926},{"_id":"public/categories/精选资源/page/2/index.html","hash":"b09cc97de368183905f3f3d9262ccd4df2a44a9f","modified":1616686275926},{"_id":"public/categories/杂谈/index.html","hash":"bf23b3bbae46cee13c78ad40fcba97ec4fb50708","modified":1616686275926},{"_id":"public/categories/杂谈/page/2/index.html","hash":"3488dac73862851a22c5c12f9333940853641194","modified":1616686275926},{"_id":"public/categories/服务端/index.html","hash":"ea5ac8b861b416d84bdb3ba19bbd59a90193db96","modified":1616686275926},{"_id":"public/categories/大前端/面试题类/index.html","hash":"689241600a69d1e7658d9d11d68b6b5e24525fcf","modified":1616686275926},{"_id":"public/categories/大前端/微信小程序/index.html","hash":"19a3fda726dde7352bf0ad6d896b8318b6f2d500","modified":1616686275926},{"_id":"public/archives/index.html","hash":"1cc9a06de62e217faf1c5e5ad4c38ca5fa19ed37","modified":1616686275926},{"_id":"public/archives/page/2/index.html","hash":"d74c3e0b0265b5c81597a7d9c3ab81bc90efc4d7","modified":1616686275926},{"_id":"public/archives/page/3/index.html","hash":"46bb9720d9e3fa47e0b1438f947bac3dd704c547","modified":1616686275926},{"_id":"public/archives/page/4/index.html","hash":"c9612cb725fe8b5077b2432a5bf776a961341b1b","modified":1616686275926},{"_id":"public/archives/page/5/index.html","hash":"37d7482e45bf4fec99192874713fb9a76f73f063","modified":1616686275926},{"_id":"public/archives/page/6/index.html","hash":"eea9a9bec3ff913e85c01a3c7eb4b576820dec43","modified":1616686275926},{"_id":"public/archives/page/7/index.html","hash":"8e549acf67f85091dcceae76b63b9548291bbef7","modified":1616686275926},{"_id":"public/archives/page/8/index.html","hash":"746146c986ca579c16d016cbb360a00e6de2c887","modified":1616686275926},{"_id":"public/archives/2019/index.html","hash":"dbb8cc03afb7dd68fed02f7b17eba340c119d4c8","modified":1616686275926},{"_id":"public/archives/2019/page/2/index.html","hash":"01b5fe37a7b8899ceaeceb83cd9ad2c9886d13f0","modified":1616686275926},{"_id":"public/archives/2019/page/3/index.html","hash":"9207549ed9b16b48d7132f641a1ad9f1c7868a05","modified":1616686275926},{"_id":"public/archives/2019/page/4/index.html","hash":"92be485ea46069aed8f564596a091ac86dff3647","modified":1616686275926},{"_id":"public/archives/2019/page/5/index.html","hash":"29c7d80af239bc0dfa431f2dc95eb6bedd47a746","modified":1616686275926},{"_id":"public/archives/2019/page/6/index.html","hash":"a86bd29fe5c61ebe7cd9c0eaeb156ca1c539d283","modified":1616686275926},{"_id":"public/archives/2019/page/7/index.html","hash":"ebaf24761dec11681b82e675d6537219b38ec53e","modified":1616686275926},{"_id":"public/archives/2019/06/index.html","hash":"6a9d0992fdf462108ef4cef0f54f2a97cd4c0135","modified":1616686275926},{"_id":"public/archives/2019/06/page/2/index.html","hash":"89c48b5664af5e5602f57697d3d4ecf930cefc65","modified":1616686275926},{"_id":"public/archives/2019/06/page/3/index.html","hash":"9da592fe26f6f2d09c1e5e74d7e9ea83bbd16286","modified":1616686275926},{"_id":"public/archives/2019/07/index.html","hash":"94c5e959076a77f4db326d4dba87ed405bcefa7b","modified":1616686275926},{"_id":"public/archives/2019/07/page/2/index.html","hash":"84b463728a105ccfe36ba4a23eb9199dec73527f","modified":1616686275926},{"_id":"public/archives/2019/08/index.html","hash":"24a5e54e7dc3680be18771d87d0f0da5fa3ed2fe","modified":1616686275926},{"_id":"public/archives/2019/09/index.html","hash":"546ea985b84d6f61be4ff6e4cea746f4299d1414","modified":1616686275926},{"_id":"public/archives/2019/10/index.html","hash":"a322d9fdff038aea2f6e0bb9198be66b0859373a","modified":1616686275926},{"_id":"public/archives/2019/11/index.html","hash":"eeae7281a0ba024b1b1f6b77741874aa7d6f3387","modified":1616686275926},{"_id":"public/archives/2019/12/index.html","hash":"539b4b9f5e99be033e445587f1db111b58fcea18","modified":1616686275926},{"_id":"public/archives/2020/index.html","hash":"ca542bb382b7c3a31eb7bd90d35a39239dd6ef81","modified":1616686275926},{"_id":"public/archives/2020/01/index.html","hash":"7a825be85b26f280b69a2e0cd8b13d3d04ed22bc","modified":1616686275926},{"_id":"public/img/favicon.png","hash":"3cf89864b4f6c9b532522a4d260a2e887971c92d","modified":1616686275926},{"_id":"public/img/404.jpg","hash":"fb4489bc1d30c93d28f7332158c1c6c1416148de","modified":1616686275926},{"_id":"public/img/algolia.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1616686275926},{"_id":"public/img/loading.gif","hash":"5f0287fb8fb98872fe1998c6f781111819e71806","modified":1616686275926},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1616686275926},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1616686275926},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1616686275926},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1616686275926},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1616686275926},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1616686275926},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1616686275926},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1616686275926},{"_id":"public/js/search/algolia.js","hash":"65b45e61586f7e66c3f338370bfd9daadd71a4b7","modified":1616686275926},{"_id":"public/js/search/local-search.js","hash":"459e2541afda483916d16fce4aaa56b41bcd42ba","modified":1616686275926},{"_id":"public/css/style.css","hash":"b3156fdcfe6586e60fa1d1a3c6cdd92fccc7873f","modified":1616686275926},{"_id":"public/css/index.css","hash":"a1916db3ab6d7d2d0c72ad4bb7b6e828433d7edf","modified":1616686275926},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1616686275926},{"_id":"public/js/utils.js","hash":"41481019ef510c74e744f4f7ec4d0a13b5ccc04c","modified":1616686275926},{"_id":"public/js/main.js","hash":"8b670bed658cf879e37a12d9fda064cf4b55cc3f","modified":1616686275926},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1616686275926},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1616686275926},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1616686275926},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1616686275926},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1616686275926}],"Category":[{"name":"影视资源","_id":"ckmozz5j700027jgs55hegb32"},{"name":"大前端","_id":"ckmozz5jo000b7jgs8lftdzw0"},{"name":"精选资源","_id":"ckmozz5jt000j7jgsgrggedb3"},{"name":"杂谈","_id":"ckmozz5kj00197jgs38eeclab"},{"name":"服务端","_id":"ckmozz5kn001g7jgs4rsl6d11"},{"name":"面试题类","parent":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmozz5nf004z7jgs90s8490t"},{"name":"微信小程序","parent":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmozz5nm005c7jgshvpmdalu"}],"Data":[],"Page":[],"Post":[{"title":"2019神剧推荐 - 豆瓣评分9.3-《爱，死亡和机器人》","url":"174.html","id":"174","date":"2019-06-24T11:38:53.000Z","_content":"\n![2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3](http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdoygiwj30zk0k0427.jpg \"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\") ![2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3](http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdtnxanj30zk0k0wgv.jpg \"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\") ![2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3](http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdxf15fj30zk0k040j.jpg \"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\") 警告：本部影片为R级影片，未满18周岁未成年人禁止观看 这部名为《爱，死亡和机器人》的动画短片合集由18部分组成，每部分时长5-15分钟。这些短片涵盖多种类型，包括科幻、奇幻、恐怖和喜剧；这些短片也将包含多种形式，包括传统2D和3DCGI短片。\n\n18部短片导演列表：\n----------\n\n1.桑尼的优势 Dave Wilson 2.三个机器人 Víctor Maldonado&Alfredo Torres 3.证人 Alberto Mielgo 4.机动装甲 Franck Balson 5.噬魂者 Owen Sullivan 6.当酸奶统治世界 Victor Maldonado & Alfredo Torres 7.裂缝以外 Leon Berlue,Dominique Boidin,Remi Kozyra,Maxime Luere 8.祝有好的收获 Oliver Thomas 9.垃圾场 Javier Recio Gracia 10.变形者 Gabriele Pennacchioli 11.帮手 Jon Yeo 12.古鱼复苏 Damian Nenow 13.新运十三 Jerome Chen 14.齐马的作品 Robert Valley 15.盲点 Vitality Shushko 16.冰河时代 Tim Miller 17.不一样的历史 Victor Maldonado & Alfredo Torres 18.秘密战争 Istvan Zorkoczy","source":"_posts/2019-e7-a5-9e-e5-89-a7-e6-8e-a8-e8-8d-90-e8-b1-86-e7-93-a3-e8-af-84-e5-88-869-3-e3-80-8a-e7-88-b1-ef-bc-8c-e6-ad-bb-e4-ba-a1-e5-92-8c-e6-9c-ba-e5-99-a8-e4-ba-ba-e3-80-8b.md","raw":"---\ntitle: 2019神剧推荐 - 豆瓣评分9.3-《爱，死亡和机器人》\ntags:\n  - 电影\n  - 高清\nurl: 174.html\nid: 174\ncategories:\n  - 影视资源\ndate: 2019-06-24 19:38:53\n---\n\n![2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3](http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdoygiwj30zk0k0427.jpg \"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\") ![2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3](http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdtnxanj30zk0k0wgv.jpg \"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\") ![2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3](http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdxf15fj30zk0k040j.jpg \"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\") 警告：本部影片为R级影片，未满18周岁未成年人禁止观看 这部名为《爱，死亡和机器人》的动画短片合集由18部分组成，每部分时长5-15分钟。这些短片涵盖多种类型，包括科幻、奇幻、恐怖和喜剧；这些短片也将包含多种形式，包括传统2D和3DCGI短片。\n\n18部短片导演列表：\n----------\n\n1.桑尼的优势 Dave Wilson 2.三个机器人 Víctor Maldonado&Alfredo Torres 3.证人 Alberto Mielgo 4.机动装甲 Franck Balson 5.噬魂者 Owen Sullivan 6.当酸奶统治世界 Victor Maldonado & Alfredo Torres 7.裂缝以外 Leon Berlue,Dominique Boidin,Remi Kozyra,Maxime Luere 8.祝有好的收获 Oliver Thomas 9.垃圾场 Javier Recio Gracia 10.变形者 Gabriele Pennacchioli 11.帮手 Jon Yeo 12.古鱼复苏 Damian Nenow 13.新运十三 Jerome Chen 14.齐马的作品 Robert Valley 15.盲点 Vitality Shushko 16.冰河时代 Tim Miller 17.不一样的历史 Victor Maldonado & Alfredo Torres 18.秘密战争 Istvan Zorkoczy","slug":"2019-e7-a5-9e-e5-89-a7-e6-8e-a8-e8-8d-90-e8-b1-86-e7-93-a3-e8-af-84-e5-88-869-3-e3-80-8a-e7-88-b1-ef-bc-8c-e6-ad-bb-e4-ba-a1-e5-92-8c-e6-9c-ba-e5-99-a8-e4-ba-ba-e3-80-8b","published":1,"updated":"2019-09-10T07:46:08.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp2698z0000c8gsc1e52d11","content":"<p><img src=\"http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdoygiwj30zk0k0427.jpg\" alt=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\" title=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\"> <img src=\"http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdtnxanj30zk0k0wgv.jpg\" alt=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\" title=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\"> <img src=\"http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdxf15fj30zk0k040j.jpg\" alt=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\" title=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\"> 警告：本部影片为R级影片，未满18周岁未成年人禁止观看 这部名为《爱，死亡和机器人》的动画短片合集由18部分组成，每部分时长5-15分钟。这些短片涵盖多种类型，包括科幻、奇幻、恐怖和喜剧；这些短片也将包含多种形式，包括传统2D和3DCGI短片。</p>\n<h2 id=\"18部短片导演列表：\"><a href=\"#18部短片导演列表：\" class=\"headerlink\" title=\"18部短片导演列表：\"></a>18部短片导演列表：</h2><p>1.桑尼的优势 Dave Wilson 2.三个机器人 Víctor Maldonado&amp;Alfredo Torres 3.证人 Alberto Mielgo 4.机动装甲 Franck Balson 5.噬魂者 Owen Sullivan 6.当酸奶统治世界 Victor Maldonado &amp; Alfredo Torres 7.裂缝以外 Leon Berlue,Dominique Boidin,Remi Kozyra,Maxime Luere 8.祝有好的收获 Oliver Thomas 9.垃圾场 Javier Recio Gracia 10.变形者 Gabriele Pennacchioli 11.帮手 Jon Yeo 12.古鱼复苏 Damian Nenow 13.新运十三 Jerome Chen 14.齐马的作品 Robert Valley 15.盲点 Vitality Shushko 16.冰河时代 Tim Miller 17.不一样的历史 Victor Maldonado &amp; Alfredo Torres 18.秘密战争 Istvan Zorkoczy</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><img src=\"http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdoygiwj30zk0k0427.jpg\" alt=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\" title=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\"> <img src=\"http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdtnxanj30zk0k0wgv.jpg\" alt=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\" title=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\"> <img src=\"http://img.viapi.cn/wp/sinaimg/006Qd4WYgy1g1ghdxf15fj30zk0k040j.jpg\" alt=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\" title=\"2019神剧推荐《爱，死亡和机器人》豆瓣评分9.3\"> 警告：本部影片为R级影片，未满18周岁未成年人禁止观看 这部名为《爱，死亡和机器人》的动画短片合集由18部分组成，每部分时长5-15分钟。这些短片涵盖多种类型，包括科幻、奇幻、恐怖和喜剧；这些短片也将包含多种形式，包括传统2D和3DCGI短片。</p>\n<h2 id=\"18部短片导演列表：\"><a href=\"#18部短片导演列表：\" class=\"headerlink\" title=\"18部短片导演列表：\"></a>18部短片导演列表：</h2><p>1.桑尼的优势 Dave Wilson 2.三个机器人 Víctor Maldonado&amp;Alfredo Torres 3.证人 Alberto Mielgo 4.机动装甲 Franck Balson 5.噬魂者 Owen Sullivan 6.当酸奶统治世界 Victor Maldonado &amp; Alfredo Torres 7.裂缝以外 Leon Berlue,Dominique Boidin,Remi Kozyra,Maxime Luere 8.祝有好的收获 Oliver Thomas 9.垃圾场 Javier Recio Gracia 10.变形者 Gabriele Pennacchioli 11.帮手 Jon Yeo 12.古鱼复苏 Damian Nenow 13.新运十三 Jerome Chen 14.齐马的作品 Robert Valley 15.盲点 Vitality Shushko 16.冰河时代 Tim Miller 17.不一样的历史 Victor Maldonado &amp; Alfredo Torres 18.秘密战争 Istvan Zorkoczy</p>\n"},{"title":"《切尔诺贝利》网盘1080P无删减全集资源下载分享","url":"204.html","id":"204","date":"2019-07-05T08:13:56.000Z","_content":"\n这个电视剧大家应该不陌生了，豆瓣9.6分足矣证明此剧绝非一般电视剧，1986年4月26日切尔诺贝利核电站爆炸，该事故被认为是历史上最严重的核电事故，切尔诺贝利事故导致**1亿公顷**的土地遭受污 染，造成**2000亿美元**的经济损失，反应堆周边的区域**2万年**内都不适宜居住，全球**20亿人口**受到不同程度的影响；死亡人数：9.3万人，致癌人数：27万人；触目惊心的数字！\n\n> 简介\n\n《切尔诺贝利》（Chernobyl）是由乔韩·瑞克执导，克雷格·麦辛编剧，杰瑞德·哈里斯、斯特兰·斯卡斯加德、艾米丽·沃森、杰西·巴克利等主演的电视迷你剧集。 该剧讲述了在1986年的乌克兰，究竟是什 么原因引发了切尔诺贝利事故，以及当年勇敢的众人是如何牺牲自己拯救处于灾难中的欧洲的故事。 该剧于2019年5月6日在HBO电视网首播。详细介绍>> ![《切尔诺贝利》百度云盘1080P无删减全集资源下载分享](https://beifenboke.oss-cn-shenzhen.aliyuncs.com/root/2019/06/cb8065380cd7912329e33fcfa3345982b2b7800e.jpg \"《切尔诺贝利》百度云盘1080P无删减全集资源下载分享\")","source":"_posts/204.md","raw":"---\ntitle: 《切尔诺贝利》网盘1080P无删减全集资源下载分享\ntags:\n  - 影视\nurl: 204.html\nid: 204\ncategories:\n  - 影视资源\ndate: 2019-07-05 16:13:56\n---\n\n这个电视剧大家应该不陌生了，豆瓣9.6分足矣证明此剧绝非一般电视剧，1986年4月26日切尔诺贝利核电站爆炸，该事故被认为是历史上最严重的核电事故，切尔诺贝利事故导致**1亿公顷**的土地遭受污 染，造成**2000亿美元**的经济损失，反应堆周边的区域**2万年**内都不适宜居住，全球**20亿人口**受到不同程度的影响；死亡人数：9.3万人，致癌人数：27万人；触目惊心的数字！\n\n> 简介\n\n《切尔诺贝利》（Chernobyl）是由乔韩·瑞克执导，克雷格·麦辛编剧，杰瑞德·哈里斯、斯特兰·斯卡斯加德、艾米丽·沃森、杰西·巴克利等主演的电视迷你剧集。 该剧讲述了在1986年的乌克兰，究竟是什 么原因引发了切尔诺贝利事故，以及当年勇敢的众人是如何牺牲自己拯救处于灾难中的欧洲的故事。 该剧于2019年5月6日在HBO电视网首播。详细介绍>> ![《切尔诺贝利》百度云盘1080P无删减全集资源下载分享](https://beifenboke.oss-cn-shenzhen.aliyuncs.com/root/2019/06/cb8065380cd7912329e33fcfa3345982b2b7800e.jpg \"《切尔诺贝利》百度云盘1080P无删减全集资源下载分享\")","slug":"204","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp2699f0001c8gs47a25pe1","content":"<p>这个电视剧大家应该不陌生了，豆瓣9.6分足矣证明此剧绝非一般电视剧，1986年4月26日切尔诺贝利核电站爆炸，该事故被认为是历史上最严重的核电事故，切尔诺贝利事故导致<strong>1亿公顷</strong>的土地遭受污 染，造成<strong>2000亿美元</strong>的经济损失，反应堆周边的区域<strong>2万年</strong>内都不适宜居住，全球<strong>20亿人口</strong>受到不同程度的影响；死亡人数：9.3万人，致癌人数：27万人；触目惊心的数字！</p>\n<blockquote>\n<p>简介</p>\n</blockquote>\n<p>《切尔诺贝利》（Chernobyl）是由乔韩·瑞克执导，克雷格·麦辛编剧，杰瑞德·哈里斯、斯特兰·斯卡斯加德、艾米丽·沃森、杰西·巴克利等主演的电视迷你剧集。 该剧讲述了在1986年的乌克兰，究竟是什 么原因引发了切尔诺贝利事故，以及当年勇敢的众人是如何牺牲自己拯救处于灾难中的欧洲的故事。 该剧于2019年5月6日在HBO电视网首播。详细介绍&gt;&gt; <img src=\"https://beifenboke.oss-cn-shenzhen.aliyuncs.com/root/2019/06/cb8065380cd7912329e33fcfa3345982b2b7800e.jpg\" alt=\"《切尔诺贝利》百度云盘1080P无删减全集资源下载分享\" title=\"《切尔诺贝利》百度云盘1080P无删减全集资源下载分享\"></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>这个电视剧大家应该不陌生了，豆瓣9.6分足矣证明此剧绝非一般电视剧，1986年4月26日切尔诺贝利核电站爆炸，该事故被认为是历史上最严重的核电事故，切尔诺贝利事故导致<strong>1亿公顷</strong>的土地遭受污 染，造成<strong>2000亿美元</strong>的经济损失，反应堆周边的区域<strong>2万年</strong>内都不适宜居住，全球<strong>20亿人口</strong>受到不同程度的影响；死亡人数：9.3万人，致癌人数：27万人；触目惊心的数字！</p>\n<blockquote>\n<p>简介</p>\n</blockquote>\n<p>《切尔诺贝利》（Chernobyl）是由乔韩·瑞克执导，克雷格·麦辛编剧，杰瑞德·哈里斯、斯特兰·斯卡斯加德、艾米丽·沃森、杰西·巴克利等主演的电视迷你剧集。 该剧讲述了在1986年的乌克兰，究竟是什 么原因引发了切尔诺贝利事故，以及当年勇敢的众人是如何牺牲自己拯救处于灾难中的欧洲的故事。 该剧于2019年5月6日在HBO电视网首播。详细介绍&gt;&gt; <img src=\"https://beifenboke.oss-cn-shenzhen.aliyuncs.com/root/2019/06/cb8065380cd7912329e33fcfa3345982b2b7800e.jpg\" alt=\"《切尔诺贝利》百度云盘1080P无删减全集资源下载分享\" title=\"《切尔诺贝利》百度云盘1080P无删减全集资源下载分享\"></p>\n"},{"title":"console 对象与控制台详解","url":"266.html","id":"266","date":"2019-07-18T08:43:08.000Z","_content":"\nconsole 对象\n----------\n\n`console`对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出`stdout`和标准错误`stderr`，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。 `console`的常见用途有两个。\n\n*   调试程序，显示网页代码运行时的错误信息。\n*   提供了一个命令行接口，用来与网页代码互动。\n\n`console`对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。\n\n1.  按 F12 或者`Control + Shift + i`（PC）/ `Command + Option + i`（Mac）。\n2.  浏览器菜单选择“工具/开发者工具”。\n3.  在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。\n\n打开开发者工具以后，顶端有多个面板。\n\n*   **Elements**：查看网页的 HTML 源码和 CSS 代码。\n*   **Resources**：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。\n*   **Network**：查看网页的 HTTP 通信情况。\n*   **Sources**：查看网页加载的脚本源码。\n*   **Timeline**：查看各种网页行为随时间变化的情况。\n*   **Performance**：查看网页的性能情况，比如 CPU 和内存消耗。\n*   **Console**：用来运行 JavaScript 命令。\n\n这些面板都有各自的用途，以下只介绍`Console`面板（又称为控制台）。 `Console`面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。\n\nconsole 对象的静态方法\n---------------\n\n`console`对象提供的各种静态方法，用来与控制台窗口互动。\n\n### console.log()，console.info()，console.debug()\n\n`console.log`方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。\n\n    console.log('Hello World')\n    // Hello World\n    console.log('a', 'b', 'c')\n    // a b c\n    \n\n`console.log`方法会自动在每次输出的结尾，添加换行符。\n\n    console.log(1);\n    console.log(2);\n    console.log(3);\n    // 1\n    // 2\n    // 3\n    \n\n如果第一个参数是格式字符串（使用了格式占位符），`console.log`方法将依次用后面的参数替换占位符，然后再进行输出。\n\n    console.log(' %s + %s = %s', 1, 1, 2)\n    //  1 + 1 = 2\n    \n\n上面代码中，`console.log`方法的第一个参数有三个占位符（`%s`），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。 `console.log`方法支持以下占位符，不同类型的数据必须使用对应的占位符。\n\n*   `%s` 字符串\n*   `%d` 整数\n*   `%i` 整数\n*   `%f` 浮点数\n*   `%o` 对象的链接\n*   `%c` CSS 格式字符串\n\n    var number = 11 * 9;\n    var color = 'red';\n    \n    console.log('%d %s balloons', number, color);\n    // 99 red balloons\n    \n\n上面代码中，第二个参数是数值，对应的占位符是`%d`，第三个参数是字符串，对应的占位符是`%s`。 使用`%c`占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。\n\n    console.log(\n      '%cThis text is styled!',\n      'color: red; background: yellow; font-size: 24px;'\n    )\n    \n\n上面代码运行后，输出的内容将显示为黄底红字。 `console.log`方法的两种参数格式，可以结合在一起使用。\n\n    console.log(' %s + %s ', 1, 1, '= 2')\n    // 1 + 1  = 2\n    \n\n如果参数是一个对象，`console.log`会显示该对象的值。\n\n    console.log({foo: 'bar'})\n    // Object {foo: \"bar\"}\n    console.log(Date)\n    // function Date() { [native code] }\n    \n\n上面代码输出`Date`对象的值，结果为一个构造函数。 `console.info`是`console.log`方法的别名，用法完全一样。只不过`console.info`方法会在输出信息的前面，加上一个蓝色图标。 `console.debug`方法与`console.log`方法类似，会在控制台输出调试信息。但是，默认情况下，`console.debug`输出的信息不会显示，只有在打开显示级别在`verbose`的情况下，才会显示。 `console`对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义`console.log`方法。\n\n    ['log', 'info', 'warn', 'error'].forEach(function(method) {\n      console[method] = console[method].bind(\n        console,\n        new Date().toISOString()\n      );\n    });\n    \n    console.log(\"出错了！\");\n    // 2014-05-18T09:00.000Z 出错了！\n    \n\n上面代码表示，使用自定义的`console.log`方法，可以在显示结果添加当前时间。\n\n### console.warn()，console.error()\n\n`warn`方法和`error`方法也是在控制台输出信息，它们与`log`方法的不同之处在于，`warn`方法输出信息时，在最前面加一个黄色三角，表示警告；`error`方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。\n\n    console.error('Error: %s (%i)', 'Server is not responding', 500)\n    // Error: Server is not responding (500)\n    console.warn('Warning! Too few nodes (%d)', document.childNodes.length)\n    // Warning! Too few nodes (1)\n    \n\n可以这样理解，`log`方法是写入标准输出（`stdout`），`warn`方法和`error`方法是写入标准错误（`stderr`）。\n\n### console.table()\n\n对于某些复合类型的数据，`console.table`方法可以将其转为表格显示。\n\n    var languages = [\n      { name: \"JavaScript\", fileExtension: \".js\" },\n      { name: \"TypeScript\", fileExtension: \".ts\" },\n      { name: \"CoffeeScript\", fileExtension: \".coffee\" }\n    ];\n    \n    console.table(languages);\n    \n\n上面代码的`language`变量，转为表格显示如下。\n\n(index)\n\nname\n\nfileExtension\n\n0\n\n\"JavaScript\"\n\n\".js\"\n\n1\n\n\"TypeScript\"\n\n\".ts\"\n\n2\n\n\"CoffeeScript\"\n\n\".coffee\"\n\n下面是显示表格内容的例子。\n\n    var languages = {\n      csharp: { name: \"C#\", paradigm: \"object-oriented\" },\n      fsharp: { name: \"F#\", paradigm: \"functional\" }\n    };\n    \n    console.table(languages);\n    \n\n上面代码的`language`，转为表格显示如下。\n\n(index)\n\nname\n\nparadigm\n\ncsharp\n\n\"C#\"\n\n\"object-oriented\"\n\nfsharp\n\n\"F#\"\n\n\"functional\"\n\n### console.count()\n\n`count`方法用于计数，输出它被调用了多少次。\n\n    function greet(user) {\n      console.count();\n      return 'hi ' + user;\n    }\n    \n    greet('bob')\n    //  : 1\n    // \"hi bob\"\n    \n    greet('alice')\n    //  : 2\n    // \"hi alice\"\n    \n    greet('bob')\n    //  : 3\n    // \"hi bob\"\n    \n\n上面代码每次调用`greet`函数，内部的`console.count`方法就输出执行次数。 该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。\n\n    function greet(user) {\n      console.count(user);\n      return \"hi \" + user;\n    }\n    \n    greet('bob')\n    // bob: 1\n    // \"hi bob\"\n    \n    greet('alice')\n    // alice: 1\n    // \"hi alice\"\n    \n    greet('bob')\n    // bob: 2\n    // \"hi bob\"\n    \n\n上面代码根据参数的不同，显示`bob`执行了两次，`alice`执行了一次。\n\n### console.dir()，console.dirxml()\n\n`dir`方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。\n\n    console.log({f1: 'foo', f2: 'bar'})\n    // Object {f1: \"foo\", f2: \"bar\"}\n    \n    console.dir({f1: 'foo', f2: 'bar'})\n    // Object\n    //   f1: \"foo\"\n    //   f2: \"bar\"\n    //   __proto__: Object\n    \n\n上面代码显示`dir`方法的输出结果，比`log`方法更易读，信息也更丰富。 该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。\n\n    console.dir(document.body)\n    \n\nNode 环境之中，还可以指定以代码高亮的形式输出。\n\n    console.dir(obj, {colors: true})\n    \n\n`dirxml`方法主要用于以目录树的形式，显示 DOM 节点。\n\n    console.dirxml(document.body)\n    \n\n如果参数不是 DOM 节点，而是普通的 JavaScript 对象，`console.dirxml`等同于`console.dir`。\n\n    console.dirxml([1, 2, 3])\n    // 等同于\n    console.dir([1, 2, 3])\n    \n\n### console.assert()\n\n`console.assert`方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。 它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为`false`，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。\n\n    console.assert(false, '判断条件不成立')\n    // Assertion failed: 判断条件不成立\n    \n    // 相当于\n    try {\n      if (!false) {\n        throw new Error('判断条件不成立');\n      }\n    } catch(e) {\n      console.error(e);\n    }\n    \n\n下面是一个例子，判断子节点的个数是否大于等于500。\n\n    console.assert(list.childNodes.length < 500, '节点个数大于等于500')\n    \n\n上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。\n\n### console.time()，console.timeEnd()\n\n这两个方法用于计时，可以算出一个操作所花费的准确时间。\n\n    console.time('Array initialize');\n    \n    var array= new Array(1000000);\n    for (var i = array.length - 1; i >= 0; i--) {\n      array[i] = new Object();\n    };\n    \n    console.timeEnd('Array initialize');\n    // Array initialize: 1914.481ms\n    \n\n`time`方法表示计时开始，`timeEnd`方法表示计时结束。它们的参数是计时器的名称。调用`timeEnd`方法之后，控制台会显示“计时器名称: 所耗费的时间”。\n\n### console.group()，console.groupEnd()，console.groupCollapsed()\n\n`console.group`和`console.groupEnd`这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。\n\n    console.group('一级分组');\n    console.log('一级分组的内容');\n    \n    console.group('二级分组');\n    console.log('二级分组的内容');\n    \n    console.groupEnd(); // 二级分组结束\n    console.groupEnd(); // 一级分组结束\n    \n\n上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。 `console.groupCollapsed`方法与`console.group`方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。\n\n    console.groupCollapsed('Fetching Data');\n    \n    console.log('Request Sent');\n    console.error('Error: Server not responding (500)');\n    \n    console.groupEnd();\n    \n\n上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。\n\n### console.trace()，console.clear()\n\n`console.trace`方法显示当前执行的代码在堆栈中的调用路径。\n\n    console.trace()\n    // console.trace()\n    //   (anonymous function)\n    //   InjectedScript._evaluateOn\n    //   InjectedScript._evaluateAndWrap\n    //   InjectedScript.evaluate\n    \n\n`console.clear`方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，`console.clear`方法将不起作用。\n\n控制台命令行 API\n----------\n\n浏览器控制台中，除了使用`console`对象，还可以使用一些控制台自带的命令行方法。 （1）`$_` `$_`属性返回上一个表达式的值。\n\n    2 + 2\n    // 4\n    $_\n    // 4\n    \n\n（2）`$0` - `$4` 控制台保存了最近5个在 Elements 面板选中的 DOM 元素，`$0`代表倒数第一个（最近一个），`$1`代表倒数第二个，以此类推直到`$4`。 （3）`$(selector)` `$(selector)`返回第一个匹配的元素，等同于`document.querySelector()`。注意，如果页面脚本对`$`有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行`$(selector)`就会采用 jQuery 的实现，返回一个数组。 （4）`$$(selector)` `$$(selector)`返回选中的 DOM 对象，等同于`document.querySelectorAll`。 （5）`$x(path)` `$x(path)`方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。\n\n    $x(\"//p[a]\")\n    \n\n上面代码返回所有包含`a`元素的`p`元素。 （6）`inspect(object)` `inspect(object)`方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在`Elements`面板中显示，比如`inspect(document)`会在 Elements 面板显示`document`元素。JavaScript 对象在控制台面板`Profiles`面板中显示，比如`inspect(window)`。 （7）`getEventListeners(object)` `getEventListeners(object)`方法返回一个对象，该对象的成员为`object`登记了回调函数的各种事件（比如`click`或`keydown`），每个事件对应一个数组，数组的成员为该事件的回调函数。 （8）`keys(object)`，`values(object)` `keys(object)`方法返回一个数组，包含`object`的所有键名。 `values(object)`方法返回一个数组，包含`object`的所有键值。\n\n    var o = {'p1': 'a', 'p2': 'b'};\n    \n    keys(o)\n    // [\"p1\", \"p2\"]\n    values(o)\n    // [\"a\", \"b\"]\n    \n\n（9）`monitorEvents(object[, events]) ，unmonitorEvents(object[, events])` `monitorEvents(object[, events])`方法监听特定对象上发生的特定事件。事件发生时，会返回一个`Event`对象，包含该事件的相关信息。`unmonitorEvents`方法用于停止监听。\n\n    monitorEvents(window, \"resize\");\n    monitorEvents(window, [\"resize\", \"scroll\"])\n    \n\n上面代码分别表示单个事件和多个事件的监听方法。\n\n    monitorEvents($0, 'mouse');\n    unmonitorEvents($0, 'mousemove');\n    \n\n上面代码表示如何停止监听。 `monitorEvents`允许监听同一大类的事件。所有事件可以分成四个大类。\n\n*   mouse：\"mousedown\", \"mouseup\", \"click\", \"dblclick\", \"mousemove\", \"mouseover\", \"mouseout\", \"mousewheel\"\n*   key：\"keydown\", \"keyup\", \"keypress\", \"textInput\"\n*   touch：\"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\"\n*   control：\"resize\", \"scroll\", \"zoom\", \"focus\", \"blur\", \"select\", \"change\", \"submit\", \"reset\"\n\n    monitorEvents($(\"#msg\"), \"key\");\n    \n\n上面代码表示监听所有`key`大类的事件。 （10）其他方法 命令行 API 还提供以下方法。\n\n*   `clear()`：清除控制台的历史。\n*   `copy(object)`：复制特定 DOM 元素到剪贴板。\n*   `dir(object)`：显示特定对象的所有属性，是`console.dir`方法的别名。\n*   `dirxml(object)`：显示特定对象的 XML 形式，是`console.dirxml`方法的别名。\n\ndebugger 语句\n-----------\n\n`debugger`语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到`debugger`语句时会自动停下。如果没有除错工具，`debugger`语句不会产生任何结果，JavaScript 引擎自动跳过这一句。 Chrome 浏览器中，当代码运行到`debugger`语句时，就会暂停运行，自动打开脚本源码界面。\n\n    for(var i = 0; i < 5; i++){\n      console.log(i);\n      if (i === 2) debugger;\n    }\n    \n\n上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。\n\n参考链接\n----\n\n*   Chrome Developer Tools, [Using the Console](https://developers.google.com/chrome-developer-tools/docs/console)\n*   Matt West, [Mastering The Developer Tools Console](http://blog.teamtreehouse.com/mastering-developer-tools-console)\n*   Firebug Wiki, [Console API](https://getfirebug.com/wiki/index.php/Console_API)\n*   Axel Rauschmayer, [The JavaScript console API](http://www.2ality.com/2013/10/console-api.html)\n*   Marius Schulz, [Advanced JavaScript Debugging with console.table()](http://blog.mariusschulz.com/2013/11/13/advanced-javascript-debugging-with-consoletable)\n*   Google Developer, [Command Line API Reference](https://developers.google.com/chrome-developer-tools/docs/commandline-api)","source":"_posts/console-e5-af-b9-e8-b1-a1-e4-b8-8e-e6-8e-a7-e5-88-b6-e5-8f-b0-e8-af-a6-e8-a7-a3.md","raw":"---\ntitle: console 对象与控制台详解\ntags:\n  - JavaScript\nurl: 266.html\nid: 266\ncategories:\n  - 大前端\ndate: 2019-07-18 16:43:08\n---\n\nconsole 对象\n----------\n\n`console`对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出`stdout`和标准错误`stderr`，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。 `console`的常见用途有两个。\n\n*   调试程序，显示网页代码运行时的错误信息。\n*   提供了一个命令行接口，用来与网页代码互动。\n\n`console`对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。\n\n1.  按 F12 或者`Control + Shift + i`（PC）/ `Command + Option + i`（Mac）。\n2.  浏览器菜单选择“工具/开发者工具”。\n3.  在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。\n\n打开开发者工具以后，顶端有多个面板。\n\n*   **Elements**：查看网页的 HTML 源码和 CSS 代码。\n*   **Resources**：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。\n*   **Network**：查看网页的 HTTP 通信情况。\n*   **Sources**：查看网页加载的脚本源码。\n*   **Timeline**：查看各种网页行为随时间变化的情况。\n*   **Performance**：查看网页的性能情况，比如 CPU 和内存消耗。\n*   **Console**：用来运行 JavaScript 命令。\n\n这些面板都有各自的用途，以下只介绍`Console`面板（又称为控制台）。 `Console`面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。\n\nconsole 对象的静态方法\n---------------\n\n`console`对象提供的各种静态方法，用来与控制台窗口互动。\n\n### console.log()，console.info()，console.debug()\n\n`console.log`方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。\n\n    console.log('Hello World')\n    // Hello World\n    console.log('a', 'b', 'c')\n    // a b c\n    \n\n`console.log`方法会自动在每次输出的结尾，添加换行符。\n\n    console.log(1);\n    console.log(2);\n    console.log(3);\n    // 1\n    // 2\n    // 3\n    \n\n如果第一个参数是格式字符串（使用了格式占位符），`console.log`方法将依次用后面的参数替换占位符，然后再进行输出。\n\n    console.log(' %s + %s = %s', 1, 1, 2)\n    //  1 + 1 = 2\n    \n\n上面代码中，`console.log`方法的第一个参数有三个占位符（`%s`），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。 `console.log`方法支持以下占位符，不同类型的数据必须使用对应的占位符。\n\n*   `%s` 字符串\n*   `%d` 整数\n*   `%i` 整数\n*   `%f` 浮点数\n*   `%o` 对象的链接\n*   `%c` CSS 格式字符串\n\n    var number = 11 * 9;\n    var color = 'red';\n    \n    console.log('%d %s balloons', number, color);\n    // 99 red balloons\n    \n\n上面代码中，第二个参数是数值，对应的占位符是`%d`，第三个参数是字符串，对应的占位符是`%s`。 使用`%c`占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。\n\n    console.log(\n      '%cThis text is styled!',\n      'color: red; background: yellow; font-size: 24px;'\n    )\n    \n\n上面代码运行后，输出的内容将显示为黄底红字。 `console.log`方法的两种参数格式，可以结合在一起使用。\n\n    console.log(' %s + %s ', 1, 1, '= 2')\n    // 1 + 1  = 2\n    \n\n如果参数是一个对象，`console.log`会显示该对象的值。\n\n    console.log({foo: 'bar'})\n    // Object {foo: \"bar\"}\n    console.log(Date)\n    // function Date() { [native code] }\n    \n\n上面代码输出`Date`对象的值，结果为一个构造函数。 `console.info`是`console.log`方法的别名，用法完全一样。只不过`console.info`方法会在输出信息的前面，加上一个蓝色图标。 `console.debug`方法与`console.log`方法类似，会在控制台输出调试信息。但是，默认情况下，`console.debug`输出的信息不会显示，只有在打开显示级别在`verbose`的情况下，才会显示。 `console`对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义`console.log`方法。\n\n    ['log', 'info', 'warn', 'error'].forEach(function(method) {\n      console[method] = console[method].bind(\n        console,\n        new Date().toISOString()\n      );\n    });\n    \n    console.log(\"出错了！\");\n    // 2014-05-18T09:00.000Z 出错了！\n    \n\n上面代码表示，使用自定义的`console.log`方法，可以在显示结果添加当前时间。\n\n### console.warn()，console.error()\n\n`warn`方法和`error`方法也是在控制台输出信息，它们与`log`方法的不同之处在于，`warn`方法输出信息时，在最前面加一个黄色三角，表示警告；`error`方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。\n\n    console.error('Error: %s (%i)', 'Server is not responding', 500)\n    // Error: Server is not responding (500)\n    console.warn('Warning! Too few nodes (%d)', document.childNodes.length)\n    // Warning! Too few nodes (1)\n    \n\n可以这样理解，`log`方法是写入标准输出（`stdout`），`warn`方法和`error`方法是写入标准错误（`stderr`）。\n\n### console.table()\n\n对于某些复合类型的数据，`console.table`方法可以将其转为表格显示。\n\n    var languages = [\n      { name: \"JavaScript\", fileExtension: \".js\" },\n      { name: \"TypeScript\", fileExtension: \".ts\" },\n      { name: \"CoffeeScript\", fileExtension: \".coffee\" }\n    ];\n    \n    console.table(languages);\n    \n\n上面代码的`language`变量，转为表格显示如下。\n\n(index)\n\nname\n\nfileExtension\n\n0\n\n\"JavaScript\"\n\n\".js\"\n\n1\n\n\"TypeScript\"\n\n\".ts\"\n\n2\n\n\"CoffeeScript\"\n\n\".coffee\"\n\n下面是显示表格内容的例子。\n\n    var languages = {\n      csharp: { name: \"C#\", paradigm: \"object-oriented\" },\n      fsharp: { name: \"F#\", paradigm: \"functional\" }\n    };\n    \n    console.table(languages);\n    \n\n上面代码的`language`，转为表格显示如下。\n\n(index)\n\nname\n\nparadigm\n\ncsharp\n\n\"C#\"\n\n\"object-oriented\"\n\nfsharp\n\n\"F#\"\n\n\"functional\"\n\n### console.count()\n\n`count`方法用于计数，输出它被调用了多少次。\n\n    function greet(user) {\n      console.count();\n      return 'hi ' + user;\n    }\n    \n    greet('bob')\n    //  : 1\n    // \"hi bob\"\n    \n    greet('alice')\n    //  : 2\n    // \"hi alice\"\n    \n    greet('bob')\n    //  : 3\n    // \"hi bob\"\n    \n\n上面代码每次调用`greet`函数，内部的`console.count`方法就输出执行次数。 该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。\n\n    function greet(user) {\n      console.count(user);\n      return \"hi \" + user;\n    }\n    \n    greet('bob')\n    // bob: 1\n    // \"hi bob\"\n    \n    greet('alice')\n    // alice: 1\n    // \"hi alice\"\n    \n    greet('bob')\n    // bob: 2\n    // \"hi bob\"\n    \n\n上面代码根据参数的不同，显示`bob`执行了两次，`alice`执行了一次。\n\n### console.dir()，console.dirxml()\n\n`dir`方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。\n\n    console.log({f1: 'foo', f2: 'bar'})\n    // Object {f1: \"foo\", f2: \"bar\"}\n    \n    console.dir({f1: 'foo', f2: 'bar'})\n    // Object\n    //   f1: \"foo\"\n    //   f2: \"bar\"\n    //   __proto__: Object\n    \n\n上面代码显示`dir`方法的输出结果，比`log`方法更易读，信息也更丰富。 该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。\n\n    console.dir(document.body)\n    \n\nNode 环境之中，还可以指定以代码高亮的形式输出。\n\n    console.dir(obj, {colors: true})\n    \n\n`dirxml`方法主要用于以目录树的形式，显示 DOM 节点。\n\n    console.dirxml(document.body)\n    \n\n如果参数不是 DOM 节点，而是普通的 JavaScript 对象，`console.dirxml`等同于`console.dir`。\n\n    console.dirxml([1, 2, 3])\n    // 等同于\n    console.dir([1, 2, 3])\n    \n\n### console.assert()\n\n`console.assert`方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。 它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为`false`，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。\n\n    console.assert(false, '判断条件不成立')\n    // Assertion failed: 判断条件不成立\n    \n    // 相当于\n    try {\n      if (!false) {\n        throw new Error('判断条件不成立');\n      }\n    } catch(e) {\n      console.error(e);\n    }\n    \n\n下面是一个例子，判断子节点的个数是否大于等于500。\n\n    console.assert(list.childNodes.length < 500, '节点个数大于等于500')\n    \n\n上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。\n\n### console.time()，console.timeEnd()\n\n这两个方法用于计时，可以算出一个操作所花费的准确时间。\n\n    console.time('Array initialize');\n    \n    var array= new Array(1000000);\n    for (var i = array.length - 1; i >= 0; i--) {\n      array[i] = new Object();\n    };\n    \n    console.timeEnd('Array initialize');\n    // Array initialize: 1914.481ms\n    \n\n`time`方法表示计时开始，`timeEnd`方法表示计时结束。它们的参数是计时器的名称。调用`timeEnd`方法之后，控制台会显示“计时器名称: 所耗费的时间”。\n\n### console.group()，console.groupEnd()，console.groupCollapsed()\n\n`console.group`和`console.groupEnd`这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。\n\n    console.group('一级分组');\n    console.log('一级分组的内容');\n    \n    console.group('二级分组');\n    console.log('二级分组的内容');\n    \n    console.groupEnd(); // 二级分组结束\n    console.groupEnd(); // 一级分组结束\n    \n\n上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。 `console.groupCollapsed`方法与`console.group`方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。\n\n    console.groupCollapsed('Fetching Data');\n    \n    console.log('Request Sent');\n    console.error('Error: Server not responding (500)');\n    \n    console.groupEnd();\n    \n\n上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。\n\n### console.trace()，console.clear()\n\n`console.trace`方法显示当前执行的代码在堆栈中的调用路径。\n\n    console.trace()\n    // console.trace()\n    //   (anonymous function)\n    //   InjectedScript._evaluateOn\n    //   InjectedScript._evaluateAndWrap\n    //   InjectedScript.evaluate\n    \n\n`console.clear`方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，`console.clear`方法将不起作用。\n\n控制台命令行 API\n----------\n\n浏览器控制台中，除了使用`console`对象，还可以使用一些控制台自带的命令行方法。 （1）`$_` `$_`属性返回上一个表达式的值。\n\n    2 + 2\n    // 4\n    $_\n    // 4\n    \n\n（2）`$0` - `$4` 控制台保存了最近5个在 Elements 面板选中的 DOM 元素，`$0`代表倒数第一个（最近一个），`$1`代表倒数第二个，以此类推直到`$4`。 （3）`$(selector)` `$(selector)`返回第一个匹配的元素，等同于`document.querySelector()`。注意，如果页面脚本对`$`有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行`$(selector)`就会采用 jQuery 的实现，返回一个数组。 （4）`$$(selector)` `$$(selector)`返回选中的 DOM 对象，等同于`document.querySelectorAll`。 （5）`$x(path)` `$x(path)`方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。\n\n    $x(\"//p[a]\")\n    \n\n上面代码返回所有包含`a`元素的`p`元素。 （6）`inspect(object)` `inspect(object)`方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在`Elements`面板中显示，比如`inspect(document)`会在 Elements 面板显示`document`元素。JavaScript 对象在控制台面板`Profiles`面板中显示，比如`inspect(window)`。 （7）`getEventListeners(object)` `getEventListeners(object)`方法返回一个对象，该对象的成员为`object`登记了回调函数的各种事件（比如`click`或`keydown`），每个事件对应一个数组，数组的成员为该事件的回调函数。 （8）`keys(object)`，`values(object)` `keys(object)`方法返回一个数组，包含`object`的所有键名。 `values(object)`方法返回一个数组，包含`object`的所有键值。\n\n    var o = {'p1': 'a', 'p2': 'b'};\n    \n    keys(o)\n    // [\"p1\", \"p2\"]\n    values(o)\n    // [\"a\", \"b\"]\n    \n\n（9）`monitorEvents(object[, events]) ，unmonitorEvents(object[, events])` `monitorEvents(object[, events])`方法监听特定对象上发生的特定事件。事件发生时，会返回一个`Event`对象，包含该事件的相关信息。`unmonitorEvents`方法用于停止监听。\n\n    monitorEvents(window, \"resize\");\n    monitorEvents(window, [\"resize\", \"scroll\"])\n    \n\n上面代码分别表示单个事件和多个事件的监听方法。\n\n    monitorEvents($0, 'mouse');\n    unmonitorEvents($0, 'mousemove');\n    \n\n上面代码表示如何停止监听。 `monitorEvents`允许监听同一大类的事件。所有事件可以分成四个大类。\n\n*   mouse：\"mousedown\", \"mouseup\", \"click\", \"dblclick\", \"mousemove\", \"mouseover\", \"mouseout\", \"mousewheel\"\n*   key：\"keydown\", \"keyup\", \"keypress\", \"textInput\"\n*   touch：\"touchstart\", \"touchmove\", \"touchend\", \"touchcancel\"\n*   control：\"resize\", \"scroll\", \"zoom\", \"focus\", \"blur\", \"select\", \"change\", \"submit\", \"reset\"\n\n    monitorEvents($(\"#msg\"), \"key\");\n    \n\n上面代码表示监听所有`key`大类的事件。 （10）其他方法 命令行 API 还提供以下方法。\n\n*   `clear()`：清除控制台的历史。\n*   `copy(object)`：复制特定 DOM 元素到剪贴板。\n*   `dir(object)`：显示特定对象的所有属性，是`console.dir`方法的别名。\n*   `dirxml(object)`：显示特定对象的 XML 形式，是`console.dirxml`方法的别名。\n\ndebugger 语句\n-----------\n\n`debugger`语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到`debugger`语句时会自动停下。如果没有除错工具，`debugger`语句不会产生任何结果，JavaScript 引擎自动跳过这一句。 Chrome 浏览器中，当代码运行到`debugger`语句时，就会暂停运行，自动打开脚本源码界面。\n\n    for(var i = 0; i < 5; i++){\n      console.log(i);\n      if (i === 2) debugger;\n    }\n    \n\n上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。\n\n参考链接\n----\n\n*   Chrome Developer Tools, [Using the Console](https://developers.google.com/chrome-developer-tools/docs/console)\n*   Matt West, [Mastering The Developer Tools Console](http://blog.teamtreehouse.com/mastering-developer-tools-console)\n*   Firebug Wiki, [Console API](https://getfirebug.com/wiki/index.php/Console_API)\n*   Axel Rauschmayer, [The JavaScript console API](http://www.2ality.com/2013/10/console-api.html)\n*   Marius Schulz, [Advanced JavaScript Debugging with console.table()](http://blog.mariusschulz.com/2013/11/13/advanced-javascript-debugging-with-consoletable)\n*   Google Developer, [Command Line API Reference](https://developers.google.com/chrome-developer-tools/docs/commandline-api)","slug":"console-e5-af-b9-e8-b1-a1-e4-b8-8e-e6-8e-a7-e5-88-b6-e5-8f-b0-e8-af-a6-e8-a7-a3","published":1,"updated":"2019-09-10T07:46:08.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp2699j0003c8gs87jf4qq0","content":"<h2 id=\"console-对象\"><a href=\"#console-对象\" class=\"headerlink\" title=\"console 对象\"></a>console 对象</h2><p><code>console</code>对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出<code>stdout</code>和标准错误<code>stderr</code>，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。 <code>console</code>的常见用途有两个。</p>\n<ul>\n<li>  调试程序，显示网页代码运行时的错误信息。</li>\n<li>  提供了一个命令行接口，用来与网页代码互动。</li>\n</ul>\n<p><code>console</code>对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。</p>\n<ol>\n<li> 按 F12 或者<code>Control + Shift + i</code>（PC）/ <code>Command + Option + i</code>（Mac）。</li>\n<li> 浏览器菜单选择“工具/开发者工具”。</li>\n<li> 在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。</li>\n</ol>\n<p>打开开发者工具以后，顶端有多个面板。</p>\n<ul>\n<li>  <strong>Elements</strong>：查看网页的 HTML 源码和 CSS 代码。</li>\n<li>  <strong>Resources</strong>：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。</li>\n<li>  <strong>Network</strong>：查看网页的 HTTP 通信情况。</li>\n<li>  <strong>Sources</strong>：查看网页加载的脚本源码。</li>\n<li>  <strong>Timeline</strong>：查看各种网页行为随时间变化的情况。</li>\n<li>  <strong>Performance</strong>：查看网页的性能情况，比如 CPU 和内存消耗。</li>\n<li>  <strong>Console</strong>：用来运行 JavaScript 命令。</li>\n</ul>\n<p>这些面板都有各自的用途，以下只介绍<code>Console</code>面板（又称为控制台）。 <code>Console</code>面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。</p>\n<h2 id=\"console-对象的静态方法\"><a href=\"#console-对象的静态方法\" class=\"headerlink\" title=\"console 对象的静态方法\"></a>console 对象的静态方法</h2><p><code>console</code>对象提供的各种静态方法，用来与控制台窗口互动。</p>\n<h3 id=\"console-log-，console-info-，console-debug\"><a href=\"#console-log-，console-info-，console-debug\" class=\"headerlink\" title=\"console.log()，console.info()，console.debug()\"></a>console.log()，console.info()，console.debug()</h3><p><code>console.log</code>方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p>\n<pre><code>console.log(&#39;Hello World&#39;)\n// Hello World\nconsole.log(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)\n// a b c\n</code></pre>\n<p><code>console.log</code>方法会自动在每次输出的结尾，添加换行符。</p>\n<pre><code>console.log(1);\nconsole.log(2);\nconsole.log(3);\n// 1\n// 2\n// 3\n</code></pre>\n<p>如果第一个参数是格式字符串（使用了格式占位符），<code>console.log</code>方法将依次用后面的参数替换占位符，然后再进行输出。</p>\n<pre><code>console.log(&#39; %s + %s = %s&#39;, 1, 1, 2)\n//  1 + 1 = 2\n</code></pre>\n<p>上面代码中，<code>console.log</code>方法的第一个参数有三个占位符（<code>%s</code>），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。 <code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p>\n<ul>\n<li><p>  <code>%s</code> 字符串</p>\n</li>\n<li><p>  <code>%d</code> 整数</p>\n</li>\n<li><p>  <code>%i</code> 整数</p>\n</li>\n<li><p>  <code>%f</code> 浮点数</p>\n</li>\n<li><p>  <code>%o</code> 对象的链接</p>\n</li>\n<li><p><code>%c</code> CSS 格式字符串</p>\n<p>  var number = 11 * 9;<br>  var color = ‘red’;</p>\n<p>  console.log(‘%d %s balloons’, number, color);<br>  // 99 red balloons</p>\n</li>\n</ul>\n<p>上面代码中，第二个参数是数值，对应的占位符是<code>%d</code>，第三个参数是字符串，对应的占位符是<code>%s</code>。 使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p>\n<pre><code>console.log(\n  &#39;%cThis text is styled!&#39;,\n  &#39;color: red; background: yellow; font-size: 24px;&#39;\n)\n</code></pre>\n<p>上面代码运行后，输出的内容将显示为黄底红字。 <code>console.log</code>方法的两种参数格式，可以结合在一起使用。</p>\n<pre><code>console.log(&#39; %s + %s &#39;, 1, 1, &#39;= 2&#39;)\n// 1 + 1  = 2\n</code></pre>\n<p>如果参数是一个对象，<code>console.log</code>会显示该对象的值。</p>\n<pre><code>console.log(&#123;foo: &#39;bar&#39;&#125;)\n// Object &#123;foo: &quot;bar&quot;&#125;\nconsole.log(Date)\n// function Date() &#123; [native code] &#125;\n</code></pre>\n<p>上面代码输出<code>Date</code>对象的值，结果为一个构造函数。 <code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标。 <code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示。 <code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法。</p>\n<pre><code>[&#39;log&#39;, &#39;info&#39;, &#39;warn&#39;, &#39;error&#39;].forEach(function(method) &#123;\n  console[method] = console[method].bind(\n    console,\n    new Date().toISOString()\n  );\n&#125;);\n\nconsole.log(&quot;出错了！&quot;);\n// 2014-05-18T09:00.000Z 出错了！\n</code></pre>\n<p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间。</p>\n<h3 id=\"console-warn-，console-error\"><a href=\"#console-warn-，console-error\" class=\"headerlink\" title=\"console.warn()，console.error()\"></a>console.warn()，console.error()</h3><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p>\n<pre><code>console.error(&#39;Error: %s (%i)&#39;, &#39;Server is not responding&#39;, 500)\n// Error: Server is not responding (500)\nconsole.warn(&#39;Warning! Too few nodes (%d)&#39;, document.childNodes.length)\n// Warning! Too few nodes (1)\n</code></pre>\n<p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）。</p>\n<h3 id=\"console-table\"><a href=\"#console-table\" class=\"headerlink\" title=\"console.table()\"></a>console.table()</h3><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。</p>\n<pre><code>var languages = [\n  &#123; name: &quot;JavaScript&quot;, fileExtension: &quot;.js&quot; &#125;,\n  &#123; name: &quot;TypeScript&quot;, fileExtension: &quot;.ts&quot; &#125;,\n  &#123; name: &quot;CoffeeScript&quot;, fileExtension: &quot;.coffee&quot; &#125;\n];\n\nconsole.table(languages);\n</code></pre>\n<p>上面代码的<code>language</code>变量，转为表格显示如下。</p>\n<p>(index)</p>\n<p>name</p>\n<p>fileExtension</p>\n<p>0</p>\n<p>“JavaScript”</p>\n<p>“.js”</p>\n<p>1</p>\n<p>“TypeScript”</p>\n<p>“.ts”</p>\n<p>2</p>\n<p>“CoffeeScript”</p>\n<p>“.coffee”</p>\n<p>下面是显示表格内容的例子。</p>\n<pre><code>var languages = &#123;\n  csharp: &#123; name: &quot;C#&quot;, paradigm: &quot;object-oriented&quot; &#125;,\n  fsharp: &#123; name: &quot;F#&quot;, paradigm: &quot;functional&quot; &#125;\n&#125;;\n\nconsole.table(languages);\n</code></pre>\n<p>上面代码的<code>language</code>，转为表格显示如下。</p>\n<p>(index)</p>\n<p>name</p>\n<p>paradigm</p>\n<p>csharp</p>\n<p>“C#”</p>\n<p>“object-oriented”</p>\n<p>fsharp</p>\n<p>“F#”</p>\n<p>“functional”</p>\n<h3 id=\"console-count\"><a href=\"#console-count\" class=\"headerlink\" title=\"console.count()\"></a>console.count()</h3><p><code>count</code>方法用于计数，输出它被调用了多少次。</p>\n<pre><code>function greet(user) &#123;\n  console.count();\n  return &#39;hi &#39; + user;\n&#125;\n\ngreet(&#39;bob&#39;)\n//  : 1\n// &quot;hi bob&quot;\n\ngreet(&#39;alice&#39;)\n//  : 2\n// &quot;hi alice&quot;\n\ngreet(&#39;bob&#39;)\n//  : 3\n// &quot;hi bob&quot;\n</code></pre>\n<p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数。 该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p>\n<pre><code>function greet(user) &#123;\n  console.count(user);\n  return &quot;hi &quot; + user;\n&#125;\n\ngreet(&#39;bob&#39;)\n// bob: 1\n// &quot;hi bob&quot;\n\ngreet(&#39;alice&#39;)\n// alice: 1\n// &quot;hi alice&quot;\n\ngreet(&#39;bob&#39;)\n// bob: 2\n// &quot;hi bob&quot;\n</code></pre>\n<p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p>\n<h3 id=\"console-dir-，console-dirxml\"><a href=\"#console-dir-，console-dirxml\" class=\"headerlink\" title=\"console.dir()，console.dirxml()\"></a>console.dir()，console.dirxml()</h3><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>\n<pre><code>console.log(&#123;f1: &#39;foo&#39;, f2: &#39;bar&#39;&#125;)\n// Object &#123;f1: &quot;foo&quot;, f2: &quot;bar&quot;&#125;\n\nconsole.dir(&#123;f1: &#39;foo&#39;, f2: &#39;bar&#39;&#125;)\n// Object\n//   f1: &quot;foo&quot;\n//   f2: &quot;bar&quot;\n//   __proto__: Object\n</code></pre>\n<p>上面代码显示<code>dir</code>方法的输出结果，比<code>log</code>方法更易读，信息也更丰富。 该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。</p>\n<pre><code>console.dir(document.body)\n</code></pre>\n<p>Node 环境之中，还可以指定以代码高亮的形式输出。</p>\n<pre><code>console.dir(obj, &#123;colors: true&#125;)\n</code></pre>\n<p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点。</p>\n<pre><code>console.dirxml(document.body)\n</code></pre>\n<p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code>。</p>\n<pre><code>console.dirxml([1, 2, 3])\n// 等同于\nconsole.dir([1, 2, 3])\n</code></pre>\n<h3 id=\"console-assert\"><a href=\"#console-assert\" class=\"headerlink\" title=\"console.assert()\"></a>console.assert()</h3><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。 它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>\n<pre><code>console.assert(false, &#39;判断条件不成立&#39;)\n// Assertion failed: 判断条件不成立\n\n// 相当于\ntry &#123;\n  if (!false) &#123;\n    throw new Error(&#39;判断条件不成立&#39;);\n  &#125;\n&#125; catch(e) &#123;\n  console.error(e);\n&#125;\n</code></pre>\n<p>下面是一个例子，判断子节点的个数是否大于等于500。</p>\n<pre><code>console.assert(list.childNodes.length &lt; 500, &#39;节点个数大于等于500&#39;)\n</code></pre>\n<p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</p>\n<h3 id=\"console-time-，console-timeEnd\"><a href=\"#console-time-，console-timeEnd\" class=\"headerlink\" title=\"console.time()，console.timeEnd()\"></a>console.time()，console.timeEnd()</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p>\n<pre><code>console.time(&#39;Array initialize&#39;);\n\nvar array= new Array(1000000);\nfor (var i = array.length - 1; i &gt;= 0; i--) &#123;\n  array[i] = new Object();\n&#125;;\n\nconsole.timeEnd(&#39;Array initialize&#39;);\n// Array initialize: 1914.481ms\n</code></pre>\n<p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p>\n<h3 id=\"console-group-，console-groupEnd-，console-groupCollapsed\"><a href=\"#console-group-，console-groupEnd-，console-groupCollapsed\" class=\"headerlink\" title=\"console.group()，console.groupEnd()，console.groupCollapsed()\"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h3><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p>\n<pre><code>console.group(&#39;一级分组&#39;);\nconsole.log(&#39;一级分组的内容&#39;);\n\nconsole.group(&#39;二级分组&#39;);\nconsole.log(&#39;二级分组的内容&#39;);\n\nconsole.groupEnd(); // 二级分组结束\nconsole.groupEnd(); // 一级分组结束\n</code></pre>\n<p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。 <code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p>\n<pre><code>console.groupCollapsed(&#39;Fetching Data&#39;);\n\nconsole.log(&#39;Request Sent&#39;);\nconsole.error(&#39;Error: Server not responding (500)&#39;);\n\nconsole.groupEnd();\n</code></pre>\n<p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。</p>\n<h3 id=\"console-trace-，console-clear\"><a href=\"#console-trace-，console-clear\" class=\"headerlink\" title=\"console.trace()，console.clear()\"></a>console.trace()，console.clear()</h3><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>\n<pre><code>console.trace()\n// console.trace()\n//   (anonymous function)\n//   InjectedScript._evaluateOn\n//   InjectedScript._evaluateAndWrap\n//   InjectedScript.evaluate\n</code></pre>\n<p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p>\n<h2 id=\"控制台命令行-API\"><a href=\"#控制台命令行-API\" class=\"headerlink\" title=\"控制台命令行 API\"></a>控制台命令行 API</h2><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法。 （1）<code>$_</code> <code>$_</code>属性返回上一个表达式的值。</p>\n<pre><code>2 + 2\n// 4\n$_\n// 4\n</code></pre>\n<p>（2）<code>$0</code> - <code>$4</code> 控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。 （3）<code>$(selector)</code> <code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。 （4）<code>$$(selector)</code> <code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。 （5）<code>$x(path)</code> <code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p>\n<pre><code>$x(&quot;//p[a]&quot;)\n</code></pre>\n<p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。 （6）<code>inspect(object)</code> <code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。 （7）<code>getEventListeners(object)</code> <code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。 （8）<code>keys(object)</code>，<code>values(object)</code> <code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。 <code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p>\n<pre><code>var o = &#123;&#39;p1&#39;: &#39;a&#39;, &#39;p2&#39;: &#39;b&#39;&#125;;\n\nkeys(o)\n// [&quot;p1&quot;, &quot;p2&quot;]\nvalues(o)\n// [&quot;a&quot;, &quot;b&quot;]\n</code></pre>\n<p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code> <code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p>\n<pre><code>monitorEvents(window, &quot;resize&quot;);\nmonitorEvents(window, [&quot;resize&quot;, &quot;scroll&quot;])\n</code></pre>\n<p>上面代码分别表示单个事件和多个事件的监听方法。</p>\n<pre><code>monitorEvents($0, &#39;mouse&#39;);\nunmonitorEvents($0, &#39;mousemove&#39;);\n</code></pre>\n<p>上面代码表示如何停止监听。 <code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p>\n<ul>\n<li><p>  mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</p>\n</li>\n<li><p>  key：”keydown”, “keyup”, “keypress”, “textInput”</p>\n</li>\n<li><p>  touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</p>\n</li>\n<li><p>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</p>\n<p>  monitorEvents($(“#msg”), “key”);</p>\n</li>\n</ul>\n<p>上面代码表示监听所有<code>key</code>大类的事件。 （10）其他方法 命令行 API 还提供以下方法。</p>\n<ul>\n<li>  <code>clear()</code>：清除控制台的历史。</li>\n<li>  <code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li>\n<li>  <code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li>\n<li>  <code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li>\n</ul>\n<h2 id=\"debugger-语句\"><a href=\"#debugger-语句\" class=\"headerlink\" title=\"debugger 语句\"></a>debugger 语句</h2><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。 Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p>\n<pre><code>for(var i = 0; i &lt; 5; i++)&#123;\n  console.log(i);\n  if (i === 2) debugger;\n&#125;\n</code></pre>\n<p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li>  Chrome Developer Tools, <a href=\"https://developers.google.com/chrome-developer-tools/docs/console\">Using the Console</a></li>\n<li>  Matt West, <a href=\"http://blog.teamtreehouse.com/mastering-developer-tools-console\">Mastering The Developer Tools Console</a></li>\n<li>  Firebug Wiki, <a href=\"https://getfirebug.com/wiki/index.php/Console_API\">Console API</a></li>\n<li>  Axel Rauschmayer, <a href=\"http://www.2ality.com/2013/10/console-api.html\">The JavaScript console API</a></li>\n<li>  Marius Schulz, <a href=\"http://blog.mariusschulz.com/2013/11/13/advanced-javascript-debugging-with-consoletable\">Advanced JavaScript Debugging with console.table()</a></li>\n<li>  Google Developer, <a href=\"https://developers.google.com/chrome-developer-tools/docs/commandline-api\">Command Line API Reference</a></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"console-对象\"><a href=\"#console-对象\" class=\"headerlink\" title=\"console 对象\"></a>console 对象</h2><p><code>console</code>对象是 JavaScript 的原生对象，它有点像 Unix 系统的标准输出<code>stdout</code>和标准错误<code>stderr</code>，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法。 <code>console</code>的常见用途有两个。</p>\n<ul>\n<li>  调试程序，显示网页代码运行时的错误信息。</li>\n<li>  提供了一个命令行接口，用来与网页代码互动。</li>\n</ul>\n<p><code>console</code>对象的浏览器实现，包含在浏览器自带的开发工具之中。以 Chrome 浏览器的“开发者工具”（Developer Tools）为例，可以使用下面三种方法的打开它。</p>\n<ol>\n<li> 按 F12 或者<code>Control + Shift + i</code>（PC）/ <code>Command + Option + i</code>（Mac）。</li>\n<li> 浏览器菜单选择“工具/开发者工具”。</li>\n<li> 在一个页面元素上，打开右键菜单，选择其中的“Inspect Element”。</li>\n</ol>\n<p>打开开发者工具以后，顶端有多个面板。</p>\n<ul>\n<li>  <strong>Elements</strong>：查看网页的 HTML 源码和 CSS 代码。</li>\n<li>  <strong>Resources</strong>：查看网页加载的各种资源文件（比如代码文件、字体文件 CSS 文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。</li>\n<li>  <strong>Network</strong>：查看网页的 HTTP 通信情况。</li>\n<li>  <strong>Sources</strong>：查看网页加载的脚本源码。</li>\n<li>  <strong>Timeline</strong>：查看各种网页行为随时间变化的情况。</li>\n<li>  <strong>Performance</strong>：查看网页的性能情况，比如 CPU 和内存消耗。</li>\n<li>  <strong>Console</strong>：用来运行 JavaScript 命令。</li>\n</ul>\n<p>这些面板都有各自的用途，以下只介绍<code>Console</code>面板（又称为控制台）。 <code>Console</code>面板基本上就是一个命令行窗口，你可以在提示符下，键入各种命令。</p>\n<h2 id=\"console-对象的静态方法\"><a href=\"#console-对象的静态方法\" class=\"headerlink\" title=\"console 对象的静态方法\"></a>console 对象的静态方法</h2><p><code>console</code>对象提供的各种静态方法，用来与控制台窗口互动。</p>\n<h3 id=\"console-log-，console-info-，console-debug\"><a href=\"#console-log-，console-info-，console-debug\" class=\"headerlink\" title=\"console.log()，console.info()，console.debug()\"></a>console.log()，console.info()，console.debug()</h3><p><code>console.log</code>方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出。</p>\n<pre><code>console.log(&#39;Hello World&#39;)\n// Hello World\nconsole.log(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)\n// a b c\n</code></pre>\n<p><code>console.log</code>方法会自动在每次输出的结尾，添加换行符。</p>\n<pre><code>console.log(1);\nconsole.log(2);\nconsole.log(3);\n// 1\n// 2\n// 3\n</code></pre>\n<p>如果第一个参数是格式字符串（使用了格式占位符），<code>console.log</code>方法将依次用后面的参数替换占位符，然后再进行输出。</p>\n<pre><code>console.log(&#39; %s + %s = %s&#39;, 1, 1, 2)\n//  1 + 1 = 2\n</code></pre>\n<p>上面代码中，<code>console.log</code>方法的第一个参数有三个占位符（<code>%s</code>），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。 <code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p>\n<ul>\n<li><p>  <code>%s</code> 字符串</p>\n</li>\n<li><p>  <code>%d</code> 整数</p>\n</li>\n<li><p>  <code>%i</code> 整数</p>\n</li>\n<li><p>  <code>%f</code> 浮点数</p>\n</li>\n<li><p>  <code>%o</code> 对象的链接</p>\n</li>\n<li><p><code>%c</code> CSS 格式字符串</p>\n<p>  var number = 11 * 9;<br>  var color = ‘red’;</p>\n<p>  console.log(‘%d %s balloons’, number, color);<br>  // 99 red balloons</p>\n</li>\n</ul>\n<p>上面代码中，第二个参数是数值，对应的占位符是<code>%d</code>，第三个参数是字符串，对应的占位符是<code>%s</code>。 使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染。</p>\n<pre><code>console.log(\n  &#39;%cThis text is styled!&#39;,\n  &#39;color: red; background: yellow; font-size: 24px;&#39;\n)\n</code></pre>\n<p>上面代码运行后，输出的内容将显示为黄底红字。 <code>console.log</code>方法的两种参数格式，可以结合在一起使用。</p>\n<pre><code>console.log(&#39; %s + %s &#39;, 1, 1, &#39;= 2&#39;)\n// 1 + 1  = 2\n</code></pre>\n<p>如果参数是一个对象，<code>console.log</code>会显示该对象的值。</p>\n<pre><code>console.log(&#123;foo: &#39;bar&#39;&#125;)\n// Object &#123;foo: &quot;bar&quot;&#125;\nconsole.log(Date)\n// function Date() &#123; [native code] &#125;\n</code></pre>\n<p>上面代码输出<code>Date</code>对象的值，结果为一个构造函数。 <code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标。 <code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示。 <code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法。</p>\n<pre><code>[&#39;log&#39;, &#39;info&#39;, &#39;warn&#39;, &#39;error&#39;].forEach(function(method) &#123;\n  console[method] = console[method].bind(\n    console,\n    new Date().toISOString()\n  );\n&#125;);\n\nconsole.log(&quot;出错了！&quot;);\n// 2014-05-18T09:00.000Z 出错了！\n</code></pre>\n<p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间。</p>\n<h3 id=\"console-warn-，console-error\"><a href=\"#console-warn-，console-error\" class=\"headerlink\" title=\"console.warn()，console.error()\"></a>console.warn()，console.error()</h3><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p>\n<pre><code>console.error(&#39;Error: %s (%i)&#39;, &#39;Server is not responding&#39;, 500)\n// Error: Server is not responding (500)\nconsole.warn(&#39;Warning! Too few nodes (%d)&#39;, document.childNodes.length)\n// Warning! Too few nodes (1)\n</code></pre>\n<p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）。</p>\n<h3 id=\"console-table\"><a href=\"#console-table\" class=\"headerlink\" title=\"console.table()\"></a>console.table()</h3><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示。</p>\n<pre><code>var languages = [\n  &#123; name: &quot;JavaScript&quot;, fileExtension: &quot;.js&quot; &#125;,\n  &#123; name: &quot;TypeScript&quot;, fileExtension: &quot;.ts&quot; &#125;,\n  &#123; name: &quot;CoffeeScript&quot;, fileExtension: &quot;.coffee&quot; &#125;\n];\n\nconsole.table(languages);\n</code></pre>\n<p>上面代码的<code>language</code>变量，转为表格显示如下。</p>\n<p>(index)</p>\n<p>name</p>\n<p>fileExtension</p>\n<p>0</p>\n<p>“JavaScript”</p>\n<p>“.js”</p>\n<p>1</p>\n<p>“TypeScript”</p>\n<p>“.ts”</p>\n<p>2</p>\n<p>“CoffeeScript”</p>\n<p>“.coffee”</p>\n<p>下面是显示表格内容的例子。</p>\n<pre><code>var languages = &#123;\n  csharp: &#123; name: &quot;C#&quot;, paradigm: &quot;object-oriented&quot; &#125;,\n  fsharp: &#123; name: &quot;F#&quot;, paradigm: &quot;functional&quot; &#125;\n&#125;;\n\nconsole.table(languages);\n</code></pre>\n<p>上面代码的<code>language</code>，转为表格显示如下。</p>\n<p>(index)</p>\n<p>name</p>\n<p>paradigm</p>\n<p>csharp</p>\n<p>“C#”</p>\n<p>“object-oriented”</p>\n<p>fsharp</p>\n<p>“F#”</p>\n<p>“functional”</p>\n<h3 id=\"console-count\"><a href=\"#console-count\" class=\"headerlink\" title=\"console.count()\"></a>console.count()</h3><p><code>count</code>方法用于计数，输出它被调用了多少次。</p>\n<pre><code>function greet(user) &#123;\n  console.count();\n  return &#39;hi &#39; + user;\n&#125;\n\ngreet(&#39;bob&#39;)\n//  : 1\n// &quot;hi bob&quot;\n\ngreet(&#39;alice&#39;)\n//  : 2\n// &quot;hi alice&quot;\n\ngreet(&#39;bob&#39;)\n//  : 3\n// &quot;hi bob&quot;\n</code></pre>\n<p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数。 该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。</p>\n<pre><code>function greet(user) &#123;\n  console.count(user);\n  return &quot;hi &quot; + user;\n&#125;\n\ngreet(&#39;bob&#39;)\n// bob: 1\n// &quot;hi bob&quot;\n\ngreet(&#39;alice&#39;)\n// alice: 1\n// &quot;hi alice&quot;\n\ngreet(&#39;bob&#39;)\n// bob: 2\n// &quot;hi bob&quot;\n</code></pre>\n<p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次。</p>\n<h3 id=\"console-dir-，console-dirxml\"><a href=\"#console-dir-，console-dirxml\" class=\"headerlink\" title=\"console.dir()，console.dirxml()\"></a>console.dir()，console.dirxml()</h3><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>\n<pre><code>console.log(&#123;f1: &#39;foo&#39;, f2: &#39;bar&#39;&#125;)\n// Object &#123;f1: &quot;foo&quot;, f2: &quot;bar&quot;&#125;\n\nconsole.dir(&#123;f1: &#39;foo&#39;, f2: &#39;bar&#39;&#125;)\n// Object\n//   f1: &quot;foo&quot;\n//   f2: &quot;bar&quot;\n//   __proto__: Object\n</code></pre>\n<p>上面代码显示<code>dir</code>方法的输出结果，比<code>log</code>方法更易读，信息也更丰富。 该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性。</p>\n<pre><code>console.dir(document.body)\n</code></pre>\n<p>Node 环境之中，还可以指定以代码高亮的形式输出。</p>\n<pre><code>console.dir(obj, &#123;colors: true&#125;)\n</code></pre>\n<p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点。</p>\n<pre><code>console.dirxml(document.body)\n</code></pre>\n<p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code>。</p>\n<pre><code>console.dirxml([1, 2, 3])\n// 等同于\nconsole.dir([1, 2, 3])\n</code></pre>\n<h3 id=\"console-assert\"><a href=\"#console-assert\" class=\"headerlink\" title=\"console.assert()\"></a>console.assert()</h3><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。 它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果。</p>\n<pre><code>console.assert(false, &#39;判断条件不成立&#39;)\n// Assertion failed: 判断条件不成立\n\n// 相当于\ntry &#123;\n  if (!false) &#123;\n    throw new Error(&#39;判断条件不成立&#39;);\n  &#125;\n&#125; catch(e) &#123;\n  console.error(e);\n&#125;\n</code></pre>\n<p>下面是一个例子，判断子节点的个数是否大于等于500。</p>\n<pre><code>console.assert(list.childNodes.length &lt; 500, &#39;节点个数大于等于500&#39;)\n</code></pre>\n<p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本。</p>\n<h3 id=\"console-time-，console-timeEnd\"><a href=\"#console-time-，console-timeEnd\" class=\"headerlink\" title=\"console.time()，console.timeEnd()\"></a>console.time()，console.timeEnd()</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p>\n<pre><code>console.time(&#39;Array initialize&#39;);\n\nvar array= new Array(1000000);\nfor (var i = array.length - 1; i &gt;= 0; i--) &#123;\n  array[i] = new Object();\n&#125;;\n\nconsole.timeEnd(&#39;Array initialize&#39;);\n// Array initialize: 1914.481ms\n</code></pre>\n<p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p>\n<h3 id=\"console-group-，console-groupEnd-，console-groupCollapsed\"><a href=\"#console-group-，console-groupEnd-，console-groupCollapsed\" class=\"headerlink\" title=\"console.group()，console.groupEnd()，console.groupCollapsed()\"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h3><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。</p>\n<pre><code>console.group(&#39;一级分组&#39;);\nconsole.log(&#39;一级分组的内容&#39;);\n\nconsole.group(&#39;二级分组&#39;);\nconsole.log(&#39;二级分组的内容&#39;);\n\nconsole.groupEnd(); // 二级分组结束\nconsole.groupEnd(); // 一级分组结束\n</code></pre>\n<p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容。 <code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。</p>\n<pre><code>console.groupCollapsed(&#39;Fetching Data&#39;);\n\nconsole.log(&#39;Request Sent&#39;);\nconsole.error(&#39;Error: Server not responding (500)&#39;);\n\nconsole.groupEnd();\n</code></pre>\n<p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行。</p>\n<h3 id=\"console-trace-，console-clear\"><a href=\"#console-trace-，console-clear\" class=\"headerlink\" title=\"console.trace()，console.clear()\"></a>console.trace()，console.clear()</h3><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>\n<pre><code>console.trace()\n// console.trace()\n//   (anonymous function)\n//   InjectedScript._evaluateOn\n//   InjectedScript._evaluateAndWrap\n//   InjectedScript.evaluate\n</code></pre>\n<p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用。</p>\n<h2 id=\"控制台命令行-API\"><a href=\"#控制台命令行-API\" class=\"headerlink\" title=\"控制台命令行 API\"></a>控制台命令行 API</h2><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法。 （1）<code>$_</code> <code>$_</code>属性返回上一个表达式的值。</p>\n<pre><code>2 + 2\n// 4\n$_\n// 4\n</code></pre>\n<p>（2）<code>$0</code> - <code>$4</code> 控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。 （3）<code>$(selector)</code> <code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。 （4）<code>$$(selector)</code> <code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。 （5）<code>$x(path)</code> <code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p>\n<pre><code>$x(&quot;//p[a]&quot;)\n</code></pre>\n<p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。 （6）<code>inspect(object)</code> <code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。 （7）<code>getEventListeners(object)</code> <code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。 （8）<code>keys(object)</code>，<code>values(object)</code> <code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。 <code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p>\n<pre><code>var o = &#123;&#39;p1&#39;: &#39;a&#39;, &#39;p2&#39;: &#39;b&#39;&#125;;\n\nkeys(o)\n// [&quot;p1&quot;, &quot;p2&quot;]\nvalues(o)\n// [&quot;a&quot;, &quot;b&quot;]\n</code></pre>\n<p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code> <code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p>\n<pre><code>monitorEvents(window, &quot;resize&quot;);\nmonitorEvents(window, [&quot;resize&quot;, &quot;scroll&quot;])\n</code></pre>\n<p>上面代码分别表示单个事件和多个事件的监听方法。</p>\n<pre><code>monitorEvents($0, &#39;mouse&#39;);\nunmonitorEvents($0, &#39;mousemove&#39;);\n</code></pre>\n<p>上面代码表示如何停止监听。 <code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p>\n<ul>\n<li><p>  mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</p>\n</li>\n<li><p>  key：”keydown”, “keyup”, “keypress”, “textInput”</p>\n</li>\n<li><p>  touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</p>\n</li>\n<li><p>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</p>\n<p>  monitorEvents($(“#msg”), “key”);</p>\n</li>\n</ul>\n<p>上面代码表示监听所有<code>key</code>大类的事件。 （10）其他方法 命令行 API 还提供以下方法。</p>\n<ul>\n<li>  <code>clear()</code>：清除控制台的历史。</li>\n<li>  <code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li>\n<li>  <code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li>\n<li>  <code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li>\n</ul>\n<h2 id=\"debugger-语句\"><a href=\"#debugger-语句\" class=\"headerlink\" title=\"debugger 语句\"></a>debugger 语句</h2><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。 Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p>\n<pre><code>for(var i = 0; i &lt; 5; i++)&#123;\n  console.log(i);\n  if (i === 2) debugger;\n&#125;\n</code></pre>\n<p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理。</p>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ul>\n<li>  Chrome Developer Tools, <a href=\"https://developers.google.com/chrome-developer-tools/docs/console\">Using the Console</a></li>\n<li>  Matt West, <a href=\"http://blog.teamtreehouse.com/mastering-developer-tools-console\">Mastering The Developer Tools Console</a></li>\n<li>  Firebug Wiki, <a href=\"https://getfirebug.com/wiki/index.php/Console_API\">Console API</a></li>\n<li>  Axel Rauschmayer, <a href=\"http://www.2ality.com/2013/10/console-api.html\">The JavaScript console API</a></li>\n<li>  Marius Schulz, <a href=\"http://blog.mariusschulz.com/2013/11/13/advanced-javascript-debugging-with-consoletable\">Advanced JavaScript Debugging with console.table()</a></li>\n<li>  Google Developer, <a href=\"https://developers.google.com/chrome-developer-tools/docs/commandline-api\">Command Line API Reference</a></li>\n</ul>\n"},{"title":"【苹果cms v10】仿优酷模板pc完美修复版","url":"143.html","id":"143","date":"2019-06-22T09:08:20.000Z","_content":"\n网上收集的一套基于苹果cms V10的仿优酷模版。 有很多问题而且是宽度1380px无法适配小屏幕显示器，在这基础上我做了一下调整改成1200px的版心可以完美兼容主流显示屏，调整为不同频道展示不同幻灯片等一些展示优化???? ![WX20190421-192911@2x.png](http://cdn.v5ant.com/ueditor/images/1119939016473579520.png) ![WX20190421-192941@2x.png](http://cdn.v5ant.com/ueditor/images/1119939182383468544.png) ![WX20190421-193031@2x.png](http://cdn.v5ant.com/ueditor/images/1119938763636740096.png)","source":"_posts/e3-80-90-e8-8b-b9-e6-9e-9ccms-v10-e3-80-91-e4-bb-bf-e4-bc-98-e9-85-b7-e6-a8-a1-e6-9d-bfpc-e5-ae-8c-e7-be-8e-e4-bf-ae-e5-a4-8d-e7-89-88.md","raw":"---\ntitle: 【苹果cms v10】仿优酷模板pc完美修复版\nurl: 143.html\nid: 143\ncategories:\n  - 精选资源\ndate: 2019-06-22 17:08:20\ntags:\n---\n\n网上收集的一套基于苹果cms V10的仿优酷模版。 有很多问题而且是宽度1380px无法适配小屏幕显示器，在这基础上我做了一下调整改成1200px的版心可以完美兼容主流显示屏，调整为不同频道展示不同幻灯片等一些展示优化???? ![WX20190421-192911@2x.png](http://cdn.v5ant.com/ueditor/images/1119939016473579520.png) ![WX20190421-192941@2x.png](http://cdn.v5ant.com/ueditor/images/1119939182383468544.png) ![WX20190421-193031@2x.png](http://cdn.v5ant.com/ueditor/images/1119938763636740096.png)","slug":"e3-80-90-e8-8b-b9-e6-9e-9ccms-v10-e3-80-91-e4-bb-bf-e4-bc-98-e9-85-b7-e6-a8-a1-e6-9d-bfpc-e5-ae-8c-e7-be-8e-e4-bf-ae-e5-a4-8d-e7-89-88","published":1,"updated":"2019-09-10T07:46:08.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp2699l0005c8gsecdrb042","content":"<p>网上收集的一套基于苹果cms V10的仿优酷模版。 有很多问题而且是宽度1380px无法适配小屏幕显示器，在这基础上我做了一下调整改成1200px的版心可以完美兼容主流显示屏，调整为不同频道展示不同幻灯片等一些展示优化???? <img src=\"http://cdn.v5ant.com/ueditor/images/1119939016473579520.png\" alt=\"WX20190421-192911@2x.png\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1119939182383468544.png\" alt=\"WX20190421-192941@2x.png\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1119938763636740096.png\" alt=\"WX20190421-193031@2x.png\"></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>网上收集的一套基于苹果cms V10的仿优酷模版。 有很多问题而且是宽度1380px无法适配小屏幕显示器，在这基础上我做了一下调整改成1200px的版心可以完美兼容主流显示屏，调整为不同频道展示不同幻灯片等一些展示优化???? <img src=\"http://cdn.v5ant.com/ueditor/images/1119939016473579520.png\" alt=\"WX20190421-192911@2x.png\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1119939182383468544.png\" alt=\"WX20190421-192941@2x.png\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1119938763636740096.png\" alt=\"WX20190421-193031@2x.png\"></p>\n"},{"title":"【视频】8天从小白到大神蜕变秘籍之Photoshop","url":"251.html","id":"251","date":"2019-07-11T12:44:25.000Z","_content":"\n![](https://www.v5ant.com/wp-content/uploads/2019/07/WX20190711-203652@2x.png) 分享给需要的朋友，关注蚂蚁号找资源少走弯路。\n","source":"_posts/e3-80-90-e8-a7-86-e9-a2-91-e3-80-918-e5-a4-a9-e4-bb-8e-e5-b0-8f-e7-99-bd-e5-88-b0-e5-a4-a7-e7-a5-9e-e8-9c-95-e5-8f-98-e7-a7-98-e7-b1-8d-e4-b9-8bphotoshop.md","raw":"---\ntitle: 【视频】8天从小白到大神蜕变秘籍之Photoshop\ntags:\n  - 学习资源\nurl: 251.html\nid: 251\ncategories:\n  - 精选资源\ndate: 2019-07-11 20:44:25\n---\n\n![](https://www.v5ant.com/wp-content/uploads/2019/07/WX20190711-203652@2x.png) 分享给需要的朋友，关注蚂蚁号找资源少走弯路。\n","slug":"e3-80-90-e8-a7-86-e9-a2-91-e3-80-918-e5-a4-a9-e4-bb-8e-e5-b0-8f-e7-99-bd-e5-88-b0-e5-a4-a7-e7-a5-9e-e8-9c-95-e5-8f-98-e7-a7-98-e7-b1-8d-e4-b9-8bphotoshop","published":1,"updated":"2019-09-11T03:05:35.448Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp2699n0008c8gsamks9en0","content":"<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/07/WX20190711-203652@2x.png\"> 分享给需要的朋友，关注蚂蚁号找资源少走弯路。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/07/WX20190711-203652@2x.png\"> 分享给需要的朋友，关注蚂蚁号找资源少走弯路。</p>\n"},{"title":"一文搞定前端 Jenkins 自动化部署","url":"369.html","id":"369","date":"2019-08-30T10:49:32.000Z","_content":"\n> 作者： 前端下午茶 公号 / SHERlocked93\n\n这两天折腾了一下 Jenkins 持续集成，由于公司使用自己搭建的 svn 服务器来进行代码管理，因此这里 Jenkins 是针对 svn 服务器来进行的配置，Git 配置基本一致，后面也介绍了下针对 Github 管理的项目的 Jenkins 配置\n\n之前项目每次修改之后都需要本地 `npm run build `一次手动发布到服务器上方便测试和产品查看，有了Jenkins持续集成之后只要 svn 或者 git 提交之后就会自动打包，很方便，此次记录以备后询。\n\n声明：\n\n1.  后面的项目地址与打包地址都是使用 `my-demo`，自行修改；\n    \n2.  另外还有路径等，根据自己情况自行修改；\n    \n\n1\\. 安装\n------\n\n### 1.1 安装 Nginx\n\n可以直接去官网下直接下载，解压缩 `start nginx`就可以使了，常用命令：\n\n1.  `start nginx # 启动`\n    \n2.  `nginx -s reload # 修改配置后重新加载生效`\n    \n3.  `nginx -s reopen # 重新打开日志文件`\n    \n4.  `nginx -t # 配置文件检测是否正确`\n    \n\n### 1.2 安装**Jenkins**\n\n从官网下载文件安装之后，我这里安装到 `C:Jenkins`（Mac 不用在意），默认端口 8080，这时候浏览器访问 `localhost:8080` 就能访问 Jenkins 首页，这里注意如果不安装到 C 盘根目录有些插件安装会出错![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-04d712c9d2881abd201c30bbb4fc7c99.jpeg)\n\n这里会让你去某个地方找一个初始密码文件打开并填到下面的密码框里，验证成功之后进入页面，选择 `Installsuggested plugins` 推介安装的插件\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-d75244e7e6eb65a190f21f1c1a1c481b.jpeg)\n\n插件都安装完成之后进入用户登录界面，设定用户名、密码及邮箱。  \n\n然后提示 Jenkins is ready！→ Start using Jenkins ~\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-508f8521d15f43ca9301b5fdb57a85d6.jpeg)\n\n注意这里因为要使用node的命令来执行创建后操作，所以还需要安装插件：`NodeJSPlugin`、 `Deployto container`、 `Github`、 `Postbuild task`  \n\n这里顺便记录一下启动和关闭Jenkins服务的命令行：\n\n1.  `net start jenkins            // 启动Jenkins服务`\n    \n2.  `net stop jenkins             // 停止Jenkins服务`\n    \n\n2\\. 创建svn项目的Jenkins任务\n---------------------\n\n### 2.1 新建\n\n左边栏新建一个任务，输入一个任务名称，这里随便写一个\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-2bb2930c2d64b455c8b97327d40670d9.jpeg)\n\n### 2.2 配置\n\n#### General\n\n这里才是重头戏，进入刚刚创建的任务的配置页面的 **General**\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-0ddc6e604eabe70e4d2a93f602459f0a.png)\n\n丢弃旧的构建就是检测到新的版本之后把旧版本的构建删除\n\n#### 源码管理\n\n这里采用的是 svn 来管理代码，![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-1277443c4bba685796ff9079bb31d2be.png)\n\n#### 构建触发器\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-ced8af3d53e7baed8c3bcc4142edddf8.png)\n\n这里的 Poll SCM 表示去检测是否更新构建的频率， `*****` 表示每分钟， `H****` 表示每小时  \n\n#### 构建\n\n1.  `cd cd C:Jenkinsworkspacemy-demo`\n    \n2.  `node -v`\n    \n3.  `npm -v`\n    \n4.  `cnpm i`\n    \n5.  `npm run build`\n    \n\n#### 构建后操作\n\n安装插件 `Postbuild task` 后，可以在 增加构建后操作步骤中选择 `Postbuild task` 选项，增加构建后执行的script，具体也可以参考文章：jenkins部署maven项目构建后部署前执行shell脚本 - https://blog.csdn.net/minebk/article/details/73294785\n\n我这里的 `Logtext` 是 `Buildcomplete`\n\nScript：\n\n1.  `rmdir /q/s C:nginx-1.14.0htmlmy-demo`\n    \n2.  `xcopy /y/e/i C:Jenkinsworkspacemy-demomy-demo C:nginx-1.14.0htmlmy-demo`\n    \n\n复制生成好的文件到Nginx的目录下，路径自行修改\n\n3\\. 创建Github项目的Jenkins任务\n------------------------\n\nJenkins 不仅可以持续集成 svn 项目，Git 项目也是可以的，这里以 Github 上的项目为例：\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-a189fed635dfa2cf96b36545fce55f3d.jpeg)\n\n其他配置和上面一章一样\n\n这样如果 github 有新的 push 请求，都会自动化部署到之前的服务器上，可以说很方便了。\n\n### 试一试\n\n配置好了我们试一试，在刚刚 github 项目中随便 commit 一版到 github ：\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-99bbd4b2df388c5ec95b7cfb609531ef.png)\n\n稍等片刻去本地 Jenkins 地址 `http://localhost:8080/job/vue-element-template/` 就能看到 Jenkins 已经在构建中了\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-d7e3cc5ca7574e5eed11784c6ef31e18.png)\n\n50秒之后：\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-4d8b2454dc78e83ad8768a028739d0aa.png)\n\n构建成功！构建用时 54 秒，现在访问本地服务器地址 `http://localhost:8282/vue-element-template`，已经能看到编译后的发布版本啦~  \n\n如果你希望发布的是测试版本，可以自行修改构建后操作的 script\n\n* * *\n\n网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~\n\n> 参考：\n> \n> 1.  使用Jenkins自动编译部署web应用\n>     \n> 2.  Jenkins+github 前端自动化部署\n>     \n> 3.  配置Jenkins邮件通知\n>     \n> 4.  jenkins部署maven项目构建后部署前执行shell脚本\n>","source":"_posts/e4-b8-80-e6-96-87-e6-90-9e-e5-ae-9a-e5-89-8d-e7-ab-af-jenkins-e8-87-aa-e5-8a-a8-e5-8c-96-e9-83-a8-e7-bd-b2.md","raw":"---\ntitle: 一文搞定前端 Jenkins 自动化部署\ntags:\n  - JavaScript\n  - 前端\nurl: 369.html\nid: 369\ncategories:\n  - 大前端\ndate: 2019-08-30 18:49:32\n---\n\n> 作者： 前端下午茶 公号 / SHERlocked93\n\n这两天折腾了一下 Jenkins 持续集成，由于公司使用自己搭建的 svn 服务器来进行代码管理，因此这里 Jenkins 是针对 svn 服务器来进行的配置，Git 配置基本一致，后面也介绍了下针对 Github 管理的项目的 Jenkins 配置\n\n之前项目每次修改之后都需要本地 `npm run build `一次手动发布到服务器上方便测试和产品查看，有了Jenkins持续集成之后只要 svn 或者 git 提交之后就会自动打包，很方便，此次记录以备后询。\n\n声明：\n\n1.  后面的项目地址与打包地址都是使用 `my-demo`，自行修改；\n    \n2.  另外还有路径等，根据自己情况自行修改；\n    \n\n1\\. 安装\n------\n\n### 1.1 安装 Nginx\n\n可以直接去官网下直接下载，解压缩 `start nginx`就可以使了，常用命令：\n\n1.  `start nginx # 启动`\n    \n2.  `nginx -s reload # 修改配置后重新加载生效`\n    \n3.  `nginx -s reopen # 重新打开日志文件`\n    \n4.  `nginx -t # 配置文件检测是否正确`\n    \n\n### 1.2 安装**Jenkins**\n\n从官网下载文件安装之后，我这里安装到 `C:Jenkins`（Mac 不用在意），默认端口 8080，这时候浏览器访问 `localhost:8080` 就能访问 Jenkins 首页，这里注意如果不安装到 C 盘根目录有些插件安装会出错![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-04d712c9d2881abd201c30bbb4fc7c99.jpeg)\n\n这里会让你去某个地方找一个初始密码文件打开并填到下面的密码框里，验证成功之后进入页面，选择 `Installsuggested plugins` 推介安装的插件\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-d75244e7e6eb65a190f21f1c1a1c481b.jpeg)\n\n插件都安装完成之后进入用户登录界面，设定用户名、密码及邮箱。  \n\n然后提示 Jenkins is ready！→ Start using Jenkins ~\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-508f8521d15f43ca9301b5fdb57a85d6.jpeg)\n\n注意这里因为要使用node的命令来执行创建后操作，所以还需要安装插件：`NodeJSPlugin`、 `Deployto container`、 `Github`、 `Postbuild task`  \n\n这里顺便记录一下启动和关闭Jenkins服务的命令行：\n\n1.  `net start jenkins            // 启动Jenkins服务`\n    \n2.  `net stop jenkins             // 停止Jenkins服务`\n    \n\n2\\. 创建svn项目的Jenkins任务\n---------------------\n\n### 2.1 新建\n\n左边栏新建一个任务，输入一个任务名称，这里随便写一个\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-2bb2930c2d64b455c8b97327d40670d9.jpeg)\n\n### 2.2 配置\n\n#### General\n\n这里才是重头戏，进入刚刚创建的任务的配置页面的 **General**\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-0ddc6e604eabe70e4d2a93f602459f0a.png)\n\n丢弃旧的构建就是检测到新的版本之后把旧版本的构建删除\n\n#### 源码管理\n\n这里采用的是 svn 来管理代码，![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-1277443c4bba685796ff9079bb31d2be.png)\n\n#### 构建触发器\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-ced8af3d53e7baed8c3bcc4142edddf8.png)\n\n这里的 Poll SCM 表示去检测是否更新构建的频率， `*****` 表示每分钟， `H****` 表示每小时  \n\n#### 构建\n\n1.  `cd cd C:Jenkinsworkspacemy-demo`\n    \n2.  `node -v`\n    \n3.  `npm -v`\n    \n4.  `cnpm i`\n    \n5.  `npm run build`\n    \n\n#### 构建后操作\n\n安装插件 `Postbuild task` 后，可以在 增加构建后操作步骤中选择 `Postbuild task` 选项，增加构建后执行的script，具体也可以参考文章：jenkins部署maven项目构建后部署前执行shell脚本 - https://blog.csdn.net/minebk/article/details/73294785\n\n我这里的 `Logtext` 是 `Buildcomplete`\n\nScript：\n\n1.  `rmdir /q/s C:nginx-1.14.0htmlmy-demo`\n    \n2.  `xcopy /y/e/i C:Jenkinsworkspacemy-demomy-demo C:nginx-1.14.0htmlmy-demo`\n    \n\n复制生成好的文件到Nginx的目录下，路径自行修改\n\n3\\. 创建Github项目的Jenkins任务\n------------------------\n\nJenkins 不仅可以持续集成 svn 项目，Git 项目也是可以的，这里以 Github 上的项目为例：\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-a189fed635dfa2cf96b36545fce55f3d.jpeg)\n\n其他配置和上面一章一样\n\n这样如果 github 有新的 push 请求，都会自动化部署到之前的服务器上，可以说很方便了。\n\n### 试一试\n\n配置好了我们试一试，在刚刚 github 项目中随便 commit 一版到 github ：\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-99bbd4b2df388c5ec95b7cfb609531ef.png)\n\n稍等片刻去本地 Jenkins 地址 `http://localhost:8080/job/vue-element-template/` 就能看到 Jenkins 已经在构建中了\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-d7e3cc5ca7574e5eed11784c6ef31e18.png)\n\n50秒之后：\n\n![一文搞定前端 Jenkins 自动化部署](https://www.v5ant.com/wp-content/uploads/2019/08/frc-4d8b2454dc78e83ad8768a028739d0aa.png)\n\n构建成功！构建用时 54 秒，现在访问本地服务器地址 `http://localhost:8282/vue-element-template`，已经能看到编译后的发布版本啦~  \n\n如果你希望发布的是测试版本，可以自行修改构建后操作的 script\n\n* * *\n\n网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~\n\n> 参考：\n> \n> 1.  使用Jenkins自动编译部署web应用\n>     \n> 2.  Jenkins+github 前端自动化部署\n>     \n> 3.  配置Jenkins邮件通知\n>     \n> 4.  jenkins部署maven项目构建后部署前执行shell脚本\n>","slug":"e4-b8-80-e6-96-87-e6-90-9e-e5-ae-9a-e5-89-8d-e7-ab-af-jenkins-e8-87-aa-e5-8a-a8-e5-8c-96-e9-83-a8-e7-bd-b2","published":1,"updated":"2019-09-10T07:46:08.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp2699q000bc8gs27b5g7w5","content":"<blockquote>\n<p>作者： 前端下午茶 公号 / SHERlocked93</p>\n</blockquote>\n<p>这两天折腾了一下 Jenkins 持续集成，由于公司使用自己搭建的 svn 服务器来进行代码管理，因此这里 Jenkins 是针对 svn 服务器来进行的配置，Git 配置基本一致，后面也介绍了下针对 Github 管理的项目的 Jenkins 配置</p>\n<p>之前项目每次修改之后都需要本地 <code>npm run build </code>一次手动发布到服务器上方便测试和产品查看，有了Jenkins持续集成之后只要 svn 或者 git 提交之后就会自动打包，很方便，此次记录以备后询。</p>\n<p>声明：</p>\n<ol>\n<li>后面的项目地址与打包地址都是使用 <code>my-demo</code>，自行修改；</li>\n<li>另外还有路径等，根据自己情况自行修改；</li>\n</ol>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><h3 id=\"1-1-安装-Nginx\"><a href=\"#1-1-安装-Nginx\" class=\"headerlink\" title=\"1.1 安装 Nginx\"></a>1.1 安装 Nginx</h3><p>可以直接去官网下直接下载，解压缩 <code>start nginx</code>就可以使了，常用命令：</p>\n<ol>\n<li><code>start nginx # 启动</code></li>\n<li><code>nginx -s reload # 修改配置后重新加载生效</code></li>\n<li><code>nginx -s reopen # 重新打开日志文件</code></li>\n<li><code>nginx -t # 配置文件检测是否正确</code></li>\n</ol>\n<h3 id=\"1-2-安装Jenkins\"><a href=\"#1-2-安装Jenkins\" class=\"headerlink\" title=\"1.2 安装Jenkins\"></a>1.2 安装<strong>Jenkins</strong></h3><p>从官网下载文件安装之后，我这里安装到 <code>C:Jenkins</code>（Mac 不用在意），默认端口 8080，这时候浏览器访问 <code>localhost:8080</code> 就能访问 Jenkins 首页，这里注意如果不安装到 C 盘根目录有些插件安装会出错<img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-04d712c9d2881abd201c30bbb4fc7c99.jpeg\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>这里会让你去某个地方找一个初始密码文件打开并填到下面的密码框里，验证成功之后进入页面，选择 <code>Installsuggested plugins</code> 推介安装的插件</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-d75244e7e6eb65a190f21f1c1a1c481b.jpeg\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>插件都安装完成之后进入用户登录界面，设定用户名、密码及邮箱。  </p>\n<p>然后提示 Jenkins is ready！→ Start using Jenkins ~</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-508f8521d15f43ca9301b5fdb57a85d6.jpeg\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>注意这里因为要使用node的命令来执行创建后操作，所以还需要安装插件：<code>NodeJSPlugin</code>、 <code>Deployto container</code>、 <code>Github</code>、 <code>Postbuild task</code>  </p>\n<p>这里顺便记录一下启动和关闭Jenkins服务的命令行：</p>\n<ol>\n<li><code>net start jenkins            // 启动Jenkins服务</code></li>\n<li><code>net stop jenkins             // 停止Jenkins服务</code></li>\n</ol>\n<h2 id=\"2-创建svn项目的Jenkins任务\"><a href=\"#2-创建svn项目的Jenkins任务\" class=\"headerlink\" title=\"2. 创建svn项目的Jenkins任务\"></a>2. 创建svn项目的Jenkins任务</h2><h3 id=\"2-1-新建\"><a href=\"#2-1-新建\" class=\"headerlink\" title=\"2.1 新建\"></a>2.1 新建</h3><p>左边栏新建一个任务，输入一个任务名称，这里随便写一个</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-2bb2930c2d64b455c8b97327d40670d9.jpeg\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<h3 id=\"2-2-配置\"><a href=\"#2-2-配置\" class=\"headerlink\" title=\"2.2 配置\"></a>2.2 配置</h3><h4 id=\"General\"><a href=\"#General\" class=\"headerlink\" title=\"General\"></a>General</h4><p>这里才是重头戏，进入刚刚创建的任务的配置页面的 <strong>General</strong></p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-0ddc6e604eabe70e4d2a93f602459f0a.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>丢弃旧的构建就是检测到新的版本之后把旧版本的构建删除</p>\n<h4 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h4><p>这里采用的是 svn 来管理代码，<img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-1277443c4bba685796ff9079bb31d2be.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<h4 id=\"构建触发器\"><a href=\"#构建触发器\" class=\"headerlink\" title=\"构建触发器\"></a>构建触发器</h4><p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-ced8af3d53e7baed8c3bcc4142edddf8.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>这里的 Poll SCM 表示去检测是否更新构建的频率， <code>*****</code> 表示每分钟， <code>H****</code> 表示每小时  </p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><ol>\n<li><code>cd cd C:Jenkinsworkspacemy-demo</code></li>\n<li><code>node -v</code></li>\n<li><code>npm -v</code></li>\n<li><code>cnpm i</code></li>\n<li><code>npm run build</code></li>\n</ol>\n<h4 id=\"构建后操作\"><a href=\"#构建后操作\" class=\"headerlink\" title=\"构建后操作\"></a>构建后操作</h4><p>安装插件 <code>Postbuild task</code> 后，可以在 增加构建后操作步骤中选择 <code>Postbuild task</code> 选项，增加构建后执行的script，具体也可以参考文章：jenkins部署maven项目构建后部署前执行shell脚本 - <a href=\"https://blog.csdn.net/minebk/article/details/73294785\">https://blog.csdn.net/minebk/article/details/73294785</a></p>\n<p>我这里的 <code>Logtext</code> 是 <code>Buildcomplete</code></p>\n<p>Script：</p>\n<ol>\n<li><code>rmdir /q/s C:nginx-1.14.0htmlmy-demo</code></li>\n<li><code>xcopy /y/e/i C:Jenkinsworkspacemy-demomy-demo C:nginx-1.14.0htmlmy-demo</code></li>\n</ol>\n<p>复制生成好的文件到Nginx的目录下，路径自行修改</p>\n<h2 id=\"3-创建Github项目的Jenkins任务\"><a href=\"#3-创建Github项目的Jenkins任务\" class=\"headerlink\" title=\"3. 创建Github项目的Jenkins任务\"></a>3. 创建Github项目的Jenkins任务</h2><p>Jenkins 不仅可以持续集成 svn 项目，Git 项目也是可以的，这里以 Github 上的项目为例：</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-a189fed635dfa2cf96b36545fce55f3d.jpeg\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>其他配置和上面一章一样</p>\n<p>这样如果 github 有新的 push 请求，都会自动化部署到之前的服务器上，可以说很方便了。</p>\n<h3 id=\"试一试\"><a href=\"#试一试\" class=\"headerlink\" title=\"试一试\"></a>试一试</h3><p>配置好了我们试一试，在刚刚 github 项目中随便 commit 一版到 github ：</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-99bbd4b2df388c5ec95b7cfb609531ef.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>稍等片刻去本地 Jenkins 地址 <code>http://localhost:8080/job/vue-element-template/</code> 就能看到 Jenkins 已经在构建中了</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-d7e3cc5ca7574e5eed11784c6ef31e18.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>50秒之后：</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-4d8b2454dc78e83ad8768a028739d0aa.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>构建成功！构建用时 54 秒，现在访问本地服务器地址 <code>http://localhost:8282/vue-element-template</code>，已经能看到编译后的发布版本啦~  </p>\n<p>如果你希望发布的是测试版本，可以自行修改构建后操作的 script</p>\n<hr>\n<p>网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~</p>\n<blockquote>\n<p>参考：</p>\n<ol>\n<li>使用Jenkins自动编译部署web应用</li>\n<li>Jenkins+github 前端自动化部署</li>\n<li>配置Jenkins邮件通知</li>\n<li> jenkins部署maven项目构建后部署前执行shell脚本</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<blockquote>\n<p>作者： 前端下午茶 公号 / SHERlocked93</p>\n</blockquote>\n<p>这两天折腾了一下 Jenkins 持续集成，由于公司使用自己搭建的 svn 服务器来进行代码管理，因此这里 Jenkins 是针对 svn 服务器来进行的配置，Git 配置基本一致，后面也介绍了下针对 Github 管理的项目的 Jenkins 配置</p>\n<p>之前项目每次修改之后都需要本地 <code>npm run build </code>一次手动发布到服务器上方便测试和产品查看，有了Jenkins持续集成之后只要 svn 或者 git 提交之后就会自动打包，很方便，此次记录以备后询。</p>\n<p>声明：</p>\n<ol>\n<li>后面的项目地址与打包地址都是使用 <code>my-demo</code>，自行修改；</li>\n<li>另外还有路径等，根据自己情况自行修改；</li>\n</ol>\n<h2 id=\"1-安装\"><a href=\"#1-安装\" class=\"headerlink\" title=\"1. 安装\"></a>1. 安装</h2><h3 id=\"1-1-安装-Nginx\"><a href=\"#1-1-安装-Nginx\" class=\"headerlink\" title=\"1.1 安装 Nginx\"></a>1.1 安装 Nginx</h3><p>可以直接去官网下直接下载，解压缩 <code>start nginx</code>就可以使了，常用命令：</p>\n<ol>\n<li><code>start nginx # 启动</code></li>\n<li><code>nginx -s reload # 修改配置后重新加载生效</code></li>\n<li><code>nginx -s reopen # 重新打开日志文件</code></li>\n<li><code>nginx -t # 配置文件检测是否正确</code></li>\n</ol>\n<h3 id=\"1-2-安装Jenkins\"><a href=\"#1-2-安装Jenkins\" class=\"headerlink\" title=\"1.2 安装Jenkins\"></a>1.2 安装<strong>Jenkins</strong></h3><p>从官网下载文件安装之后，我这里安装到 <code>C:Jenkins</code>（Mac 不用在意），默认端口 8080，这时候浏览器访问 <code>localhost:8080</code> 就能访问 Jenkins 首页，这里注意如果不安装到 C 盘根目录有些插件安装会出错<img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-04d712c9d2881abd201c30bbb4fc7c99.jpeg\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>这里会让你去某个地方找一个初始密码文件打开并填到下面的密码框里，验证成功之后进入页面，选择 <code>Installsuggested plugins</code> 推介安装的插件</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-d75244e7e6eb65a190f21f1c1a1c481b.jpeg\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>插件都安装完成之后进入用户登录界面，设定用户名、密码及邮箱。  </p>\n<p>然后提示 Jenkins is ready！→ Start using Jenkins ~</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-508f8521d15f43ca9301b5fdb57a85d6.jpeg\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>注意这里因为要使用node的命令来执行创建后操作，所以还需要安装插件：<code>NodeJSPlugin</code>、 <code>Deployto container</code>、 <code>Github</code>、 <code>Postbuild task</code>  </p>\n<p>这里顺便记录一下启动和关闭Jenkins服务的命令行：</p>\n<ol>\n<li><code>net start jenkins            // 启动Jenkins服务</code></li>\n<li><code>net stop jenkins             // 停止Jenkins服务</code></li>\n</ol>\n<h2 id=\"2-创建svn项目的Jenkins任务\"><a href=\"#2-创建svn项目的Jenkins任务\" class=\"headerlink\" title=\"2. 创建svn项目的Jenkins任务\"></a>2. 创建svn项目的Jenkins任务</h2><h3 id=\"2-1-新建\"><a href=\"#2-1-新建\" class=\"headerlink\" title=\"2.1 新建\"></a>2.1 新建</h3><p>左边栏新建一个任务，输入一个任务名称，这里随便写一个</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-2bb2930c2d64b455c8b97327d40670d9.jpeg\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<h3 id=\"2-2-配置\"><a href=\"#2-2-配置\" class=\"headerlink\" title=\"2.2 配置\"></a>2.2 配置</h3><h4 id=\"General\"><a href=\"#General\" class=\"headerlink\" title=\"General\"></a>General</h4><p>这里才是重头戏，进入刚刚创建的任务的配置页面的 <strong>General</strong></p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-0ddc6e604eabe70e4d2a93f602459f0a.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>丢弃旧的构建就是检测到新的版本之后把旧版本的构建删除</p>\n<h4 id=\"源码管理\"><a href=\"#源码管理\" class=\"headerlink\" title=\"源码管理\"></a>源码管理</h4><p>这里采用的是 svn 来管理代码，<img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-1277443c4bba685796ff9079bb31d2be.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<h4 id=\"构建触发器\"><a href=\"#构建触发器\" class=\"headerlink\" title=\"构建触发器\"></a>构建触发器</h4><p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-ced8af3d53e7baed8c3bcc4142edddf8.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>这里的 Poll SCM 表示去检测是否更新构建的频率， <code>*****</code> 表示每分钟， <code>H****</code> 表示每小时  </p>\n<h4 id=\"构建\"><a href=\"#构建\" class=\"headerlink\" title=\"构建\"></a>构建</h4><ol>\n<li><code>cd cd C:Jenkinsworkspacemy-demo</code></li>\n<li><code>node -v</code></li>\n<li><code>npm -v</code></li>\n<li><code>cnpm i</code></li>\n<li><code>npm run build</code></li>\n</ol>\n<h4 id=\"构建后操作\"><a href=\"#构建后操作\" class=\"headerlink\" title=\"构建后操作\"></a>构建后操作</h4><p>安装插件 <code>Postbuild task</code> 后，可以在 增加构建后操作步骤中选择 <code>Postbuild task</code> 选项，增加构建后执行的script，具体也可以参考文章：jenkins部署maven项目构建后部署前执行shell脚本 - <a href=\"https://blog.csdn.net/minebk/article/details/73294785\">https://blog.csdn.net/minebk/article/details/73294785</a></p>\n<p>我这里的 <code>Logtext</code> 是 <code>Buildcomplete</code></p>\n<p>Script：</p>\n<ol>\n<li><code>rmdir /q/s C:nginx-1.14.0htmlmy-demo</code></li>\n<li><code>xcopy /y/e/i C:Jenkinsworkspacemy-demomy-demo C:nginx-1.14.0htmlmy-demo</code></li>\n</ol>\n<p>复制生成好的文件到Nginx的目录下，路径自行修改</p>\n<h2 id=\"3-创建Github项目的Jenkins任务\"><a href=\"#3-创建Github项目的Jenkins任务\" class=\"headerlink\" title=\"3. 创建Github项目的Jenkins任务\"></a>3. 创建Github项目的Jenkins任务</h2><p>Jenkins 不仅可以持续集成 svn 项目，Git 项目也是可以的，这里以 Github 上的项目为例：</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-a189fed635dfa2cf96b36545fce55f3d.jpeg\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>其他配置和上面一章一样</p>\n<p>这样如果 github 有新的 push 请求，都会自动化部署到之前的服务器上，可以说很方便了。</p>\n<h3 id=\"试一试\"><a href=\"#试一试\" class=\"headerlink\" title=\"试一试\"></a>试一试</h3><p>配置好了我们试一试，在刚刚 github 项目中随便 commit 一版到 github ：</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-99bbd4b2df388c5ec95b7cfb609531ef.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>稍等片刻去本地 Jenkins 地址 <code>http://localhost:8080/job/vue-element-template/</code> 就能看到 Jenkins 已经在构建中了</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-d7e3cc5ca7574e5eed11784c6ef31e18.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>50秒之后：</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-4d8b2454dc78e83ad8768a028739d0aa.png\" alt=\"一文搞定前端 Jenkins 自动化部署\"></p>\n<p>构建成功！构建用时 54 秒，现在访问本地服务器地址 <code>http://localhost:8282/vue-element-template</code>，已经能看到编译后的发布版本啦~  </p>\n<p>如果你希望发布的是测试版本，可以自行修改构建后操作的 script</p>\n<hr>\n<p>网上的帖子大多深浅不一，甚至有些前后矛盾，在下的文章都是学习过程中的总结，如果发现错误，欢迎留言指出~</p>\n<blockquote>\n<p>参考：</p>\n<ol>\n<li>使用Jenkins自动编译部署web应用</li>\n<li>Jenkins+github 前端自动化部署</li>\n<li>配置Jenkins邮件通知</li>\n<li> jenkins部署maven项目构建后部署前执行shell脚本</li>\n</ol>\n</blockquote>\n"},{"title":"传说中图片防盗链的爱恨情仇","url":"119.html","id":"119","date":"2019-06-22T08:18:20.000Z","_content":"\n原理\n--\n\n> 注：这里有个很有趣的就是 Referrer 和 Referer 的故事了感兴趣的自行去了解以下\n\n我们先来了解了解防盗链的原理，在http 协议中，如果从一个页面跳到另一个页面，header字段里面会带个 Referer。图片服务器通过检测 Referer 是否来自规定域名，来进行防盗链。如果盗用网站是 **https** 的 协议，而图片链接是 http 的话，则从 https 向 http 发起的请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。官方输出图片的时候，判断了来源(Referer)，就是从哪个网站访问这个图片，如果是你的网站去加载这个图片，那么Referer就是：你的网站地址；你的网址肯定没在官方的白名单内，(当然作为可操作性极强的浏览器来说referer是完全可以伪造一个官方的URL这样也也就也可以饶过限制????)所以就看不到图片了。 因此，若不发送Referer，也就是没有来源。那么官方那边，就认为是从浏览器直接访问的，所以就能加载正常的图片了。\n\n目的\n--\n\n盗链是指在自己的页面上展示一些并不在自己服务器上的内容。通常的做法是通过技术手段获得它人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向最终用户提供此内容。比较常见的是一些小站盗用大站的资源（图片、音乐、视频），对于这些小站来说，通过盗链的方法可以减轻自己服务器的负担，因为真实的空间和流量均是来自别人的服务器。对大站造成的影响确实徒徒增加了服务器压力，用户还不是自己的。。。 防盗链就是防止这种行为的产生，实施防盗链系统后，因为屏蔽了那些盗链的间接资源请求，从而可以大大减轻服务器及带宽的压力，也正如此，越来越多的站点都开始实施防盗链技术。\n\n实现\n--\n\n\\> nginx\n\n    location ~* \\.(gif|jpg|png|bmp)$ {    \n        valid_referers none blocked *.ttlsa.com server_names ~\\.google\\. ~\\.baidu\\.;    \n        if ($invalid_referer) {        \n            return 403;        \n            #rewrite ^/ http://www.xxx.com/403.jpg;    \n        }\n    }\n\n以上所有来至xxx.com和域名中包含google和baidu的站点都可以访问到当前站点的图片,如果来源域名（白名单列表）不在这个列表中。 那么$invalid_referer等于1，在if语句中返回一个403给用户，这样用户便会看到一个403的页面,如果使用下面的rewrite，那么盗链的图片都会显示403.jpg。 > apache 在根目录下创建.htaccess 文件\n\n    RewriteEngine On\n    RewriteCond %{HTTP_REFERER} !^$ [NC]\n    RewriteCond %{HTTP_REFERER} !phpddt.com [NC]\n    RewriteCond %{HTTP_REFERER} !google.com [NC]\n    RewriteCond %{HTTP_REFERER} !baidu.com.com [NC]\n    RewriteCond %{HTTP_REFERER} !feedburner.com [NC]\n    RewriteCond %{HTTP_REFERER} !feedsky.com [NC]\n    RewriteRule .*\\.(rar|zip)$ http://www.xxx.com/ [R,NC,L]\n\n这段话也可写在Apache配置文件当中 .htaccess文件将影响其所在的目录及其子目录。你可以将其放在根目录或项目的子目录 上面这段代码也是很容易理解的： RewriteCond %{HTTP\\_REFERER} !^$ \\[NC\\] 允许空的来源，即用户浏览器手动属于则允许访问文件。 RewriteCond %{HTTP\\_REFERER} !phpddt.com \\[NC\\] 允许站点自身访问，同理，后面还要允许百度，谷歌，和一些订阅源访问。 RewriteRule .*\\\\.(rar|zip)$ http://www.xxx.com/ \\[R,NC,L\\] 这里可以设置防止盗链的类型，如果盗链可以跳转到网站首页，本站没有做图片防盗链，如果你做图片防盗链可以设置被盗链的替代图片： RewriteRule .*\\\\.(gif|jpg|png)$ http://xxx.com/logo.png \\[R,NC,L\\]\n\n破解\n--\n\n????道高一尺魔高一丈既然知道原理那么就来看看一些常用的破解方案如果你有更好的记得给我留言。 >1\\. 如果盗用图片资源是http协议那么盗用网址可以使用https去请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。 >2. 在HTML代码的head中添加一句 `<meta name=\"referrer\" content=\"no-referrer\" />`  >3.\n\n    function showImg( url ) {\n            var frameid = 'frameimg' + Math.random();\n            window.img = '<img id=\"img\" src=\\''+url+'?'+Math.random()+'\\' />\n            <script>window.onload = function() { parent.document.getElementById\n            (\\''+frameid+'\\').height = document.getElementById(\\'img\\').height\n            +\\'px\\'; }<'+'/script>';\n            document.write('<iframe id=\"'+frameid+'\" src=\"javascript:parent.img;\n            \" frameBorder=\"0\" scrolling=\"no\" width=\"100%\"></iframe>');\n    }\n\n>6\\. 前面也提到来可以服务端伪造请求头具体不同的语言自行搜索对应方案，这里就不一一列举了。\n\n反破解\n---\n\n既然有破解就当然有常用的防御机制???? 1、不允许referer为空（不建议，因在某些开启隐私模式的浏览器中，或https页面引用下，referer是空的） 2、地址变更（lighttpd的是根据有效时间，nginx的根据是md5，IP地址变化） 3、登录校验（如必须登录网站帐号后才能访问） 以下是防止网站被镜像，被iframe **1.防止网站被镜像（被恶意解析和转发等）** 现象：他人域名访问到的是我的网站解析的ip地址我的 解决方法： http.ini里可以这样写\n\n    <script type=”text/javascript> \n       if(window!=parent) \n      window.top.location.href = window.location.href; \n    < /script>\n\n代码的意思也很简单，用js方法检测地址栏域名是不是当前网站绑定的域名，如果不是，则跳转到绑定的域名上来，这样就不怕网站被别人iframe了。","source":"_posts/e4-bc-a0-e8-af-b4-e4-b8-ad-e5-9b-be-e7-89-87-e9-98-b2-e7-9b-97-e9-93-be-e7-9a-84-e7-88-b1-e6-81-a8-e6-83-85-e4-bb-87.md","raw":"---\ntitle: 传说中图片防盗链的爱恨情仇\ntags:\n  - 前端，盗链\nurl: 119.html\nid: 119\ncategories:\n  - 大前端\ndate: 2019-06-22 16:18:20\n---\n\n原理\n--\n\n> 注：这里有个很有趣的就是 Referrer 和 Referer 的故事了感兴趣的自行去了解以下\n\n我们先来了解了解防盗链的原理，在http 协议中，如果从一个页面跳到另一个页面，header字段里面会带个 Referer。图片服务器通过检测 Referer 是否来自规定域名，来进行防盗链。如果盗用网站是 **https** 的 协议，而图片链接是 http 的话，则从 https 向 http 发起的请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。官方输出图片的时候，判断了来源(Referer)，就是从哪个网站访问这个图片，如果是你的网站去加载这个图片，那么Referer就是：你的网站地址；你的网址肯定没在官方的白名单内，(当然作为可操作性极强的浏览器来说referer是完全可以伪造一个官方的URL这样也也就也可以饶过限制????)所以就看不到图片了。 因此，若不发送Referer，也就是没有来源。那么官方那边，就认为是从浏览器直接访问的，所以就能加载正常的图片了。\n\n目的\n--\n\n盗链是指在自己的页面上展示一些并不在自己服务器上的内容。通常的做法是通过技术手段获得它人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向最终用户提供此内容。比较常见的是一些小站盗用大站的资源（图片、音乐、视频），对于这些小站来说，通过盗链的方法可以减轻自己服务器的负担，因为真实的空间和流量均是来自别人的服务器。对大站造成的影响确实徒徒增加了服务器压力，用户还不是自己的。。。 防盗链就是防止这种行为的产生，实施防盗链系统后，因为屏蔽了那些盗链的间接资源请求，从而可以大大减轻服务器及带宽的压力，也正如此，越来越多的站点都开始实施防盗链技术。\n\n实现\n--\n\n\\> nginx\n\n    location ~* \\.(gif|jpg|png|bmp)$ {    \n        valid_referers none blocked *.ttlsa.com server_names ~\\.google\\. ~\\.baidu\\.;    \n        if ($invalid_referer) {        \n            return 403;        \n            #rewrite ^/ http://www.xxx.com/403.jpg;    \n        }\n    }\n\n以上所有来至xxx.com和域名中包含google和baidu的站点都可以访问到当前站点的图片,如果来源域名（白名单列表）不在这个列表中。 那么$invalid_referer等于1，在if语句中返回一个403给用户，这样用户便会看到一个403的页面,如果使用下面的rewrite，那么盗链的图片都会显示403.jpg。 > apache 在根目录下创建.htaccess 文件\n\n    RewriteEngine On\n    RewriteCond %{HTTP_REFERER} !^$ [NC]\n    RewriteCond %{HTTP_REFERER} !phpddt.com [NC]\n    RewriteCond %{HTTP_REFERER} !google.com [NC]\n    RewriteCond %{HTTP_REFERER} !baidu.com.com [NC]\n    RewriteCond %{HTTP_REFERER} !feedburner.com [NC]\n    RewriteCond %{HTTP_REFERER} !feedsky.com [NC]\n    RewriteRule .*\\.(rar|zip)$ http://www.xxx.com/ [R,NC,L]\n\n这段话也可写在Apache配置文件当中 .htaccess文件将影响其所在的目录及其子目录。你可以将其放在根目录或项目的子目录 上面这段代码也是很容易理解的： RewriteCond %{HTTP\\_REFERER} !^$ \\[NC\\] 允许空的来源，即用户浏览器手动属于则允许访问文件。 RewriteCond %{HTTP\\_REFERER} !phpddt.com \\[NC\\] 允许站点自身访问，同理，后面还要允许百度，谷歌，和一些订阅源访问。 RewriteRule .*\\\\.(rar|zip)$ http://www.xxx.com/ \\[R,NC,L\\] 这里可以设置防止盗链的类型，如果盗链可以跳转到网站首页，本站没有做图片防盗链，如果你做图片防盗链可以设置被盗链的替代图片： RewriteRule .*\\\\.(gif|jpg|png)$ http://xxx.com/logo.png \\[R,NC,L\\]\n\n破解\n--\n\n????道高一尺魔高一丈既然知道原理那么就来看看一些常用的破解方案如果你有更好的记得给我留言。 >1\\. 如果盗用图片资源是http协议那么盗用网址可以使用https去请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。 >2. 在HTML代码的head中添加一句 `<meta name=\"referrer\" content=\"no-referrer\" />`  >3.\n\n    function showImg( url ) {\n            var frameid = 'frameimg' + Math.random();\n            window.img = '<img id=\"img\" src=\\''+url+'?'+Math.random()+'\\' />\n            <script>window.onload = function() { parent.document.getElementById\n            (\\''+frameid+'\\').height = document.getElementById(\\'img\\').height\n            +\\'px\\'; }<'+'/script>';\n            document.write('<iframe id=\"'+frameid+'\" src=\"javascript:parent.img;\n            \" frameBorder=\"0\" scrolling=\"no\" width=\"100%\"></iframe>');\n    }\n\n>6\\. 前面也提到来可以服务端伪造请求头具体不同的语言自行搜索对应方案，这里就不一一列举了。\n\n反破解\n---\n\n既然有破解就当然有常用的防御机制???? 1、不允许referer为空（不建议，因在某些开启隐私模式的浏览器中，或https页面引用下，referer是空的） 2、地址变更（lighttpd的是根据有效时间，nginx的根据是md5，IP地址变化） 3、登录校验（如必须登录网站帐号后才能访问） 以下是防止网站被镜像，被iframe **1.防止网站被镜像（被恶意解析和转发等）** 现象：他人域名访问到的是我的网站解析的ip地址我的 解决方法： http.ini里可以这样写\n\n    <script type=”text/javascript> \n       if(window!=parent) \n      window.top.location.href = window.location.href; \n    < /script>\n\n代码的意思也很简单，用js方法检测地址栏域名是不是当前网站绑定的域名，如果不是，则跳转到绑定的域名上来，这样就不怕网站被别人iframe了。","slug":"e4-bc-a0-e8-af-b4-e4-b8-ad-e5-9b-be-e7-89-87-e9-98-b2-e7-9b-97-e9-93-be-e7-9a-84-e7-88-b1-e6-81-a8-e6-83-85-e4-bb-87","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp2699t000ec8gs7qj07zpp","content":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p>注：这里有个很有趣的就是 Referrer 和 Referer 的故事了感兴趣的自行去了解以下</p>\n</blockquote>\n<p>我们先来了解了解防盗链的原理，在http 协议中，如果从一个页面跳到另一个页面，header字段里面会带个 Referer。图片服务器通过检测 Referer 是否来自规定域名，来进行防盗链。如果盗用网站是 <strong>https</strong> 的 协议，而图片链接是 http 的话，则从 https 向 http 发起的请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。官方输出图片的时候，判断了来源(Referer)，就是从哪个网站访问这个图片，如果是你的网站去加载这个图片，那么Referer就是：你的网站地址；你的网址肯定没在官方的白名单内，(当然作为可操作性极强的浏览器来说referer是完全可以伪造一个官方的URL这样也也就也可以饶过限制????)所以就看不到图片了。 因此，若不发送Referer，也就是没有来源。那么官方那边，就认为是从浏览器直接访问的，所以就能加载正常的图片了。</p>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>盗链是指在自己的页面上展示一些并不在自己服务器上的内容。通常的做法是通过技术手段获得它人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向最终用户提供此内容。比较常见的是一些小站盗用大站的资源（图片、音乐、视频），对于这些小站来说，通过盗链的方法可以减轻自己服务器的负担，因为真实的空间和流量均是来自别人的服务器。对大站造成的影响确实徒徒增加了服务器压力，用户还不是自己的。。。 防盗链就是防止这种行为的产生，实施防盗链系统后，因为屏蔽了那些盗链的间接资源请求，从而可以大大减轻服务器及带宽的压力，也正如此，越来越多的站点都开始实施防盗链技术。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>&gt; nginx</p>\n<pre><code>location ~* \\.(gif|jpg|png|bmp)$ &#123;    \n    valid_referers none blocked *.ttlsa.com server_names ~\\.google\\. ~\\.baidu\\.;    \n    if ($invalid_referer) &#123;        \n        return 403;        \n        #rewrite ^/ http://www.xxx.com/403.jpg;    \n    &#125;\n&#125;\n</code></pre>\n<p>以上所有来至xxx.com和域名中包含google和baidu的站点都可以访问到当前站点的图片,如果来源域名（白名单列表）不在这个列表中。 那么$invalid_referer等于1，在if语句中返回一个403给用户，这样用户便会看到一个403的页面,如果使用下面的rewrite，那么盗链的图片都会显示403.jpg。 &gt; apache 在根目录下创建.htaccess 文件</p>\n<pre><code>RewriteEngine On\nRewriteCond %&#123;HTTP_REFERER&#125; !^$ [NC]\nRewriteCond %&#123;HTTP_REFERER&#125; !phpddt.com [NC]\nRewriteCond %&#123;HTTP_REFERER&#125; !google.com [NC]\nRewriteCond %&#123;HTTP_REFERER&#125; !baidu.com.com [NC]\nRewriteCond %&#123;HTTP_REFERER&#125; !feedburner.com [NC]\nRewriteCond %&#123;HTTP_REFERER&#125; !feedsky.com [NC]\nRewriteRule .*\\.(rar|zip)$ http://www.xxx.com/ [R,NC,L]\n</code></pre>\n<p>这段话也可写在Apache配置文件当中 .htaccess文件将影响其所在的目录及其子目录。你可以将其放在根目录或项目的子目录 上面这段代码也是很容易理解的： RewriteCond %{HTTP_REFERER} !^$ [NC] 允许空的来源，即用户浏览器手动属于则允许访问文件。 RewriteCond %{HTTP_REFERER} !phpddt.com [NC] 允许站点自身访问，同理，后面还要允许百度，谷歌，和一些订阅源访问。 RewriteRule .*\\.(rar|zip)$ <a href=\"http://www.xxx.com/\">http://www.xxx.com/</a> [R,NC,L] 这里可以设置防止盗链的类型，如果盗链可以跳转到网站首页，本站没有做图片防盗链，如果你做图片防盗链可以设置被盗链的替代图片： RewriteRule .*\\.(gif|jpg|png)$ <a href=\"http://xxx.com/logo.png\">http://xxx.com/logo.png</a> [R,NC,L]</p>\n<h2 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h2><p>????道高一尺魔高一丈既然知道原理那么就来看看一些常用的破解方案如果你有更好的记得给我留言。 &gt;1. 如果盗用图片资源是http协议那么盗用网址可以使用https去请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。 &gt;2. 在HTML代码的head中添加一句 <code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code>  &gt;3.</p>\n<pre><code>function showImg( url ) &#123;\n        var frameid = &#39;frameimg&#39; + Math.random();\n        window.img = &#39;&lt;img id=&quot;img&quot; src=\\&#39;&#39;+url+&#39;?&#39;+Math.random()+&#39;\\&#39; /&gt;\n        &lt;script&gt;window.onload = function() &#123; parent.document.getElementById\n        (\\&#39;&#39;+frameid+&#39;\\&#39;).height = document.getElementById(\\&#39;img\\&#39;).height\n        +\\&#39;px\\&#39;; &#125;&lt;&#39;+&#39;/script&gt;&#39;;\n        document.write(&#39;&lt;iframe id=&quot;&#39;+frameid+&#39;&quot; src=&quot;javascript:parent.img;\n        &quot; frameBorder=&quot;0&quot; scrolling=&quot;no&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&#39;);\n&#125;\n</code></pre>\n<blockquote>\n<p>6. 前面也提到来可以服务端伪造请求头具体不同的语言自行搜索对应方案，这里就不一一列举了。</p>\n</blockquote>\n<h2 id=\"反破解\"><a href=\"#反破解\" class=\"headerlink\" title=\"反破解\"></a>反破解</h2><p>既然有破解就当然有常用的防御机制???? 1、不允许referer为空（不建议，因在某些开启隐私模式的浏览器中，或https页面引用下，referer是空的） 2、地址变更（lighttpd的是根据有效时间，nginx的根据是md5，IP地址变化） 3、登录校验（如必须登录网站帐号后才能访问） 以下是防止网站被镜像，被iframe <strong>1.防止网站被镜像（被恶意解析和转发等）</strong> 现象：他人域名访问到的是我的网站解析的ip地址我的 解决方法： http.ini里可以这样写</p>\n<pre><code>&lt;script type=”text/javascript&gt; \n   if(window!=parent) \n  window.top.location.href = window.location.href; \n&lt; /script&gt;\n</code></pre>\n<p>代码的意思也很简单，用js方法检测地址栏域名是不是当前网站绑定的域名，如果不是，则跳转到绑定的域名上来，这样就不怕网站被别人iframe了。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><blockquote>\n<p>注：这里有个很有趣的就是 Referrer 和 Referer 的故事了感兴趣的自行去了解以下</p>\n</blockquote>\n<p>我们先来了解了解防盗链的原理，在http 协议中，如果从一个页面跳到另一个页面，header字段里面会带个 Referer。图片服务器通过检测 Referer 是否来自规定域名，来进行防盗链。如果盗用网站是 <strong>https</strong> 的 协议，而图片链接是 http 的话，则从 https 向 http 发起的请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。官方输出图片的时候，判断了来源(Referer)，就是从哪个网站访问这个图片，如果是你的网站去加载这个图片，那么Referer就是：你的网站地址；你的网址肯定没在官方的白名单内，(当然作为可操作性极强的浏览器来说referer是完全可以伪造一个官方的URL这样也也就也可以饶过限制????)所以就看不到图片了。 因此，若不发送Referer，也就是没有来源。那么官方那边，就认为是从浏览器直接访问的，所以就能加载正常的图片了。</p>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><p>盗链是指在自己的页面上展示一些并不在自己服务器上的内容。通常的做法是通过技术手段获得它人服务器上的资源地址，绕过别人的资源展示页面，直接在自己的页面上向最终用户提供此内容。比较常见的是一些小站盗用大站的资源（图片、音乐、视频），对于这些小站来说，通过盗链的方法可以减轻自己服务器的负担，因为真实的空间和流量均是来自别人的服务器。对大站造成的影响确实徒徒增加了服务器压力，用户还不是自己的。。。 防盗链就是防止这种行为的产生，实施防盗链系统后，因为屏蔽了那些盗链的间接资源请求，从而可以大大减轻服务器及带宽的压力，也正如此，越来越多的站点都开始实施防盗链技术。</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><p>&gt; nginx</p>\n<pre><code>location ~* \\.(gif|jpg|png|bmp)$ &#123;    \n    valid_referers none blocked *.ttlsa.com server_names ~\\.google\\. ~\\.baidu\\.;    \n    if ($invalid_referer) &#123;        \n        return 403;        \n        #rewrite ^/ http://www.xxx.com/403.jpg;    \n    &#125;\n&#125;\n</code></pre>\n<p>以上所有来至xxx.com和域名中包含google和baidu的站点都可以访问到当前站点的图片,如果来源域名（白名单列表）不在这个列表中。 那么$invalid_referer等于1，在if语句中返回一个403给用户，这样用户便会看到一个403的页面,如果使用下面的rewrite，那么盗链的图片都会显示403.jpg。 &gt; apache 在根目录下创建.htaccess 文件</p>\n<pre><code>RewriteEngine On\nRewriteCond %&#123;HTTP_REFERER&#125; !^$ [NC]\nRewriteCond %&#123;HTTP_REFERER&#125; !phpddt.com [NC]\nRewriteCond %&#123;HTTP_REFERER&#125; !google.com [NC]\nRewriteCond %&#123;HTTP_REFERER&#125; !baidu.com.com [NC]\nRewriteCond %&#123;HTTP_REFERER&#125; !feedburner.com [NC]\nRewriteCond %&#123;HTTP_REFERER&#125; !feedsky.com [NC]\nRewriteRule .*\\.(rar|zip)$ http://www.xxx.com/ [R,NC,L]\n</code></pre>\n<p>这段话也可写在Apache配置文件当中 .htaccess文件将影响其所在的目录及其子目录。你可以将其放在根目录或项目的子目录 上面这段代码也是很容易理解的： RewriteCond %{HTTP_REFERER} !^$ [NC] 允许空的来源，即用户浏览器手动属于则允许访问文件。 RewriteCond %{HTTP_REFERER} !phpddt.com [NC] 允许站点自身访问，同理，后面还要允许百度，谷歌，和一些订阅源访问。 RewriteRule .*\\.(rar|zip)$ <a href=\"http://www.xxx.com/\">http://www.xxx.com/</a> [R,NC,L] 这里可以设置防止盗链的类型，如果盗链可以跳转到网站首页，本站没有做图片防盗链，如果你做图片防盗链可以设置被盗链的替代图片： RewriteRule .*\\.(gif|jpg|png)$ <a href=\"http://xxx.com/logo.png\">http://xxx.com/logo.png</a> [R,NC,L]</p>\n<h2 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h2><p>????道高一尺魔高一丈既然知道原理那么就来看看一些常用的破解方案如果你有更好的记得给我留言。 &gt;1. 如果盗用图片资源是http协议那么盗用网址可以使用https去请求会因为安全性的规定，而不带 referer，从而实现防盗链的绕过。 &gt;2. 在HTML代码的head中添加一句 <code>&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot; /&gt;</code>  &gt;3.</p>\n<pre><code>function showImg( url ) &#123;\n        var frameid = &#39;frameimg&#39; + Math.random();\n        window.img = &#39;&lt;img id=&quot;img&quot; src=\\&#39;&#39;+url+&#39;?&#39;+Math.random()+&#39;\\&#39; /&gt;\n        &lt;script&gt;window.onload = function() &#123; parent.document.getElementById\n        (\\&#39;&#39;+frameid+&#39;\\&#39;).height = document.getElementById(\\&#39;img\\&#39;).height\n        +\\&#39;px\\&#39;; &#125;&lt;&#39;+&#39;/script&gt;&#39;;\n        document.write(&#39;&lt;iframe id=&quot;&#39;+frameid+&#39;&quot; src=&quot;javascript:parent.img;\n        &quot; frameBorder=&quot;0&quot; scrolling=&quot;no&quot; width=&quot;100%&quot;&gt;&lt;/iframe&gt;&#39;);\n&#125;\n</code></pre>\n<blockquote>\n<p>6. 前面也提到来可以服务端伪造请求头具体不同的语言自行搜索对应方案，这里就不一一列举了。</p>\n</blockquote>\n<h2 id=\"反破解\"><a href=\"#反破解\" class=\"headerlink\" title=\"反破解\"></a>反破解</h2><p>既然有破解就当然有常用的防御机制???? 1、不允许referer为空（不建议，因在某些开启隐私模式的浏览器中，或https页面引用下，referer是空的） 2、地址变更（lighttpd的是根据有效时间，nginx的根据是md5，IP地址变化） 3、登录校验（如必须登录网站帐号后才能访问） 以下是防止网站被镜像，被iframe <strong>1.防止网站被镜像（被恶意解析和转发等）</strong> 现象：他人域名访问到的是我的网站解析的ip地址我的 解决方法： http.ini里可以这样写</p>\n<pre><code>&lt;script type=”text/javascript&gt; \n   if(window!=parent) \n  window.top.location.href = window.location.href; \n&lt; /script&gt;\n</code></pre>\n<p>代码的意思也很简单，用js方法检测地址栏域名是不是当前网站绑定的域名，如果不是，则跳转到绑定的域名上来，这样就不怕网站被别人iframe了。</p>\n"},{"title":"入门篇-如何用javascript实现一个模板引擎","url":"139.html","id":"139","date":"2019-06-22T09:03:15.000Z","_content":"\n模板引擎简介\n======\n\n模板引擎是html渲染必不可少的工具，前端开发的同学经历了从最原始的字符串拼接、用数组push/join，发展到封装简单的string.format函数，再到功能更加强大的模板引擎，可以在模板中内嵌处理逻辑。 传统的页面开发语言技术asp.net,php,jsp都内置了模板引擎，javascrip常见的模板引擎有jquery的tmpl插件，underscore的template函数，ejs、jade、artTemplate等,以ejs为例，模板语法如下：\n\n    function render(tpl,data){     \n        tpl=tpl.replace(/(\\r|\\n)/ig,\"\");     \n        var arr=tpl.split(/(\\<%=?|%\\>)/gm);//拆分模板     \n        var funcBody=[\"with(this){\\r\\nvar result=[];\"];     \n        var item,codeType;     \n        codeType=0;     \n        for(var i=0;i<arr.length;i++){         \n            item=arr[i];         //将代码片段分为3类         \n            if(item==\"<%\"){            \n                codeType=1;           \n                continue;         \n            }else if(item==\"<%=\"){            \n                codeType=2;            \n                continue;         \n            }else if(item==\"%>\"){             \n                codeType=0;             \n                continue;         \n           }          //为3类代码片段生成最终可被eval的函数体         \n           if(codeType==0){ //字符             \n               funcBody.push(\"result.push(\\\"\");             \n               funcBody.push(item);             \n               funcBody.push(\"\\\");\\r\\n\");         \n           }else if(codeType==1){ //代码             \n               funcBody.push(item);             \n               funcBody.push(\"\\r\\n\");         \n           }else if (codeType==2){ //代码输出             \n               funcBody.push(\"result.push(\");             \n               funcBody.push(item);             \n               funcBody.push(\");\\r\\n\");         \n           }     \n       }     \n       funcBody.push(\"return result.join('')\\r\\n}\");     \n       var template_func=new Function([\"renderData\"],funcBody.join(\"\"));     \n       return template_func.apply(data,[data]);  \n    }\n\n测试一下\n\n    var html=render(\"<% list.forEach(function (item,idx){ %>\" +\" <div><%=idx+1+\n    '、'+item%></div>\" +\" <%})%>\", {list:[\"javascript\",\"css\",\"node.js\"]}) \n    document.write(html)\n\n完美运行 ![WX20190506-153145@2x.png](http://cdn.v5ant.com/ueditor/images/1125301559559852032.png \"undefined\") 我们来看一下最终编译后生成的函数是什么样子的，如下图： ![WX20190506-153048@2x.png](http://cdn.v5ant.com/ueditor/images/1125301346816364544.png \"undefined\") 由于生成的函数是用apply调用的，template_inner.apply(data,\\[data\\]),所以函数内部的this指向传入的数据源(data变量)，因此可以在模板中直接使用传入的数据源对象\n\n模板引擎与ES6模板字符串对比\n===============\n\nES6新增了模板字符串功能，不同于普通字符串的单引号和双引号，模板字符用`符号定义，在模板字符中直接可以通过${变量名}访问当前作用域内的变量并直接输出该变量的值，并且在js文件中定义大段的html字符串时，一般是把html片段粘帖进来，包含很多换行符，而模板字符串可以直接兼容换行符，使用起来非常方便。上文中的模板，用ES6的模板字符串来实现，代码也非常精简，如下：\n\n    var user={name:\"windy\"}; \n    var str=`<h2>${user.name}</h2>`\n\nES6模板字符串与普通的模板引擎相比，最大区别在于开发流程的不同，业务逻辑是在js中实现的，模板只实现纯净的变量替换功能，代码与逻辑分离，比较规范易用，可维护也较好，而普通的模板引擎不仅实现了变量替换，还可以内嵌js逻辑代码，更加灵活和强大。","source":"_posts/e5-85-a5-e9-97-a8-e7-af-87-e5-a6-82-e4-bd-95-e7-94-a8javascript-e5-ae-9e-e7-8e-b0-e4-b8-80-e4-b8-aa-e6-a8-a1-e6-9d-bf-e5-bc-95-e6-93-8e.md","raw":"---\ntitle: 入门篇-如何用javascript实现一个模板引擎\nurl: 139.html\nid: 139\ncategories:\n  - 大前端\ndate: 2019-06-22 17:03:15\ntags:\n---\n\n模板引擎简介\n======\n\n模板引擎是html渲染必不可少的工具，前端开发的同学经历了从最原始的字符串拼接、用数组push/join，发展到封装简单的string.format函数，再到功能更加强大的模板引擎，可以在模板中内嵌处理逻辑。 传统的页面开发语言技术asp.net,php,jsp都内置了模板引擎，javascrip常见的模板引擎有jquery的tmpl插件，underscore的template函数，ejs、jade、artTemplate等,以ejs为例，模板语法如下：\n\n    function render(tpl,data){     \n        tpl=tpl.replace(/(\\r|\\n)/ig,\"\");     \n        var arr=tpl.split(/(\\<%=?|%\\>)/gm);//拆分模板     \n        var funcBody=[\"with(this){\\r\\nvar result=[];\"];     \n        var item,codeType;     \n        codeType=0;     \n        for(var i=0;i<arr.length;i++){         \n            item=arr[i];         //将代码片段分为3类         \n            if(item==\"<%\"){            \n                codeType=1;           \n                continue;         \n            }else if(item==\"<%=\"){            \n                codeType=2;            \n                continue;         \n            }else if(item==\"%>\"){             \n                codeType=0;             \n                continue;         \n           }          //为3类代码片段生成最终可被eval的函数体         \n           if(codeType==0){ //字符             \n               funcBody.push(\"result.push(\\\"\");             \n               funcBody.push(item);             \n               funcBody.push(\"\\\");\\r\\n\");         \n           }else if(codeType==1){ //代码             \n               funcBody.push(item);             \n               funcBody.push(\"\\r\\n\");         \n           }else if (codeType==2){ //代码输出             \n               funcBody.push(\"result.push(\");             \n               funcBody.push(item);             \n               funcBody.push(\");\\r\\n\");         \n           }     \n       }     \n       funcBody.push(\"return result.join('')\\r\\n}\");     \n       var template_func=new Function([\"renderData\"],funcBody.join(\"\"));     \n       return template_func.apply(data,[data]);  \n    }\n\n测试一下\n\n    var html=render(\"<% list.forEach(function (item,idx){ %>\" +\" <div><%=idx+1+\n    '、'+item%></div>\" +\" <%})%>\", {list:[\"javascript\",\"css\",\"node.js\"]}) \n    document.write(html)\n\n完美运行 ![WX20190506-153145@2x.png](http://cdn.v5ant.com/ueditor/images/1125301559559852032.png \"undefined\") 我们来看一下最终编译后生成的函数是什么样子的，如下图： ![WX20190506-153048@2x.png](http://cdn.v5ant.com/ueditor/images/1125301346816364544.png \"undefined\") 由于生成的函数是用apply调用的，template_inner.apply(data,\\[data\\]),所以函数内部的this指向传入的数据源(data变量)，因此可以在模板中直接使用传入的数据源对象\n\n模板引擎与ES6模板字符串对比\n===============\n\nES6新增了模板字符串功能，不同于普通字符串的单引号和双引号，模板字符用`符号定义，在模板字符中直接可以通过${变量名}访问当前作用域内的变量并直接输出该变量的值，并且在js文件中定义大段的html字符串时，一般是把html片段粘帖进来，包含很多换行符，而模板字符串可以直接兼容换行符，使用起来非常方便。上文中的模板，用ES6的模板字符串来实现，代码也非常精简，如下：\n\n    var user={name:\"windy\"}; \n    var str=`<h2>${user.name}</h2>`\n\nES6模板字符串与普通的模板引擎相比，最大区别在于开发流程的不同，业务逻辑是在js中实现的，模板只实现纯净的变量替换功能，代码与逻辑分离，比较规范易用，可维护也较好，而普通的模板引擎不仅实现了变量替换，还可以内嵌js逻辑代码，更加灵活和强大。","slug":"e5-85-a5-e9-97-a8-e7-af-87-e5-a6-82-e4-bd-95-e7-94-a8javascript-e5-ae-9e-e7-8e-b0-e4-b8-80-e4-b8-aa-e6-a8-a1-e6-9d-bf-e5-bc-95-e6-93-8e","published":1,"updated":"2019-09-10T07:46:08.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp2699v000hc8gs6j6xa69r","content":"<h1 id=\"模板引擎简介\"><a href=\"#模板引擎简介\" class=\"headerlink\" title=\"模板引擎简介\"></a>模板引擎简介</h1><p>模板引擎是html渲染必不可少的工具，前端开发的同学经历了从最原始的字符串拼接、用数组push/join，发展到封装简单的string.format函数，再到功能更加强大的模板引擎，可以在模板中内嵌处理逻辑。 传统的页面开发语言技术asp.net,php,jsp都内置了模板引擎，javascrip常见的模板引擎有jquery的tmpl插件，underscore的template函数，ejs、jade、artTemplate等,以ejs为例，模板语法如下：</p>\n<pre><code>function render(tpl,data)&#123;     \n    tpl=tpl.replace(/(\\r|\\n)/ig,&quot;&quot;);     \n    var arr=tpl.split(/(\\&lt;%=?|%\\&gt;)/gm);//拆分模板     \n    var funcBody=[&quot;with(this)&#123;\\r\\nvar result=[];&quot;];     \n    var item,codeType;     \n    codeType=0;     \n    for(var i=0;i&lt;arr.length;i++)&#123;         \n        item=arr[i];         //将代码片段分为3类         \n        if(item==&quot;&lt;%&quot;)&#123;            \n            codeType=1;           \n            continue;         \n        &#125;else if(item==&quot;&lt;%=&quot;)&#123;            \n            codeType=2;            \n            continue;         \n        &#125;else if(item==&quot;%&gt;&quot;)&#123;             \n            codeType=0;             \n            continue;         \n       &#125;          //为3类代码片段生成最终可被eval的函数体         \n       if(codeType==0)&#123; //字符             \n           funcBody.push(&quot;result.push(\\&quot;&quot;);             \n           funcBody.push(item);             \n           funcBody.push(&quot;\\&quot;);\\r\\n&quot;);         \n       &#125;else if(codeType==1)&#123; //代码             \n           funcBody.push(item);             \n           funcBody.push(&quot;\\r\\n&quot;);         \n       &#125;else if (codeType==2)&#123; //代码输出             \n           funcBody.push(&quot;result.push(&quot;);             \n           funcBody.push(item);             \n           funcBody.push(&quot;);\\r\\n&quot;);         \n       &#125;     \n   &#125;     \n   funcBody.push(&quot;return result.join(&#39;&#39;)\\r\\n&#125;&quot;);     \n   var template_func=new Function([&quot;renderData&quot;],funcBody.join(&quot;&quot;));     \n   return template_func.apply(data,[data]);  \n&#125;\n</code></pre>\n<p>测试一下</p>\n<pre><code>var html=render(&quot;&lt;% list.forEach(function (item,idx)&#123; %&gt;&quot; +&quot; &lt;div&gt;&lt;%=idx+1+\n&#39;、&#39;+item%&gt;&lt;/div&gt;&quot; +&quot; &lt;%&#125;)%&gt;&quot;, &#123;list:[&quot;javascript&quot;,&quot;css&quot;,&quot;node.js&quot;]&#125;) \ndocument.write(html)\n</code></pre>\n<p>完美运行 <img src=\"http://cdn.v5ant.com/ueditor/images/1125301559559852032.png\" alt=\"WX20190506-153145@2x.png\" title=\"undefined\"> 我们来看一下最终编译后生成的函数是什么样子的，如下图： <img src=\"http://cdn.v5ant.com/ueditor/images/1125301346816364544.png\" alt=\"WX20190506-153048@2x.png\" title=\"undefined\"> 由于生成的函数是用apply调用的，template_inner.apply(data,[data]),所以函数内部的this指向传入的数据源(data变量)，因此可以在模板中直接使用传入的数据源对象</p>\n<h1 id=\"模板引擎与ES6模板字符串对比\"><a href=\"#模板引擎与ES6模板字符串对比\" class=\"headerlink\" title=\"模板引擎与ES6模板字符串对比\"></a>模板引擎与ES6模板字符串对比</h1><p>ES6新增了模板字符串功能，不同于普通字符串的单引号和双引号，模板字符用`符号定义，在模板字符中直接可以通过${变量名}访问当前作用域内的变量并直接输出该变量的值，并且在js文件中定义大段的html字符串时，一般是把html片段粘帖进来，包含很多换行符，而模板字符串可以直接兼容换行符，使用起来非常方便。上文中的模板，用ES6的模板字符串来实现，代码也非常精简，如下：</p>\n<pre><code>var user=&#123;name:&quot;windy&quot;&#125;; \nvar str=`&lt;h2&gt;$&#123;user.name&#125;&lt;/h2&gt;`\n</code></pre>\n<p>ES6模板字符串与普通的模板引擎相比，最大区别在于开发流程的不同，业务逻辑是在js中实现的，模板只实现纯净的变量替换功能，代码与逻辑分离，比较规范易用，可维护也较好，而普通的模板引擎不仅实现了变量替换，还可以内嵌js逻辑代码，更加灵活和强大。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"模板引擎简介\"><a href=\"#模板引擎简介\" class=\"headerlink\" title=\"模板引擎简介\"></a>模板引擎简介</h1><p>模板引擎是html渲染必不可少的工具，前端开发的同学经历了从最原始的字符串拼接、用数组push/join，发展到封装简单的string.format函数，再到功能更加强大的模板引擎，可以在模板中内嵌处理逻辑。 传统的页面开发语言技术asp.net,php,jsp都内置了模板引擎，javascrip常见的模板引擎有jquery的tmpl插件，underscore的template函数，ejs、jade、artTemplate等,以ejs为例，模板语法如下：</p>\n<pre><code>function render(tpl,data)&#123;     \n    tpl=tpl.replace(/(\\r|\\n)/ig,&quot;&quot;);     \n    var arr=tpl.split(/(\\&lt;%=?|%\\&gt;)/gm);//拆分模板     \n    var funcBody=[&quot;with(this)&#123;\\r\\nvar result=[];&quot;];     \n    var item,codeType;     \n    codeType=0;     \n    for(var i=0;i&lt;arr.length;i++)&#123;         \n        item=arr[i];         //将代码片段分为3类         \n        if(item==&quot;&lt;%&quot;)&#123;            \n            codeType=1;           \n            continue;         \n        &#125;else if(item==&quot;&lt;%=&quot;)&#123;            \n            codeType=2;            \n            continue;         \n        &#125;else if(item==&quot;%&gt;&quot;)&#123;             \n            codeType=0;             \n            continue;         \n       &#125;          //为3类代码片段生成最终可被eval的函数体         \n       if(codeType==0)&#123; //字符             \n           funcBody.push(&quot;result.push(\\&quot;&quot;);             \n           funcBody.push(item);             \n           funcBody.push(&quot;\\&quot;);\\r\\n&quot;);         \n       &#125;else if(codeType==1)&#123; //代码             \n           funcBody.push(item);             \n           funcBody.push(&quot;\\r\\n&quot;);         \n       &#125;else if (codeType==2)&#123; //代码输出             \n           funcBody.push(&quot;result.push(&quot;);             \n           funcBody.push(item);             \n           funcBody.push(&quot;);\\r\\n&quot;);         \n       &#125;     \n   &#125;     \n   funcBody.push(&quot;return result.join(&#39;&#39;)\\r\\n&#125;&quot;);     \n   var template_func=new Function([&quot;renderData&quot;],funcBody.join(&quot;&quot;));     \n   return template_func.apply(data,[data]);  \n&#125;\n</code></pre>\n<p>测试一下</p>\n<pre><code>var html=render(&quot;&lt;% list.forEach(function (item,idx)&#123; %&gt;&quot; +&quot; &lt;div&gt;&lt;%=idx+1+\n&#39;、&#39;+item%&gt;&lt;/div&gt;&quot; +&quot; &lt;%&#125;)%&gt;&quot;, &#123;list:[&quot;javascript&quot;,&quot;css&quot;,&quot;node.js&quot;]&#125;) \ndocument.write(html)\n</code></pre>\n<p>完美运行 <img src=\"http://cdn.v5ant.com/ueditor/images/1125301559559852032.png\" alt=\"WX20190506-153145@2x.png\" title=\"undefined\"> 我们来看一下最终编译后生成的函数是什么样子的，如下图： <img src=\"http://cdn.v5ant.com/ueditor/images/1125301346816364544.png\" alt=\"WX20190506-153048@2x.png\" title=\"undefined\"> 由于生成的函数是用apply调用的，template_inner.apply(data,[data]),所以函数内部的this指向传入的数据源(data变量)，因此可以在模板中直接使用传入的数据源对象</p>\n<h1 id=\"模板引擎与ES6模板字符串对比\"><a href=\"#模板引擎与ES6模板字符串对比\" class=\"headerlink\" title=\"模板引擎与ES6模板字符串对比\"></a>模板引擎与ES6模板字符串对比</h1><p>ES6新增了模板字符串功能，不同于普通字符串的单引号和双引号，模板字符用`符号定义，在模板字符中直接可以通过${变量名}访问当前作用域内的变量并直接输出该变量的值，并且在js文件中定义大段的html字符串时，一般是把html片段粘帖进来，包含很多换行符，而模板字符串可以直接兼容换行符，使用起来非常方便。上文中的模板，用ES6的模板字符串来实现，代码也非常精简，如下：</p>\n<pre><code>var user=&#123;name:&quot;windy&quot;&#125;; \nvar str=`&lt;h2&gt;$&#123;user.name&#125;&lt;/h2&gt;`\n</code></pre>\n<p>ES6模板字符串与普通的模板引擎相比，最大区别在于开发流程的不同，业务逻辑是在js中实现的，模板只实现纯净的变量替换功能，代码与逻辑分离，比较规范易用，可维护也较好，而普通的模板引擎不仅实现了变量替换，还可以内嵌js逻辑代码，更加灵活和强大。</p>\n"},{"title":"关于Wordpress主题Vieu以及其他主题侧栏css样式框配置教程","url":"341.html","id":"341","date":"2019-08-29T04:43:27.000Z","_content":"\n目前我用的也是 vieu 主题，后台配置起来比较方便。之前看到有的朋友对下面 👇 这个侧栏样式框感兴趣又不知道该如何添加，今天也就帮大家弄一个简单教程，会技术的绕道 😆 ![](https://www.v5ant.com/wp-content/uploads/2019/08/WX20190829-123259@2x.png)\n\n## 第一步：复制结构代码\n\n下面代码为一条，复制多个即多条自行配置（代码中‘zhan-link-z1’，z1,z2 这些类推对应不同颜色样式） 复制以下代码到主题设置-》小工具-》自定义 HTML，这个小工具添加到需要的页面 <span class=\"zhan-widget-link zhan-link-z1\"> <span class=\"zhan-widget-link-count\">一个低调的个人影院</span> <a href=\"https://imov.vip/\" target=\"_blank\" rel=\"noopener noreferrer\"> <span class=\"zhan-widget-link-title\">蚂蚁影院</span> </a> </span>\n\n## 第二步：复制 css 样式代码\n\n复制以下代码到主题设置-》自定义代码-》自定义 css 样式\n\n.zhan-widget-link {\nposition:relative;\nmargin-bottom:10px;\nposition:relative;\ndisplay:block;\nfont-size:13px;\nbackground:#fff;\ncolor:#525252;\nline-height:40px;\npadding:0 14px;\nborder:1px solid #DDD;\nborder-radius:2px\n}\n.zhan-widget-link-count i {\nmargin-right:9px;\nfont-size:17px;\nvertical-align:middle\n}\n.zhan-widget-link-title {\nposition:absolute;\ntop:-1px;\nright:-1px;\nbottom:-1px;\nwidth:100px;\ntext-align:center;\nbackground:rgba(255,255,255,.08);\ntransition:width .3s;\nborder-radius:0 3px 3px 0\n}\n.zhan-widget-link:hover .zhan-widget-link-title {\nwidth:116px\n}\n.zhan-widget-link a {\nposition:absolute;\ntop:0;\nleft:0;\nright:0;\nbottom:0\n}\n.zhan-link-z1 {\nborder-color:rgba(236,61,81,.39)\n}\n.zhan-link-z1 i {\ncolor:#FFF;\nmargin-right:3px\n}\n.zhan-link-z1 .zhan-widget-link-title {\nbackground-color:#ec3d51;\ncolor:#fff\n}\n.zhan-link-z2 {\nborder-color:rgba(18,170,232,.39)\n}\n.zhan-link-z2 i {\ncolor:#FFF;\nmargin-right:3px\n}\n.zhan-link-z2 .zhan-widget-link-title {\nbackground-color:#12aae8;\ncolor:#fff\n}\n.zhan-link-z3 {\nborder-color:rgba(221,7,208,.39)\n}\n.zhan-link-z3 i {\ncolor:#FFF;\nmargin-right:3px\n}\n.zhan-link-z3 .zhan-widget-link-title {\nbackground-color:#dd07d0;\ncolor:#fff\n}\n.zhan-link-z4 {\nborder-color:rgba(249,82,16,.39)\n}\n.zhan-link-z4 i {\ncolor:#FFF;\nmargin-right:3px\n}\n.zhan-link-z4 .zhan-widget-link-title {\nbackground-color:#f95210;\ncolor:#fff\n}\n.zhan-link-z5 {\nborder-color:rgba(25,152,114,.39)\n}\n.zhan-link-z5 i {\ncolor:#FFF;\nmargin-right:3px\n}\n.zhan-link-z5 .zhan-widget-link-title {\nbackground-color:#199872;\ncolor:#fff\n}\n\n# 搞定！\n\n是不是很简单呢，赶紧搞起来。\n","source":"_posts/e5-85-b3-e4-ba-8ewordpress-e4-b8-bb-e9-a2-98vieu-e4-bb-a5-e5-8f-8a-e5-85-b6-e4-bb-96-e4-b8-bb-e9-a2-98-e4-be-a7-e6-a0-8fcss-e6-a0-b7-e5-bc-8f-e6-a1-86-e9-85-8d-e7-bd-ae-e6-95-99-e7-a8-8b.md","raw":"---\ntitle: 关于Wordpress主题Vieu以及其他主题侧栏css样式框配置教程\nurl: 341.html\nid: 341\ncategories:\n  - 杂谈\ndate: 2019-08-29 12:43:27\ntags:\n---\n\n目前我用的也是 vieu 主题，后台配置起来比较方便。之前看到有的朋友对下面 👇 这个侧栏样式框感兴趣又不知道该如何添加，今天也就帮大家弄一个简单教程，会技术的绕道 😆 ![](https://www.v5ant.com/wp-content/uploads/2019/08/WX20190829-123259@2x.png)\n\n## 第一步：复制结构代码\n\n下面代码为一条，复制多个即多条自行配置（代码中‘zhan-link-z1’，z1,z2 这些类推对应不同颜色样式） 复制以下代码到主题设置-》小工具-》自定义 HTML，这个小工具添加到需要的页面 <span class=\"zhan-widget-link zhan-link-z1\"> <span class=\"zhan-widget-link-count\">一个低调的个人影院</span> <a href=\"https://imov.vip/\" target=\"_blank\" rel=\"noopener noreferrer\"> <span class=\"zhan-widget-link-title\">蚂蚁影院</span> </a> </span>\n\n## 第二步：复制 css 样式代码\n\n复制以下代码到主题设置-》自定义代码-》自定义 css 样式\n\n.zhan-widget-link {\nposition:relative;\nmargin-bottom:10px;\nposition:relative;\ndisplay:block;\nfont-size:13px;\nbackground:#fff;\ncolor:#525252;\nline-height:40px;\npadding:0 14px;\nborder:1px solid #DDD;\nborder-radius:2px\n}\n.zhan-widget-link-count i {\nmargin-right:9px;\nfont-size:17px;\nvertical-align:middle\n}\n.zhan-widget-link-title {\nposition:absolute;\ntop:-1px;\nright:-1px;\nbottom:-1px;\nwidth:100px;\ntext-align:center;\nbackground:rgba(255,255,255,.08);\ntransition:width .3s;\nborder-radius:0 3px 3px 0\n}\n.zhan-widget-link:hover .zhan-widget-link-title {\nwidth:116px\n}\n.zhan-widget-link a {\nposition:absolute;\ntop:0;\nleft:0;\nright:0;\nbottom:0\n}\n.zhan-link-z1 {\nborder-color:rgba(236,61,81,.39)\n}\n.zhan-link-z1 i {\ncolor:#FFF;\nmargin-right:3px\n}\n.zhan-link-z1 .zhan-widget-link-title {\nbackground-color:#ec3d51;\ncolor:#fff\n}\n.zhan-link-z2 {\nborder-color:rgba(18,170,232,.39)\n}\n.zhan-link-z2 i {\ncolor:#FFF;\nmargin-right:3px\n}\n.zhan-link-z2 .zhan-widget-link-title {\nbackground-color:#12aae8;\ncolor:#fff\n}\n.zhan-link-z3 {\nborder-color:rgba(221,7,208,.39)\n}\n.zhan-link-z3 i {\ncolor:#FFF;\nmargin-right:3px\n}\n.zhan-link-z3 .zhan-widget-link-title {\nbackground-color:#dd07d0;\ncolor:#fff\n}\n.zhan-link-z4 {\nborder-color:rgba(249,82,16,.39)\n}\n.zhan-link-z4 i {\ncolor:#FFF;\nmargin-right:3px\n}\n.zhan-link-z4 .zhan-widget-link-title {\nbackground-color:#f95210;\ncolor:#fff\n}\n.zhan-link-z5 {\nborder-color:rgba(25,152,114,.39)\n}\n.zhan-link-z5 i {\ncolor:#FFF;\nmargin-right:3px\n}\n.zhan-link-z5 .zhan-widget-link-title {\nbackground-color:#199872;\ncolor:#fff\n}\n\n# 搞定！\n\n是不是很简单呢，赶紧搞起来。\n","slug":"e5-85-b3-e4-ba-8ewordpress-e4-b8-bb-e9-a2-98vieu-e4-bb-a5-e5-8f-8a-e5-85-b6-e4-bb-96-e4-b8-bb-e9-a2-98-e4-be-a7-e6-a0-8fcss-e6-a0-b7-e5-bc-8f-e6-a1-86-e9-85-8d-e7-bd-ae-e6-95-99-e7-a8-8b","published":1,"updated":"2019-09-11T03:12:39.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269a0000kc8gshj7n1vqn","content":"<p>目前我用的也是 vieu 主题，后台配置起来比较方便。之前看到有的朋友对下面 👇 这个侧栏样式框感兴趣又不知道该如何添加，今天也就帮大家弄一个简单教程，会技术的绕道 😆 <img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/WX20190829-123259@2x.png\"></p>\n<h2 id=\"第一步：复制结构代码\"><a href=\"#第一步：复制结构代码\" class=\"headerlink\" title=\"第一步：复制结构代码\"></a>第一步：复制结构代码</h2><p>下面代码为一条，复制多个即多条自行配置（代码中‘zhan-link-z1’，z1,z2 这些类推对应不同颜色样式） 复制以下代码到主题设置-》小工具-》自定义 HTML，这个小工具添加到需要的页面 <span class=\"zhan-widget-link zhan-link-z1\"> <span class=\"zhan-widget-link-count\">一个低调的个人影院</span> <a href=\"https://imov.vip/\" target=\"_blank\" rel=\"noopener noreferrer\"> <span class=\"zhan-widget-link-title\">蚂蚁影院</span> </a> </span></p>\n<h2 id=\"第二步：复制-css-样式代码\"><a href=\"#第二步：复制-css-样式代码\" class=\"headerlink\" title=\"第二步：复制 css 样式代码\"></a>第二步：复制 css 样式代码</h2><p>复制以下代码到主题设置-》自定义代码-》自定义 css 样式</p>\n<p>.zhan-widget-link {<br>position:relative;<br>margin-bottom:10px;<br>position:relative;<br>display:block;<br>font-size:13px;<br>background:#fff;<br>color:#525252;<br>line-height:40px;<br>padding:0 14px;<br>border:1px solid #DDD;<br>border-radius:2px<br>}<br>.zhan-widget-link-count i {<br>margin-right:9px;<br>font-size:17px;<br>vertical-align:middle<br>}<br>.zhan-widget-link-title {<br>position:absolute;<br>top:-1px;<br>right:-1px;<br>bottom:-1px;<br>width:100px;<br>text-align:center;<br>background:rgba(255,255,255,.08);<br>transition:width .3s;<br>border-radius:0 3px 3px 0<br>}<br>.zhan-widget-link:hover .zhan-widget-link-title {<br>width:116px<br>}<br>.zhan-widget-link a {<br>position:absolute;<br>top:0;<br>left:0;<br>right:0;<br>bottom:0<br>}<br>.zhan-link-z1 {<br>border-color:rgba(236,61,81,.39)<br>}<br>.zhan-link-z1 i {<br>color:#FFF;<br>margin-right:3px<br>}<br>.zhan-link-z1 .zhan-widget-link-title {<br>background-color:#ec3d51;<br>color:#fff<br>}<br>.zhan-link-z2 {<br>border-color:rgba(18,170,232,.39)<br>}<br>.zhan-link-z2 i {<br>color:#FFF;<br>margin-right:3px<br>}<br>.zhan-link-z2 .zhan-widget-link-title {<br>background-color:#12aae8;<br>color:#fff<br>}<br>.zhan-link-z3 {<br>border-color:rgba(221,7,208,.39)<br>}<br>.zhan-link-z3 i {<br>color:#FFF;<br>margin-right:3px<br>}<br>.zhan-link-z3 .zhan-widget-link-title {<br>background-color:#dd07d0;<br>color:#fff<br>}<br>.zhan-link-z4 {<br>border-color:rgba(249,82,16,.39)<br>}<br>.zhan-link-z4 i {<br>color:#FFF;<br>margin-right:3px<br>}<br>.zhan-link-z4 .zhan-widget-link-title {<br>background-color:#f95210;<br>color:#fff<br>}<br>.zhan-link-z5 {<br>border-color:rgba(25,152,114,.39)<br>}<br>.zhan-link-z5 i {<br>color:#FFF;<br>margin-right:3px<br>}<br>.zhan-link-z5 .zhan-widget-link-title {<br>background-color:#199872;<br>color:#fff<br>}</p>\n<h1 id=\"搞定！\"><a href=\"#搞定！\" class=\"headerlink\" title=\"搞定！\"></a>搞定！</h1><p>是不是很简单呢，赶紧搞起来。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>目前我用的也是 vieu 主题，后台配置起来比较方便。之前看到有的朋友对下面 👇 这个侧栏样式框感兴趣又不知道该如何添加，今天也就帮大家弄一个简单教程，会技术的绕道 😆 <img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/WX20190829-123259@2x.png\"></p>\n<h2 id=\"第一步：复制结构代码\"><a href=\"#第一步：复制结构代码\" class=\"headerlink\" title=\"第一步：复制结构代码\"></a>第一步：复制结构代码</h2><p>下面代码为一条，复制多个即多条自行配置（代码中‘zhan-link-z1’，z1,z2 这些类推对应不同颜色样式） 复制以下代码到主题设置-》小工具-》自定义 HTML，这个小工具添加到需要的页面 <span class=\"zhan-widget-link zhan-link-z1\"> <span class=\"zhan-widget-link-count\">一个低调的个人影院</span> <a href=\"https://imov.vip/\" target=\"_blank\" rel=\"noopener noreferrer\"> <span class=\"zhan-widget-link-title\">蚂蚁影院</span> </a> </span></p>\n<h2 id=\"第二步：复制-css-样式代码\"><a href=\"#第二步：复制-css-样式代码\" class=\"headerlink\" title=\"第二步：复制 css 样式代码\"></a>第二步：复制 css 样式代码</h2><p>复制以下代码到主题设置-》自定义代码-》自定义 css 样式</p>\n<p>.zhan-widget-link {<br>position:relative;<br>margin-bottom:10px;<br>position:relative;<br>display:block;<br>font-size:13px;<br>background:#fff;<br>color:#525252;<br>line-height:40px;<br>padding:0 14px;<br>border:1px solid #DDD;<br>border-radius:2px<br>}<br>.zhan-widget-link-count i {<br>margin-right:9px;<br>font-size:17px;<br>vertical-align:middle<br>}<br>.zhan-widget-link-title {<br>position:absolute;<br>top:-1px;<br>right:-1px;<br>bottom:-1px;<br>width:100px;<br>text-align:center;<br>background:rgba(255,255,255,.08);<br>transition:width .3s;<br>border-radius:0 3px 3px 0<br>}<br>.zhan-widget-link:hover .zhan-widget-link-title {<br>width:116px<br>}<br>.zhan-widget-link a {<br>position:absolute;<br>top:0;<br>left:0;<br>right:0;<br>bottom:0<br>}<br>.zhan-link-z1 {<br>border-color:rgba(236,61,81,.39)<br>}<br>.zhan-link-z1 i {<br>color:#FFF;<br>margin-right:3px<br>}<br>.zhan-link-z1 .zhan-widget-link-title {<br>background-color:#ec3d51;<br>color:#fff<br>}<br>.zhan-link-z2 {<br>border-color:rgba(18,170,232,.39)<br>}<br>.zhan-link-z2 i {<br>color:#FFF;<br>margin-right:3px<br>}<br>.zhan-link-z2 .zhan-widget-link-title {<br>background-color:#12aae8;<br>color:#fff<br>}<br>.zhan-link-z3 {<br>border-color:rgba(221,7,208,.39)<br>}<br>.zhan-link-z3 i {<br>color:#FFF;<br>margin-right:3px<br>}<br>.zhan-link-z3 .zhan-widget-link-title {<br>background-color:#dd07d0;<br>color:#fff<br>}<br>.zhan-link-z4 {<br>border-color:rgba(249,82,16,.39)<br>}<br>.zhan-link-z4 i {<br>color:#FFF;<br>margin-right:3px<br>}<br>.zhan-link-z4 .zhan-widget-link-title {<br>background-color:#f95210;<br>color:#fff<br>}<br>.zhan-link-z5 {<br>border-color:rgba(25,152,114,.39)<br>}<br>.zhan-link-z5 i {<br>color:#FFF;<br>margin-right:3px<br>}<br>.zhan-link-z5 .zhan-widget-link-title {<br>background-color:#199872;<br>color:#fff<br>}</p>\n<h1 id=\"搞定！\"><a href=\"#搞定！\" class=\"headerlink\" title=\"搞定！\"></a>搞定！</h1><p>是不是很简单呢，赶紧搞起来。</p>\n"},{"title":"分享一下Sass处理的更高级媒体查询","url":"133.html","id":"133","date":"2019-06-22T08:49:13.000Z","_content":"\n普通css中使用@media 去处理响应式网站开发估计大部分人都遇到过，但是在css预处理如此流行的今天，我们应该学会更敏捷的开发模式，更好的让他们发挥最大的效率。响应式开发大同小异但是具体处理方案还是很多的，这里我分享一个比较规范，用起来也比较舒服的scss处理的媒体查询方案。 具体方案大概是这样： **先定义一些断点（也就是我们要界别的设备尺寸）**\n\n    // _config.scss\n    $breakpoints: (\n      'xs': 'only screen and ( min-width: 480px)',\n      'sm': 'only screen and ( min-width: 768px)',\n      'md': 'only screen and ( min-width: 992px)',\n      'lg': 'only screen and ( min-width: 1200px)',\n    ) !default;\n\n**然后定义mixin:**\n\n    // _mixins.scss\n    @mixin respond-to($breakpoint) {\n      $query: map-get($breakpoints, $breakpoint);\n      // 这里是scss error提示估计大部分人（包括我）都没怎么使用过\n      @if not $query {\n        @error 'No value found for `#{$breakpoint}`. Please make sure it is \n        defined in `$breakpoints` map.';\n      }\n       // 具体断点解释在这里，作者比较严谨，校验了$query合法性\n      @media #{if(type-of($query) == 'string', unquote($query), inspect($query))}\n       {\n        @content;\n      }\n    }\n\n这里解释一些出现的一些scss函数 字符串函数顾名思意是用来处理字符串的函数。Sass 的字符串函数主要包括两个函数：\n\n    unquote($query)：删除字符串中的引号；\n    quote($query)：给字符串添加引号。\n    inspect($query) Maps不能转换为纯CSS。作为变量的值或参数传递给CSS函数将会导致错误。\n                    使用inspect($query) 函数以产生输出字符串\n\n**使用的时候这样写：**\n\n    // _component.scss\n    .element {\n      color: #000;\n    \n      @include respond-to(sm) {\n        color: #333;\n      }\n    }\n\n最后编译完成输出结构是\n\n    .element {\n      color: #000;\n    }\n    \n    @media (min-width: 768px) {\n      .element {\n        color: #333;\n      }\n    }\n\n这样当需求更改，导致媒体查询数值变化的时候，我们只需要改$breakpoints中的值，而不必查找、替换。并且使用@include可以使我们的代码维护容易。 那么如果我需要定义移动端retina屏幕使用二倍的背景图，需要怎么做？ 新增加一个断点，然后使用即可。\n\n    $breakpoints: (\n      ...\n      'xs-retina'  : ( max-width: 768px) and (-webkit-min-device-pixel-ratio: 2),\n    );\n\n**这时候就出现小问题了，如果页面很复杂，需要新增很多断点，那么可能会出现组合爆炸，造成$brekpoints的子项很多很多，除了会影响sass编译速度之外，维护起来也会更加麻烦。** **Sass媒体查询应该是这样**\n\n*   动态，可定义，可以随意增加断点\n*   简洁，自然的语法，可以使用 <=,>=, >,< 符号（←_←）比如`@include media(\">minWidth\")`\n*   可以自由组合，临时定义断点，可以组合多个断点，也可以临时自定义断点，比如`@include media(\">tablet\", \"<1280px\")`\n\n![sass-media.gif](http://cdn.v5ant.com/ueditor/images/1126462661136093184.gif) 如果你觉得感兴趣，可以尝试下Eduardo Bouças和Hugo Giraudel的开源作品[@include-media](http://include-media.com/) 原文地址：https://www.w3ctrain.com/2015/12/02/sass-media-query/","source":"_posts/e5-88-86-e4-ba-ab-e4-b8-80-e4-b8-8bsass-e5-a4-84-e7-90-86-e7-9a-84-e6-9b-b4-e9-ab-98-e7-ba-a7-e5-aa-92-e4-bd-93-e6-9f-a5-e8-af-a2.md","raw":"---\ntitle: 分享一下Sass处理的更高级媒体查询\ntags:\n  - scss\nurl: 133.html\nid: 133\ncategories:\n  - 大前端\ndate: 2019-06-22 16:49:13\n---\n\n普通css中使用@media 去处理响应式网站开发估计大部分人都遇到过，但是在css预处理如此流行的今天，我们应该学会更敏捷的开发模式，更好的让他们发挥最大的效率。响应式开发大同小异但是具体处理方案还是很多的，这里我分享一个比较规范，用起来也比较舒服的scss处理的媒体查询方案。 具体方案大概是这样： **先定义一些断点（也就是我们要界别的设备尺寸）**\n\n    // _config.scss\n    $breakpoints: (\n      'xs': 'only screen and ( min-width: 480px)',\n      'sm': 'only screen and ( min-width: 768px)',\n      'md': 'only screen and ( min-width: 992px)',\n      'lg': 'only screen and ( min-width: 1200px)',\n    ) !default;\n\n**然后定义mixin:**\n\n    // _mixins.scss\n    @mixin respond-to($breakpoint) {\n      $query: map-get($breakpoints, $breakpoint);\n      // 这里是scss error提示估计大部分人（包括我）都没怎么使用过\n      @if not $query {\n        @error 'No value found for `#{$breakpoint}`. Please make sure it is \n        defined in `$breakpoints` map.';\n      }\n       // 具体断点解释在这里，作者比较严谨，校验了$query合法性\n      @media #{if(type-of($query) == 'string', unquote($query), inspect($query))}\n       {\n        @content;\n      }\n    }\n\n这里解释一些出现的一些scss函数 字符串函数顾名思意是用来处理字符串的函数。Sass 的字符串函数主要包括两个函数：\n\n    unquote($query)：删除字符串中的引号；\n    quote($query)：给字符串添加引号。\n    inspect($query) Maps不能转换为纯CSS。作为变量的值或参数传递给CSS函数将会导致错误。\n                    使用inspect($query) 函数以产生输出字符串\n\n**使用的时候这样写：**\n\n    // _component.scss\n    .element {\n      color: #000;\n    \n      @include respond-to(sm) {\n        color: #333;\n      }\n    }\n\n最后编译完成输出结构是\n\n    .element {\n      color: #000;\n    }\n    \n    @media (min-width: 768px) {\n      .element {\n        color: #333;\n      }\n    }\n\n这样当需求更改，导致媒体查询数值变化的时候，我们只需要改$breakpoints中的值，而不必查找、替换。并且使用@include可以使我们的代码维护容易。 那么如果我需要定义移动端retina屏幕使用二倍的背景图，需要怎么做？ 新增加一个断点，然后使用即可。\n\n    $breakpoints: (\n      ...\n      'xs-retina'  : ( max-width: 768px) and (-webkit-min-device-pixel-ratio: 2),\n    );\n\n**这时候就出现小问题了，如果页面很复杂，需要新增很多断点，那么可能会出现组合爆炸，造成$brekpoints的子项很多很多，除了会影响sass编译速度之外，维护起来也会更加麻烦。** **Sass媒体查询应该是这样**\n\n*   动态，可定义，可以随意增加断点\n*   简洁，自然的语法，可以使用 <=,>=, >,< 符号（←_←）比如`@include media(\">minWidth\")`\n*   可以自由组合，临时定义断点，可以组合多个断点，也可以临时自定义断点，比如`@include media(\">tablet\", \"<1280px\")`\n\n![sass-media.gif](http://cdn.v5ant.com/ueditor/images/1126462661136093184.gif) 如果你觉得感兴趣，可以尝试下Eduardo Bouças和Hugo Giraudel的开源作品[@include-media](http://include-media.com/) 原文地址：https://www.w3ctrain.com/2015/12/02/sass-media-query/","slug":"e5-88-86-e4-ba-ab-e4-b8-80-e4-b8-8bsass-e5-a4-84-e7-90-86-e7-9a-84-e6-9b-b4-e9-ab-98-e7-ba-a7-e5-aa-92-e4-bd-93-e6-9f-a5-e8-af-a2","published":1,"updated":"2019-09-10T07:46:08.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269a2000nc8gsb44m7eib","content":"<p>普通css中使用@media 去处理响应式网站开发估计大部分人都遇到过，但是在css预处理如此流行的今天，我们应该学会更敏捷的开发模式，更好的让他们发挥最大的效率。响应式开发大同小异但是具体处理方案还是很多的，这里我分享一个比较规范，用起来也比较舒服的scss处理的媒体查询方案。 具体方案大概是这样： <strong>先定义一些断点（也就是我们要界别的设备尺寸）</strong></p>\n<pre><code>// _config.scss\n$breakpoints: (\n  &#39;xs&#39;: &#39;only screen and ( min-width: 480px)&#39;,\n  &#39;sm&#39;: &#39;only screen and ( min-width: 768px)&#39;,\n  &#39;md&#39;: &#39;only screen and ( min-width: 992px)&#39;,\n  &#39;lg&#39;: &#39;only screen and ( min-width: 1200px)&#39;,\n) !default;\n</code></pre>\n<p><strong>然后定义mixin:</strong></p>\n<pre><code>// _mixins.scss\n@mixin respond-to($breakpoint) &#123;\n  $query: map-get($breakpoints, $breakpoint);\n  // 这里是scss error提示估计大部分人（包括我）都没怎么使用过\n  @if not $query &#123;\n    @error &#39;No value found for `#&#123;$breakpoint&#125;`. Please make sure it is \n    defined in `$breakpoints` map.&#39;;\n  &#125;\n   // 具体断点解释在这里，作者比较严谨，校验了$query合法性\n  @media #&#123;if(type-of($query) == &#39;string&#39;, unquote($query), inspect($query))&#125;\n   &#123;\n    @content;\n  &#125;\n&#125;\n</code></pre>\n<p>这里解释一些出现的一些scss函数 字符串函数顾名思意是用来处理字符串的函数。Sass 的字符串函数主要包括两个函数：</p>\n<pre><code>unquote($query)：删除字符串中的引号；\nquote($query)：给字符串添加引号。\ninspect($query) Maps不能转换为纯CSS。作为变量的值或参数传递给CSS函数将会导致错误。\n                使用inspect($query) 函数以产生输出字符串\n</code></pre>\n<p><strong>使用的时候这样写：</strong></p>\n<pre><code>// _component.scss\n.element &#123;\n  color: #000;\n\n  @include respond-to(sm) &#123;\n    color: #333;\n  &#125;\n&#125;\n</code></pre>\n<p>最后编译完成输出结构是</p>\n<pre><code>.element &#123;\n  color: #000;\n&#125;\n\n@media (min-width: 768px) &#123;\n  .element &#123;\n    color: #333;\n  &#125;\n&#125;\n</code></pre>\n<p>这样当需求更改，导致媒体查询数值变化的时候，我们只需要改$breakpoints中的值，而不必查找、替换。并且使用@include可以使我们的代码维护容易。 那么如果我需要定义移动端retina屏幕使用二倍的背景图，需要怎么做？ 新增加一个断点，然后使用即可。</p>\n<pre><code>$breakpoints: (\n  ...\n  &#39;xs-retina&#39;  : ( max-width: 768px) and (-webkit-min-device-pixel-ratio: 2),\n);\n</code></pre>\n<p><strong>这时候就出现小问题了，如果页面很复杂，需要新增很多断点，那么可能会出现组合爆炸，造成$brekpoints的子项很多很多，除了会影响sass编译速度之外，维护起来也会更加麻烦。</strong> <strong>Sass媒体查询应该是这样</strong></p>\n<ul>\n<li>  动态，可定义，可以随意增加断点</li>\n<li>  简洁，自然的语法，可以使用 &lt;=,&gt;=, &gt;,&lt; 符号（←_←）比如<code>@include media(&quot;&gt;minWidth&quot;)</code></li>\n<li>  可以自由组合，临时定义断点，可以组合多个断点，也可以临时自定义断点，比如<code>@include media(&quot;&gt;tablet&quot;, &quot;&lt;1280px&quot;)</code></li>\n</ul>\n<p><img src=\"http://cdn.v5ant.com/ueditor/images/1126462661136093184.gif\" alt=\"sass-media.gif\"> 如果你觉得感兴趣，可以尝试下Eduardo Bouças和Hugo Giraudel的开源作品<a href=\"http://include-media.com/\">@include-media</a> 原文地址：<a href=\"https://www.w3ctrain.com/2015/12/02/sass-media-query/\">https://www.w3ctrain.com/2015/12/02/sass-media-query/</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>普通css中使用@media 去处理响应式网站开发估计大部分人都遇到过，但是在css预处理如此流行的今天，我们应该学会更敏捷的开发模式，更好的让他们发挥最大的效率。响应式开发大同小异但是具体处理方案还是很多的，这里我分享一个比较规范，用起来也比较舒服的scss处理的媒体查询方案。 具体方案大概是这样： <strong>先定义一些断点（也就是我们要界别的设备尺寸）</strong></p>\n<pre><code>// _config.scss\n$breakpoints: (\n  &#39;xs&#39;: &#39;only screen and ( min-width: 480px)&#39;,\n  &#39;sm&#39;: &#39;only screen and ( min-width: 768px)&#39;,\n  &#39;md&#39;: &#39;only screen and ( min-width: 992px)&#39;,\n  &#39;lg&#39;: &#39;only screen and ( min-width: 1200px)&#39;,\n) !default;\n</code></pre>\n<p><strong>然后定义mixin:</strong></p>\n<pre><code>// _mixins.scss\n@mixin respond-to($breakpoint) &#123;\n  $query: map-get($breakpoints, $breakpoint);\n  // 这里是scss error提示估计大部分人（包括我）都没怎么使用过\n  @if not $query &#123;\n    @error &#39;No value found for `#&#123;$breakpoint&#125;`. Please make sure it is \n    defined in `$breakpoints` map.&#39;;\n  &#125;\n   // 具体断点解释在这里，作者比较严谨，校验了$query合法性\n  @media #&#123;if(type-of($query) == &#39;string&#39;, unquote($query), inspect($query))&#125;\n   &#123;\n    @content;\n  &#125;\n&#125;\n</code></pre>\n<p>这里解释一些出现的一些scss函数 字符串函数顾名思意是用来处理字符串的函数。Sass 的字符串函数主要包括两个函数：</p>\n<pre><code>unquote($query)：删除字符串中的引号；\nquote($query)：给字符串添加引号。\ninspect($query) Maps不能转换为纯CSS。作为变量的值或参数传递给CSS函数将会导致错误。\n                使用inspect($query) 函数以产生输出字符串\n</code></pre>\n<p><strong>使用的时候这样写：</strong></p>\n<pre><code>// _component.scss\n.element &#123;\n  color: #000;\n\n  @include respond-to(sm) &#123;\n    color: #333;\n  &#125;\n&#125;\n</code></pre>\n<p>最后编译完成输出结构是</p>\n<pre><code>.element &#123;\n  color: #000;\n&#125;\n\n@media (min-width: 768px) &#123;\n  .element &#123;\n    color: #333;\n  &#125;\n&#125;\n</code></pre>\n<p>这样当需求更改，导致媒体查询数值变化的时候，我们只需要改$breakpoints中的值，而不必查找、替换。并且使用@include可以使我们的代码维护容易。 那么如果我需要定义移动端retina屏幕使用二倍的背景图，需要怎么做？ 新增加一个断点，然后使用即可。</p>\n<pre><code>$breakpoints: (\n  ...\n  &#39;xs-retina&#39;  : ( max-width: 768px) and (-webkit-min-device-pixel-ratio: 2),\n);\n</code></pre>\n<p><strong>这时候就出现小问题了，如果页面很复杂，需要新增很多断点，那么可能会出现组合爆炸，造成$brekpoints的子项很多很多，除了会影响sass编译速度之外，维护起来也会更加麻烦。</strong> <strong>Sass媒体查询应该是这样</strong></p>\n<ul>\n<li>  动态，可定义，可以随意增加断点</li>\n<li>  简洁，自然的语法，可以使用 &lt;=,&gt;=, &gt;,&lt; 符号（←_←）比如<code>@include media(&quot;&gt;minWidth&quot;)</code></li>\n<li>  可以自由组合，临时定义断点，可以组合多个断点，也可以临时自定义断点，比如<code>@include media(&quot;&gt;tablet&quot;, &quot;&lt;1280px&quot;)</code></li>\n</ul>\n<p><img src=\"http://cdn.v5ant.com/ueditor/images/1126462661136093184.gif\" alt=\"sass-media.gif\"> 如果你觉得感兴趣，可以尝试下Eduardo Bouças和Hugo Giraudel的开源作品<a href=\"http://include-media.com/\">@include-media</a> 原文地址：<a href=\"https://www.w3ctrain.com/2015/12/02/sass-media-query/\">https://www.w3ctrain.com/2015/12/02/sass-media-query/</a></p>\n"},{"title":"分享网络小游戏合集-星益手机电脑小游戏平台网页源码","url":"392.html","id":"392","date":"2019-09-02T08:23:03.000Z","_content":"\n![](https://img.viapi.cn/wp/uploads/2019/08/6dfe1565324369.png)\n\n<!-- more -->\n\n![](https://img.viapi.cn/wp/uploads/2019/08/9dfb1565324242.png)\n\n## 简要介绍：\n\n本程序由小星合集整理制作，共计 80 个小游戏，本程序大部分都是自适应，但是使用电脑端体验更佳。\n\n## 安装教程：\n\n上传到根目录即可使用，访问域名。\n","source":"_posts/e5-88-86-e4-ba-ab-e7-bd-91-e7-bb-9c-e5-b0-8f-e6-b8-b8-e6-88-8f-e5-90-88-e9-9b-86-e6-98-9f-e7-9b-8a-e6-89-8b-e6-9c-ba-e7-94-b5-e8-84-91-e5-b0-8f-e6-b8-b8-e6-88-8f-e5-b9-b3-e5-8f-b0-e7-bd-91-e9-a1-b5.md","raw":"---\ntitle: 分享网络小游戏合集-星益手机电脑小游戏平台网页源码\ntags:\n  - 小游戏\n  - 源码\nurl: 392.html\nid: 392\ncategories:\n  - 精选资源\ndate: 2019-09-02 16:23:03\n---\n\n![](https://img.viapi.cn/wp/uploads/2019/08/6dfe1565324369.png)\n\n<!-- more -->\n\n![](https://img.viapi.cn/wp/uploads/2019/08/9dfb1565324242.png)\n\n## 简要介绍：\n\n本程序由小星合集整理制作，共计 80 个小游戏，本程序大部分都是自适应，但是使用电脑端体验更佳。\n\n## 安装教程：\n\n上传到根目录即可使用，访问域名。\n","slug":"e5-88-86-e4-ba-ab-e7-bd-91-e7-bb-9c-e5-b0-8f-e6-b8-b8-e6-88-8f-e5-90-88-e9-9b-86-e6-98-9f-e7-9b-8a-e6-89-8b-e6-9c-ba-e7-94-b5-e8-84-91-e5-b0-8f-e6-b8-b8-e6-88-8f-e5-b9-b3-e5-8f-b0-e7-bd-91-e9-a1-b5","published":1,"updated":"2019-09-11T08:46:33.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269a3000pc8gs63qh1hej","content":"<p><img src=\"https://img.viapi.cn/wp/uploads/2019/08/6dfe1565324369.png\"></p>\n<span id=\"more\"></span>\n\n<p><img src=\"https://img.viapi.cn/wp/uploads/2019/08/9dfb1565324242.png\"></p>\n<h2 id=\"简要介绍：\"><a href=\"#简要介绍：\" class=\"headerlink\" title=\"简要介绍：\"></a>简要介绍：</h2><p>本程序由小星合集整理制作，共计 80 个小游戏，本程序大部分都是自适应，但是使用电脑端体验更佳。</p>\n<h2 id=\"安装教程：\"><a href=\"#安装教程：\" class=\"headerlink\" title=\"安装教程：\"></a>安装教程：</h2><p>上传到根目录即可使用，访问域名。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<p><img src=\"https://img.viapi.cn/wp/uploads/2019/08/6dfe1565324369.png\"></p>","more":"<p><img src=\"https://img.viapi.cn/wp/uploads/2019/08/9dfb1565324242.png\"></p>\n<h2 id=\"简要介绍：\"><a href=\"#简要介绍：\" class=\"headerlink\" title=\"简要介绍：\"></a>简要介绍：</h2><p>本程序由小星合集整理制作，共计 80 个小游戏，本程序大部分都是自适应，但是使用电脑端体验更佳。</p>\n<h2 id=\"安装教程：\"><a href=\"#安装教程：\" class=\"headerlink\" title=\"安装教程：\"></a>安装教程：</h2><p>上传到根目录即可使用，访问域名。</p>"},{"title":"分析微信公众号-LocalStorage 缓存机制","url":"254.html","id":"254","date":"2019-07-12T11:55:42.000Z","_content":"\n微信公众号的阅读体验非常流畅，作为一名程序员很好奇他具体实现套路是什么，相比于我们常规开发用了什么黑科技？ 于是下意识的打开浏览器控制台一探究 奇怪！Network里面没有发起任何请求，那文章数据哪里来呢？\n\n假设：服务端渲染机制\n----------\n\n通过请求得到的HTML文件发现并不是，只拿到了标题，很显然这个假设否定❌ 继续查找发现js文件都没有返回，那么就只肯定是本地localStorage 我这菜鸟也暂时想不到其他的可能了， 看到 Local Storage 里密密麻麻的 js 文件,我就放心了这确实也是一种前端加载优化策略。\n\n通过网上的相关文章和本地分析，梳理一下大概实现的方案\n--------------------------\n\n \n\n### 缓存更新机制\n\n项目在迭代开发的过程中，难以避免需要更新资源文件，常用的方法有`文件名${md5}.js`或者在资源 url 后面加上特定后缀的方式 etc.，而在微信做法中以 _\\_\\_MOON\\_\\_pages/report.js_ 为例，其版本信息使用 key 为 _\\_\\_MOON\\_\\_pages/report.js_ver_ 的存储项保存：\n\n`__MOON__pages/report.js_ver: //res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/report3b8dd6.js`\n\n我们不直接使用这个 value 动态插入 script 节点来加载该文件，而是根据后端提供的配置信息，判断是选择使用缓存的 _\\_\\_MOON\\_\\_pages/report.js_ 文件，还是重新发起加载请求。\n\n### 搭建更新代码的脚手架\n\n（加载 combo 化）使用基于 localStorage 的缓存机制，就需要一个脚手架来管理资源文件的读取和写入，不难看出微信使用的是自己开发的脚手架 _moon.js_，阅读其源码代价较大，暂不分析。\n\n### 资源配置信息\n\n前端在进行资源更新时需要后端提供一份依据供前端用于判断哪些资源需要更新，并且脚手架 moon.js 需要该资源配置信息才能正常工作，所以配置信息一定要在 moon.js 的 script 标签前输出：\n\n`window.moon_map = {\"new_video/player.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/player.html3b8dd6.js\",\"biz_wap/zepto/touch.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/touch34c264.js\",\"biz_wap/zepto/event.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/event34c264.js\",\"biz_wap/zepto/zepto.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/zepto34c264.js\",\"page/pages/video.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/pages/video.css3b8dd6.js\",\"a/appdialog_confirm.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/appdialog_confirm.html34f0d8.js\",\"widget/wx_profile_dialog_primary.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/widget/wx_profile_dialog_primary.css34f0d8.js\",\"appmsg/emotion/caret.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/caret278965.js\",\"new_video/player.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/player3b8ecd.js\",\"a/appdialog_confirm.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/appdialog_confirm34c32a.js\",\"biz_wap/jsapi/cardticket.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/jsapi/cardticket34c264.js\",\"biz_common/utils/emoji_panel_data.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/emoji_panel_data3518c6.js\",\"biz_common/utils/emoji_data.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/emoji_data3518c6.js\",\"appmsg/emotion/textarea.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/textarea353f34.js\",\"appmsg/emotion/nav.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/nav278965.js\",\"appmsg/emotion/common.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/common3518c6.js\",\"appmsg/emotion/slide.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/slide2a9cd9.js\",\"pages/loadscript.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/loadscript39aac6.js\",\"pages/music_report_conf.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/music_report_conf39aac6.js\",\"pages/report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/report3b8dd6.js\",\"pages/player_adaptor.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/player_adaptor39d6ee.js\",\"pages/music_player.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/music_player3af14e.js\",\"appmsg/emotion/dom.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/dom31ff31.js\",\"appmsg/comment_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/comment_tpl.html36c376.js\",\"biz_wap/utils/fakehash.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/fakehash38c7af.js\",\"biz_common/utils/wxgspeedsdk.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/wxgspeedsdk3518c6.js\",\"a/video.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/video3b8ecd.js\",\"a/sponsor.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/sponsor3b86a9.js\",\"a/app_card.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/app_card393ef4.js\",\"a/ios.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/ios393966.js\",\"a/android.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/android393966.js\",\"a/profile.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/profile31ff31.js\",\"a/cpc_a_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/cpc_a_tpl.html3b540a.js\",\"a/sponsor_a_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/sponsor_a_tpl.html36c7cf.js\",\"a/a_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a_tpl.html3b86a9.js\",\"a/mpshop.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/mpshop311179.js\",\"a/wxopen_card.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/wxopen_card3a95b8.js\",\"a/card.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/card311179.js\",\"biz_wap/utils/position.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/position34c264.js\",\"a/a_report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a_report393966.js\",\"appmsg/my_comment_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/my_comment_tpl.html36906d.js\",\"appmsg/cmt_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cmt_tpl.html369d00.js\",\"sougou/a_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/sougou/a_tpl.html2c6e7c.js\",\"appmsg/emotion/emotion.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/emotion353f34.js\",\"biz_wap/utils/wapsdk.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/wapsdk34c264.js\",\"biz_common/utils/report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/report3518c6.js\",\"appmsg/open_url_with_webview.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/open_url_with_webview3145f0.js\",\"biz_common/utils/http.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/http3518c6.js\",\"biz_common/utils/cookie.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/cookie3518c6.js\",\"appmsg/topic_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/topic_tpl.html31ff31.js\",\"pages/weapp_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/weapp_tpl.html36906d.js\",\"biz_common/utils/monitor.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/monitor3518c6.js\",\"appmsg/weapp_common.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weapp_common3af55a.js\",\"pages/voice_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/voice_tpl.html38518d.js\",\"pages/kugoumusic_ctrl.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/kugoumusic_ctrl393e3a.js\",\"pages/qqmusic_ctrl.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/qqmusic_ctrl39b68c.js\",\"pages/voice_component.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/voice_component3af14e.js\",\"pages/qqmusic_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/qqmusic_tpl.html393e3a.js\",\"new_video/ctl.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/ctl2d441f.js\",\"a/testdata.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/testdata3b86a9.js\",\"appmsg/reward_entry.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/reward_entry3b1cff.js\",\"appmsg/comment.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/comment3944ad.js\",\"appmsg/like.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/like375fea.js\",\"pages/version4video.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/version4video3a9bef.js\",\"a/a.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a3b8ecd.js\",\"rt/appmsg/getappmsgext.rt.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/rt/appmsg/getappmsgext.rt2c21f6.js\",\"biz_wap/utils/storage.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/storage34c264.js\",\"biz_common/tmpl.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/tmpl3518c6.js\",\"appmsg/share_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/share_tpl.html36906d.js\",\"appmsg/img_copyright_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/img_copyright_tpl.html2a2c13.js\",\"pages/video_ctrl.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/video_ctrl36ebcf.js\",\"biz_common/ui/imgonepx.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/ui/imgonepx3518c6.js\",\"biz_common/utils/respTypes.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/respTypes3518c6.js\",\"biz_wap/utils/log.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/log34c264.js\",\"sougou/index.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/sougou/index36913b.js\",\"biz_wap/safe/mutation_observer_report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/safe/mutation_observer_report34c264.js\",\"appmsg/fereport.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/fereport3b9457.js\",\"appmsg/report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/report3404b3.js\",\"appmsg/report_and_source.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/report_and_source3a7477.js\",\"appmsg/page_pos.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/page_pos3a95b8.js\",\"appmsg/cdn_speed_report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cdn_speed_report3097b2.js\",\"appmsg/wxtopic.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/wxtopic31a3be.js\",\"appmsg/new_index.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/new_index36906d.js\",\"appmsg/weapp.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weapp3af55a.js\",\"appmsg/weproduct.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weproduct3af55a.js\",\"appmsg/voicemsg.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/voicemsg3b1748.js\",\"appmsg/autoread.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/autoread3af14e.js\",\"appmsg/voice.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/voice38518d.js\",\"appmsg/qqmusic.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/qqmusic39dc43.js\",\"appmsg/iframe.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/iframe39ab71.js\",\"appmsg/product.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/product393966.js\",\"appmsg/review_image.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/review_image3af55a.js\",\"appmsg/outer_link.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/outer_link275627.js\",\"appmsg/copyright_report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/copyright_report2ec4b2.js\",\"appmsg/async.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/async3b27d5.js\",\"biz_wap/ui/lazyload_img.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/ui/lazyload_img3af55a.js\",\"biz_common/log/jserr.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/log/jserr3518c6.js\",\"appmsg/share.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/share3b4418.js\",\"appmsg/cdn_img_lib.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cdn_img_lib38b7bb.js\",\"biz_common/utils/url/parse.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/url/parse36ebcf.js\",\"page/appmsg/not_in_mm.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg/not_in_mm.css36906d.js\",\"page/appmsg/page_mp_article_improve_combo.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg/page_mp_article_improve_combo.css3b86a9.js\",\"page/appmsg_new/not_in_mm.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg_new/not_in_mm.css36f05c.js\",\"page/appmsg_new/combo.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg_new/combo.css3b86a9.js\",\"biz_wap/jsapi/core.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/jsapi/core3b0568.js\",\"biz_common/dom/event.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/event3a25e9.js\",\"appmsg/test.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/test354009.js\",\"biz_wap/utils/mmversion.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/mmversion34c264.js\",\"appmsg/max_age.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/max_age2fdd28.js\",\"biz_common/dom/attr.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/attr3518c6.js\",\"biz_wap/utils/ajax.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/ajax38c31a.js\",\"appmsg/log.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/log300330.js\",\"biz_common/dom/class.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/class3518c6.js\",\"biz_wap/utils/device.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/device34c264.js\",\"biz_common/utils/string/html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/string/html3518c6.js\",\"appmsg/index.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/index3b1748.js\"};`\n\n### 存在 XSS 安全隐患\n\n在 _\\_\\_MOON\\_\\_pages/report.js_ 文件的入口处加入代码 _alert('Helo World');_ 刷新页面后弹出提示 “Hello World”，说明使用基于 localStorage 的缓存机制存在一些安全隐患，并且微信尚未对这些攻击漏洞进行处理。\n\n关于使用 localStorage 进行资源缓存其他思考\n----------------------------\n\n1.  如果先输出 html 然后用 js 从本地缓存读取样式再插入会出现严重的阻塞和闪烁问题\n2.  这种解决方案更加适合单页面应用否则容易产生冗余\n3.  存在浏览器兼容性问题（隐身模式 etc.）（微信具有自己的X5内核完美解决该问题）\n4.  网络速度快，协商缓存的响应延迟可能比 _LS读取+eval_ 更小\n5.  浏览器对于单次 set 和对 LS（本质是 SQL lite）的总容量存在限制\n6.  可以节省流量，并且可以用于 A/B test\n7.  移动端的浏览器缓存经常会被清理且网络状态通常较差，更加适合这种解决方案\n\n  大概就是这么个意思，不过要快速构建到已有的项目中还没仔细考虑，后面再讨论。 https://github.com/mtjs/mt  （腾讯开源专注于移动端的、带有增量更新特色的js模块管理框架）","source":"_posts/e5-88-86-e6-9e-90-e5-be-ae-e4-bf-a1-e5-85-ac-e4-bc-97-e5-8f-b7-localstorage-e7-bc-93-e5-ad-98-e6-9c-ba-e5-88-b6.md","raw":"---\ntitle: 分析微信公众号-LocalStorage 缓存机制\nurl: 254.html\nid: 254\ncategories:\n  - 大前端\ndate: 2019-07-12 19:55:42\ntags:\n---\n\n微信公众号的阅读体验非常流畅，作为一名程序员很好奇他具体实现套路是什么，相比于我们常规开发用了什么黑科技？ 于是下意识的打开浏览器控制台一探究 奇怪！Network里面没有发起任何请求，那文章数据哪里来呢？\n\n假设：服务端渲染机制\n----------\n\n通过请求得到的HTML文件发现并不是，只拿到了标题，很显然这个假设否定❌ 继续查找发现js文件都没有返回，那么就只肯定是本地localStorage 我这菜鸟也暂时想不到其他的可能了， 看到 Local Storage 里密密麻麻的 js 文件,我就放心了这确实也是一种前端加载优化策略。\n\n通过网上的相关文章和本地分析，梳理一下大概实现的方案\n--------------------------\n\n \n\n### 缓存更新机制\n\n项目在迭代开发的过程中，难以避免需要更新资源文件，常用的方法有`文件名${md5}.js`或者在资源 url 后面加上特定后缀的方式 etc.，而在微信做法中以 _\\_\\_MOON\\_\\_pages/report.js_ 为例，其版本信息使用 key 为 _\\_\\_MOON\\_\\_pages/report.js_ver_ 的存储项保存：\n\n`__MOON__pages/report.js_ver: //res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/report3b8dd6.js`\n\n我们不直接使用这个 value 动态插入 script 节点来加载该文件，而是根据后端提供的配置信息，判断是选择使用缓存的 _\\_\\_MOON\\_\\_pages/report.js_ 文件，还是重新发起加载请求。\n\n### 搭建更新代码的脚手架\n\n（加载 combo 化）使用基于 localStorage 的缓存机制，就需要一个脚手架来管理资源文件的读取和写入，不难看出微信使用的是自己开发的脚手架 _moon.js_，阅读其源码代价较大，暂不分析。\n\n### 资源配置信息\n\n前端在进行资源更新时需要后端提供一份依据供前端用于判断哪些资源需要更新，并且脚手架 moon.js 需要该资源配置信息才能正常工作，所以配置信息一定要在 moon.js 的 script 标签前输出：\n\n`window.moon_map = {\"new_video/player.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/player.html3b8dd6.js\",\"biz_wap/zepto/touch.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/touch34c264.js\",\"biz_wap/zepto/event.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/event34c264.js\",\"biz_wap/zepto/zepto.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/zepto34c264.js\",\"page/pages/video.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/pages/video.css3b8dd6.js\",\"a/appdialog_confirm.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/appdialog_confirm.html34f0d8.js\",\"widget/wx_profile_dialog_primary.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/widget/wx_profile_dialog_primary.css34f0d8.js\",\"appmsg/emotion/caret.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/caret278965.js\",\"new_video/player.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/player3b8ecd.js\",\"a/appdialog_confirm.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/appdialog_confirm34c32a.js\",\"biz_wap/jsapi/cardticket.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/jsapi/cardticket34c264.js\",\"biz_common/utils/emoji_panel_data.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/emoji_panel_data3518c6.js\",\"biz_common/utils/emoji_data.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/emoji_data3518c6.js\",\"appmsg/emotion/textarea.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/textarea353f34.js\",\"appmsg/emotion/nav.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/nav278965.js\",\"appmsg/emotion/common.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/common3518c6.js\",\"appmsg/emotion/slide.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/slide2a9cd9.js\",\"pages/loadscript.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/loadscript39aac6.js\",\"pages/music_report_conf.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/music_report_conf39aac6.js\",\"pages/report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/report3b8dd6.js\",\"pages/player_adaptor.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/player_adaptor39d6ee.js\",\"pages/music_player.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/music_player3af14e.js\",\"appmsg/emotion/dom.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/dom31ff31.js\",\"appmsg/comment_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/comment_tpl.html36c376.js\",\"biz_wap/utils/fakehash.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/fakehash38c7af.js\",\"biz_common/utils/wxgspeedsdk.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/wxgspeedsdk3518c6.js\",\"a/video.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/video3b8ecd.js\",\"a/sponsor.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/sponsor3b86a9.js\",\"a/app_card.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/app_card393ef4.js\",\"a/ios.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/ios393966.js\",\"a/android.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/android393966.js\",\"a/profile.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/profile31ff31.js\",\"a/cpc_a_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/cpc_a_tpl.html3b540a.js\",\"a/sponsor_a_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/sponsor_a_tpl.html36c7cf.js\",\"a/a_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a_tpl.html3b86a9.js\",\"a/mpshop.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/mpshop311179.js\",\"a/wxopen_card.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/wxopen_card3a95b8.js\",\"a/card.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/card311179.js\",\"biz_wap/utils/position.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/position34c264.js\",\"a/a_report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a_report393966.js\",\"appmsg/my_comment_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/my_comment_tpl.html36906d.js\",\"appmsg/cmt_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cmt_tpl.html369d00.js\",\"sougou/a_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/sougou/a_tpl.html2c6e7c.js\",\"appmsg/emotion/emotion.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/emotion353f34.js\",\"biz_wap/utils/wapsdk.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/wapsdk34c264.js\",\"biz_common/utils/report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/report3518c6.js\",\"appmsg/open_url_with_webview.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/open_url_with_webview3145f0.js\",\"biz_common/utils/http.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/http3518c6.js\",\"biz_common/utils/cookie.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/cookie3518c6.js\",\"appmsg/topic_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/topic_tpl.html31ff31.js\",\"pages/weapp_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/weapp_tpl.html36906d.js\",\"biz_common/utils/monitor.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/monitor3518c6.js\",\"appmsg/weapp_common.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weapp_common3af55a.js\",\"pages/voice_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/voice_tpl.html38518d.js\",\"pages/kugoumusic_ctrl.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/kugoumusic_ctrl393e3a.js\",\"pages/qqmusic_ctrl.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/qqmusic_ctrl39b68c.js\",\"pages/voice_component.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/voice_component3af14e.js\",\"pages/qqmusic_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/qqmusic_tpl.html393e3a.js\",\"new_video/ctl.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/ctl2d441f.js\",\"a/testdata.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/testdata3b86a9.js\",\"appmsg/reward_entry.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/reward_entry3b1cff.js\",\"appmsg/comment.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/comment3944ad.js\",\"appmsg/like.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/like375fea.js\",\"pages/version4video.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/version4video3a9bef.js\",\"a/a.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a3b8ecd.js\",\"rt/appmsg/getappmsgext.rt.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/rt/appmsg/getappmsgext.rt2c21f6.js\",\"biz_wap/utils/storage.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/storage34c264.js\",\"biz_common/tmpl.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/tmpl3518c6.js\",\"appmsg/share_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/share_tpl.html36906d.js\",\"appmsg/img_copyright_tpl.html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/img_copyright_tpl.html2a2c13.js\",\"pages/video_ctrl.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/video_ctrl36ebcf.js\",\"biz_common/ui/imgonepx.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/ui/imgonepx3518c6.js\",\"biz_common/utils/respTypes.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/respTypes3518c6.js\",\"biz_wap/utils/log.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/log34c264.js\",\"sougou/index.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/sougou/index36913b.js\",\"biz_wap/safe/mutation_observer_report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/safe/mutation_observer_report34c264.js\",\"appmsg/fereport.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/fereport3b9457.js\",\"appmsg/report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/report3404b3.js\",\"appmsg/report_and_source.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/report_and_source3a7477.js\",\"appmsg/page_pos.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/page_pos3a95b8.js\",\"appmsg/cdn_speed_report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cdn_speed_report3097b2.js\",\"appmsg/wxtopic.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/wxtopic31a3be.js\",\"appmsg/new_index.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/new_index36906d.js\",\"appmsg/weapp.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weapp3af55a.js\",\"appmsg/weproduct.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weproduct3af55a.js\",\"appmsg/voicemsg.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/voicemsg3b1748.js\",\"appmsg/autoread.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/autoread3af14e.js\",\"appmsg/voice.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/voice38518d.js\",\"appmsg/qqmusic.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/qqmusic39dc43.js\",\"appmsg/iframe.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/iframe39ab71.js\",\"appmsg/product.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/product393966.js\",\"appmsg/review_image.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/review_image3af55a.js\",\"appmsg/outer_link.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/outer_link275627.js\",\"appmsg/copyright_report.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/copyright_report2ec4b2.js\",\"appmsg/async.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/async3b27d5.js\",\"biz_wap/ui/lazyload_img.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/ui/lazyload_img3af55a.js\",\"biz_common/log/jserr.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/log/jserr3518c6.js\",\"appmsg/share.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/share3b4418.js\",\"appmsg/cdn_img_lib.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cdn_img_lib38b7bb.js\",\"biz_common/utils/url/parse.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/url/parse36ebcf.js\",\"page/appmsg/not_in_mm.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg/not_in_mm.css36906d.js\",\"page/appmsg/page_mp_article_improve_combo.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg/page_mp_article_improve_combo.css3b86a9.js\",\"page/appmsg_new/not_in_mm.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg_new/not_in_mm.css36f05c.js\",\"page/appmsg_new/combo.css\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg_new/combo.css3b86a9.js\",\"biz_wap/jsapi/core.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/jsapi/core3b0568.js\",\"biz_common/dom/event.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/event3a25e9.js\",\"appmsg/test.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/test354009.js\",\"biz_wap/utils/mmversion.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/mmversion34c264.js\",\"appmsg/max_age.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/max_age2fdd28.js\",\"biz_common/dom/attr.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/attr3518c6.js\",\"biz_wap/utils/ajax.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/ajax38c31a.js\",\"appmsg/log.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/log300330.js\",\"biz_common/dom/class.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/class3518c6.js\",\"biz_wap/utils/device.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/device34c264.js\",\"biz_common/utils/string/html.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/string/html3518c6.js\",\"appmsg/index.js\":\"//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/index3b1748.js\"};`\n\n### 存在 XSS 安全隐患\n\n在 _\\_\\_MOON\\_\\_pages/report.js_ 文件的入口处加入代码 _alert('Helo World');_ 刷新页面后弹出提示 “Hello World”，说明使用基于 localStorage 的缓存机制存在一些安全隐患，并且微信尚未对这些攻击漏洞进行处理。\n\n关于使用 localStorage 进行资源缓存其他思考\n----------------------------\n\n1.  如果先输出 html 然后用 js 从本地缓存读取样式再插入会出现严重的阻塞和闪烁问题\n2.  这种解决方案更加适合单页面应用否则容易产生冗余\n3.  存在浏览器兼容性问题（隐身模式 etc.）（微信具有自己的X5内核完美解决该问题）\n4.  网络速度快，协商缓存的响应延迟可能比 _LS读取+eval_ 更小\n5.  浏览器对于单次 set 和对 LS（本质是 SQL lite）的总容量存在限制\n6.  可以节省流量，并且可以用于 A/B test\n7.  移动端的浏览器缓存经常会被清理且网络状态通常较差，更加适合这种解决方案\n\n  大概就是这么个意思，不过要快速构建到已有的项目中还没仔细考虑，后面再讨论。 https://github.com/mtjs/mt  （腾讯开源专注于移动端的、带有增量更新特色的js模块管理框架）","slug":"e5-88-86-e6-9e-90-e5-be-ae-e4-bf-a1-e5-85-ac-e4-bc-97-e5-8f-b7-localstorage-e7-bc-93-e5-ad-98-e6-9c-ba-e5-88-b6","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269a6000sc8gs2gcr7ydm","content":"<p>微信公众号的阅读体验非常流畅，作为一名程序员很好奇他具体实现套路是什么，相比于我们常规开发用了什么黑科技？ 于是下意识的打开浏览器控制台一探究 奇怪！Network里面没有发起任何请求，那文章数据哪里来呢？</p>\n<h2 id=\"假设：服务端渲染机制\"><a href=\"#假设：服务端渲染机制\" class=\"headerlink\" title=\"假设：服务端渲染机制\"></a>假设：服务端渲染机制</h2><p>通过请求得到的HTML文件发现并不是，只拿到了标题，很显然这个假设否定❌ 继续查找发现js文件都没有返回，那么就只肯定是本地localStorage 我这菜鸟也暂时想不到其他的可能了， 看到 Local Storage 里密密麻麻的 js 文件,我就放心了这确实也是一种前端加载优化策略。</p>\n<h2 id=\"通过网上的相关文章和本地分析，梳理一下大概实现的方案\"><a href=\"#通过网上的相关文章和本地分析，梳理一下大概实现的方案\" class=\"headerlink\" title=\"通过网上的相关文章和本地分析，梳理一下大概实现的方案\"></a>通过网上的相关文章和本地分析，梳理一下大概实现的方案</h2><p> </p>\n<h3 id=\"缓存更新机制\"><a href=\"#缓存更新机制\" class=\"headerlink\" title=\"缓存更新机制\"></a>缓存更新机制</h3><p>项目在迭代开发的过程中，难以避免需要更新资源文件，常用的方法有<code>文件名$&#123;md5&#125;.js</code>或者在资源 url 后面加上特定后缀的方式 etc.，而在微信做法中以 <em>__MOON__pages/report.js</em> 为例，其版本信息使用 key 为 <em>__MOON__pages/report.js_ver</em> 的存储项保存：</p>\n<p><code>__MOON__pages/report.js_ver: //res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/report3b8dd6.js</code></p>\n<p>我们不直接使用这个 value 动态插入 script 节点来加载该文件，而是根据后端提供的配置信息，判断是选择使用缓存的 <em>__MOON__pages/report.js</em> 文件，还是重新发起加载请求。</p>\n<h3 id=\"搭建更新代码的脚手架\"><a href=\"#搭建更新代码的脚手架\" class=\"headerlink\" title=\"搭建更新代码的脚手架\"></a>搭建更新代码的脚手架</h3><p>（加载 combo 化）使用基于 localStorage 的缓存机制，就需要一个脚手架来管理资源文件的读取和写入，不难看出微信使用的是自己开发的脚手架 _moon.js_，阅读其源码代价较大，暂不分析。</p>\n<h3 id=\"资源配置信息\"><a href=\"#资源配置信息\" class=\"headerlink\" title=\"资源配置信息\"></a>资源配置信息</h3><p>前端在进行资源更新时需要后端提供一份依据供前端用于判断哪些资源需要更新，并且脚手架 moon.js 需要该资源配置信息才能正常工作，所以配置信息一定要在 moon.js 的 script 标签前输出：</p>\n<p><code>window.moon_map = &#123;&quot;new_video/player.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/player.html3b8dd6.js&quot;,&quot;biz_wap/zepto/touch.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/touch34c264.js&quot;,&quot;biz_wap/zepto/event.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/event34c264.js&quot;,&quot;biz_wap/zepto/zepto.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/zepto34c264.js&quot;,&quot;page/pages/video.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/pages/video.css3b8dd6.js&quot;,&quot;a/appdialog_confirm.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/appdialog_confirm.html34f0d8.js&quot;,&quot;widget/wx_profile_dialog_primary.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/widget/wx_profile_dialog_primary.css34f0d8.js&quot;,&quot;appmsg/emotion/caret.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/caret278965.js&quot;,&quot;new_video/player.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/player3b8ecd.js&quot;,&quot;a/appdialog_confirm.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/appdialog_confirm34c32a.js&quot;,&quot;biz_wap/jsapi/cardticket.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/jsapi/cardticket34c264.js&quot;,&quot;biz_common/utils/emoji_panel_data.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/emoji_panel_data3518c6.js&quot;,&quot;biz_common/utils/emoji_data.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/emoji_data3518c6.js&quot;,&quot;appmsg/emotion/textarea.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/textarea353f34.js&quot;,&quot;appmsg/emotion/nav.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/nav278965.js&quot;,&quot;appmsg/emotion/common.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/common3518c6.js&quot;,&quot;appmsg/emotion/slide.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/slide2a9cd9.js&quot;,&quot;pages/loadscript.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/loadscript39aac6.js&quot;,&quot;pages/music_report_conf.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/music_report_conf39aac6.js&quot;,&quot;pages/report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/report3b8dd6.js&quot;,&quot;pages/player_adaptor.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/player_adaptor39d6ee.js&quot;,&quot;pages/music_player.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/music_player3af14e.js&quot;,&quot;appmsg/emotion/dom.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/dom31ff31.js&quot;,&quot;appmsg/comment_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/comment_tpl.html36c376.js&quot;,&quot;biz_wap/utils/fakehash.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/fakehash38c7af.js&quot;,&quot;biz_common/utils/wxgspeedsdk.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/wxgspeedsdk3518c6.js&quot;,&quot;a/video.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/video3b8ecd.js&quot;,&quot;a/sponsor.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/sponsor3b86a9.js&quot;,&quot;a/app_card.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/app_card393ef4.js&quot;,&quot;a/ios.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/ios393966.js&quot;,&quot;a/android.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/android393966.js&quot;,&quot;a/profile.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/profile31ff31.js&quot;,&quot;a/cpc_a_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/cpc_a_tpl.html3b540a.js&quot;,&quot;a/sponsor_a_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/sponsor_a_tpl.html36c7cf.js&quot;,&quot;a/a_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a_tpl.html3b86a9.js&quot;,&quot;a/mpshop.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/mpshop311179.js&quot;,&quot;a/wxopen_card.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/wxopen_card3a95b8.js&quot;,&quot;a/card.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/card311179.js&quot;,&quot;biz_wap/utils/position.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/position34c264.js&quot;,&quot;a/a_report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a_report393966.js&quot;,&quot;appmsg/my_comment_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/my_comment_tpl.html36906d.js&quot;,&quot;appmsg/cmt_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cmt_tpl.html369d00.js&quot;,&quot;sougou/a_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/sougou/a_tpl.html2c6e7c.js&quot;,&quot;appmsg/emotion/emotion.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/emotion353f34.js&quot;,&quot;biz_wap/utils/wapsdk.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/wapsdk34c264.js&quot;,&quot;biz_common/utils/report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/report3518c6.js&quot;,&quot;appmsg/open_url_with_webview.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/open_url_with_webview3145f0.js&quot;,&quot;biz_common/utils/http.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/http3518c6.js&quot;,&quot;biz_common/utils/cookie.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/cookie3518c6.js&quot;,&quot;appmsg/topic_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/topic_tpl.html31ff31.js&quot;,&quot;pages/weapp_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/weapp_tpl.html36906d.js&quot;,&quot;biz_common/utils/monitor.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/monitor3518c6.js&quot;,&quot;appmsg/weapp_common.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weapp_common3af55a.js&quot;,&quot;pages/voice_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/voice_tpl.html38518d.js&quot;,&quot;pages/kugoumusic_ctrl.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/kugoumusic_ctrl393e3a.js&quot;,&quot;pages/qqmusic_ctrl.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/qqmusic_ctrl39b68c.js&quot;,&quot;pages/voice_component.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/voice_component3af14e.js&quot;,&quot;pages/qqmusic_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/qqmusic_tpl.html393e3a.js&quot;,&quot;new_video/ctl.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/ctl2d441f.js&quot;,&quot;a/testdata.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/testdata3b86a9.js&quot;,&quot;appmsg/reward_entry.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/reward_entry3b1cff.js&quot;,&quot;appmsg/comment.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/comment3944ad.js&quot;,&quot;appmsg/like.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/like375fea.js&quot;,&quot;pages/version4video.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/version4video3a9bef.js&quot;,&quot;a/a.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a3b8ecd.js&quot;,&quot;rt/appmsg/getappmsgext.rt.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/rt/appmsg/getappmsgext.rt2c21f6.js&quot;,&quot;biz_wap/utils/storage.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/storage34c264.js&quot;,&quot;biz_common/tmpl.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/tmpl3518c6.js&quot;,&quot;appmsg/share_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/share_tpl.html36906d.js&quot;,&quot;appmsg/img_copyright_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/img_copyright_tpl.html2a2c13.js&quot;,&quot;pages/video_ctrl.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/video_ctrl36ebcf.js&quot;,&quot;biz_common/ui/imgonepx.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/ui/imgonepx3518c6.js&quot;,&quot;biz_common/utils/respTypes.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/respTypes3518c6.js&quot;,&quot;biz_wap/utils/log.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/log34c264.js&quot;,&quot;sougou/index.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/sougou/index36913b.js&quot;,&quot;biz_wap/safe/mutation_observer_report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/safe/mutation_observer_report34c264.js&quot;,&quot;appmsg/fereport.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/fereport3b9457.js&quot;,&quot;appmsg/report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/report3404b3.js&quot;,&quot;appmsg/report_and_source.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/report_and_source3a7477.js&quot;,&quot;appmsg/page_pos.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/page_pos3a95b8.js&quot;,&quot;appmsg/cdn_speed_report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cdn_speed_report3097b2.js&quot;,&quot;appmsg/wxtopic.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/wxtopic31a3be.js&quot;,&quot;appmsg/new_index.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/new_index36906d.js&quot;,&quot;appmsg/weapp.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weapp3af55a.js&quot;,&quot;appmsg/weproduct.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weproduct3af55a.js&quot;,&quot;appmsg/voicemsg.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/voicemsg3b1748.js&quot;,&quot;appmsg/autoread.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/autoread3af14e.js&quot;,&quot;appmsg/voice.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/voice38518d.js&quot;,&quot;appmsg/qqmusic.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/qqmusic39dc43.js&quot;,&quot;appmsg/iframe.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/iframe39ab71.js&quot;,&quot;appmsg/product.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/product393966.js&quot;,&quot;appmsg/review_image.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/review_image3af55a.js&quot;,&quot;appmsg/outer_link.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/outer_link275627.js&quot;,&quot;appmsg/copyright_report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/copyright_report2ec4b2.js&quot;,&quot;appmsg/async.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/async3b27d5.js&quot;,&quot;biz_wap/ui/lazyload_img.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/ui/lazyload_img3af55a.js&quot;,&quot;biz_common/log/jserr.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/log/jserr3518c6.js&quot;,&quot;appmsg/share.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/share3b4418.js&quot;,&quot;appmsg/cdn_img_lib.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cdn_img_lib38b7bb.js&quot;,&quot;biz_common/utils/url/parse.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/url/parse36ebcf.js&quot;,&quot;page/appmsg/not_in_mm.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg/not_in_mm.css36906d.js&quot;,&quot;page/appmsg/page_mp_article_improve_combo.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg/page_mp_article_improve_combo.css3b86a9.js&quot;,&quot;page/appmsg_new/not_in_mm.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg_new/not_in_mm.css36f05c.js&quot;,&quot;page/appmsg_new/combo.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg_new/combo.css3b86a9.js&quot;,&quot;biz_wap/jsapi/core.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/jsapi/core3b0568.js&quot;,&quot;biz_common/dom/event.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/event3a25e9.js&quot;,&quot;appmsg/test.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/test354009.js&quot;,&quot;biz_wap/utils/mmversion.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/mmversion34c264.js&quot;,&quot;appmsg/max_age.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/max_age2fdd28.js&quot;,&quot;biz_common/dom/attr.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/attr3518c6.js&quot;,&quot;biz_wap/utils/ajax.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/ajax38c31a.js&quot;,&quot;appmsg/log.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/log300330.js&quot;,&quot;biz_common/dom/class.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/class3518c6.js&quot;,&quot;biz_wap/utils/device.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/device34c264.js&quot;,&quot;biz_common/utils/string/html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/string/html3518c6.js&quot;,&quot;appmsg/index.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/index3b1748.js&quot;&#125;;</code></p>\n<h3 id=\"存在-XSS-安全隐患\"><a href=\"#存在-XSS-安全隐患\" class=\"headerlink\" title=\"存在 XSS 安全隐患\"></a>存在 XSS 安全隐患</h3><p>在 <em>__MOON__pages/report.js</em> 文件的入口处加入代码 <em>alert(‘Helo World’);</em> 刷新页面后弹出提示 “Hello World”，说明使用基于 localStorage 的缓存机制存在一些安全隐患，并且微信尚未对这些攻击漏洞进行处理。</p>\n<h2 id=\"关于使用-localStorage-进行资源缓存其他思考\"><a href=\"#关于使用-localStorage-进行资源缓存其他思考\" class=\"headerlink\" title=\"关于使用 localStorage 进行资源缓存其他思考\"></a>关于使用 localStorage 进行资源缓存其他思考</h2><ol>\n<li> 如果先输出 html 然后用 js 从本地缓存读取样式再插入会出现严重的阻塞和闪烁问题</li>\n<li> 这种解决方案更加适合单页面应用否则容易产生冗余</li>\n<li> 存在浏览器兼容性问题（隐身模式 etc.）（微信具有自己的X5内核完美解决该问题）</li>\n<li> 网络速度快，协商缓存的响应延迟可能比 <em>LS读取+eval</em> 更小</li>\n<li> 浏览器对于单次 set 和对 LS（本质是 SQL lite）的总容量存在限制</li>\n<li> 可以节省流量，并且可以用于 A/B test</li>\n<li> 移动端的浏览器缓存经常会被清理且网络状态通常较差，更加适合这种解决方案</li>\n</ol>\n<p>  大概就是这么个意思，不过要快速构建到已有的项目中还没仔细考虑，后面再讨论。 <a href=\"https://github.com/mtjs/mt\">https://github.com/mtjs/mt</a>  （腾讯开源专注于移动端的、带有增量更新特色的js模块管理框架）</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>微信公众号的阅读体验非常流畅，作为一名程序员很好奇他具体实现套路是什么，相比于我们常规开发用了什么黑科技？ 于是下意识的打开浏览器控制台一探究 奇怪！Network里面没有发起任何请求，那文章数据哪里来呢？</p>\n<h2 id=\"假设：服务端渲染机制\"><a href=\"#假设：服务端渲染机制\" class=\"headerlink\" title=\"假设：服务端渲染机制\"></a>假设：服务端渲染机制</h2><p>通过请求得到的HTML文件发现并不是，只拿到了标题，很显然这个假设否定❌ 继续查找发现js文件都没有返回，那么就只肯定是本地localStorage 我这菜鸟也暂时想不到其他的可能了， 看到 Local Storage 里密密麻麻的 js 文件,我就放心了这确实也是一种前端加载优化策略。</p>\n<h2 id=\"通过网上的相关文章和本地分析，梳理一下大概实现的方案\"><a href=\"#通过网上的相关文章和本地分析，梳理一下大概实现的方案\" class=\"headerlink\" title=\"通过网上的相关文章和本地分析，梳理一下大概实现的方案\"></a>通过网上的相关文章和本地分析，梳理一下大概实现的方案</h2><p> </p>\n<h3 id=\"缓存更新机制\"><a href=\"#缓存更新机制\" class=\"headerlink\" title=\"缓存更新机制\"></a>缓存更新机制</h3><p>项目在迭代开发的过程中，难以避免需要更新资源文件，常用的方法有<code>文件名$&#123;md5&#125;.js</code>或者在资源 url 后面加上特定后缀的方式 etc.，而在微信做法中以 <em>__MOON__pages/report.js</em> 为例，其版本信息使用 key 为 <em>__MOON__pages/report.js_ver</em> 的存储项保存：</p>\n<p><code>__MOON__pages/report.js_ver: //res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/report3b8dd6.js</code></p>\n<p>我们不直接使用这个 value 动态插入 script 节点来加载该文件，而是根据后端提供的配置信息，判断是选择使用缓存的 <em>__MOON__pages/report.js</em> 文件，还是重新发起加载请求。</p>\n<h3 id=\"搭建更新代码的脚手架\"><a href=\"#搭建更新代码的脚手架\" class=\"headerlink\" title=\"搭建更新代码的脚手架\"></a>搭建更新代码的脚手架</h3><p>（加载 combo 化）使用基于 localStorage 的缓存机制，就需要一个脚手架来管理资源文件的读取和写入，不难看出微信使用的是自己开发的脚手架 _moon.js_，阅读其源码代价较大，暂不分析。</p>\n<h3 id=\"资源配置信息\"><a href=\"#资源配置信息\" class=\"headerlink\" title=\"资源配置信息\"></a>资源配置信息</h3><p>前端在进行资源更新时需要后端提供一份依据供前端用于判断哪些资源需要更新，并且脚手架 moon.js 需要该资源配置信息才能正常工作，所以配置信息一定要在 moon.js 的 script 标签前输出：</p>\n<p><code>window.moon_map = &#123;&quot;new_video/player.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/player.html3b8dd6.js&quot;,&quot;biz_wap/zepto/touch.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/touch34c264.js&quot;,&quot;biz_wap/zepto/event.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/event34c264.js&quot;,&quot;biz_wap/zepto/zepto.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/zepto/zepto34c264.js&quot;,&quot;page/pages/video.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/pages/video.css3b8dd6.js&quot;,&quot;a/appdialog_confirm.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/appdialog_confirm.html34f0d8.js&quot;,&quot;widget/wx_profile_dialog_primary.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/widget/wx_profile_dialog_primary.css34f0d8.js&quot;,&quot;appmsg/emotion/caret.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/caret278965.js&quot;,&quot;new_video/player.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/player3b8ecd.js&quot;,&quot;a/appdialog_confirm.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/appdialog_confirm34c32a.js&quot;,&quot;biz_wap/jsapi/cardticket.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/jsapi/cardticket34c264.js&quot;,&quot;biz_common/utils/emoji_panel_data.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/emoji_panel_data3518c6.js&quot;,&quot;biz_common/utils/emoji_data.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/emoji_data3518c6.js&quot;,&quot;appmsg/emotion/textarea.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/textarea353f34.js&quot;,&quot;appmsg/emotion/nav.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/nav278965.js&quot;,&quot;appmsg/emotion/common.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/common3518c6.js&quot;,&quot;appmsg/emotion/slide.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/slide2a9cd9.js&quot;,&quot;pages/loadscript.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/loadscript39aac6.js&quot;,&quot;pages/music_report_conf.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/music_report_conf39aac6.js&quot;,&quot;pages/report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/report3b8dd6.js&quot;,&quot;pages/player_adaptor.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/player_adaptor39d6ee.js&quot;,&quot;pages/music_player.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/music_player3af14e.js&quot;,&quot;appmsg/emotion/dom.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/dom31ff31.js&quot;,&quot;appmsg/comment_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/comment_tpl.html36c376.js&quot;,&quot;biz_wap/utils/fakehash.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/fakehash38c7af.js&quot;,&quot;biz_common/utils/wxgspeedsdk.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/wxgspeedsdk3518c6.js&quot;,&quot;a/video.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/video3b8ecd.js&quot;,&quot;a/sponsor.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/sponsor3b86a9.js&quot;,&quot;a/app_card.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/app_card393ef4.js&quot;,&quot;a/ios.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/ios393966.js&quot;,&quot;a/android.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/android393966.js&quot;,&quot;a/profile.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/profile31ff31.js&quot;,&quot;a/cpc_a_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/cpc_a_tpl.html3b540a.js&quot;,&quot;a/sponsor_a_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/sponsor_a_tpl.html36c7cf.js&quot;,&quot;a/a_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a_tpl.html3b86a9.js&quot;,&quot;a/mpshop.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/mpshop311179.js&quot;,&quot;a/wxopen_card.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/wxopen_card3a95b8.js&quot;,&quot;a/card.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/card311179.js&quot;,&quot;biz_wap/utils/position.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/position34c264.js&quot;,&quot;a/a_report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a_report393966.js&quot;,&quot;appmsg/my_comment_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/my_comment_tpl.html36906d.js&quot;,&quot;appmsg/cmt_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cmt_tpl.html369d00.js&quot;,&quot;sougou/a_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/sougou/a_tpl.html2c6e7c.js&quot;,&quot;appmsg/emotion/emotion.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/emotion/emotion353f34.js&quot;,&quot;biz_wap/utils/wapsdk.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/wapsdk34c264.js&quot;,&quot;biz_common/utils/report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/report3518c6.js&quot;,&quot;appmsg/open_url_with_webview.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/open_url_with_webview3145f0.js&quot;,&quot;biz_common/utils/http.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/http3518c6.js&quot;,&quot;biz_common/utils/cookie.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/cookie3518c6.js&quot;,&quot;appmsg/topic_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/topic_tpl.html31ff31.js&quot;,&quot;pages/weapp_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/weapp_tpl.html36906d.js&quot;,&quot;biz_common/utils/monitor.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/monitor3518c6.js&quot;,&quot;appmsg/weapp_common.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weapp_common3af55a.js&quot;,&quot;pages/voice_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/voice_tpl.html38518d.js&quot;,&quot;pages/kugoumusic_ctrl.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/kugoumusic_ctrl393e3a.js&quot;,&quot;pages/qqmusic_ctrl.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/qqmusic_ctrl39b68c.js&quot;,&quot;pages/voice_component.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/voice_component3af14e.js&quot;,&quot;pages/qqmusic_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/qqmusic_tpl.html393e3a.js&quot;,&quot;new_video/ctl.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/new_video/ctl2d441f.js&quot;,&quot;a/testdata.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/testdata3b86a9.js&quot;,&quot;appmsg/reward_entry.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/reward_entry3b1cff.js&quot;,&quot;appmsg/comment.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/comment3944ad.js&quot;,&quot;appmsg/like.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/like375fea.js&quot;,&quot;pages/version4video.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/version4video3a9bef.js&quot;,&quot;a/a.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/a/a3b8ecd.js&quot;,&quot;rt/appmsg/getappmsgext.rt.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/rt/appmsg/getappmsgext.rt2c21f6.js&quot;,&quot;biz_wap/utils/storage.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/storage34c264.js&quot;,&quot;biz_common/tmpl.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/tmpl3518c6.js&quot;,&quot;appmsg/share_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/share_tpl.html36906d.js&quot;,&quot;appmsg/img_copyright_tpl.html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/img_copyright_tpl.html2a2c13.js&quot;,&quot;pages/video_ctrl.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/pages/video_ctrl36ebcf.js&quot;,&quot;biz_common/ui/imgonepx.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/ui/imgonepx3518c6.js&quot;,&quot;biz_common/utils/respTypes.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/respTypes3518c6.js&quot;,&quot;biz_wap/utils/log.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/log34c264.js&quot;,&quot;sougou/index.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/sougou/index36913b.js&quot;,&quot;biz_wap/safe/mutation_observer_report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/safe/mutation_observer_report34c264.js&quot;,&quot;appmsg/fereport.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/fereport3b9457.js&quot;,&quot;appmsg/report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/report3404b3.js&quot;,&quot;appmsg/report_and_source.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/report_and_source3a7477.js&quot;,&quot;appmsg/page_pos.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/page_pos3a95b8.js&quot;,&quot;appmsg/cdn_speed_report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cdn_speed_report3097b2.js&quot;,&quot;appmsg/wxtopic.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/wxtopic31a3be.js&quot;,&quot;appmsg/new_index.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/new_index36906d.js&quot;,&quot;appmsg/weapp.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weapp3af55a.js&quot;,&quot;appmsg/weproduct.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/weproduct3af55a.js&quot;,&quot;appmsg/voicemsg.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/voicemsg3b1748.js&quot;,&quot;appmsg/autoread.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/autoread3af14e.js&quot;,&quot;appmsg/voice.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/voice38518d.js&quot;,&quot;appmsg/qqmusic.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/qqmusic39dc43.js&quot;,&quot;appmsg/iframe.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/iframe39ab71.js&quot;,&quot;appmsg/product.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/product393966.js&quot;,&quot;appmsg/review_image.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/review_image3af55a.js&quot;,&quot;appmsg/outer_link.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/outer_link275627.js&quot;,&quot;appmsg/copyright_report.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/copyright_report2ec4b2.js&quot;,&quot;appmsg/async.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/async3b27d5.js&quot;,&quot;biz_wap/ui/lazyload_img.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/ui/lazyload_img3af55a.js&quot;,&quot;biz_common/log/jserr.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/log/jserr3518c6.js&quot;,&quot;appmsg/share.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/share3b4418.js&quot;,&quot;appmsg/cdn_img_lib.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/cdn_img_lib38b7bb.js&quot;,&quot;biz_common/utils/url/parse.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/url/parse36ebcf.js&quot;,&quot;page/appmsg/not_in_mm.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg/not_in_mm.css36906d.js&quot;,&quot;page/appmsg/page_mp_article_improve_combo.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg/page_mp_article_improve_combo.css3b86a9.js&quot;,&quot;page/appmsg_new/not_in_mm.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg_new/not_in_mm.css36f05c.js&quot;,&quot;page/appmsg_new/combo.css&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/style/page/appmsg_new/combo.css3b86a9.js&quot;,&quot;biz_wap/jsapi/core.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/jsapi/core3b0568.js&quot;,&quot;biz_common/dom/event.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/event3a25e9.js&quot;,&quot;appmsg/test.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/test354009.js&quot;,&quot;biz_wap/utils/mmversion.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/mmversion34c264.js&quot;,&quot;appmsg/max_age.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/max_age2fdd28.js&quot;,&quot;biz_common/dom/attr.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/attr3518c6.js&quot;,&quot;biz_wap/utils/ajax.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/ajax38c31a.js&quot;,&quot;appmsg/log.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/log300330.js&quot;,&quot;biz_common/dom/class.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/dom/class3518c6.js&quot;,&quot;biz_wap/utils/device.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_wap/utils/device34c264.js&quot;,&quot;biz_common/utils/string/html.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/biz_common/utils/string/html3518c6.js&quot;,&quot;appmsg/index.js&quot;:&quot;//res.wx.qq.com/mmbizwap/zh_CN/htmledition/js/appmsg/index3b1748.js&quot;&#125;;</code></p>\n<h3 id=\"存在-XSS-安全隐患\"><a href=\"#存在-XSS-安全隐患\" class=\"headerlink\" title=\"存在 XSS 安全隐患\"></a>存在 XSS 安全隐患</h3><p>在 <em>__MOON__pages/report.js</em> 文件的入口处加入代码 <em>alert(‘Helo World’);</em> 刷新页面后弹出提示 “Hello World”，说明使用基于 localStorage 的缓存机制存在一些安全隐患，并且微信尚未对这些攻击漏洞进行处理。</p>\n<h2 id=\"关于使用-localStorage-进行资源缓存其他思考\"><a href=\"#关于使用-localStorage-进行资源缓存其他思考\" class=\"headerlink\" title=\"关于使用 localStorage 进行资源缓存其他思考\"></a>关于使用 localStorage 进行资源缓存其他思考</h2><ol>\n<li> 如果先输出 html 然后用 js 从本地缓存读取样式再插入会出现严重的阻塞和闪烁问题</li>\n<li> 这种解决方案更加适合单页面应用否则容易产生冗余</li>\n<li> 存在浏览器兼容性问题（隐身模式 etc.）（微信具有自己的X5内核完美解决该问题）</li>\n<li> 网络速度快，协商缓存的响应延迟可能比 <em>LS读取+eval</em> 更小</li>\n<li> 浏览器对于单次 set 和对 LS（本质是 SQL lite）的总容量存在限制</li>\n<li> 可以节省流量，并且可以用于 A/B test</li>\n<li> 移动端的浏览器缓存经常会被清理且网络状态通常较差，更加适合这种解决方案</li>\n</ol>\n<p>  大概就是这么个意思，不过要快速构建到已有的项目中还没仔细考虑，后面再讨论。 <a href=\"https://github.com/mtjs/mt\">https://github.com/mtjs/mt</a>  （腾讯开源专注于移动端的、带有增量更新特色的js模块管理框架）</p>\n"},{"title":"前端小白入门之再学JavaScript (一)","url":"123.html","id":"123","date":"2019-06-22T08:36:40.000Z","_content":"\nJavaScript（缩写：JS）是一门完备的 动态编程语言。当应用于 HTML 文档时，可为网站提供动态交互特性。由布兰登·艾克（ Brendan Eich，Mozilla 项目、Mozilla 基金会和 Mozilla 公司的联合创始人）发明。 JavaScript 的应用场合极其广泛。简单到幻灯片、照片库、浮动布局和响应按钮点击。复杂到游戏、2D 和 3D 动画、大型数据库驱动程序，等等。 JavaScript 相当简洁，却非常灵活。开发者们基于 JavaScript 核心编写了大量实用工具，可以使 开发工作事半功倍。其中包括：\n\n*   浏览器应用程序接口（API）—— 浏览器内置的 API 提供了丰富的功能，比如：动态创建 HTML 和设置 CSS 样式、从用户的摄像头采集处理视频流、生成3D 图像与音频样本，等等。\n*   第三方 API —— 让开发者可以在自己的站点中整合其它内容提供者（Twitter、Facebook 等）提供的功能。\n*   第三方框架和库 —— 用来快速构建网站和应用。\n\n\\-\\-\\-\\-\\-\\-\\-[https://developer.mozilla.org](https://developer.mozilla.org/) \\[MDN\\] script标签简单介绍：\n\n    所有浏览器都支持 <script> 标签。\n    属性        值\n    type       MIME-type   指示脚本的 MIME 类型。    \n    async      async       规定异步执行脚本（仅适用于外部脚本）。    \n    charset    charset     规定在外部脚本文件中使用的字符编码。    \n    defer      defer       规定是否对脚本执行进行延迟，直到页面加载为止。    \n    language   script      不赞成使用。规定脚本语言。请使用 type 属性代替它。    \n    src        URL         规定外部脚本文件的 URL。    \n    xml:space  preserve    规定是否保留代码中的空白。\n\n上面属性简单了解一下就OK，因为html5以后标签的type不是不是必须所以新手的话只需要记住标签写法就可以，如果外链脚本加上src属性就好了。\n\n写下我们第一个JavaScript脚本\n===================\n\n听起来是不是很兴奋????，学习js的前提我假设大家已经学习过了html+css后面不再做过多解释哈。 对于我们程序猿来说当然第一个代码就是输出一个hello world。 新建一个index.html，然后输入\n\n    <!DOCTYPE html>\n    <html>\n        <head>\n            <title>我的第一个JavaScript脚本</title>\n        </head>\n        <body>\n            <h1>学习</h1>\n            <script>\n                document.write(\"Hello World!\")\n            </script>\n        </body>\n    </html>\n\n这样我们一个就完成了万里长征的第一步，很简单是不是 下面我们再尝试一下js的dom（document object model文档对象模型，简单理解有一下可以操作问题的API）操作能力\n\n    <script>\n        var title = document.querySelector('titl\n\n        title.innerHtml = '学习JavaScript';\n        \n    </script>\n\n以上就是一个简单的js开发上手实践，后面文章我们正式学习js基础知识，后面每篇文章大致分为俩部分：基础概念和手写实践。","source":"_posts/e5-89-8d-e7-ab-af-e5-b0-8f-e7-99-bd-e5-85-a5-e9-97-a8-e4-b9-8b-e5-86-8d-e5-ad-a6javascript-e4-b8-80.md","raw":"---\ntitle: 前端小白入门之再学JavaScript (一)\ntags:\n  - 前端，JavaScript\nurl: 123.html\nid: 123\ncategories:\n  - 大前端\ndate: 2019-06-22 16:36:40\n---\n\nJavaScript（缩写：JS）是一门完备的 动态编程语言。当应用于 HTML 文档时，可为网站提供动态交互特性。由布兰登·艾克（ Brendan Eich，Mozilla 项目、Mozilla 基金会和 Mozilla 公司的联合创始人）发明。 JavaScript 的应用场合极其广泛。简单到幻灯片、照片库、浮动布局和响应按钮点击。复杂到游戏、2D 和 3D 动画、大型数据库驱动程序，等等。 JavaScript 相当简洁，却非常灵活。开发者们基于 JavaScript 核心编写了大量实用工具，可以使 开发工作事半功倍。其中包括：\n\n*   浏览器应用程序接口（API）—— 浏览器内置的 API 提供了丰富的功能，比如：动态创建 HTML 和设置 CSS 样式、从用户的摄像头采集处理视频流、生成3D 图像与音频样本，等等。\n*   第三方 API —— 让开发者可以在自己的站点中整合其它内容提供者（Twitter、Facebook 等）提供的功能。\n*   第三方框架和库 —— 用来快速构建网站和应用。\n\n\\-\\-\\-\\-\\-\\-\\-[https://developer.mozilla.org](https://developer.mozilla.org/) \\[MDN\\] script标签简单介绍：\n\n    所有浏览器都支持 <script> 标签。\n    属性        值\n    type       MIME-type   指示脚本的 MIME 类型。    \n    async      async       规定异步执行脚本（仅适用于外部脚本）。    \n    charset    charset     规定在外部脚本文件中使用的字符编码。    \n    defer      defer       规定是否对脚本执行进行延迟，直到页面加载为止。    \n    language   script      不赞成使用。规定脚本语言。请使用 type 属性代替它。    \n    src        URL         规定外部脚本文件的 URL。    \n    xml:space  preserve    规定是否保留代码中的空白。\n\n上面属性简单了解一下就OK，因为html5以后标签的type不是不是必须所以新手的话只需要记住标签写法就可以，如果外链脚本加上src属性就好了。\n\n写下我们第一个JavaScript脚本\n===================\n\n听起来是不是很兴奋????，学习js的前提我假设大家已经学习过了html+css后面不再做过多解释哈。 对于我们程序猿来说当然第一个代码就是输出一个hello world。 新建一个index.html，然后输入\n\n    <!DOCTYPE html>\n    <html>\n        <head>\n            <title>我的第一个JavaScript脚本</title>\n        </head>\n        <body>\n            <h1>学习</h1>\n            <script>\n                document.write(\"Hello World!\")\n            </script>\n        </body>\n    </html>\n\n这样我们一个就完成了万里长征的第一步，很简单是不是 下面我们再尝试一下js的dom（document object model文档对象模型，简单理解有一下可以操作问题的API）操作能力\n\n    <script>\n        var title = document.querySelector('titl\n\n        title.innerHtml = '学习JavaScript';\n        \n    </script>\n\n以上就是一个简单的js开发上手实践，后面文章我们正式学习js基础知识，后面每篇文章大致分为俩部分：基础概念和手写实践。","slug":"e5-89-8d-e7-ab-af-e5-b0-8f-e7-99-bd-e5-85-a5-e9-97-a8-e4-b9-8b-e5-86-8d-e5-ad-a6javascript-e4-b8-80","published":1,"updated":"2019-09-10T07:46:08.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269a8000vc8gs717m6xpp","content":"<p>JavaScript（缩写：JS）是一门完备的 动态编程语言。当应用于 HTML 文档时，可为网站提供动态交互特性。由布兰登·艾克（ Brendan Eich，Mozilla 项目、Mozilla 基金会和 Mozilla 公司的联合创始人）发明。 JavaScript 的应用场合极其广泛。简单到幻灯片、照片库、浮动布局和响应按钮点击。复杂到游戏、2D 和 3D 动画、大型数据库驱动程序，等等。 JavaScript 相当简洁，却非常灵活。开发者们基于 JavaScript 核心编写了大量实用工具，可以使 开发工作事半功倍。其中包括：</p>\n<ul>\n<li>  浏览器应用程序接口（API）—— 浏览器内置的 API 提供了丰富的功能，比如：动态创建 HTML 和设置 CSS 样式、从用户的摄像头采集处理视频流、生成3D 图像与音频样本，等等。</li>\n<li>  第三方 API —— 让开发者可以在自己的站点中整合其它内容提供者（Twitter、Facebook 等）提供的功能。</li>\n<li>  第三方框架和库 —— 用来快速构建网站和应用。</li>\n</ul>\n<p>-------<a href=\"https://developer.mozilla.org/\">https://developer.mozilla.org</a> [MDN] script标签简单介绍：</p>\n<pre><code>所有浏览器都支持 &lt;script&gt; 标签。\n属性        值\ntype       MIME-type   指示脚本的 MIME 类型。    \nasync      async       规定异步执行脚本（仅适用于外部脚本）。    \ncharset    charset     规定在外部脚本文件中使用的字符编码。    \ndefer      defer       规定是否对脚本执行进行延迟，直到页面加载为止。    \nlanguage   script      不赞成使用。规定脚本语言。请使用 type 属性代替它。    \nsrc        URL         规定外部脚本文件的 URL。    \nxml:space  preserve    规定是否保留代码中的空白。\n</code></pre>\n<p>上面属性简单了解一下就OK，因为html5以后标签的type不是不是必须所以新手的话只需要记住标签写法就可以，如果外链脚本加上src属性就好了。</p>\n<h1 id=\"写下我们第一个JavaScript脚本\"><a href=\"#写下我们第一个JavaScript脚本\" class=\"headerlink\" title=\"写下我们第一个JavaScript脚本\"></a>写下我们第一个JavaScript脚本</h1><p>听起来是不是很兴奋????，学习js的前提我假设大家已经学习过了html+css后面不再做过多解释哈。 对于我们程序猿来说当然第一个代码就是输出一个hello world。 新建一个index.html，然后输入</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;我的第一个JavaScript脚本&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;学习&lt;/h1&gt;\n        &lt;script&gt;\n            document.write(&quot;Hello World!&quot;)\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>这样我们一个就完成了万里长征的第一步，很简单是不是 下面我们再尝试一下js的dom（document object model文档对象模型，简单理解有一下可以操作问题的API）操作能力</p>\n<pre><code>&lt;script&gt;\n    var title = document.querySelector(&#39;titl\n\n    title.innerHtml = &#39;学习JavaScript&#39;;\n    \n&lt;/script&gt;\n</code></pre>\n<p>以上就是一个简单的js开发上手实践，后面文章我们正式学习js基础知识，后面每篇文章大致分为俩部分：基础概念和手写实践。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>JavaScript（缩写：JS）是一门完备的 动态编程语言。当应用于 HTML 文档时，可为网站提供动态交互特性。由布兰登·艾克（ Brendan Eich，Mozilla 项目、Mozilla 基金会和 Mozilla 公司的联合创始人）发明。 JavaScript 的应用场合极其广泛。简单到幻灯片、照片库、浮动布局和响应按钮点击。复杂到游戏、2D 和 3D 动画、大型数据库驱动程序，等等。 JavaScript 相当简洁，却非常灵活。开发者们基于 JavaScript 核心编写了大量实用工具，可以使 开发工作事半功倍。其中包括：</p>\n<ul>\n<li>  浏览器应用程序接口（API）—— 浏览器内置的 API 提供了丰富的功能，比如：动态创建 HTML 和设置 CSS 样式、从用户的摄像头采集处理视频流、生成3D 图像与音频样本，等等。</li>\n<li>  第三方 API —— 让开发者可以在自己的站点中整合其它内容提供者（Twitter、Facebook 等）提供的功能。</li>\n<li>  第三方框架和库 —— 用来快速构建网站和应用。</li>\n</ul>\n<p>-------<a href=\"https://developer.mozilla.org/\">https://developer.mozilla.org</a> [MDN] script标签简单介绍：</p>\n<pre><code>所有浏览器都支持 &lt;script&gt; 标签。\n属性        值\ntype       MIME-type   指示脚本的 MIME 类型。    \nasync      async       规定异步执行脚本（仅适用于外部脚本）。    \ncharset    charset     规定在外部脚本文件中使用的字符编码。    \ndefer      defer       规定是否对脚本执行进行延迟，直到页面加载为止。    \nlanguage   script      不赞成使用。规定脚本语言。请使用 type 属性代替它。    \nsrc        URL         规定外部脚本文件的 URL。    \nxml:space  preserve    规定是否保留代码中的空白。\n</code></pre>\n<p>上面属性简单了解一下就OK，因为html5以后标签的type不是不是必须所以新手的话只需要记住标签写法就可以，如果外链脚本加上src属性就好了。</p>\n<h1 id=\"写下我们第一个JavaScript脚本\"><a href=\"#写下我们第一个JavaScript脚本\" class=\"headerlink\" title=\"写下我们第一个JavaScript脚本\"></a>写下我们第一个JavaScript脚本</h1><p>听起来是不是很兴奋????，学习js的前提我假设大家已经学习过了html+css后面不再做过多解释哈。 对于我们程序猿来说当然第一个代码就是输出一个hello world。 新建一个index.html，然后输入</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n    &lt;head&gt;\n        &lt;title&gt;我的第一个JavaScript脚本&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;h1&gt;学习&lt;/h1&gt;\n        &lt;script&gt;\n            document.write(&quot;Hello World!&quot;)\n        &lt;/script&gt;\n    &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>\n<p>这样我们一个就完成了万里长征的第一步，很简单是不是 下面我们再尝试一下js的dom（document object model文档对象模型，简单理解有一下可以操作问题的API）操作能力</p>\n<pre><code>&lt;script&gt;\n    var title = document.querySelector(&#39;titl\n\n    title.innerHtml = &#39;学习JavaScript&#39;;\n    \n&lt;/script&gt;\n</code></pre>\n<p>以上就是一个简单的js开发上手实践，后面文章我们正式学习js基础知识，后面每篇文章大致分为俩部分：基础概念和手写实践。</p>\n"},{"title":"前端小白入门之再学JavaScript (二)","url":"127.html","id":"127","date":"2019-06-22T08:37:58.000Z","_content":"\nJavaScript 是一种**弱类型**或者说**动态**语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：\n\n    var foo = 42;    // foo is a Number \n    nowfoo = \"bar\"; // foo is a String \n    nowfoo = true;  // foo is a Boolean now\n\n最新的 ECMAScript 规范，定义了7种数据类型\n\n*   String\n*   Number\n*   Boolean\n*   Undefined\n*   Null\n*   Symbol (ES6新定义类型)\n*   Object\n\n一般面试过过程中一般会问基础类型(简单类型)或者复杂类型(引用类型)，那么以上6种就是所谓的基本类型，Object属于复杂类型它包含有Object，Array，Function。 在计算机运算过程中变量的存放一般是俩种方式栈（stack）和堆（heap） **栈** stack是有结构的，先进后出，存放基本类型和对象的引用，每个区块的大小是明确的。如果你不太好理解，就想一想古时候客栈，计算机中的栈也类型一层一层，你想如果1楼最后来的人把门口堵住了2楼，3楼是不是无法出去必须等一楼出去才可以，这就是所谓的先进后出的原则????。 **堆** heap没有结构，数据任意存放，js中主要存放的是引用类型，比如：Array，Object对象 很容易看出来，如果进行数据查询速度比较的话stack效率远远高于heap，毕竟人家都是登记好的拿了本子就可以查到是不是???? 在实际开发过程中，偶尔遇到栈溢出的情况，stack overflow错误，一般在代码运行时会分配1M-2M空间，不同设备可能不同的。栈因为stack创建时候，大小是确定的，超过额度大小就会发生栈溢出【当js出现死循环或者错误的递归时候】。 heap大小是不确定的，需要可以一直累加。 js是单线程的，核心特征哈，那么怎么利用多核的CPU呢？H5的Web Worker标准，允许js脚本创建多个线程，但是子线程受主线程的控制，且不能操作DOM。 stack是线程独占的，heap是线程共有的。 好了回到正题继续讨论今天的数据类型\n\n#### Undefined\n\nUndefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。不过，一般建议尽量给变量初始化，但是在早期的js版本中是没有规定undefined这个值的，所以在有些框架中为了兼容旧版浏览器，会给window对象添加undefined值。\n\n    window['undefined'] = window['undefined'];  //或者\n    window.undefined = window.undefined;\n\n**Null** Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回object的原因。\n\n      var car = null;  \n      console.log(typeof car); // \"object\"\n\n如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检测null值就可以知道相应的变量是否已经保存了一个对象的引用了。\n\n     if(car != null){    \n         //对car对象执行某些操作\n     }\n\n#### Boolean\n\n该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。 虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean(),也可以使用小技巧!!俩个叹号转译为布尔类型\n\n数据类型\n\n转换为true的值\n\n转换为false的值\n\nBoolean\n\ntrue\n\nfalse\n\nString\n\n任何非空的字符串\n\n\"\"(空字符串)\n\nNumber\n\n任何非0数值（包括无穷大）\n\n0和NaN\n\nObject\n\n任何对象\n\nnull\n\nUndefined\n\n不适用\n\nundefined\n\n  **Number** 这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。 NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代码会返回false。 **String** String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由单引号(')或双引号(\")表示。我建议在js中一律使用单引号,毕竟少按一个shift 而且很多权威规范也都是这样 string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本类型相似的不可变引用类型 **Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型**，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：\n\n    var name = String(\"v5ant\");\n    alert(typeof name);//\"string\"\n    var x=new String('12345')\n    typeof x //object \n    x='12345'\n    typeof x //string\n    var author = \"Tom\";\n    alert(typeof name);//\"string\"\n\n**symbol** 新加入的一原始类型，表示独一无二的值 注意，`Symbol`函数前不能使用`new`命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象 `Symbol`函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分 我们可以通过调用`Symbol()`函数来创建一个Symbol实例：\n\n    let s1 = Symbol()\n    let s2 = Symbol('another symbol')\n    let s3 = Symbol('another symbol')\n    \n    s1 === s2 // false\n    s2 === s3 // false\n\n#### 应用场景1：使用Symbol来作为对象属性名(key)\n\n    const PROP_NAME = Symbol()\n    const PROP_AGE = Symbol()\n    let obj = {\n      [PROP_NAME]: \"一斤代码\"\n    }\n    obj[PROP_AGE] = 18\n    \n    obj[PROP_NAME] // '一斤代码'\n    obj[PROP_AGE] // 18\n\n随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用`Object.keys()`或者`for...in`来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：\n\n    et obj = {\n       [Symbol('name')]: '一斤代码',   \n       age: 18,   \n       title: 'Engineer'\n    }\n    Object.keys(obj)   // ['age', 'title']\n    for (let p in obj) {   \n        console.log(p)   \n        // 分别会输出：'age' 和 'title'\n    }\n    Object.getOwnPropertyNames(obj)   // ['age', 'title']\n\n由上代码可知，Symbol类型的key是不能通过`Object.keys()`或者`for...in`来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。 也正因为这样一个特性，当使用`JSON.stringify()`将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外： 然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如：\n\n    // 使用Object的API\n    Object.getOwnPropertySymbols(obj) // [Symbol(name)]\n    // 使用新增的反射API\n    Reflect.ownKeys(obj) // [Symbol(name), 'age', 'title']\n\n应用场景2：使用Symbol来替代常量\n\n#### 应用场景3：使用Symbol定义类的私有属性/方法","source":"_posts/e5-89-8d-e7-ab-af-e5-b0-8f-e7-99-bd-e5-85-a5-e9-97-a8-e4-b9-8b-e5-86-8d-e5-ad-a6javascript-e4-ba-8c.md","raw":"---\ntitle: 前端小白入门之再学JavaScript (二)\ntags:\n  - 前端，JavaScript\nurl: 127.html\nid: 127\ncategories:\n  - 大前端\ndate: 2019-06-22 16:37:58\n---\n\nJavaScript 是一种**弱类型**或者说**动态**语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：\n\n    var foo = 42;    // foo is a Number \n    nowfoo = \"bar\"; // foo is a String \n    nowfoo = true;  // foo is a Boolean now\n\n最新的 ECMAScript 规范，定义了7种数据类型\n\n*   String\n*   Number\n*   Boolean\n*   Undefined\n*   Null\n*   Symbol (ES6新定义类型)\n*   Object\n\n一般面试过过程中一般会问基础类型(简单类型)或者复杂类型(引用类型)，那么以上6种就是所谓的基本类型，Object属于复杂类型它包含有Object，Array，Function。 在计算机运算过程中变量的存放一般是俩种方式栈（stack）和堆（heap） **栈** stack是有结构的，先进后出，存放基本类型和对象的引用，每个区块的大小是明确的。如果你不太好理解，就想一想古时候客栈，计算机中的栈也类型一层一层，你想如果1楼最后来的人把门口堵住了2楼，3楼是不是无法出去必须等一楼出去才可以，这就是所谓的先进后出的原则????。 **堆** heap没有结构，数据任意存放，js中主要存放的是引用类型，比如：Array，Object对象 很容易看出来，如果进行数据查询速度比较的话stack效率远远高于heap，毕竟人家都是登记好的拿了本子就可以查到是不是???? 在实际开发过程中，偶尔遇到栈溢出的情况，stack overflow错误，一般在代码运行时会分配1M-2M空间，不同设备可能不同的。栈因为stack创建时候，大小是确定的，超过额度大小就会发生栈溢出【当js出现死循环或者错误的递归时候】。 heap大小是不确定的，需要可以一直累加。 js是单线程的，核心特征哈，那么怎么利用多核的CPU呢？H5的Web Worker标准，允许js脚本创建多个线程，但是子线程受主线程的控制，且不能操作DOM。 stack是线程独占的，heap是线程共有的。 好了回到正题继续讨论今天的数据类型\n\n#### Undefined\n\nUndefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。不过，一般建议尽量给变量初始化，但是在早期的js版本中是没有规定undefined这个值的，所以在有些框架中为了兼容旧版浏览器，会给window对象添加undefined值。\n\n    window['undefined'] = window['undefined'];  //或者\n    window.undefined = window.undefined;\n\n**Null** Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回object的原因。\n\n      var car = null;  \n      console.log(typeof car); // \"object\"\n\n如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检测null值就可以知道相应的变量是否已经保存了一个对象的引用了。\n\n     if(car != null){    \n         //对car对象执行某些操作\n     }\n\n#### Boolean\n\n该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。 虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean(),也可以使用小技巧!!俩个叹号转译为布尔类型\n\n数据类型\n\n转换为true的值\n\n转换为false的值\n\nBoolean\n\ntrue\n\nfalse\n\nString\n\n任何非空的字符串\n\n\"\"(空字符串)\n\nNumber\n\n任何非0数值（包括无穷大）\n\n0和NaN\n\nObject\n\n任何对象\n\nnull\n\nUndefined\n\n不适用\n\nundefined\n\n  **Number** 这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。 NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代码会返回false。 **String** String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由单引号(')或双引号(\")表示。我建议在js中一律使用单引号,毕竟少按一个shift 而且很多权威规范也都是这样 string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本类型相似的不可变引用类型 **Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型**，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：\n\n    var name = String(\"v5ant\");\n    alert(typeof name);//\"string\"\n    var x=new String('12345')\n    typeof x //object \n    x='12345'\n    typeof x //string\n    var author = \"Tom\";\n    alert(typeof name);//\"string\"\n\n**symbol** 新加入的一原始类型，表示独一无二的值 注意，`Symbol`函数前不能使用`new`命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象 `Symbol`函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分 我们可以通过调用`Symbol()`函数来创建一个Symbol实例：\n\n    let s1 = Symbol()\n    let s2 = Symbol('another symbol')\n    let s3 = Symbol('another symbol')\n    \n    s1 === s2 // false\n    s2 === s3 // false\n\n#### 应用场景1：使用Symbol来作为对象属性名(key)\n\n    const PROP_NAME = Symbol()\n    const PROP_AGE = Symbol()\n    let obj = {\n      [PROP_NAME]: \"一斤代码\"\n    }\n    obj[PROP_AGE] = 18\n    \n    obj[PROP_NAME] // '一斤代码'\n    obj[PROP_AGE] // 18\n\n随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用`Object.keys()`或者`for...in`来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：\n\n    et obj = {\n       [Symbol('name')]: '一斤代码',   \n       age: 18,   \n       title: 'Engineer'\n    }\n    Object.keys(obj)   // ['age', 'title']\n    for (let p in obj) {   \n        console.log(p)   \n        // 分别会输出：'age' 和 'title'\n    }\n    Object.getOwnPropertyNames(obj)   // ['age', 'title']\n\n由上代码可知，Symbol类型的key是不能通过`Object.keys()`或者`for...in`来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。 也正因为这样一个特性，当使用`JSON.stringify()`将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外： 然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如：\n\n    // 使用Object的API\n    Object.getOwnPropertySymbols(obj) // [Symbol(name)]\n    // 使用新增的反射API\n    Reflect.ownKeys(obj) // [Symbol(name), 'age', 'title']\n\n应用场景2：使用Symbol来替代常量\n\n#### 应用场景3：使用Symbol定义类的私有属性/方法","slug":"e5-89-8d-e7-ab-af-e5-b0-8f-e7-99-bd-e5-85-a5-e9-97-a8-e4-b9-8b-e5-86-8d-e5-ad-a6javascript-e4-ba-8c","published":1,"updated":"2019-09-10T07:46:08.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269ad000yc8gse3wteujx","content":"<p>JavaScript 是一种<strong>弱类型</strong>或者说<strong>动态</strong>语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：</p>\n<pre><code>var foo = 42;    // foo is a Number \nnowfoo = &quot;bar&quot;; // foo is a String \nnowfoo = true;  // foo is a Boolean now\n</code></pre>\n<p>最新的 ECMAScript 规范，定义了7种数据类型</p>\n<ul>\n<li>  String</li>\n<li>  Number</li>\n<li>  Boolean</li>\n<li>  Undefined</li>\n<li>  Null</li>\n<li>  Symbol (ES6新定义类型)</li>\n<li>  Object</li>\n</ul>\n<p>一般面试过过程中一般会问基础类型(简单类型)或者复杂类型(引用类型)，那么以上6种就是所谓的基本类型，Object属于复杂类型它包含有Object，Array，Function。 在计算机运算过程中变量的存放一般是俩种方式栈（stack）和堆（heap） <strong>栈</strong> stack是有结构的，先进后出，存放基本类型和对象的引用，每个区块的大小是明确的。如果你不太好理解，就想一想古时候客栈，计算机中的栈也类型一层一层，你想如果1楼最后来的人把门口堵住了2楼，3楼是不是无法出去必须等一楼出去才可以，这就是所谓的先进后出的原则????。 <strong>堆</strong> heap没有结构，数据任意存放，js中主要存放的是引用类型，比如：Array，Object对象 很容易看出来，如果进行数据查询速度比较的话stack效率远远高于heap，毕竟人家都是登记好的拿了本子就可以查到是不是???? 在实际开发过程中，偶尔遇到栈溢出的情况，stack overflow错误，一般在代码运行时会分配1M-2M空间，不同设备可能不同的。栈因为stack创建时候，大小是确定的，超过额度大小就会发生栈溢出【当js出现死循环或者错误的递归时候】。 heap大小是不确定的，需要可以一直累加。 js是单线程的，核心特征哈，那么怎么利用多核的CPU呢？H5的Web Worker标准，允许js脚本创建多个线程，但是子线程受主线程的控制，且不能操作DOM。 stack是线程独占的，heap是线程共有的。 好了回到正题继续讨论今天的数据类型</p>\n<h4 id=\"Undefined\"><a href=\"#Undefined\" class=\"headerlink\" title=\"Undefined\"></a>Undefined</h4><p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。不过，一般建议尽量给变量初始化，但是在早期的js版本中是没有规定undefined这个值的，所以在有些框架中为了兼容旧版浏览器，会给window对象添加undefined值。</p>\n<pre><code>window[&#39;undefined&#39;] = window[&#39;undefined&#39;];  //或者\nwindow.undefined = window.undefined;\n</code></pre>\n<p><strong>Null</strong> Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回object的原因。</p>\n<pre><code>  var car = null;  \n  console.log(typeof car); // &quot;object&quot;\n</code></pre>\n<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检测null值就可以知道相应的变量是否已经保存了一个对象的引用了。</p>\n<pre><code> if(car != null)&#123;    \n     //对car对象执行某些操作\n &#125;\n</code></pre>\n<h4 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h4><p>该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。 虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean(),也可以使用小技巧!!俩个叹号转译为布尔类型</p>\n<p>数据类型</p>\n<p>转换为true的值</p>\n<p>转换为false的值</p>\n<p>Boolean</p>\n<p>true</p>\n<p>false</p>\n<p>String</p>\n<p>任何非空的字符串</p>\n<p>“”(空字符串)</p>\n<p>Number</p>\n<p>任何非0数值（包括无穷大）</p>\n<p>0和NaN</p>\n<p>Object</p>\n<p>任何对象</p>\n<p>null</p>\n<p>Undefined</p>\n<p>不适用</p>\n<p>undefined</p>\n<p>  <strong>Number</strong> 这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。 NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代码会返回false。 <strong>String</strong> String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由单引号(‘)或双引号(“)表示。我建议在js中一律使用单引号,毕竟少按一个shift 而且很多权威规范也都是这样 string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本类型相似的不可变引用类型 <strong>Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型</strong>，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：</p>\n<pre><code>var name = String(&quot;v5ant&quot;);\nalert(typeof name);//&quot;string&quot;\nvar x=new String(&#39;12345&#39;)\ntypeof x //object \nx=&#39;12345&#39;\ntypeof x //string\nvar author = &quot;Tom&quot;;\nalert(typeof name);//&quot;string&quot;\n</code></pre>\n<p><strong>symbol</strong> 新加入的一原始类型，表示独一无二的值 注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象 <code>Symbol</code>函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分 我们可以通过调用<code>Symbol()</code>函数来创建一个Symbol实例：</p>\n<pre><code>let s1 = Symbol()\nlet s2 = Symbol(&#39;another symbol&#39;)\nlet s3 = Symbol(&#39;another symbol&#39;)\n\ns1 === s2 // false\ns2 === s3 // false\n</code></pre>\n<h4 id=\"应用场景1：使用Symbol来作为对象属性名-key\"><a href=\"#应用场景1：使用Symbol来作为对象属性名-key\" class=\"headerlink\" title=\"应用场景1：使用Symbol来作为对象属性名(key)\"></a>应用场景1：使用Symbol来作为对象属性名(key)</h4><pre><code>const PROP_NAME = Symbol()\nconst PROP_AGE = Symbol()\nlet obj = &#123;\n  [PROP_NAME]: &quot;一斤代码&quot;\n&#125;\nobj[PROP_AGE] = 18\n\nobj[PROP_NAME] // &#39;一斤代码&#39;\nobj[PROP_AGE] // 18\n</code></pre>\n<p>随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用<code>Object.keys()</code>或者<code>for...in</code>来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：</p>\n<pre><code>et obj = &#123;\n   [Symbol(&#39;name&#39;)]: &#39;一斤代码&#39;,   \n   age: 18,   \n   title: &#39;Engineer&#39;\n&#125;\nObject.keys(obj)   // [&#39;age&#39;, &#39;title&#39;]\nfor (let p in obj) &#123;   \n    console.log(p)   \n    // 分别会输出：&#39;age&#39; 和 &#39;title&#39;\n&#125;\nObject.getOwnPropertyNames(obj)   // [&#39;age&#39;, &#39;title&#39;]\n</code></pre>\n<p>由上代码可知，Symbol类型的key是不能通过<code>Object.keys()</code>或者<code>for...in</code>来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。 也正因为这样一个特性，当使用<code>JSON.stringify()</code>将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外： 然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如：</p>\n<pre><code>// 使用Object的API\nObject.getOwnPropertySymbols(obj) // [Symbol(name)]\n// 使用新增的反射API\nReflect.ownKeys(obj) // [Symbol(name), &#39;age&#39;, &#39;title&#39;]\n</code></pre>\n<p>应用场景2：使用Symbol来替代常量</p>\n<h4 id=\"应用场景3：使用Symbol定义类的私有属性-方法\"><a href=\"#应用场景3：使用Symbol定义类的私有属性-方法\" class=\"headerlink\" title=\"应用场景3：使用Symbol定义类的私有属性/方法\"></a>应用场景3：使用Symbol定义类的私有属性/方法</h4>","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>JavaScript 是一种<strong>弱类型</strong>或者说<strong>动态</strong>语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：</p>\n<pre><code>var foo = 42;    // foo is a Number \nnowfoo = &quot;bar&quot;; // foo is a String \nnowfoo = true;  // foo is a Boolean now\n</code></pre>\n<p>最新的 ECMAScript 规范，定义了7种数据类型</p>\n<ul>\n<li>  String</li>\n<li>  Number</li>\n<li>  Boolean</li>\n<li>  Undefined</li>\n<li>  Null</li>\n<li>  Symbol (ES6新定义类型)</li>\n<li>  Object</li>\n</ul>\n<p>一般面试过过程中一般会问基础类型(简单类型)或者复杂类型(引用类型)，那么以上6种就是所谓的基本类型，Object属于复杂类型它包含有Object，Array，Function。 在计算机运算过程中变量的存放一般是俩种方式栈（stack）和堆（heap） <strong>栈</strong> stack是有结构的，先进后出，存放基本类型和对象的引用，每个区块的大小是明确的。如果你不太好理解，就想一想古时候客栈，计算机中的栈也类型一层一层，你想如果1楼最后来的人把门口堵住了2楼，3楼是不是无法出去必须等一楼出去才可以，这就是所谓的先进后出的原则????。 <strong>堆</strong> heap没有结构，数据任意存放，js中主要存放的是引用类型，比如：Array，Object对象 很容易看出来，如果进行数据查询速度比较的话stack效率远远高于heap，毕竟人家都是登记好的拿了本子就可以查到是不是???? 在实际开发过程中，偶尔遇到栈溢出的情况，stack overflow错误，一般在代码运行时会分配1M-2M空间，不同设备可能不同的。栈因为stack创建时候，大小是确定的，超过额度大小就会发生栈溢出【当js出现死循环或者错误的递归时候】。 heap大小是不确定的，需要可以一直累加。 js是单线程的，核心特征哈，那么怎么利用多核的CPU呢？H5的Web Worker标准，允许js脚本创建多个线程，但是子线程受主线程的控制，且不能操作DOM。 stack是线程独占的，heap是线程共有的。 好了回到正题继续讨论今天的数据类型</p>\n<h4 id=\"Undefined\"><a href=\"#Undefined\" class=\"headerlink\" title=\"Undefined\"></a>Undefined</h4><p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。不过，一般建议尽量给变量初始化，但是在早期的js版本中是没有规定undefined这个值的，所以在有些框架中为了兼容旧版浏览器，会给window对象添加undefined值。</p>\n<pre><code>window[&#39;undefined&#39;] = window[&#39;undefined&#39;];  //或者\nwindow.undefined = window.undefined;\n</code></pre>\n<p><strong>Null</strong> Null类型是第二个只有一个值的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个空对象指针，而这也正是使用typeof操作符检测null时会返回object的原因。</p>\n<pre><code>  var car = null;  \n  console.log(typeof car); // &quot;object&quot;\n</code></pre>\n<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检测null值就可以知道相应的变量是否已经保存了一个对象的引用了。</p>\n<pre><code> if(car != null)&#123;    \n     //对car对象执行某些操作\n &#125;\n</code></pre>\n<h4 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean\"></a>Boolean</h4><p>该类型只有两个字面值：true和false。这两个值与数字值不是一回事，因此true不一定等于1，而false也不一定等于0。 虽然Boolean类型的字面值只有两个，但JavaScript中所有类型的值都有与这两个Boolean值等价的值。要将一个值转换为其对应的Boolean值，可以调用类型转换函数Boolean(),也可以使用小技巧!!俩个叹号转译为布尔类型</p>\n<p>数据类型</p>\n<p>转换为true的值</p>\n<p>转换为false的值</p>\n<p>Boolean</p>\n<p>true</p>\n<p>false</p>\n<p>String</p>\n<p>任何非空的字符串</p>\n<p>“”(空字符串)</p>\n<p>Number</p>\n<p>任何非0数值（包括无穷大）</p>\n<p>0和NaN</p>\n<p>Object</p>\n<p>任何对象</p>\n<p>null</p>\n<p>Undefined</p>\n<p>不适用</p>\n<p>undefined</p>\n<p>  <strong>Number</strong> 这种类型用来表示整数和浮点数值，还有一种特殊的数值，即NaN（非数值 Not a Number）。这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。 NaN本身有两个非同寻常的特点。首先，任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身。例如，下面的代码会返回false。 <strong>String</strong> String类型用于表示由零或多个16位Unicode字符组成的字符序列，即字符串。字符串可以由单引号(‘)或双引号(“)表示。我建议在js中一律使用单引号,毕竟少按一个shift 而且很多权威规范也都是这样 string类型有些特殊，因为字符串具有可变的大小，所以显然它不能被直接存储在具有固定大小的变量中。由于效率的原因，我们希望JS只复制对字符串的引用，而不是字符串的内容。但是另一方面，字符串在许多方面都和基本类型的表现相似，而字符串是不可变的这一事实（即没法改变一个字符串值的内容），因此可以将字符串看成行为与基本类型相似的不可变引用类型 <strong>Boolean、Number、String 这三个是Javascript中的基本包装类型，也就是这三个其实是一个构造函数，他们是Function的实例，是引用类型</strong>，至于这里的String与以上说的String是同名，是因为其实上文说的String是指字符串，这里的String指的是String这个构造函数，上面那么写，是为了更好的理解，因为Javascript是松散类型的。我们可以看下String实例化的例子：</p>\n<pre><code>var name = String(&quot;v5ant&quot;);\nalert(typeof name);//&quot;string&quot;\nvar x=new String(&#39;12345&#39;)\ntypeof x //object \nx=&#39;12345&#39;\ntypeof x //string\nvar author = &quot;Tom&quot;;\nalert(typeof name);//&quot;string&quot;\n</code></pre>\n<p><strong>symbol</strong> 新加入的一原始类型，表示独一无二的值 注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象 <code>Symbol</code>函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分 我们可以通过调用<code>Symbol()</code>函数来创建一个Symbol实例：</p>\n<pre><code>let s1 = Symbol()\nlet s2 = Symbol(&#39;another symbol&#39;)\nlet s3 = Symbol(&#39;another symbol&#39;)\n\ns1 === s2 // false\ns2 === s3 // false\n</code></pre>\n<h4 id=\"应用场景1：使用Symbol来作为对象属性名-key\"><a href=\"#应用场景1：使用Symbol来作为对象属性名-key\" class=\"headerlink\" title=\"应用场景1：使用Symbol来作为对象属性名(key)\"></a>应用场景1：使用Symbol来作为对象属性名(key)</h4><pre><code>const PROP_NAME = Symbol()\nconst PROP_AGE = Symbol()\nlet obj = &#123;\n  [PROP_NAME]: &quot;一斤代码&quot;\n&#125;\nobj[PROP_AGE] = 18\n\nobj[PROP_NAME] // &#39;一斤代码&#39;\nobj[PROP_AGE] // 18\n</code></pre>\n<p>随之而来的是另一个非常值得注意的问题：就是当使用了Symbol作为对象的属性key后，在对该对象进行key的枚举时，会有什么不同？在实际应用中，我们经常会需要使用<code>Object.keys()</code>或者<code>for...in</code>来枚举对象的属性名，那在这方面，Symbol类型的key表现的会有什么不同之处呢？来看以下示例代码：</p>\n<pre><code>et obj = &#123;\n   [Symbol(&#39;name&#39;)]: &#39;一斤代码&#39;,   \n   age: 18,   \n   title: &#39;Engineer&#39;\n&#125;\nObject.keys(obj)   // [&#39;age&#39;, &#39;title&#39;]\nfor (let p in obj) &#123;   \n    console.log(p)   \n    // 分别会输出：&#39;age&#39; 和 &#39;title&#39;\n&#125;\nObject.getOwnPropertyNames(obj)   // [&#39;age&#39;, &#39;title&#39;]\n</code></pre>\n<p>由上代码可知，Symbol类型的key是不能通过<code>Object.keys()</code>或者<code>for...in</code>来枚举的，它未被包含在对象自身的属性名集合(property names)之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。 也正因为这样一个特性，当使用<code>JSON.stringify()</code>将对象转换成JSON字符串的时候，Symbol属性也会被排除在输出内容之外： 然而，这样的话，我们就没办法获取以Symbol方式定义的对象属性了么？非也。还是会有一些专门针对Symbol的API，比如：</p>\n<pre><code>// 使用Object的API\nObject.getOwnPropertySymbols(obj) // [Symbol(name)]\n// 使用新增的反射API\nReflect.ownKeys(obj) // [Symbol(name), &#39;age&#39;, &#39;title&#39;]\n</code></pre>\n<p>应用场景2：使用Symbol来替代常量</p>\n<h4 id=\"应用场景3：使用Symbol定义类的私有属性-方法\"><a href=\"#应用场景3：使用Symbol定义类的私有属性-方法\" class=\"headerlink\" title=\"应用场景3：使用Symbol定义类的私有属性/方法\"></a>应用场景3：使用Symbol定义类的私有属性/方法</h4>"},{"title":"哪吒之魔童降世 高清在线播放-HD高清","url":"273.html","id":"273","date":"2019-07-29T07:38:24.000Z","_content":"\n![](https://www.imov.vip/upload/vod/20190726-1/17fa9e0284480eb237502cfdffab49a5.jpg)\n\n天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王。调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对魔丸的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔？他将何去何从？\n\n\\[video\\]https://dbx5.tyswmp.com/20190827/wOOwEQv6/index.m3u8\\[/video\\]\n\n声明：该资源来自互联网TS版本，如有侵权请立即告知留言，如有必要请购买观看正版影视，本站仅提供学习交流，尊重和维护知识版权。","source":"_posts/e5-93-aa-e5-90-92-e4-b9-8b-e9-ad-94-e7-ab-a5-e9-99-8d-e4-b8-96-e9-ab-98-e6-b8-85-e5-9c-a8-e7-ba-bf-e6-92-ad-e6-94-be-hd-e9-ab-98-e6-b8-85.md","raw":"---\ntitle: 哪吒之魔童降世 高清在线播放-HD高清\ntags:\n  - 热门影视\n  - 高清\nurl: 273.html\nid: 273\ncategories:\n  - 影视资源\ndate: 2019-07-29 15:38:24\n---\n\n![](https://www.imov.vip/upload/vod/20190726-1/17fa9e0284480eb237502cfdffab49a5.jpg)\n\n天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王。调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对魔丸的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔？他将何去何从？\n\n\\[video\\]https://dbx5.tyswmp.com/20190827/wOOwEQv6/index.m3u8\\[/video\\]\n\n声明：该资源来自互联网TS版本，如有侵权请立即告知留言，如有必要请购买观看正版影视，本站仅提供学习交流，尊重和维护知识版权。","slug":"e5-93-aa-e5-90-92-e4-b9-8b-e9-ad-94-e7-ab-a5-e9-99-8d-e4-b8-96-e9-ab-98-e6-b8-85-e5-9c-a8-e7-ba-bf-e6-92-ad-e6-94-be-hd-e9-ab-98-e6-b8-85","published":1,"updated":"2019-09-10T07:46:08.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269ag0011c8gs6tesdhk3","content":"<p><img src=\"https://www.imov.vip/upload/vod/20190726-1/17fa9e0284480eb237502cfdffab49a5.jpg\"></p>\n<p>天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王。调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对魔丸的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔？他将何去何从？</p>\n<p>[video]<a href=\"https://dbx5.tyswmp.com/20190827/wOOwEQv6/index.m3u8/[/video/]\">https://dbx5.tyswmp.com/20190827/wOOwEQv6/index.m3u8\\[/video\\]</a></p>\n<p>声明：该资源来自互联网TS版本，如有侵权请立即告知留言，如有必要请购买观看正版影视，本站仅提供学习交流，尊重和维护知识版权。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><img src=\"https://www.imov.vip/upload/vod/20190726-1/17fa9e0284480eb237502cfdffab49a5.jpg\"></p>\n<p>天地灵气孕育出一颗能量巨大的混元珠，元始天尊将混元珠提炼成灵珠和魔丸，灵珠投胎为人，助周伐纣时可堪大用；而魔丸则会诞出魔王，为祸人间元始天尊启动了天劫咒语，3年后天雷将会降临，摧毁魔丸。太乙受命将灵珠托生于陈塘关李靖家的儿子哪吒身上。然而阴差阳错，灵珠和魔丸竟然被掉包。本应是灵珠英雄的哪吒却成了混世大魔王。调皮捣蛋顽劣不堪的哪吒却徒有一颗做英雄的心。然而面对众人对魔丸的误解和即将来临的天雷的降临，哪吒是否命中注定会立地成魔？他将何去何从？</p>\n<p>[video]<a href=\"https://dbx5.tyswmp.com/20190827/wOOwEQv6/index.m3u8/[/video/]\">https://dbx5.tyswmp.com/20190827/wOOwEQv6/index.m3u8\\[/video\\]</a></p>\n<p>声明：该资源来自互联网TS版本，如有侵权请立即告知留言，如有必要请购买观看正版影视，本站仅提供学习交流，尊重和维护知识版权。</p>\n"},{"title":"国外CloudFlare免费CDN加速及防护注册使用教程","url":"291.html","id":"291","date":"2019-08-14T07:59:18.000Z","_content":"\n国内也有很多免费 CDN 工具，都是需要网站备案后才能使用。网站没有备案的站长可以选择使用国外 CDN 工具，操作起来也没有我们想象的那么麻烦。 cloudflare 是一款免费的 CDN 工具，CloudFlare 可以帮助受保护站点抵御包括拒绝服务攻击(DenialofService)在内的大多数网络攻击，确保该网站长期在线，同时提升网站的性能、访问速度以改善访客体验。 这个教程教大家怎么简单注册和使用 cloudflare。 **1，注册登录 cloudflare 这里都是英文界面，但是不难读懂** ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第1张](https://images.lusongsong.com/upload/1492-1.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第1张') cloudflare 注册教程 **2，\"add websites\"添加网站域名，这里不要带 www** ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第2张](https://images.lusongsong.com/upload/1492-2.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第2张') **3, cloudflare 扫描网站后或自动扫描出 dns 解析条目，可以再额外增加和删除解析。嫌麻烦的就直接点击\"continue\"** ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第3张](https://images.lusongsong.com/upload/1492-3.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第3张') **4，选择\"free plan\"，使用免费版本的 cloudflare** ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第4张](https://images.lusongsong.com/upload/1492-4.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第4张') **5，修改 dns 服务**器 ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第5张](https://images.lusongsong.com/upload/1492-5.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第5张') 如我现在使用的是万网域名，我的域名解析服务器是\"dns9.hichina.com\",现在需要将服务器修改为 cloudflare 服务器。 需要到[万网后台去修改](https://lusongsong.com/blog/post/305.html)，这里需要注意的是：不是增加或者修改解析条目，而是修改解析服务器。所以在万网后台选择的是\"管理\"而不是\"解析\" ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第6张](https://images.lusongsong.com/upload/1492-6.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第6张') ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第7张](https://images.lusongsong.com/upload/1492-7.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第7张') **6，cloudflare 域名解析服务器** 修改解析服务器后大约需要几分钟就能生效。 解析成功后，会显示\"status:active\" 据网站行业权威人士数据，世界上 90%以上的网站很容易遭受攻击。我们小站更是轻而易举的就会被黑，未雨绸缪防范于未然是每个站长必须考虑的事情，除非你不想把网站做大做强做持久。cloudflare 防止攻击的一个方式就是隐藏网站真实 ip 地址。 在安装 cloudflare 以后仍然遭受攻击，页面经常会出现 508 错误，一个很大的原因就是网站 ip 已经暴露。 这里提醒下大家，如果你网站未做任何防护请行动起来，如果你也要使用 cloudflare，，请先安装软件后再更换服务器，而不是更换服务器后再安装防护软件。也只有做好了防范工作，我们的网站才能长治久安。 原文地址：https://lusongsong.com/reed/1492.html\n","source":"_posts/e5-9b-bd-e5-a4-96cloudflare-e5-85-8d-e8-b4-b9cdn-e5-8a-a0-e9-80-9f-e5-8f-8a-e9-98-b2-e6-8a-a4-e6-b3-a8-e5-86-8c-e4-bd-bf-e7-94-a8-e6-95-99-e7-a8-8b.md","raw":"---\ntitle: 国外CloudFlare免费CDN加速及防护注册使用教程\ntags:\n  - CDN\nurl: 291.html\nid: 291\ncategories:\n  - 服务端\ndate: 2019-08-14 15:59:18\n---\n\n国内也有很多免费 CDN 工具，都是需要网站备案后才能使用。网站没有备案的站长可以选择使用国外 CDN 工具，操作起来也没有我们想象的那么麻烦。 cloudflare 是一款免费的 CDN 工具，CloudFlare 可以帮助受保护站点抵御包括拒绝服务攻击(DenialofService)在内的大多数网络攻击，确保该网站长期在线，同时提升网站的性能、访问速度以改善访客体验。 这个教程教大家怎么简单注册和使用 cloudflare。 **1，注册登录 cloudflare 这里都是英文界面，但是不难读懂** ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第1张](https://images.lusongsong.com/upload/1492-1.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第1张') cloudflare 注册教程 **2，\"add websites\"添加网站域名，这里不要带 www** ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第2张](https://images.lusongsong.com/upload/1492-2.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第2张') **3, cloudflare 扫描网站后或自动扫描出 dns 解析条目，可以再额外增加和删除解析。嫌麻烦的就直接点击\"continue\"** ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第3张](https://images.lusongsong.com/upload/1492-3.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第3张') **4，选择\"free plan\"，使用免费版本的 cloudflare** ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第4张](https://images.lusongsong.com/upload/1492-4.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第4张') **5，修改 dns 服务**器 ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第5张](https://images.lusongsong.com/upload/1492-5.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第5张') 如我现在使用的是万网域名，我的域名解析服务器是\"dns9.hichina.com\",现在需要将服务器修改为 cloudflare 服务器。 需要到[万网后台去修改](https://lusongsong.com/blog/post/305.html)，这里需要注意的是：不是增加或者修改解析条目，而是修改解析服务器。所以在万网后台选择的是\"管理\"而不是\"解析\" ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第6张](https://images.lusongsong.com/upload/1492-6.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第6张') ![国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第7张](https://images.lusongsong.com/upload/1492-7.jpg '国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第7张') **6，cloudflare 域名解析服务器** 修改解析服务器后大约需要几分钟就能生效。 解析成功后，会显示\"status:active\" 据网站行业权威人士数据，世界上 90%以上的网站很容易遭受攻击。我们小站更是轻而易举的就会被黑，未雨绸缪防范于未然是每个站长必须考虑的事情，除非你不想把网站做大做强做持久。cloudflare 防止攻击的一个方式就是隐藏网站真实 ip 地址。 在安装 cloudflare 以后仍然遭受攻击，页面经常会出现 508 错误，一个很大的原因就是网站 ip 已经暴露。 这里提醒下大家，如果你网站未做任何防护请行动起来，如果你也要使用 cloudflare，，请先安装软件后再更换服务器，而不是更换服务器后再安装防护软件。也只有做好了防范工作，我们的网站才能长治久安。 原文地址：https://lusongsong.com/reed/1492.html\n","slug":"e5-9b-bd-e5-a4-96cloudflare-e5-85-8d-e8-b4-b9cdn-e5-8a-a0-e9-80-9f-e5-8f-8a-e9-98-b2-e6-8a-a4-e6-b3-a8-e5-86-8c-e4-bd-bf-e7-94-a8-e6-95-99-e7-a8-8b","published":1,"updated":"2019-09-11T03:06:08.389Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269ai0014c8gs0ss67kvs","content":"<p>国内也有很多免费 CDN 工具，都是需要网站备案后才能使用。网站没有备案的站长可以选择使用国外 CDN 工具，操作起来也没有我们想象的那么麻烦。 cloudflare 是一款免费的 CDN 工具，CloudFlare 可以帮助受保护站点抵御包括拒绝服务攻击(DenialofService)在内的大多数网络攻击，确保该网站长期在线，同时提升网站的性能、访问速度以改善访客体验。 这个教程教大家怎么简单注册和使用 cloudflare。 <strong>1，注册登录 cloudflare 这里都是英文界面，但是不难读懂</strong> <img src=\"https://images.lusongsong.com/upload/1492-1.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第1张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第1张\"> cloudflare 注册教程 <strong>2，”add websites”添加网站域名，这里不要带 www</strong> <img src=\"https://images.lusongsong.com/upload/1492-2.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第2张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第2张\"> <strong>3, cloudflare 扫描网站后或自动扫描出 dns 解析条目，可以再额外增加和删除解析。嫌麻烦的就直接点击”continue”</strong> <img src=\"https://images.lusongsong.com/upload/1492-3.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第3张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第3张\"> <strong>4，选择”free plan”，使用免费版本的 cloudflare</strong> <img src=\"https://images.lusongsong.com/upload/1492-4.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第4张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第4张\"> <strong>5，修改 dns 服务</strong>器 <img src=\"https://images.lusongsong.com/upload/1492-5.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第5张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第5张\"> 如我现在使用的是万网域名，我的域名解析服务器是”dns9.hichina.com”,现在需要将服务器修改为 cloudflare 服务器。 需要到<a href=\"https://lusongsong.com/blog/post/305.html\">万网后台去修改</a>，这里需要注意的是：不是增加或者修改解析条目，而是修改解析服务器。所以在万网后台选择的是”管理”而不是”解析” <img src=\"https://images.lusongsong.com/upload/1492-6.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第6张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第6张\"> <img src=\"https://images.lusongsong.com/upload/1492-7.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第7张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第7张\"> <strong>6，cloudflare 域名解析服务器</strong> 修改解析服务器后大约需要几分钟就能生效。 解析成功后，会显示”status:active” 据网站行业权威人士数据，世界上 90%以上的网站很容易遭受攻击。我们小站更是轻而易举的就会被黑，未雨绸缪防范于未然是每个站长必须考虑的事情，除非你不想把网站做大做强做持久。cloudflare 防止攻击的一个方式就是隐藏网站真实 ip 地址。 在安装 cloudflare 以后仍然遭受攻击，页面经常会出现 508 错误，一个很大的原因就是网站 ip 已经暴露。 这里提醒下大家，如果你网站未做任何防护请行动起来，如果你也要使用 cloudflare，，请先安装软件后再更换服务器，而不是更换服务器后再安装防护软件。也只有做好了防范工作，我们的网站才能长治久安。 原文地址：<a href=\"https://lusongsong.com/reed/1492.html\">https://lusongsong.com/reed/1492.html</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>国内也有很多免费 CDN 工具，都是需要网站备案后才能使用。网站没有备案的站长可以选择使用国外 CDN 工具，操作起来也没有我们想象的那么麻烦。 cloudflare 是一款免费的 CDN 工具，CloudFlare 可以帮助受保护站点抵御包括拒绝服务攻击(DenialofService)在内的大多数网络攻击，确保该网站长期在线，同时提升网站的性能、访问速度以改善访客体验。 这个教程教大家怎么简单注册和使用 cloudflare。 <strong>1，注册登录 cloudflare 这里都是英文界面，但是不难读懂</strong> <img src=\"https://images.lusongsong.com/upload/1492-1.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第1张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第1张\"> cloudflare 注册教程 <strong>2，”add websites”添加网站域名，这里不要带 www</strong> <img src=\"https://images.lusongsong.com/upload/1492-2.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第2张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第2张\"> <strong>3, cloudflare 扫描网站后或自动扫描出 dns 解析条目，可以再额外增加和删除解析。嫌麻烦的就直接点击”continue”</strong> <img src=\"https://images.lusongsong.com/upload/1492-3.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第3张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第3张\"> <strong>4，选择”free plan”，使用免费版本的 cloudflare</strong> <img src=\"https://images.lusongsong.com/upload/1492-4.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第4张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第4张\"> <strong>5，修改 dns 服务</strong>器 <img src=\"https://images.lusongsong.com/upload/1492-5.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第5张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第5张\"> 如我现在使用的是万网域名，我的域名解析服务器是”dns9.hichina.com”,现在需要将服务器修改为 cloudflare 服务器。 需要到<a href=\"https://lusongsong.com/blog/post/305.html\">万网后台去修改</a>，这里需要注意的是：不是增加或者修改解析条目，而是修改解析服务器。所以在万网后台选择的是”管理”而不是”解析” <img src=\"https://images.lusongsong.com/upload/1492-6.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第6张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第6张\"> <img src=\"https://images.lusongsong.com/upload/1492-7.jpg\" alt=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第7张\" title=\"国外免费CDN加速及防护:CloudFlare注册使用教程 主机 网站安全 网站运营 站长 建站教程 第7张\"> <strong>6，cloudflare 域名解析服务器</strong> 修改解析服务器后大约需要几分钟就能生效。 解析成功后，会显示”status:active” 据网站行业权威人士数据，世界上 90%以上的网站很容易遭受攻击。我们小站更是轻而易举的就会被黑，未雨绸缪防范于未然是每个站长必须考虑的事情，除非你不想把网站做大做强做持久。cloudflare 防止攻击的一个方式就是隐藏网站真实 ip 地址。 在安装 cloudflare 以后仍然遭受攻击，页面经常会出现 508 错误，一个很大的原因就是网站 ip 已经暴露。 这里提醒下大家，如果你网站未做任何防护请行动起来，如果你也要使用 cloudflare，，请先安装软件后再更换服务器，而不是更换服务器后再安装防护软件。也只有做好了防范工作，我们的网站才能长治久安。 原文地址：<a href=\"https://lusongsong.com/reed/1492.html\">https://lusongsong.com/reed/1492.html</a></p>\n"},{"title":"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载","url":"319.html","id":"319","date":"2019-08-27T04:03:04.000Z","_content":"\n![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/6cebc158dde97e94a1879c5bb33c4b0e.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") ![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/49ab4fc0c7bdb6eefe7f843cbab72f5c.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") ![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/207697f37c4135cb40989f29002c9034.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") ![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/c9bbc5173f73db1f8b5ae53d1aaf7aec.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") ![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/d16374492fb60d6117a6e29b6039bb32.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") ![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/e5c63e19647966b2ee92046358400443.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") 一声响指，宇宙间半数生命灰飞烟灭。几近绝望的复仇者们在惊奇队长（布丽·拉尔森BrieLarson饰）的帮助下找到灭霸（乔什·布洛林JoshBrolin饰）归隐之处，却得知六颗无限宝石均被销毁，希望彻底破灭。如是过了五年，迷失在量子领域的蚁人（保罗·路德PaulRudd饰）意外回到现实世界，他的出现为幸存的复仇者们点燃了希望。与美国队长（克里斯·埃文斯ChrisEvans饰）冰释前嫌的托尼（小罗伯特·唐尼RobertDowneyJr.饰）找到了穿越时空的方法，星散各地的超级英雄再度集结，他们分别穿越不同的时代去搜集无限宝石。而在这一过程中，平行宇宙的灭霸察觉了他们的计划。 注定要载入史册的最终决战，超级英雄们为了心中恪守的信念前仆后继……","source":"_posts/e5-a4-8d-e4-bb-87-e8-80-85-e8-81-94-e7-9b-9f4-ef-bc-9a-e7-bb-88-e5-b1-80-e4-b9-8b-e6-88-98bd4k-e8-8b-b1-e8-af-ad-e5-ae-98-e6-96-b9-e7-89-b9-e6-95-88-e4-b8-ad-e8-8b-b1-e5-8f-8c-e5-ad-97-e7-99-be.md","raw":"---\ntitle: 复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\ntags:\n  - 复仇者联盟\n  - 电影资源\nurl: 319.html\nid: 319\ncategories:\n  - 影视资源\ndate: 2019-08-27 12:03:04\n---\n\n![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/6cebc158dde97e94a1879c5bb33c4b0e.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") ![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/49ab4fc0c7bdb6eefe7f843cbab72f5c.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") ![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/207697f37c4135cb40989f29002c9034.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") ![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/c9bbc5173f73db1f8b5ae53d1aaf7aec.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") ![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/d16374492fb60d6117a6e29b6039bb32.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") ![复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载](https://img.viapi.cn/wp/uploads/2019/08/e5c63e19647966b2ee92046358400443.jpg \"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\") 一声响指，宇宙间半数生命灰飞烟灭。几近绝望的复仇者们在惊奇队长（布丽·拉尔森BrieLarson饰）的帮助下找到灭霸（乔什·布洛林JoshBrolin饰）归隐之处，却得知六颗无限宝石均被销毁，希望彻底破灭。如是过了五年，迷失在量子领域的蚁人（保罗·路德PaulRudd饰）意外回到现实世界，他的出现为幸存的复仇者们点燃了希望。与美国队长（克里斯·埃文斯ChrisEvans饰）冰释前嫌的托尼（小罗伯特·唐尼RobertDowneyJr.饰）找到了穿越时空的方法，星散各地的超级英雄再度集结，他们分别穿越不同的时代去搜集无限宝石。而在这一过程中，平行宇宙的灭霸察觉了他们的计划。 注定要载入史册的最终决战，超级英雄们为了心中恪守的信念前仆后继……","slug":"e5-a4-8d-e4-bb-87-e8-80-85-e8-81-94-e7-9b-9f4-ef-bc-9a-e7-bb-88-e5-b1-80-e4-b9-8b-e6-88-98bd4k-e8-8b-b1-e8-af-ad-e5-ae-98-e6-96-b9-e7-89-b9-e6-95-88-e4-b8-ad-e8-8b-b1-e5-8f-8c-e5-ad-97-e7-99-be","published":1,"updated":"2019-09-10T07:46:08.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269ak0017c8gsemwt9h23","content":"<p><img src=\"https://img.viapi.cn/wp/uploads/2019/08/6cebc158dde97e94a1879c5bb33c4b0e.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/08/49ab4fc0c7bdb6eefe7f843cbab72f5c.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/08/207697f37c4135cb40989f29002c9034.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/08/c9bbc5173f73db1f8b5ae53d1aaf7aec.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/08/d16374492fb60d6117a6e29b6039bb32.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/08/e5c63e19647966b2ee92046358400443.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> 一声响指，宇宙间半数生命灰飞烟灭。几近绝望的复仇者们在惊奇队长（布丽·拉尔森BrieLarson饰）的帮助下找到灭霸（乔什·布洛林JoshBrolin饰）归隐之处，却得知六颗无限宝石均被销毁，希望彻底破灭。如是过了五年，迷失在量子领域的蚁人（保罗·路德PaulRudd饰）意外回到现实世界，他的出现为幸存的复仇者们点燃了希望。与美国队长（克里斯·埃文斯ChrisEvans饰）冰释前嫌的托尼（小罗伯特·唐尼RobertDowneyJr.饰）找到了穿越时空的方法，星散各地的超级英雄再度集结，他们分别穿越不同的时代去搜集无限宝石。而在这一过程中，平行宇宙的灭霸察觉了他们的计划。 注定要载入史册的最终决战，超级英雄们为了心中恪守的信念前仆后继……</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><img src=\"https://img.viapi.cn/wp/uploads/2019/08/6cebc158dde97e94a1879c5bb33c4b0e.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/08/49ab4fc0c7bdb6eefe7f843cbab72f5c.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/08/207697f37c4135cb40989f29002c9034.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/08/c9bbc5173f73db1f8b5ae53d1aaf7aec.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/08/d16374492fb60d6117a6e29b6039bb32.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/08/e5c63e19647966b2ee92046358400443.jpg\" alt=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\" title=\"复仇者联盟4：终局之战BD4K英语官方特效中英双字百度云在线下载\"> 一声响指，宇宙间半数生命灰飞烟灭。几近绝望的复仇者们在惊奇队长（布丽·拉尔森BrieLarson饰）的帮助下找到灭霸（乔什·布洛林JoshBrolin饰）归隐之处，却得知六颗无限宝石均被销毁，希望彻底破灭。如是过了五年，迷失在量子领域的蚁人（保罗·路德PaulRudd饰）意外回到现实世界，他的出现为幸存的复仇者们点燃了希望。与美国队长（克里斯·埃文斯ChrisEvans饰）冰释前嫌的托尼（小罗伯特·唐尼RobertDowneyJr.饰）找到了穿越时空的方法，星散各地的超级英雄再度集结，他们分别穿越不同的时代去搜集无限宝石。而在这一过程中，平行宇宙的灭霸察觉了他们的计划。 注定要载入史册的最终决战，超级英雄们为了心中恪守的信念前仆后继……</p>\n"},{"title":"如此火爆的自走棋手游，做得究竟怎么样？","url":"141.html","id":"141","date":"2019-06-22T09:05:43.000Z","_content":"\n作为今年游戏圈的一匹黑马，刀塔自走棋走红的速度让很多人都感到惊讶。少数派在 3 个月前就撰文分析过刀塔自走棋为何如此火爆的原因，其中免费的准入门槛、优秀的直播（观看）体验、社交性、游戏机制（羁绊、强迫症）和赌博成瘾性构成了最主要的因素。\n\n自走棋手游是什么？\n---------\n\n不过彼时刀塔自走棋只是 Dota 2 游戏中的一款 MOD，如果一直保持这样的状态势必会限制游戏的发展，因为 Valve 官方肯定不希望看到一款第三方 MOD 的人气比自家的正作还火。所以，刀塔自走棋的开发者（巨鸟多多工作室）开始寻求脱离 Dota 2 客户端，制作自己的自走棋游戏。 随着时间的推移，巨鸟多多的合作者渐渐浮出了水面，它们就是曾经代理过聚爆、Cytus、Deemo 等游戏的成都龙渊网络科技有限公司，以及国内知名的电竞内容供应平台 ImbaTV。 3 月 14 日，自走棋手游正式公布，并开启了 官网预约活动。在新游戏中，预约用户和老玩家皆可获得不同程度的奖励。截止发稿日，预约人数已经突破了 100 万人。 ![](https://cdn.sspai.com/20190418152612.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)图片来自自走棋官网 4 月 18 日，自走棋官方宣布「测试范围扩大至所有玩家」，所有安卓用户都可以直接下载并进入游戏，而 iOS 用户因为平台的审核机制还需要再等等。借此机会，我也体验了两天的自走棋手游，来给大家讲讲这款游戏的上手体验。\n\n游戏画面\n----\n\n因为自走棋之前是 Dota 2 游戏中的一个 MOD，所以使用了大量官方的模型和素材。现在独立出来后，为了避免侵权，巨鸟多多工作室除了彻底地更改游戏画风别无他法。在尽可能地保留原作元素的基础上，巨鸟多多选择将游戏中的画面卡通化，一是为了规避侵权，二也是为了吸引更多年轻的新用户。 ![](https://cdn.sspai.com/20190419140800.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 打开游戏界面，你就可以看到一个丑丑的绿毛怪，没错它就是你的默认信使。你可以在集齐 88 个糖果后通过扭蛋机随机获得其他的信使，也可以在游戏正式上线后通过氪金的方式来直接购买糖果并换取信使。 ![](https://cdn.sspai.com/20190418155414.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 而在主界面的左边有一个「图鉴」的按钮，点击即可进入官方 WIKI，包含了棋子图鉴、装备图鉴、游戏百科、操作说明等四个方面的内容。新手在看完这些内容后，就可以大致了解自走棋这个游戏的玩法。 ![](https://cdn.sspai.com/20190418223639.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n游戏体验\n----\n\n相比游戏画面，我相信更多的玩家关心的是自走棋手游的游戏体验，毕竟要将桌面端上完整的游戏移植到屏幕更小、操作逻辑迥然不同的移动端上是一个很大的挑战。 在玩过了几局游戏后，我觉得自走棋手游基本上保留了桌面端的玩法和操作逻辑，并利用触控手势优化了一些操作，但也因为屏幕尺寸的限制做出了一些妥协。 首先，信使被固定在了右下角，桌面端上通过信使才能完成的移动棋子、撤下棋子、销毁棋子等操作现在可以通过拖拽的手势来完成，而研读棋谱、招募棋子等操作可以通过主界面右下角的按钮来完成，所以手游中的信使就没有什么存在感了。在桌面端，升星的操作必须满足相同的棋子同时在场上或者等候区的条件才能完成，但在手游中，升星的操作取消了这个限制。不过，如果你想将两个德鲁伊升级，还是需要将另一个德鲁伊放到场上，这是唯一的例外。 ![](https://cdn.sspai.com/20190419081052.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 其次，桌面端用信使拣取装备的操作改成了更简单的点触，装备会进入左上角的仓库中，并会在可以合成时提示你。仓库里的装备可以通过拖拽到棋子身上，或者拖拽到棋子的详情页来装备，这一点与桌面端的操作还是类似的。 ![](https://cdn.sspai.com/20190419140035.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 我最喜欢的一个改进是自走棋手游中全新的战斗面板，通过这个面板我可以同时掌握所有对手的信使等级、所剩金钱和羁绊（种族 / 职业）情况等信息，而不用像桌面端一样频繁地在其他玩家的视角中切换。 ![](https://cdn.sspai.com/20190419140411.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 自走棋手游还加入了一个查看对战记录的功能，点击场上左侧的路牌就可打开。研读棋谱的信息则直接放在了主界面的右下角，不用像桌面端一样按住 `⌥option` 才能查看。而预计收益只要长按主界面上方状态栏中的金币按钮就能查看。 ![](https://cdn.sspai.com/20190419110427.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 而妥协主要体现在界面元素的简化带来的更复杂的操作上，比如主界面左侧的这个状态栏，集合了自己的羁绊（种族 / 职业）情况、DPS 输出和玩家排名 / 血量等三种信息，你只能通过上下滑动来切换显示。不方便先不说，上下两个箭头按钮还很容易导致误触（曲面屏手机尤甚）。 ![](https://cdn.sspai.com/20190419104322.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 而另一个较差的游戏体验在于视角的切换。时刻观察对手的战况是每一个棋手的必备技能，但是在自走棋手游中，切换玩家视角时会出现一个战争迷雾一样的过渡动画，导致整个过程很不流畅，但最重要的是浪费了宝贵的时间。别小看了这 0.5 秒，你一次性看其他七位玩家就相当于浪费了 3.5 秒，这对于一个需要争分夺秒操作的游戏来说真的有非常大的影响。 ![](https://cdn.sspai.com/20190419105757.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 棋子技能的特效目前来看也还有很多路要走，虽然像小鹿的加血有了范围显示、谜团的大招也有了更深的配色，但绝大多数的棋子技能还是非常不明显，像女王、毒龙、斧王、发条等棋子几乎看不出技能施放后的效果。 ![](https://cdn.sspai.com/20190419111202.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 虽然整体的游戏机制没有变，但奖励机制发生了变化。在桌面端只有每局游戏的前三名可以获得随机（官方从来没有解释过糖果分发机制）的糖果，但在自走棋手游中每局游戏的前 5 名都可以获得糖果，第一名 5 颗，第二名 4 颗，以此类推。这样的设定可以让玩家获得更多的成就感，并且积累更多的糖果换取信使，个人觉得这是一个正确的改变。 ![](https://cdn.sspai.com/20190419111522.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n总结\n--\n\n说实话，作为一名刀塔自走棋的老玩家，我对这款自走棋手游的完成度还是挺满意的。虽然无法体验到原汁原味的 Dota 2 元素，但是这款游戏的核心玩法还是得到了最大程度的保留，我认为这才是最重要的。至于游戏画面、操作体验和玩法机制，我相信巨鸟多多用不了多久就可以优化到一个不错的水准。 不过摆在巨鸟多多面前的还有一个更大的问题：如何让自走棋动辄 30 - 40 分钟的游戏时间来适应手游市场的快节奏呢？让我们一起拭目以待吧。","source":"_posts/e5-a6-82-e6-ad-a4-e7-81-ab-e7-88-86-e7-9a-84-e8-87-aa-e8-b5-b0-e6-a3-8b-e6-89-8b-e6-b8-b8-ef-bc-8c-e5-81-9a-e5-be-97-e7-a9-b6-e7-ab-9f-e6-80-8e-e4-b9-88-e6-a0-b7-ef-bc-9f.md","raw":"---\ntitle: 如此火爆的自走棋手游，做得究竟怎么样？\nurl: 141.html\nid: 141\ncategories:\n  - 杂谈\ndate: 2019-06-22 17:05:43\ntags:\n---\n\n作为今年游戏圈的一匹黑马，刀塔自走棋走红的速度让很多人都感到惊讶。少数派在 3 个月前就撰文分析过刀塔自走棋为何如此火爆的原因，其中免费的准入门槛、优秀的直播（观看）体验、社交性、游戏机制（羁绊、强迫症）和赌博成瘾性构成了最主要的因素。\n\n自走棋手游是什么？\n---------\n\n不过彼时刀塔自走棋只是 Dota 2 游戏中的一款 MOD，如果一直保持这样的状态势必会限制游戏的发展，因为 Valve 官方肯定不希望看到一款第三方 MOD 的人气比自家的正作还火。所以，刀塔自走棋的开发者（巨鸟多多工作室）开始寻求脱离 Dota 2 客户端，制作自己的自走棋游戏。 随着时间的推移，巨鸟多多的合作者渐渐浮出了水面，它们就是曾经代理过聚爆、Cytus、Deemo 等游戏的成都龙渊网络科技有限公司，以及国内知名的电竞内容供应平台 ImbaTV。 3 月 14 日，自走棋手游正式公布，并开启了 官网预约活动。在新游戏中，预约用户和老玩家皆可获得不同程度的奖励。截止发稿日，预约人数已经突破了 100 万人。 ![](https://cdn.sspai.com/20190418152612.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)图片来自自走棋官网 4 月 18 日，自走棋官方宣布「测试范围扩大至所有玩家」，所有安卓用户都可以直接下载并进入游戏，而 iOS 用户因为平台的审核机制还需要再等等。借此机会，我也体验了两天的自走棋手游，来给大家讲讲这款游戏的上手体验。\n\n游戏画面\n----\n\n因为自走棋之前是 Dota 2 游戏中的一个 MOD，所以使用了大量官方的模型和素材。现在独立出来后，为了避免侵权，巨鸟多多工作室除了彻底地更改游戏画风别无他法。在尽可能地保留原作元素的基础上，巨鸟多多选择将游戏中的画面卡通化，一是为了规避侵权，二也是为了吸引更多年轻的新用户。 ![](https://cdn.sspai.com/20190419140800.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 打开游戏界面，你就可以看到一个丑丑的绿毛怪，没错它就是你的默认信使。你可以在集齐 88 个糖果后通过扭蛋机随机获得其他的信使，也可以在游戏正式上线后通过氪金的方式来直接购买糖果并换取信使。 ![](https://cdn.sspai.com/20190418155414.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 而在主界面的左边有一个「图鉴」的按钮，点击即可进入官方 WIKI，包含了棋子图鉴、装备图鉴、游戏百科、操作说明等四个方面的内容。新手在看完这些内容后，就可以大致了解自走棋这个游戏的玩法。 ![](https://cdn.sspai.com/20190418223639.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n游戏体验\n----\n\n相比游戏画面，我相信更多的玩家关心的是自走棋手游的游戏体验，毕竟要将桌面端上完整的游戏移植到屏幕更小、操作逻辑迥然不同的移动端上是一个很大的挑战。 在玩过了几局游戏后，我觉得自走棋手游基本上保留了桌面端的玩法和操作逻辑，并利用触控手势优化了一些操作，但也因为屏幕尺寸的限制做出了一些妥协。 首先，信使被固定在了右下角，桌面端上通过信使才能完成的移动棋子、撤下棋子、销毁棋子等操作现在可以通过拖拽的手势来完成，而研读棋谱、招募棋子等操作可以通过主界面右下角的按钮来完成，所以手游中的信使就没有什么存在感了。在桌面端，升星的操作必须满足相同的棋子同时在场上或者等候区的条件才能完成，但在手游中，升星的操作取消了这个限制。不过，如果你想将两个德鲁伊升级，还是需要将另一个德鲁伊放到场上，这是唯一的例外。 ![](https://cdn.sspai.com/20190419081052.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 其次，桌面端用信使拣取装备的操作改成了更简单的点触，装备会进入左上角的仓库中，并会在可以合成时提示你。仓库里的装备可以通过拖拽到棋子身上，或者拖拽到棋子的详情页来装备，这一点与桌面端的操作还是类似的。 ![](https://cdn.sspai.com/20190419140035.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 我最喜欢的一个改进是自走棋手游中全新的战斗面板，通过这个面板我可以同时掌握所有对手的信使等级、所剩金钱和羁绊（种族 / 职业）情况等信息，而不用像桌面端一样频繁地在其他玩家的视角中切换。 ![](https://cdn.sspai.com/20190419140411.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 自走棋手游还加入了一个查看对战记录的功能，点击场上左侧的路牌就可打开。研读棋谱的信息则直接放在了主界面的右下角，不用像桌面端一样按住 `⌥option` 才能查看。而预计收益只要长按主界面上方状态栏中的金币按钮就能查看。 ![](https://cdn.sspai.com/20190419110427.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 而妥协主要体现在界面元素的简化带来的更复杂的操作上，比如主界面左侧的这个状态栏，集合了自己的羁绊（种族 / 职业）情况、DPS 输出和玩家排名 / 血量等三种信息，你只能通过上下滑动来切换显示。不方便先不说，上下两个箭头按钮还很容易导致误触（曲面屏手机尤甚）。 ![](https://cdn.sspai.com/20190419104322.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 而另一个较差的游戏体验在于视角的切换。时刻观察对手的战况是每一个棋手的必备技能，但是在自走棋手游中，切换玩家视角时会出现一个战争迷雾一样的过渡动画，导致整个过程很不流畅，但最重要的是浪费了宝贵的时间。别小看了这 0.5 秒，你一次性看其他七位玩家就相当于浪费了 3.5 秒，这对于一个需要争分夺秒操作的游戏来说真的有非常大的影响。 ![](https://cdn.sspai.com/20190419105757.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 棋子技能的特效目前来看也还有很多路要走，虽然像小鹿的加血有了范围显示、谜团的大招也有了更深的配色，但绝大多数的棋子技能还是非常不明显，像女王、毒龙、斧王、发条等棋子几乎看不出技能施放后的效果。 ![](https://cdn.sspai.com/20190419111202.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 虽然整体的游戏机制没有变，但奖励机制发生了变化。在桌面端只有每局游戏的前三名可以获得随机（官方从来没有解释过糖果分发机制）的糖果，但在自走棋手游中每局游戏的前 5 名都可以获得糖果，第一名 5 颗，第二名 4 颗，以此类推。这样的设定可以让玩家获得更多的成就感，并且积累更多的糖果换取信使，个人觉得这是一个正确的改变。 ![](https://cdn.sspai.com/20190419111522.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n总结\n--\n\n说实话，作为一名刀塔自走棋的老玩家，我对这款自走棋手游的完成度还是挺满意的。虽然无法体验到原汁原味的 Dota 2 元素，但是这款游戏的核心玩法还是得到了最大程度的保留，我认为这才是最重要的。至于游戏画面、操作体验和玩法机制，我相信巨鸟多多用不了多久就可以优化到一个不错的水准。 不过摆在巨鸟多多面前的还有一个更大的问题：如何让自走棋动辄 30 - 40 分钟的游戏时间来适应手游市场的快节奏呢？让我们一起拭目以待吧。","slug":"e5-a6-82-e6-ad-a4-e7-81-ab-e7-88-86-e7-9a-84-e8-87-aa-e8-b5-b0-e6-a3-8b-e6-89-8b-e6-b8-b8-ef-bc-8c-e5-81-9a-e5-be-97-e7-a9-b6-e7-ab-9f-e6-80-8e-e4-b9-88-e6-a0-b7-ef-bc-9f","published":1,"updated":"2019-09-10T07:46:08.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269an001ac8gshpqag94v","content":"<p>作为今年游戏圈的一匹黑马，刀塔自走棋走红的速度让很多人都感到惊讶。少数派在 3 个月前就撰文分析过刀塔自走棋为何如此火爆的原因，其中免费的准入门槛、优秀的直播（观看）体验、社交性、游戏机制（羁绊、强迫症）和赌博成瘾性构成了最主要的因素。</p>\n<h2 id=\"自走棋手游是什么？\"><a href=\"#自走棋手游是什么？\" class=\"headerlink\" title=\"自走棋手游是什么？\"></a>自走棋手游是什么？</h2><p>不过彼时刀塔自走棋只是 Dota 2 游戏中的一款 MOD，如果一直保持这样的状态势必会限制游戏的发展，因为 Valve 官方肯定不希望看到一款第三方 MOD 的人气比自家的正作还火。所以，刀塔自走棋的开发者（巨鸟多多工作室）开始寻求脱离 Dota 2 客户端，制作自己的自走棋游戏。 随着时间的推移，巨鸟多多的合作者渐渐浮出了水面，它们就是曾经代理过聚爆、Cytus、Deemo 等游戏的成都龙渊网络科技有限公司，以及国内知名的电竞内容供应平台 ImbaTV。 3 月 14 日，自走棋手游正式公布，并开启了 官网预约活动。在新游戏中，预约用户和老玩家皆可获得不同程度的奖励。截止发稿日，预约人数已经突破了 100 万人。 <img src=\"https://cdn.sspai.com/20190418152612.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">图片来自自走棋官网 4 月 18 日，自走棋官方宣布「测试范围扩大至所有玩家」，所有安卓用户都可以直接下载并进入游戏，而 iOS 用户因为平台的审核机制还需要再等等。借此机会，我也体验了两天的自走棋手游，来给大家讲讲这款游戏的上手体验。</p>\n<h2 id=\"游戏画面\"><a href=\"#游戏画面\" class=\"headerlink\" title=\"游戏画面\"></a>游戏画面</h2><p>因为自走棋之前是 Dota 2 游戏中的一个 MOD，所以使用了大量官方的模型和素材。现在独立出来后，为了避免侵权，巨鸟多多工作室除了彻底地更改游戏画风别无他法。在尽可能地保留原作元素的基础上，巨鸟多多选择将游戏中的画面卡通化，一是为了规避侵权，二也是为了吸引更多年轻的新用户。 <img src=\"https://cdn.sspai.com/20190419140800.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 打开游戏界面，你就可以看到一个丑丑的绿毛怪，没错它就是你的默认信使。你可以在集齐 88 个糖果后通过扭蛋机随机获得其他的信使，也可以在游戏正式上线后通过氪金的方式来直接购买糖果并换取信使。 <img src=\"https://cdn.sspai.com/20190418155414.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 而在主界面的左边有一个「图鉴」的按钮，点击即可进入官方 WIKI，包含了棋子图鉴、装备图鉴、游戏百科、操作说明等四个方面的内容。新手在看完这些内容后，就可以大致了解自走棋这个游戏的玩法。 <img src=\"https://cdn.sspai.com/20190418223639.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<h2 id=\"游戏体验\"><a href=\"#游戏体验\" class=\"headerlink\" title=\"游戏体验\"></a>游戏体验</h2><p>相比游戏画面，我相信更多的玩家关心的是自走棋手游的游戏体验，毕竟要将桌面端上完整的游戏移植到屏幕更小、操作逻辑迥然不同的移动端上是一个很大的挑战。 在玩过了几局游戏后，我觉得自走棋手游基本上保留了桌面端的玩法和操作逻辑，并利用触控手势优化了一些操作，但也因为屏幕尺寸的限制做出了一些妥协。 首先，信使被固定在了右下角，桌面端上通过信使才能完成的移动棋子、撤下棋子、销毁棋子等操作现在可以通过拖拽的手势来完成，而研读棋谱、招募棋子等操作可以通过主界面右下角的按钮来完成，所以手游中的信使就没有什么存在感了。在桌面端，升星的操作必须满足相同的棋子同时在场上或者等候区的条件才能完成，但在手游中，升星的操作取消了这个限制。不过，如果你想将两个德鲁伊升级，还是需要将另一个德鲁伊放到场上，这是唯一的例外。 <img src=\"https://cdn.sspai.com/20190419081052.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 其次，桌面端用信使拣取装备的操作改成了更简单的点触，装备会进入左上角的仓库中，并会在可以合成时提示你。仓库里的装备可以通过拖拽到棋子身上，或者拖拽到棋子的详情页来装备，这一点与桌面端的操作还是类似的。 <img src=\"https://cdn.sspai.com/20190419140035.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 我最喜欢的一个改进是自走棋手游中全新的战斗面板，通过这个面板我可以同时掌握所有对手的信使等级、所剩金钱和羁绊（种族 / 职业）情况等信息，而不用像桌面端一样频繁地在其他玩家的视角中切换。 <img src=\"https://cdn.sspai.com/20190419140411.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 自走棋手游还加入了一个查看对战记录的功能，点击场上左侧的路牌就可打开。研读棋谱的信息则直接放在了主界面的右下角，不用像桌面端一样按住 <code>⌥option</code> 才能查看。而预计收益只要长按主界面上方状态栏中的金币按钮就能查看。 <img src=\"https://cdn.sspai.com/20190419110427.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 而妥协主要体现在界面元素的简化带来的更复杂的操作上，比如主界面左侧的这个状态栏，集合了自己的羁绊（种族 / 职业）情况、DPS 输出和玩家排名 / 血量等三种信息，你只能通过上下滑动来切换显示。不方便先不说，上下两个箭头按钮还很容易导致误触（曲面屏手机尤甚）。 <img src=\"https://cdn.sspai.com/20190419104322.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 而另一个较差的游戏体验在于视角的切换。时刻观察对手的战况是每一个棋手的必备技能，但是在自走棋手游中，切换玩家视角时会出现一个战争迷雾一样的过渡动画，导致整个过程很不流畅，但最重要的是浪费了宝贵的时间。别小看了这 0.5 秒，你一次性看其他七位玩家就相当于浪费了 3.5 秒，这对于一个需要争分夺秒操作的游戏来说真的有非常大的影响。 <img src=\"https://cdn.sspai.com/20190419105757.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 棋子技能的特效目前来看也还有很多路要走，虽然像小鹿的加血有了范围显示、谜团的大招也有了更深的配色，但绝大多数的棋子技能还是非常不明显，像女王、毒龙、斧王、发条等棋子几乎看不出技能施放后的效果。 <img src=\"https://cdn.sspai.com/20190419111202.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 虽然整体的游戏机制没有变，但奖励机制发生了变化。在桌面端只有每局游戏的前三名可以获得随机（官方从来没有解释过糖果分发机制）的糖果，但在自走棋手游中每局游戏的前 5 名都可以获得糖果，第一名 5 颗，第二名 4 颗，以此类推。这样的设定可以让玩家获得更多的成就感，并且积累更多的糖果换取信使，个人觉得这是一个正确的改变。 <img src=\"https://cdn.sspai.com/20190419111522.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>说实话，作为一名刀塔自走棋的老玩家，我对这款自走棋手游的完成度还是挺满意的。虽然无法体验到原汁原味的 Dota 2 元素，但是这款游戏的核心玩法还是得到了最大程度的保留，我认为这才是最重要的。至于游戏画面、操作体验和玩法机制，我相信巨鸟多多用不了多久就可以优化到一个不错的水准。 不过摆在巨鸟多多面前的还有一个更大的问题：如何让自走棋动辄 30 - 40 分钟的游戏时间来适应手游市场的快节奏呢？让我们一起拭目以待吧。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>作为今年游戏圈的一匹黑马，刀塔自走棋走红的速度让很多人都感到惊讶。少数派在 3 个月前就撰文分析过刀塔自走棋为何如此火爆的原因，其中免费的准入门槛、优秀的直播（观看）体验、社交性、游戏机制（羁绊、强迫症）和赌博成瘾性构成了最主要的因素。</p>\n<h2 id=\"自走棋手游是什么？\"><a href=\"#自走棋手游是什么？\" class=\"headerlink\" title=\"自走棋手游是什么？\"></a>自走棋手游是什么？</h2><p>不过彼时刀塔自走棋只是 Dota 2 游戏中的一款 MOD，如果一直保持这样的状态势必会限制游戏的发展，因为 Valve 官方肯定不希望看到一款第三方 MOD 的人气比自家的正作还火。所以，刀塔自走棋的开发者（巨鸟多多工作室）开始寻求脱离 Dota 2 客户端，制作自己的自走棋游戏。 随着时间的推移，巨鸟多多的合作者渐渐浮出了水面，它们就是曾经代理过聚爆、Cytus、Deemo 等游戏的成都龙渊网络科技有限公司，以及国内知名的电竞内容供应平台 ImbaTV。 3 月 14 日，自走棋手游正式公布，并开启了 官网预约活动。在新游戏中，预约用户和老玩家皆可获得不同程度的奖励。截止发稿日，预约人数已经突破了 100 万人。 <img src=\"https://cdn.sspai.com/20190418152612.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">图片来自自走棋官网 4 月 18 日，自走棋官方宣布「测试范围扩大至所有玩家」，所有安卓用户都可以直接下载并进入游戏，而 iOS 用户因为平台的审核机制还需要再等等。借此机会，我也体验了两天的自走棋手游，来给大家讲讲这款游戏的上手体验。</p>\n<h2 id=\"游戏画面\"><a href=\"#游戏画面\" class=\"headerlink\" title=\"游戏画面\"></a>游戏画面</h2><p>因为自走棋之前是 Dota 2 游戏中的一个 MOD，所以使用了大量官方的模型和素材。现在独立出来后，为了避免侵权，巨鸟多多工作室除了彻底地更改游戏画风别无他法。在尽可能地保留原作元素的基础上，巨鸟多多选择将游戏中的画面卡通化，一是为了规避侵权，二也是为了吸引更多年轻的新用户。 <img src=\"https://cdn.sspai.com/20190419140800.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 打开游戏界面，你就可以看到一个丑丑的绿毛怪，没错它就是你的默认信使。你可以在集齐 88 个糖果后通过扭蛋机随机获得其他的信使，也可以在游戏正式上线后通过氪金的方式来直接购买糖果并换取信使。 <img src=\"https://cdn.sspai.com/20190418155414.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 而在主界面的左边有一个「图鉴」的按钮，点击即可进入官方 WIKI，包含了棋子图鉴、装备图鉴、游戏百科、操作说明等四个方面的内容。新手在看完这些内容后，就可以大致了解自走棋这个游戏的玩法。 <img src=\"https://cdn.sspai.com/20190418223639.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<h2 id=\"游戏体验\"><a href=\"#游戏体验\" class=\"headerlink\" title=\"游戏体验\"></a>游戏体验</h2><p>相比游戏画面，我相信更多的玩家关心的是自走棋手游的游戏体验，毕竟要将桌面端上完整的游戏移植到屏幕更小、操作逻辑迥然不同的移动端上是一个很大的挑战。 在玩过了几局游戏后，我觉得自走棋手游基本上保留了桌面端的玩法和操作逻辑，并利用触控手势优化了一些操作，但也因为屏幕尺寸的限制做出了一些妥协。 首先，信使被固定在了右下角，桌面端上通过信使才能完成的移动棋子、撤下棋子、销毁棋子等操作现在可以通过拖拽的手势来完成，而研读棋谱、招募棋子等操作可以通过主界面右下角的按钮来完成，所以手游中的信使就没有什么存在感了。在桌面端，升星的操作必须满足相同的棋子同时在场上或者等候区的条件才能完成，但在手游中，升星的操作取消了这个限制。不过，如果你想将两个德鲁伊升级，还是需要将另一个德鲁伊放到场上，这是唯一的例外。 <img src=\"https://cdn.sspai.com/20190419081052.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 其次，桌面端用信使拣取装备的操作改成了更简单的点触，装备会进入左上角的仓库中，并会在可以合成时提示你。仓库里的装备可以通过拖拽到棋子身上，或者拖拽到棋子的详情页来装备，这一点与桌面端的操作还是类似的。 <img src=\"https://cdn.sspai.com/20190419140035.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 我最喜欢的一个改进是自走棋手游中全新的战斗面板，通过这个面板我可以同时掌握所有对手的信使等级、所剩金钱和羁绊（种族 / 职业）情况等信息，而不用像桌面端一样频繁地在其他玩家的视角中切换。 <img src=\"https://cdn.sspai.com/20190419140411.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 自走棋手游还加入了一个查看对战记录的功能，点击场上左侧的路牌就可打开。研读棋谱的信息则直接放在了主界面的右下角，不用像桌面端一样按住 <code>⌥option</code> 才能查看。而预计收益只要长按主界面上方状态栏中的金币按钮就能查看。 <img src=\"https://cdn.sspai.com/20190419110427.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 而妥协主要体现在界面元素的简化带来的更复杂的操作上，比如主界面左侧的这个状态栏，集合了自己的羁绊（种族 / 职业）情况、DPS 输出和玩家排名 / 血量等三种信息，你只能通过上下滑动来切换显示。不方便先不说，上下两个箭头按钮还很容易导致误触（曲面屏手机尤甚）。 <img src=\"https://cdn.sspai.com/20190419104322.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 而另一个较差的游戏体验在于视角的切换。时刻观察对手的战况是每一个棋手的必备技能，但是在自走棋手游中，切换玩家视角时会出现一个战争迷雾一样的过渡动画，导致整个过程很不流畅，但最重要的是浪费了宝贵的时间。别小看了这 0.5 秒，你一次性看其他七位玩家就相当于浪费了 3.5 秒，这对于一个需要争分夺秒操作的游戏来说真的有非常大的影响。 <img src=\"https://cdn.sspai.com/20190419105757.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 棋子技能的特效目前来看也还有很多路要走，虽然像小鹿的加血有了范围显示、谜团的大招也有了更深的配色，但绝大多数的棋子技能还是非常不明显，像女王、毒龙、斧王、发条等棋子几乎看不出技能施放后的效果。 <img src=\"https://cdn.sspai.com/20190419111202.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 虽然整体的游戏机制没有变，但奖励机制发生了变化。在桌面端只有每局游戏的前三名可以获得随机（官方从来没有解释过糖果分发机制）的糖果，但在自走棋手游中每局游戏的前 5 名都可以获得糖果，第一名 5 颗，第二名 4 颗，以此类推。这样的设定可以让玩家获得更多的成就感，并且积累更多的糖果换取信使，个人觉得这是一个正确的改变。 <img src=\"https://cdn.sspai.com/20190419111522.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>说实话，作为一名刀塔自走棋的老玩家，我对这款自走棋手游的完成度还是挺满意的。虽然无法体验到原汁原味的 Dota 2 元素，但是这款游戏的核心玩法还是得到了最大程度的保留，我认为这才是最重要的。至于游戏画面、操作体验和玩法机制，我相信巨鸟多多用不了多久就可以优化到一个不错的水准。 不过摆在巨鸟多多面前的还有一个更大的问题：如何让自走棋动辄 30 - 40 分钟的游戏时间来适应手游市场的快节奏呢？让我们一起拭目以待吧。</p>\n"},{"title":"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API","url":"115.html","id":"115","date":"2019-06-22T07:43:42.000Z","_content":"\n源码简介\n----\n\n小涴熊漫画CMS，开源免费，基于ThinkPHP 5.1及Redis缓存，自带火车头api方便我们采集发布，功能就不多说了，可以看下面的截图，漫画系统都差不多。作者更新也积极，貌似还计划加入会员系统等其他功能，这里就发一下。\n\n图片预览\n----\n\n[![小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API](https://www.mosq.cn/usr/uploads/sina/5cc3f8bea185f.jpg \"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\")](https://www.mosq.cn/usr/uploads/sina/5cc3f8bea185f.jpg) [![小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API](https://www.mosq.cn/usr/uploads/sina/5cc3f8beaecdc.jpg \"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\")](https://www.mosq.cn/usr/uploads/sina/5cc3f8beaecdc.jpg) [![小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API](https://www.mosq.cn/usr/uploads/sina/5cc3f8bebad18.jpg \"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\")](https://www.mosq.cn/usr/uploads/sina/5cc3f8bebad18.jpg) [![小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API](https://www.mosq.cn/usr/uploads/sina/5cc3f8becdac3.jpg \"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\")](https://www.mosq.cn/usr/uploads/sina/5cc3f8becdac3.jpg)\n\n安装教程\n----\n\n环境要求：PHP 5.6-7.2、MySQL >= 5.7、Redis、Redis扩展 1、安装环境 这里依旧走简单路线，使用宝塔面板做演示，使用命令： CentOS系统\n\n    if (!-e $request_filename) {    \n          rewrite  ^(.*)$  /index.php?s=/$1  last;    \n          break;    \n        }\n\n然后打开域名开始安装程序。 如果要开启404，而不让cms报错信息显示出来，需要修改config/app.php文件： 去掉第一排的//即可\n\n    ‘exception_tmpl’         => Env::get(‘app_path’) . ‘index/view/pub/404.html’,  \n    ‘exception_tmpl’         => Env::get(‘think_path’) . ‘tpl/think_exception.tpl’,\n\n采集\n--\n\n通常情况下，漫画站图片资源分两种，一种本地化，一种盗链方式，这里建议将图片本地化，这样能保证网站资源稳定性，并且该程序还提供了火车头采集器的API，能够很简单的对接火车头采集器进行漫画和章节图片的采集。 首先我们需要一个火车采集器，官网→传送门，不过分为免费版和收费版，但免费版由于某些功能限制，没法满足图片本地化需求，所以暂时不适用，如果你有钱可以买一个收费版的，不过没钱也没事，可以直接使用火车头企业破解版，大概目前最新的一个破解版，也可以满足该程序的采集需求，具体怎么下载，就自行百度，很多网站提供下载链接。 注意：由于火车头V7和V8没有url编码解码功能，所以不能采集带有中文链接的漫画网站，但V9版本可以，有钱可以直接上。 采集api说明： 采集api地址：域名/api/index/save。 请求方式：post 表单字段及说明： book\\_name 漫画名 nick\\_name 漫画别名 tags 分类，多个分类用|隔开 author 作者名字 src 采集源 end 状态，1代表完结，0代表连载中 cover\\_url 封面图远程地址 chapter\\_name 章节名 images 由图片标签组成的字符串，示例：\n\n    <img src=“http://www.m.com/1.jpg”>\n    <img src=“http://www.m.com/2.jpg”>\n    <img src=“http://www.m.com/3.jpg”>\n\napi_key 用于身份验证，要和后台配置的api密钥相同 summary 漫画简介 由于采集过程有点复杂，不是很好发，所以有兴趣且不会采集的可以看下官方的使用教程[→传送门](https://www.kancloud.cn/hiliqi/xwx_comic_cms/962155)，大致步骤就是打开火车头采集器主界面-发布-新建-内容发布参数，然后发布模块编写完之后，开始找目标站并写采集规则，最后采集发布即可。 Github地址：[https://github.com/hiliqi/xiaohuanxiong](https://github.com/hiliqi/xiaohuanxiong)","source":"_posts/e5-b0-8f-e6-b6-b4-e7-86-8a-e6-bc-ab-e7-94-bbcms-e5-bc-80-e6-ba-90-e5-85-8d-e8-b4-b9-e7-9a-84-e9-87-87-e9-9b-86-e6-bc-ab-e7-94-bb-e8-bf-9e-e8-bd-bd-e7-b3-bb-e7-bb-9f-ef-bc-8c-e5-b8-a6-e9-87-87.md","raw":"---\ntitle: 小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\nurl: 115.html\nid: 115\ncategories:\n  - 精选资源\ndate: 2019-06-22 15:43:42\ntags:\n---\n\n源码简介\n----\n\n小涴熊漫画CMS，开源免费，基于ThinkPHP 5.1及Redis缓存，自带火车头api方便我们采集发布，功能就不多说了，可以看下面的截图，漫画系统都差不多。作者更新也积极，貌似还计划加入会员系统等其他功能，这里就发一下。\n\n图片预览\n----\n\n[![小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API](https://www.mosq.cn/usr/uploads/sina/5cc3f8bea185f.jpg \"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\")](https://www.mosq.cn/usr/uploads/sina/5cc3f8bea185f.jpg) [![小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API](https://www.mosq.cn/usr/uploads/sina/5cc3f8beaecdc.jpg \"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\")](https://www.mosq.cn/usr/uploads/sina/5cc3f8beaecdc.jpg) [![小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API](https://www.mosq.cn/usr/uploads/sina/5cc3f8bebad18.jpg \"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\")](https://www.mosq.cn/usr/uploads/sina/5cc3f8bebad18.jpg) [![小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API](https://www.mosq.cn/usr/uploads/sina/5cc3f8becdac3.jpg \"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\")](https://www.mosq.cn/usr/uploads/sina/5cc3f8becdac3.jpg)\n\n安装教程\n----\n\n环境要求：PHP 5.6-7.2、MySQL >= 5.7、Redis、Redis扩展 1、安装环境 这里依旧走简单路线，使用宝塔面板做演示，使用命令： CentOS系统\n\n    if (!-e $request_filename) {    \n          rewrite  ^(.*)$  /index.php?s=/$1  last;    \n          break;    \n        }\n\n然后打开域名开始安装程序。 如果要开启404，而不让cms报错信息显示出来，需要修改config/app.php文件： 去掉第一排的//即可\n\n    ‘exception_tmpl’         => Env::get(‘app_path’) . ‘index/view/pub/404.html’,  \n    ‘exception_tmpl’         => Env::get(‘think_path’) . ‘tpl/think_exception.tpl’,\n\n采集\n--\n\n通常情况下，漫画站图片资源分两种，一种本地化，一种盗链方式，这里建议将图片本地化，这样能保证网站资源稳定性，并且该程序还提供了火车头采集器的API，能够很简单的对接火车头采集器进行漫画和章节图片的采集。 首先我们需要一个火车采集器，官网→传送门，不过分为免费版和收费版，但免费版由于某些功能限制，没法满足图片本地化需求，所以暂时不适用，如果你有钱可以买一个收费版的，不过没钱也没事，可以直接使用火车头企业破解版，大概目前最新的一个破解版，也可以满足该程序的采集需求，具体怎么下载，就自行百度，很多网站提供下载链接。 注意：由于火车头V7和V8没有url编码解码功能，所以不能采集带有中文链接的漫画网站，但V9版本可以，有钱可以直接上。 采集api说明： 采集api地址：域名/api/index/save。 请求方式：post 表单字段及说明： book\\_name 漫画名 nick\\_name 漫画别名 tags 分类，多个分类用|隔开 author 作者名字 src 采集源 end 状态，1代表完结，0代表连载中 cover\\_url 封面图远程地址 chapter\\_name 章节名 images 由图片标签组成的字符串，示例：\n\n    <img src=“http://www.m.com/1.jpg”>\n    <img src=“http://www.m.com/2.jpg”>\n    <img src=“http://www.m.com/3.jpg”>\n\napi_key 用于身份验证，要和后台配置的api密钥相同 summary 漫画简介 由于采集过程有点复杂，不是很好发，所以有兴趣且不会采集的可以看下官方的使用教程[→传送门](https://www.kancloud.cn/hiliqi/xwx_comic_cms/962155)，大致步骤就是打开火车头采集器主界面-发布-新建-内容发布参数，然后发布模块编写完之后，开始找目标站并写采集规则，最后采集发布即可。 Github地址：[https://github.com/hiliqi/xiaohuanxiong](https://github.com/hiliqi/xiaohuanxiong)","slug":"e5-b0-8f-e6-b6-b4-e7-86-8a-e6-bc-ab-e7-94-bbcms-e5-bc-80-e6-ba-90-e5-85-8d-e8-b4-b9-e7-9a-84-e9-87-87-e9-9b-86-e6-bc-ab-e7-94-bb-e8-bf-9e-e8-bd-bd-e7-b3-bb-e7-bb-9f-ef-bc-8c-e5-b8-a6-e9-87-87","published":1,"updated":"2019-09-10T07:46:08.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269b0001dc8gsg2ro703j","content":"<h2 id=\"源码简介\"><a href=\"#源码简介\" class=\"headerlink\" title=\"源码简介\"></a>源码简介</h2><p>小涴熊漫画CMS，开源免费，基于ThinkPHP 5.1及Redis缓存，自带火车头api方便我们采集发布，功能就不多说了，可以看下面的截图，漫画系统都差不多。作者更新也积极，貌似还计划加入会员系统等其他功能，这里就发一下。</p>\n<h2 id=\"图片预览\"><a href=\"#图片预览\" class=\"headerlink\" title=\"图片预览\"></a>图片预览</h2><p><a href=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8bea185f.jpg\"><img src=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8bea185f.jpg\" alt=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\" title=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\"></a> <a href=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8beaecdc.jpg\"><img src=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8beaecdc.jpg\" alt=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\" title=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\"></a> <a href=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8bebad18.jpg\"><img src=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8bebad18.jpg\" alt=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\" title=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\"></a> <a href=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8becdac3.jpg\"><img src=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8becdac3.jpg\" alt=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\" title=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\"></a></p>\n<h2 id=\"安装教程\"><a href=\"#安装教程\" class=\"headerlink\" title=\"安装教程\"></a>安装教程</h2><p>环境要求：PHP 5.6-7.2、MySQL &gt;= 5.7、Redis、Redis扩展 1、安装环境 这里依旧走简单路线，使用宝塔面板做演示，使用命令： CentOS系统</p>\n<pre><code>if (!-e $request_filename) &#123;    \n      rewrite  ^(.*)$  /index.php?s=/$1  last;    \n      break;    \n    &#125;\n</code></pre>\n<p>然后打开域名开始安装程序。 如果要开启404，而不让cms报错信息显示出来，需要修改config/app.php文件： 去掉第一排的//即可</p>\n<pre><code>‘exception_tmpl’         =&gt; Env::get(‘app_path’) . ‘index/view/pub/404.html’,  \n‘exception_tmpl’         =&gt; Env::get(‘think_path’) . ‘tpl/think_exception.tpl’,\n</code></pre>\n<h2 id=\"采集\"><a href=\"#采集\" class=\"headerlink\" title=\"采集\"></a>采集</h2><p>通常情况下，漫画站图片资源分两种，一种本地化，一种盗链方式，这里建议将图片本地化，这样能保证网站资源稳定性，并且该程序还提供了火车头采集器的API，能够很简单的对接火车头采集器进行漫画和章节图片的采集。 首先我们需要一个火车采集器，官网→传送门，不过分为免费版和收费版，但免费版由于某些功能限制，没法满足图片本地化需求，所以暂时不适用，如果你有钱可以买一个收费版的，不过没钱也没事，可以直接使用火车头企业破解版，大概目前最新的一个破解版，也可以满足该程序的采集需求，具体怎么下载，就自行百度，很多网站提供下载链接。 注意：由于火车头V7和V8没有url编码解码功能，所以不能采集带有中文链接的漫画网站，但V9版本可以，有钱可以直接上。 采集api说明： 采集api地址：域名/api/index/save。 请求方式：post 表单字段及说明： book_name 漫画名 nick_name 漫画别名 tags 分类，多个分类用|隔开 author 作者名字 src 采集源 end 状态，1代表完结，0代表连载中 cover_url 封面图远程地址 chapter_name 章节名 images 由图片标签组成的字符串，示例：</p>\n<pre><code>&lt;img src=“http://www.m.com/1.jpg”&gt;\n&lt;img src=“http://www.m.com/2.jpg”&gt;\n&lt;img src=“http://www.m.com/3.jpg”&gt;\n</code></pre>\n<p>api_key 用于身份验证，要和后台配置的api密钥相同 summary 漫画简介 由于采集过程有点复杂，不是很好发，所以有兴趣且不会采集的可以看下官方的使用教程<a href=\"https://www.kancloud.cn/hiliqi/xwx_comic_cms/962155\">→传送门</a>，大致步骤就是打开火车头采集器主界面-发布-新建-内容发布参数，然后发布模块编写完之后，开始找目标站并写采集规则，最后采集发布即可。 Github地址：<a href=\"https://github.com/hiliqi/xiaohuanxiong\">https://github.com/hiliqi/xiaohuanxiong</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"源码简介\"><a href=\"#源码简介\" class=\"headerlink\" title=\"源码简介\"></a>源码简介</h2><p>小涴熊漫画CMS，开源免费，基于ThinkPHP 5.1及Redis缓存，自带火车头api方便我们采集发布，功能就不多说了，可以看下面的截图，漫画系统都差不多。作者更新也积极，貌似还计划加入会员系统等其他功能，这里就发一下。</p>\n<h2 id=\"图片预览\"><a href=\"#图片预览\" class=\"headerlink\" title=\"图片预览\"></a>图片预览</h2><p><a href=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8bea185f.jpg\"><img src=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8bea185f.jpg\" alt=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\" title=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\"></a> <a href=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8beaecdc.jpg\"><img src=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8beaecdc.jpg\" alt=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\" title=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\"></a> <a href=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8bebad18.jpg\"><img src=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8bebad18.jpg\" alt=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\" title=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\"></a> <a href=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8becdac3.jpg\"><img src=\"https://www.mosq.cn/usr/uploads/sina/5cc3f8becdac3.jpg\" alt=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\" title=\"小涴熊漫画CMS-开源免费的采集漫画连载系统，带采集API\"></a></p>\n<h2 id=\"安装教程\"><a href=\"#安装教程\" class=\"headerlink\" title=\"安装教程\"></a>安装教程</h2><p>环境要求：PHP 5.6-7.2、MySQL &gt;= 5.7、Redis、Redis扩展 1、安装环境 这里依旧走简单路线，使用宝塔面板做演示，使用命令： CentOS系统</p>\n<pre><code>if (!-e $request_filename) &#123;    \n      rewrite  ^(.*)$  /index.php?s=/$1  last;    \n      break;    \n    &#125;\n</code></pre>\n<p>然后打开域名开始安装程序。 如果要开启404，而不让cms报错信息显示出来，需要修改config/app.php文件： 去掉第一排的//即可</p>\n<pre><code>‘exception_tmpl’         =&gt; Env::get(‘app_path’) . ‘index/view/pub/404.html’,  \n‘exception_tmpl’         =&gt; Env::get(‘think_path’) . ‘tpl/think_exception.tpl’,\n</code></pre>\n<h2 id=\"采集\"><a href=\"#采集\" class=\"headerlink\" title=\"采集\"></a>采集</h2><p>通常情况下，漫画站图片资源分两种，一种本地化，一种盗链方式，这里建议将图片本地化，这样能保证网站资源稳定性，并且该程序还提供了火车头采集器的API，能够很简单的对接火车头采集器进行漫画和章节图片的采集。 首先我们需要一个火车采集器，官网→传送门，不过分为免费版和收费版，但免费版由于某些功能限制，没法满足图片本地化需求，所以暂时不适用，如果你有钱可以买一个收费版的，不过没钱也没事，可以直接使用火车头企业破解版，大概目前最新的一个破解版，也可以满足该程序的采集需求，具体怎么下载，就自行百度，很多网站提供下载链接。 注意：由于火车头V7和V8没有url编码解码功能，所以不能采集带有中文链接的漫画网站，但V9版本可以，有钱可以直接上。 采集api说明： 采集api地址：域名/api/index/save。 请求方式：post 表单字段及说明： book_name 漫画名 nick_name 漫画别名 tags 分类，多个分类用|隔开 author 作者名字 src 采集源 end 状态，1代表完结，0代表连载中 cover_url 封面图远程地址 chapter_name 章节名 images 由图片标签组成的字符串，示例：</p>\n<pre><code>&lt;img src=“http://www.m.com/1.jpg”&gt;\n&lt;img src=“http://www.m.com/2.jpg”&gt;\n&lt;img src=“http://www.m.com/3.jpg”&gt;\n</code></pre>\n<p>api_key 用于身份验证，要和后台配置的api密钥相同 summary 漫画简介 由于采集过程有点复杂，不是很好发，所以有兴趣且不会采集的可以看下官方的使用教程<a href=\"https://www.kancloud.cn/hiliqi/xwx_comic_cms/962155\">→传送门</a>，大致步骤就是打开火车头采集器主界面-发布-新建-内容发布参数，然后发布模块编写完之后，开始找目标站并写采集规则，最后采集发布即可。 Github地址：<a href=\"https://github.com/hiliqi/xiaohuanxiong\">https://github.com/hiliqi/xiaohuanxiong</a></p>\n"},{"title":"开发Linux运维人员最常用166个命令汇总","url":"388.html","id":"388","date":"2019-08-30T11:41:29.000Z","_content":"\nLinux运维人员最常用166个命令汇总\n====================\n\n命令\n\n功能说明\n\n线上查询、帮助命令（2个）\n\nman\n\n查看命令帮助，命令词典，更复杂还有info，但不常用。\n\nhelp\n\n查看Linux内置命令的帮助，比如cd等命令。\n\n文件、目录操作命令（18个）\n\nls\n\n全拼为list，功能是列出目录的内容及其内容属性信息。\n\ncd\n\n全拼为change directory，功能是从当前工作目录切换到指定的工作目录。\n\ncp\n\n全拼为copy，功能为复制文件或目录。\n\nfind\n\n查找，用于查找目录及目录下文件。\n\nmkdir\n\n全拼为make directories，其功能是创建目录。\n\nmv\n\n全拼为move，其功能是移动或重命名文件。\n\npwd\n\n全拼为print working directory，功能是显示当前工作目录的绝对路径。\n\nrename\n\n用于重新命名文件。\n\nrm\n\n全拼为remove，其功能是删除一个或多个文件或目录。\n\nrmdir\n\n全拼为remove empty directories，功能是删除空目录。\n\ntouch\n\n创建个空文件，改变已有文件的时间戳属性。\n\ntree\n\n功能是以树形结构显示目录下的内容。\n\nbasename\n\n显示文件名或着目录名。\n\ndirname\n\n显示文件或着目录路径。\n\nchattr\n\n改变文件扩展属性。\n\nlsattr\n\n查看文件扩展属性。\n\nfile\n\n显示文件类型。\n\nmd5sum\n\n计算和校验文件的MD5值。\n\n查看文件、内容处理命令（21个）\n\ncat\n\n全拼为concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。\n\ntac\n\ntac是cat的反向拼写，因此命令的功能为反向显示文件内容。\n\nmore\n\n分页显示文件内容。\n\nless\n\n分页显示文件内容，more命令的相反用法。\n\nhead\n\n显示文件内容头部。\n\ntail\n\n显示文件内容尾部。\n\ncut\n\n将文件的每一行按指定分隔符分割并输出。\n\nsplit\n\n分割文件为不同的片段。\n\npaste\n\n按行合并文件内容。\n\nsort\n\n对文件的文本内容排序。\n\nuniq\n\n去除掉重复行。\n\nwc\n\n统计文件行数、单词数或是字节数。\n\niconv\n\n转换文件编码格式。\n\ndos2unix\n\n将DOS格式文件转换成UNIX格式。\n\ndiff\n\n全拼为difference，比较文件差异，用于文本文件。\n\nvimdiff\n\n命令行可视化文件比较工具，用于文本文件。\n\nrev\n\n反向输出文件内容。\n\ngrep/egrep\n\n常用于过滤字符串。\n\njoin\n\n按两个文件的相同字段合并。\n\ntr\n\n替换、删除字符。\n\nvi/vim\n\n命令行文本编辑器。\n\n文件压缩及解压缩命令（4个）\n\ntar\n\n打包压缩。\n\nunzip\n\n解压文件。\n\ngzip\n\n压缩工具。\n\nzip\n\n压缩工具。\n\n信息显示命令（11个）\n\nuname\n\n显示操作系统相关信息。\n\nhostname\n\n显示或者设置当前系统的主机名。\n\ndmesg\n\n显示开机信息，用于诊断系统故障。\n\nuptime\n\n显示系统运行时间以及负载。\n\nstat\n\n显示文件或文件系统的状态。\n\ndu\n\n计算磁盘空间使用情况。\n\ndf\n\n报告文件系统磁盘空间使用情况。\n\ntop\n\n实时显示系统资源使用情况。\n\nfree\n\n查看系统内存。\n\ndate\n\n显示、设置系统时间。\n\ncal\n\n查看日历、时间信息。\n\n搜索文件命令（4个）\n\nwhich\n\n查找二进制文件的命令，按环境变量PATH路径查找。\n\nfind\n\n从磁盘遍历查找文件或目录。\n\nwhereis\n\n查找二进制文件的命令，按环境变量PATH路径查找。\n\nlocate\n\n从数据库/var/lib/mlocate/mlocate.db中查找命令，使用updatedb更新库。\n\n用户管理命令（10个）\n\nuseradd\n\n添加用户。\n\nusermod\n\n修改系统已经存在用户属性。\n\nuserdel\n\n删除用户。\n\ngroupadd\n\n添加用户群组。\n\npasswd\n\n修改用户密码。\n\nchage\n\n修改用户密码有效期限。\n\nid\n\n查看用户的uid/gid及归属的用户群组。\n\nsu\n\n切换用户身份。\n\nvisudo\n\n编辑/etc/sudoers文件的专属命令。\n\nsudo\n\n以另外一用户身份（默认为root用户）执行事先在sudoers文件中允许的命令。\n\n基础网络操作命令（11个）\n\ntelnet\n\n用TELNET协议远程登录。\n\nssh\n\n用SSH加密协议远程登录。\n\nscp\n\n全拼为secure copy，用于不同主机之间复制文件。\n\nwget\n\n用命令行下载文件。\n\nping\n\n测试主机之间网络的连通性。\n\nroute\n\n显示和设置linux系统的路由表。\n\nifconfig\n\n查看、配置、启用或禁用网络接口的命令。\n\nifup\n\n启动网卡。\n\nifdown\n\n关闭网卡。\n\nnetstat\n\n查看网络状态。\n\nss\n\n查看网络状态。\n\n深入网络操作命令（9个）\n\nnmap\n\n网络扫描命令。\n\nlsof\n\n全名为list open files，也就是列举系统中已经被打开的文件。\n\nmail\n\n发送、接收邮件。\n\nmutt\n\n邮件管理命令。\n\nnslookup\n\n查询互联网DNS服务器的命令。\n\ndig\n\n查找DNS的解析过程。\n\nhost\n\n查询DNS的命令。\n\ntraceroute\n\n追踪数据传输路由状况。\n\ntcpdump\n\n命令行的抓包工具。\n\n有关磁盘与文件系统的命令（16个）\n\nmount\n\n挂载文件系统。\n\numount\n\n卸载文件系统。\n\nfsck\n\n检查并修复Linux文件系统。\n\ndd\n\n转换、复制文件。\n\ndumpe2fs\n\n导出ext2/ext3/ext4等文件系统信息。\n\ndump\n\next2/3/4等文件系统备份工具。\n\nfdisk\n\n磁盘分区命令，适用于2TB以下磁盘分区。\n\nparted\n\n磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。\n\nmkfs\n\n格式化创建Linux文件系统。\n\npartprobe\n\n更新内核的硬盘分区表信息。\n\ne2fsck\n\n检查ext2/ext3/ext4等类型文件系统。\n\nmkswap\n\n创建Linux的交换分区。\n\nswapon\n\n启用交换分区。\n\nswapoff\n\n关闭交换分区。\n\nsync\n\n将内存缓冲区内的数据写入磁盘。\n\nresize2fs\n\n调整ext2/ext3/ext4等文件系统大小。\n\n系统权限、用户授权相关命令（4个）\n\nchmod\n\n改变文件、目录权限。\n\nchown\n\n改变文件、目录的属主和属组。\n\nchgrp\n\n更改文件用户群组。\n\numask\n\n显示、设置权限掩码。\n\n查看系统用户登陆信息命令（7个）\n\nwhoami\n\n显示当前有效用户名称，相当于执行id -un命令。\n\nwho\n\n显示目前已登录系统的用户信息。\n\nw\n\n显示已登陆系统的用户列表，并显示用户正在执行的指令。\n\nlast\n\n显示已登入系统的用户。\n\nlastlog\n\n显示系统中所有用户最近一次的登录信息。\n\nusers\n\n显示当前登录系统的所有用户的用户列表。\n\nfinger\n\n查找、显示用户信息。\n\n内置命令、其它（19个）\n\necho\n\n打印变量，直接输出指定的字符串\n\nprintf\n\n将结果格式化输出到标准输出中。\n\nrpm\n\n管理rpm包命令。\n\nyum\n\n自动化简单化地管理rpm包的命令。\n\nwatch\n\n周期的执行给定的命令，并将命令的输出以全屏方式显示。\n\nalias\n\n设置系统别名。\n\nunalias\n\n取消系统别名。\n\ndate\n\n查看、设置系统时间。\n\nclear\n\n清除屏幕，简称清屏。\n\nhistory\n\n查看命令执行的历史纪录。\n\neject\n\n弹出光驱。\n\ntime\n\n计算命令执行时间。\n\nnc\n\n功能强大网络工具。\n\nxargs\n\n将标准输入转换成命令行的参数。\n\nexec\n\n调用并执行指令的命令。\n\nexport\n\n设置或者显示环境变量。\n\nunset\n\n删除变量、函数。\n\ntype\n\n用于判断另外一个命令是否为内置的命令。\n\nbc\n\n命令行科学计算器\n\n系统管理、性能监视命令（9个）\n\nchkconfig\n\n管理Linux系统开机启动项。\n\nvmstat\n\n虚拟内存统计。\n\nmpstat\n\n显示各个可用CPU的状态统计。\n\niostat\n\n统计系统的IO。\n\nsar\n\n全面地获取系统CPU、运行队列、磁盘读写、分页、内存、 CPU中断和网络性能数据。\n\nipcs\n\n用于报告Linux中进程间通信设施的状态，显示信息包括消息列表、共享内存和信号量信息。\n\nipcrm\n\n用来删除一个或更多的消息队列、信号量集或者共享内存标识。\n\nstrace\n\n用于诊断、调试Linux用户空间跟踪器。我们用它来监控用户空间进程和内核交互，比如系统调用、信号传递、进程状态变更。\n\nltrace\n\n命令会跟踪进程库函数调用，它会显现哪个库函数被调用。\n\n关机/重启/注销和查看系统信息的命令（6个）\n\nshutdown\n\n关机。\n\nhalt\n\n关机。\n\npoweroff\n\n关闭电源。\n\nlogout\n\n退出当前登录的Shell。\n\nexit\n\n退出当前登录的Shell。\n\nCtrl+d\n\n退出当前登录的Shell的快捷键。\n\n进程管理相关命令（15个）\n\nbg\n\n将一个后台暂停的命令，变成继续执行。\n\nfg\n\n将后台的命令调至前台继续运行。\n\njobs\n\n查看当前有多少后台运行的命令。\n\nkill\n\n终止进程。\n\nkillall\n\n通过进程名来终止进程。\n\npkill\n\n通过进程名来终止进程。\n\ncrontab\n\n定时任务命令。\n\nps\n\n显示进程快照。\n\npstree\n\n树形显示进程。\n\nnice/renice\n\n调整程序运行的优先级。\n\nnohup\n\n忽略挂起信号运行指定。\n\npgrep\n\n查找匹配条件进程。\n\nrunlevel\n\n查看系统当前运行级别。\n\ninit\n\n切换运行级别。\n\nservice\n\n启动、停止、重新启动、关闭系统服务，还可以显示所有系统服务的当前状态。","source":"_posts/e5-bc-80-e5-8f-91linux-e8-bf-90-e7-bb-b4-e4-ba-ba-e5-91-98-e6-9c-80-e5-b8-b8-e7-94-a8166-e4-b8-aa-e5-91-bd-e4-bb-a4-e6-b1-87-e6-80-bb.md","raw":"---\ntitle: 开发Linux运维人员最常用166个命令汇总\ntags:\n  - Linux\nurl: 388.html\nid: 388\ncategories:\n  - 服务端\ndate: 2019-08-30 19:41:29\n---\n\nLinux运维人员最常用166个命令汇总\n====================\n\n命令\n\n功能说明\n\n线上查询、帮助命令（2个）\n\nman\n\n查看命令帮助，命令词典，更复杂还有info，但不常用。\n\nhelp\n\n查看Linux内置命令的帮助，比如cd等命令。\n\n文件、目录操作命令（18个）\n\nls\n\n全拼为list，功能是列出目录的内容及其内容属性信息。\n\ncd\n\n全拼为change directory，功能是从当前工作目录切换到指定的工作目录。\n\ncp\n\n全拼为copy，功能为复制文件或目录。\n\nfind\n\n查找，用于查找目录及目录下文件。\n\nmkdir\n\n全拼为make directories，其功能是创建目录。\n\nmv\n\n全拼为move，其功能是移动或重命名文件。\n\npwd\n\n全拼为print working directory，功能是显示当前工作目录的绝对路径。\n\nrename\n\n用于重新命名文件。\n\nrm\n\n全拼为remove，其功能是删除一个或多个文件或目录。\n\nrmdir\n\n全拼为remove empty directories，功能是删除空目录。\n\ntouch\n\n创建个空文件，改变已有文件的时间戳属性。\n\ntree\n\n功能是以树形结构显示目录下的内容。\n\nbasename\n\n显示文件名或着目录名。\n\ndirname\n\n显示文件或着目录路径。\n\nchattr\n\n改变文件扩展属性。\n\nlsattr\n\n查看文件扩展属性。\n\nfile\n\n显示文件类型。\n\nmd5sum\n\n计算和校验文件的MD5值。\n\n查看文件、内容处理命令（21个）\n\ncat\n\n全拼为concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。\n\ntac\n\ntac是cat的反向拼写，因此命令的功能为反向显示文件内容。\n\nmore\n\n分页显示文件内容。\n\nless\n\n分页显示文件内容，more命令的相反用法。\n\nhead\n\n显示文件内容头部。\n\ntail\n\n显示文件内容尾部。\n\ncut\n\n将文件的每一行按指定分隔符分割并输出。\n\nsplit\n\n分割文件为不同的片段。\n\npaste\n\n按行合并文件内容。\n\nsort\n\n对文件的文本内容排序。\n\nuniq\n\n去除掉重复行。\n\nwc\n\n统计文件行数、单词数或是字节数。\n\niconv\n\n转换文件编码格式。\n\ndos2unix\n\n将DOS格式文件转换成UNIX格式。\n\ndiff\n\n全拼为difference，比较文件差异，用于文本文件。\n\nvimdiff\n\n命令行可视化文件比较工具，用于文本文件。\n\nrev\n\n反向输出文件内容。\n\ngrep/egrep\n\n常用于过滤字符串。\n\njoin\n\n按两个文件的相同字段合并。\n\ntr\n\n替换、删除字符。\n\nvi/vim\n\n命令行文本编辑器。\n\n文件压缩及解压缩命令（4个）\n\ntar\n\n打包压缩。\n\nunzip\n\n解压文件。\n\ngzip\n\n压缩工具。\n\nzip\n\n压缩工具。\n\n信息显示命令（11个）\n\nuname\n\n显示操作系统相关信息。\n\nhostname\n\n显示或者设置当前系统的主机名。\n\ndmesg\n\n显示开机信息，用于诊断系统故障。\n\nuptime\n\n显示系统运行时间以及负载。\n\nstat\n\n显示文件或文件系统的状态。\n\ndu\n\n计算磁盘空间使用情况。\n\ndf\n\n报告文件系统磁盘空间使用情况。\n\ntop\n\n实时显示系统资源使用情况。\n\nfree\n\n查看系统内存。\n\ndate\n\n显示、设置系统时间。\n\ncal\n\n查看日历、时间信息。\n\n搜索文件命令（4个）\n\nwhich\n\n查找二进制文件的命令，按环境变量PATH路径查找。\n\nfind\n\n从磁盘遍历查找文件或目录。\n\nwhereis\n\n查找二进制文件的命令，按环境变量PATH路径查找。\n\nlocate\n\n从数据库/var/lib/mlocate/mlocate.db中查找命令，使用updatedb更新库。\n\n用户管理命令（10个）\n\nuseradd\n\n添加用户。\n\nusermod\n\n修改系统已经存在用户属性。\n\nuserdel\n\n删除用户。\n\ngroupadd\n\n添加用户群组。\n\npasswd\n\n修改用户密码。\n\nchage\n\n修改用户密码有效期限。\n\nid\n\n查看用户的uid/gid及归属的用户群组。\n\nsu\n\n切换用户身份。\n\nvisudo\n\n编辑/etc/sudoers文件的专属命令。\n\nsudo\n\n以另外一用户身份（默认为root用户）执行事先在sudoers文件中允许的命令。\n\n基础网络操作命令（11个）\n\ntelnet\n\n用TELNET协议远程登录。\n\nssh\n\n用SSH加密协议远程登录。\n\nscp\n\n全拼为secure copy，用于不同主机之间复制文件。\n\nwget\n\n用命令行下载文件。\n\nping\n\n测试主机之间网络的连通性。\n\nroute\n\n显示和设置linux系统的路由表。\n\nifconfig\n\n查看、配置、启用或禁用网络接口的命令。\n\nifup\n\n启动网卡。\n\nifdown\n\n关闭网卡。\n\nnetstat\n\n查看网络状态。\n\nss\n\n查看网络状态。\n\n深入网络操作命令（9个）\n\nnmap\n\n网络扫描命令。\n\nlsof\n\n全名为list open files，也就是列举系统中已经被打开的文件。\n\nmail\n\n发送、接收邮件。\n\nmutt\n\n邮件管理命令。\n\nnslookup\n\n查询互联网DNS服务器的命令。\n\ndig\n\n查找DNS的解析过程。\n\nhost\n\n查询DNS的命令。\n\ntraceroute\n\n追踪数据传输路由状况。\n\ntcpdump\n\n命令行的抓包工具。\n\n有关磁盘与文件系统的命令（16个）\n\nmount\n\n挂载文件系统。\n\numount\n\n卸载文件系统。\n\nfsck\n\n检查并修复Linux文件系统。\n\ndd\n\n转换、复制文件。\n\ndumpe2fs\n\n导出ext2/ext3/ext4等文件系统信息。\n\ndump\n\next2/3/4等文件系统备份工具。\n\nfdisk\n\n磁盘分区命令，适用于2TB以下磁盘分区。\n\nparted\n\n磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。\n\nmkfs\n\n格式化创建Linux文件系统。\n\npartprobe\n\n更新内核的硬盘分区表信息。\n\ne2fsck\n\n检查ext2/ext3/ext4等类型文件系统。\n\nmkswap\n\n创建Linux的交换分区。\n\nswapon\n\n启用交换分区。\n\nswapoff\n\n关闭交换分区。\n\nsync\n\n将内存缓冲区内的数据写入磁盘。\n\nresize2fs\n\n调整ext2/ext3/ext4等文件系统大小。\n\n系统权限、用户授权相关命令（4个）\n\nchmod\n\n改变文件、目录权限。\n\nchown\n\n改变文件、目录的属主和属组。\n\nchgrp\n\n更改文件用户群组。\n\numask\n\n显示、设置权限掩码。\n\n查看系统用户登陆信息命令（7个）\n\nwhoami\n\n显示当前有效用户名称，相当于执行id -un命令。\n\nwho\n\n显示目前已登录系统的用户信息。\n\nw\n\n显示已登陆系统的用户列表，并显示用户正在执行的指令。\n\nlast\n\n显示已登入系统的用户。\n\nlastlog\n\n显示系统中所有用户最近一次的登录信息。\n\nusers\n\n显示当前登录系统的所有用户的用户列表。\n\nfinger\n\n查找、显示用户信息。\n\n内置命令、其它（19个）\n\necho\n\n打印变量，直接输出指定的字符串\n\nprintf\n\n将结果格式化输出到标准输出中。\n\nrpm\n\n管理rpm包命令。\n\nyum\n\n自动化简单化地管理rpm包的命令。\n\nwatch\n\n周期的执行给定的命令，并将命令的输出以全屏方式显示。\n\nalias\n\n设置系统别名。\n\nunalias\n\n取消系统别名。\n\ndate\n\n查看、设置系统时间。\n\nclear\n\n清除屏幕，简称清屏。\n\nhistory\n\n查看命令执行的历史纪录。\n\neject\n\n弹出光驱。\n\ntime\n\n计算命令执行时间。\n\nnc\n\n功能强大网络工具。\n\nxargs\n\n将标准输入转换成命令行的参数。\n\nexec\n\n调用并执行指令的命令。\n\nexport\n\n设置或者显示环境变量。\n\nunset\n\n删除变量、函数。\n\ntype\n\n用于判断另外一个命令是否为内置的命令。\n\nbc\n\n命令行科学计算器\n\n系统管理、性能监视命令（9个）\n\nchkconfig\n\n管理Linux系统开机启动项。\n\nvmstat\n\n虚拟内存统计。\n\nmpstat\n\n显示各个可用CPU的状态统计。\n\niostat\n\n统计系统的IO。\n\nsar\n\n全面地获取系统CPU、运行队列、磁盘读写、分页、内存、 CPU中断和网络性能数据。\n\nipcs\n\n用于报告Linux中进程间通信设施的状态，显示信息包括消息列表、共享内存和信号量信息。\n\nipcrm\n\n用来删除一个或更多的消息队列、信号量集或者共享内存标识。\n\nstrace\n\n用于诊断、调试Linux用户空间跟踪器。我们用它来监控用户空间进程和内核交互，比如系统调用、信号传递、进程状态变更。\n\nltrace\n\n命令会跟踪进程库函数调用，它会显现哪个库函数被调用。\n\n关机/重启/注销和查看系统信息的命令（6个）\n\nshutdown\n\n关机。\n\nhalt\n\n关机。\n\npoweroff\n\n关闭电源。\n\nlogout\n\n退出当前登录的Shell。\n\nexit\n\n退出当前登录的Shell。\n\nCtrl+d\n\n退出当前登录的Shell的快捷键。\n\n进程管理相关命令（15个）\n\nbg\n\n将一个后台暂停的命令，变成继续执行。\n\nfg\n\n将后台的命令调至前台继续运行。\n\njobs\n\n查看当前有多少后台运行的命令。\n\nkill\n\n终止进程。\n\nkillall\n\n通过进程名来终止进程。\n\npkill\n\n通过进程名来终止进程。\n\ncrontab\n\n定时任务命令。\n\nps\n\n显示进程快照。\n\npstree\n\n树形显示进程。\n\nnice/renice\n\n调整程序运行的优先级。\n\nnohup\n\n忽略挂起信号运行指定。\n\npgrep\n\n查找匹配条件进程。\n\nrunlevel\n\n查看系统当前运行级别。\n\ninit\n\n切换运行级别。\n\nservice\n\n启动、停止、重新启动、关闭系统服务，还可以显示所有系统服务的当前状态。","slug":"e5-bc-80-e5-8f-91linux-e8-bf-90-e7-bb-b4-e4-ba-ba-e5-91-98-e6-9c-80-e5-b8-b8-e7-94-a8166-e4-b8-aa-e5-91-bd-e4-bb-a4-e6-b1-87-e6-80-bb","published":1,"updated":"2019-09-10T07:46:08.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269b3001gc8gs3ff6ba8i","content":"<h1 id=\"Linux运维人员最常用166个命令汇总\"><a href=\"#Linux运维人员最常用166个命令汇总\" class=\"headerlink\" title=\"Linux运维人员最常用166个命令汇总\"></a>Linux运维人员最常用166个命令汇总</h1><p>命令</p>\n<p>功能说明</p>\n<p>线上查询、帮助命令（2个）</p>\n<p>man</p>\n<p>查看命令帮助，命令词典，更复杂还有info，但不常用。</p>\n<p>help</p>\n<p>查看Linux内置命令的帮助，比如cd等命令。</p>\n<p>文件、目录操作命令（18个）</p>\n<p>ls</p>\n<p>全拼为list，功能是列出目录的内容及其内容属性信息。</p>\n<p>cd</p>\n<p>全拼为change directory，功能是从当前工作目录切换到指定的工作目录。</p>\n<p>cp</p>\n<p>全拼为copy，功能为复制文件或目录。</p>\n<p>find</p>\n<p>查找，用于查找目录及目录下文件。</p>\n<p>mkdir</p>\n<p>全拼为make directories，其功能是创建目录。</p>\n<p>mv</p>\n<p>全拼为move，其功能是移动或重命名文件。</p>\n<p>pwd</p>\n<p>全拼为print working directory，功能是显示当前工作目录的绝对路径。</p>\n<p>rename</p>\n<p>用于重新命名文件。</p>\n<p>rm</p>\n<p>全拼为remove，其功能是删除一个或多个文件或目录。</p>\n<p>rmdir</p>\n<p>全拼为remove empty directories，功能是删除空目录。</p>\n<p>touch</p>\n<p>创建个空文件，改变已有文件的时间戳属性。</p>\n<p>tree</p>\n<p>功能是以树形结构显示目录下的内容。</p>\n<p>basename</p>\n<p>显示文件名或着目录名。</p>\n<p>dirname</p>\n<p>显示文件或着目录路径。</p>\n<p>chattr</p>\n<p>改变文件扩展属性。</p>\n<p>lsattr</p>\n<p>查看文件扩展属性。</p>\n<p>file</p>\n<p>显示文件类型。</p>\n<p>md5sum</p>\n<p>计算和校验文件的MD5值。</p>\n<p>查看文件、内容处理命令（21个）</p>\n<p>cat</p>\n<p>全拼为concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。</p>\n<p>tac</p>\n<p>tac是cat的反向拼写，因此命令的功能为反向显示文件内容。</p>\n<p>more</p>\n<p>分页显示文件内容。</p>\n<p>less</p>\n<p>分页显示文件内容，more命令的相反用法。</p>\n<p>head</p>\n<p>显示文件内容头部。</p>\n<p>tail</p>\n<p>显示文件内容尾部。</p>\n<p>cut</p>\n<p>将文件的每一行按指定分隔符分割并输出。</p>\n<p>split</p>\n<p>分割文件为不同的片段。</p>\n<p>paste</p>\n<p>按行合并文件内容。</p>\n<p>sort</p>\n<p>对文件的文本内容排序。</p>\n<p>uniq</p>\n<p>去除掉重复行。</p>\n<p>wc</p>\n<p>统计文件行数、单词数或是字节数。</p>\n<p>iconv</p>\n<p>转换文件编码格式。</p>\n<p>dos2unix</p>\n<p>将DOS格式文件转换成UNIX格式。</p>\n<p>diff</p>\n<p>全拼为difference，比较文件差异，用于文本文件。</p>\n<p>vimdiff</p>\n<p>命令行可视化文件比较工具，用于文本文件。</p>\n<p>rev</p>\n<p>反向输出文件内容。</p>\n<p>grep/egrep</p>\n<p>常用于过滤字符串。</p>\n<p>join</p>\n<p>按两个文件的相同字段合并。</p>\n<p>tr</p>\n<p>替换、删除字符。</p>\n<p>vi/vim</p>\n<p>命令行文本编辑器。</p>\n<p>文件压缩及解压缩命令（4个）</p>\n<p>tar</p>\n<p>打包压缩。</p>\n<p>unzip</p>\n<p>解压文件。</p>\n<p>gzip</p>\n<p>压缩工具。</p>\n<p>zip</p>\n<p>压缩工具。</p>\n<p>信息显示命令（11个）</p>\n<p>uname</p>\n<p>显示操作系统相关信息。</p>\n<p>hostname</p>\n<p>显示或者设置当前系统的主机名。</p>\n<p>dmesg</p>\n<p>显示开机信息，用于诊断系统故障。</p>\n<p>uptime</p>\n<p>显示系统运行时间以及负载。</p>\n<p>stat</p>\n<p>显示文件或文件系统的状态。</p>\n<p>du</p>\n<p>计算磁盘空间使用情况。</p>\n<p>df</p>\n<p>报告文件系统磁盘空间使用情况。</p>\n<p>top</p>\n<p>实时显示系统资源使用情况。</p>\n<p>free</p>\n<p>查看系统内存。</p>\n<p>date</p>\n<p>显示、设置系统时间。</p>\n<p>cal</p>\n<p>查看日历、时间信息。</p>\n<p>搜索文件命令（4个）</p>\n<p>which</p>\n<p>查找二进制文件的命令，按环境变量PATH路径查找。</p>\n<p>find</p>\n<p>从磁盘遍历查找文件或目录。</p>\n<p>whereis</p>\n<p>查找二进制文件的命令，按环境变量PATH路径查找。</p>\n<p>locate</p>\n<p>从数据库/var/lib/mlocate/mlocate.db中查找命令，使用updatedb更新库。</p>\n<p>用户管理命令（10个）</p>\n<p>useradd</p>\n<p>添加用户。</p>\n<p>usermod</p>\n<p>修改系统已经存在用户属性。</p>\n<p>userdel</p>\n<p>删除用户。</p>\n<p>groupadd</p>\n<p>添加用户群组。</p>\n<p>passwd</p>\n<p>修改用户密码。</p>\n<p>chage</p>\n<p>修改用户密码有效期限。</p>\n<p>id</p>\n<p>查看用户的uid/gid及归属的用户群组。</p>\n<p>su</p>\n<p>切换用户身份。</p>\n<p>visudo</p>\n<p>编辑/etc/sudoers文件的专属命令。</p>\n<p>sudo</p>\n<p>以另外一用户身份（默认为root用户）执行事先在sudoers文件中允许的命令。</p>\n<p>基础网络操作命令（11个）</p>\n<p>telnet</p>\n<p>用TELNET协议远程登录。</p>\n<p>ssh</p>\n<p>用SSH加密协议远程登录。</p>\n<p>scp</p>\n<p>全拼为secure copy，用于不同主机之间复制文件。</p>\n<p>wget</p>\n<p>用命令行下载文件。</p>\n<p>ping</p>\n<p>测试主机之间网络的连通性。</p>\n<p>route</p>\n<p>显示和设置linux系统的路由表。</p>\n<p>ifconfig</p>\n<p>查看、配置、启用或禁用网络接口的命令。</p>\n<p>ifup</p>\n<p>启动网卡。</p>\n<p>ifdown</p>\n<p>关闭网卡。</p>\n<p>netstat</p>\n<p>查看网络状态。</p>\n<p>ss</p>\n<p>查看网络状态。</p>\n<p>深入网络操作命令（9个）</p>\n<p>nmap</p>\n<p>网络扫描命令。</p>\n<p>lsof</p>\n<p>全名为list open files，也就是列举系统中已经被打开的文件。</p>\n<p>mail</p>\n<p>发送、接收邮件。</p>\n<p>mutt</p>\n<p>邮件管理命令。</p>\n<p>nslookup</p>\n<p>查询互联网DNS服务器的命令。</p>\n<p>dig</p>\n<p>查找DNS的解析过程。</p>\n<p>host</p>\n<p>查询DNS的命令。</p>\n<p>traceroute</p>\n<p>追踪数据传输路由状况。</p>\n<p>tcpdump</p>\n<p>命令行的抓包工具。</p>\n<p>有关磁盘与文件系统的命令（16个）</p>\n<p>mount</p>\n<p>挂载文件系统。</p>\n<p>umount</p>\n<p>卸载文件系统。</p>\n<p>fsck</p>\n<p>检查并修复Linux文件系统。</p>\n<p>dd</p>\n<p>转换、复制文件。</p>\n<p>dumpe2fs</p>\n<p>导出ext2/ext3/ext4等文件系统信息。</p>\n<p>dump</p>\n<p>ext2/3/4等文件系统备份工具。</p>\n<p>fdisk</p>\n<p>磁盘分区命令，适用于2TB以下磁盘分区。</p>\n<p>parted</p>\n<p>磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。</p>\n<p>mkfs</p>\n<p>格式化创建Linux文件系统。</p>\n<p>partprobe</p>\n<p>更新内核的硬盘分区表信息。</p>\n<p>e2fsck</p>\n<p>检查ext2/ext3/ext4等类型文件系统。</p>\n<p>mkswap</p>\n<p>创建Linux的交换分区。</p>\n<p>swapon</p>\n<p>启用交换分区。</p>\n<p>swapoff</p>\n<p>关闭交换分区。</p>\n<p>sync</p>\n<p>将内存缓冲区内的数据写入磁盘。</p>\n<p>resize2fs</p>\n<p>调整ext2/ext3/ext4等文件系统大小。</p>\n<p>系统权限、用户授权相关命令（4个）</p>\n<p>chmod</p>\n<p>改变文件、目录权限。</p>\n<p>chown</p>\n<p>改变文件、目录的属主和属组。</p>\n<p>chgrp</p>\n<p>更改文件用户群组。</p>\n<p>umask</p>\n<p>显示、设置权限掩码。</p>\n<p>查看系统用户登陆信息命令（7个）</p>\n<p>whoami</p>\n<p>显示当前有效用户名称，相当于执行id -un命令。</p>\n<p>who</p>\n<p>显示目前已登录系统的用户信息。</p>\n<p>w</p>\n<p>显示已登陆系统的用户列表，并显示用户正在执行的指令。</p>\n<p>last</p>\n<p>显示已登入系统的用户。</p>\n<p>lastlog</p>\n<p>显示系统中所有用户最近一次的登录信息。</p>\n<p>users</p>\n<p>显示当前登录系统的所有用户的用户列表。</p>\n<p>finger</p>\n<p>查找、显示用户信息。</p>\n<p>内置命令、其它（19个）</p>\n<p>echo</p>\n<p>打印变量，直接输出指定的字符串</p>\n<p>printf</p>\n<p>将结果格式化输出到标准输出中。</p>\n<p>rpm</p>\n<p>管理rpm包命令。</p>\n<p>yum</p>\n<p>自动化简单化地管理rpm包的命令。</p>\n<p>watch</p>\n<p>周期的执行给定的命令，并将命令的输出以全屏方式显示。</p>\n<p>alias</p>\n<p>设置系统别名。</p>\n<p>unalias</p>\n<p>取消系统别名。</p>\n<p>date</p>\n<p>查看、设置系统时间。</p>\n<p>clear</p>\n<p>清除屏幕，简称清屏。</p>\n<p>history</p>\n<p>查看命令执行的历史纪录。</p>\n<p>eject</p>\n<p>弹出光驱。</p>\n<p>time</p>\n<p>计算命令执行时间。</p>\n<p>nc</p>\n<p>功能强大网络工具。</p>\n<p>xargs</p>\n<p>将标准输入转换成命令行的参数。</p>\n<p>exec</p>\n<p>调用并执行指令的命令。</p>\n<p>export</p>\n<p>设置或者显示环境变量。</p>\n<p>unset</p>\n<p>删除变量、函数。</p>\n<p>type</p>\n<p>用于判断另外一个命令是否为内置的命令。</p>\n<p>bc</p>\n<p>命令行科学计算器</p>\n<p>系统管理、性能监视命令（9个）</p>\n<p>chkconfig</p>\n<p>管理Linux系统开机启动项。</p>\n<p>vmstat</p>\n<p>虚拟内存统计。</p>\n<p>mpstat</p>\n<p>显示各个可用CPU的状态统计。</p>\n<p>iostat</p>\n<p>统计系统的IO。</p>\n<p>sar</p>\n<p>全面地获取系统CPU、运行队列、磁盘读写、分页、内存、 CPU中断和网络性能数据。</p>\n<p>ipcs</p>\n<p>用于报告Linux中进程间通信设施的状态，显示信息包括消息列表、共享内存和信号量信息。</p>\n<p>ipcrm</p>\n<p>用来删除一个或更多的消息队列、信号量集或者共享内存标识。</p>\n<p>strace</p>\n<p>用于诊断、调试Linux用户空间跟踪器。我们用它来监控用户空间进程和内核交互，比如系统调用、信号传递、进程状态变更。</p>\n<p>ltrace</p>\n<p>命令会跟踪进程库函数调用，它会显现哪个库函数被调用。</p>\n<p>关机/重启/注销和查看系统信息的命令（6个）</p>\n<p>shutdown</p>\n<p>关机。</p>\n<p>halt</p>\n<p>关机。</p>\n<p>poweroff</p>\n<p>关闭电源。</p>\n<p>logout</p>\n<p>退出当前登录的Shell。</p>\n<p>exit</p>\n<p>退出当前登录的Shell。</p>\n<p>Ctrl+d</p>\n<p>退出当前登录的Shell的快捷键。</p>\n<p>进程管理相关命令（15个）</p>\n<p>bg</p>\n<p>将一个后台暂停的命令，变成继续执行。</p>\n<p>fg</p>\n<p>将后台的命令调至前台继续运行。</p>\n<p>jobs</p>\n<p>查看当前有多少后台运行的命令。</p>\n<p>kill</p>\n<p>终止进程。</p>\n<p>killall</p>\n<p>通过进程名来终止进程。</p>\n<p>pkill</p>\n<p>通过进程名来终止进程。</p>\n<p>crontab</p>\n<p>定时任务命令。</p>\n<p>ps</p>\n<p>显示进程快照。</p>\n<p>pstree</p>\n<p>树形显示进程。</p>\n<p>nice/renice</p>\n<p>调整程序运行的优先级。</p>\n<p>nohup</p>\n<p>忽略挂起信号运行指定。</p>\n<p>pgrep</p>\n<p>查找匹配条件进程。</p>\n<p>runlevel</p>\n<p>查看系统当前运行级别。</p>\n<p>init</p>\n<p>切换运行级别。</p>\n<p>service</p>\n<p>启动、停止、重新启动、关闭系统服务，还可以显示所有系统服务的当前状态。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"Linux运维人员最常用166个命令汇总\"><a href=\"#Linux运维人员最常用166个命令汇总\" class=\"headerlink\" title=\"Linux运维人员最常用166个命令汇总\"></a>Linux运维人员最常用166个命令汇总</h1><p>命令</p>\n<p>功能说明</p>\n<p>线上查询、帮助命令（2个）</p>\n<p>man</p>\n<p>查看命令帮助，命令词典，更复杂还有info，但不常用。</p>\n<p>help</p>\n<p>查看Linux内置命令的帮助，比如cd等命令。</p>\n<p>文件、目录操作命令（18个）</p>\n<p>ls</p>\n<p>全拼为list，功能是列出目录的内容及其内容属性信息。</p>\n<p>cd</p>\n<p>全拼为change directory，功能是从当前工作目录切换到指定的工作目录。</p>\n<p>cp</p>\n<p>全拼为copy，功能为复制文件或目录。</p>\n<p>find</p>\n<p>查找，用于查找目录及目录下文件。</p>\n<p>mkdir</p>\n<p>全拼为make directories，其功能是创建目录。</p>\n<p>mv</p>\n<p>全拼为move，其功能是移动或重命名文件。</p>\n<p>pwd</p>\n<p>全拼为print working directory，功能是显示当前工作目录的绝对路径。</p>\n<p>rename</p>\n<p>用于重新命名文件。</p>\n<p>rm</p>\n<p>全拼为remove，其功能是删除一个或多个文件或目录。</p>\n<p>rmdir</p>\n<p>全拼为remove empty directories，功能是删除空目录。</p>\n<p>touch</p>\n<p>创建个空文件，改变已有文件的时间戳属性。</p>\n<p>tree</p>\n<p>功能是以树形结构显示目录下的内容。</p>\n<p>basename</p>\n<p>显示文件名或着目录名。</p>\n<p>dirname</p>\n<p>显示文件或着目录路径。</p>\n<p>chattr</p>\n<p>改变文件扩展属性。</p>\n<p>lsattr</p>\n<p>查看文件扩展属性。</p>\n<p>file</p>\n<p>显示文件类型。</p>\n<p>md5sum</p>\n<p>计算和校验文件的MD5值。</p>\n<p>查看文件、内容处理命令（21个）</p>\n<p>cat</p>\n<p>全拼为concatenate，功能是用于连接多个文件并且打印到屏幕输出或重定向到指定文件中。</p>\n<p>tac</p>\n<p>tac是cat的反向拼写，因此命令的功能为反向显示文件内容。</p>\n<p>more</p>\n<p>分页显示文件内容。</p>\n<p>less</p>\n<p>分页显示文件内容，more命令的相反用法。</p>\n<p>head</p>\n<p>显示文件内容头部。</p>\n<p>tail</p>\n<p>显示文件内容尾部。</p>\n<p>cut</p>\n<p>将文件的每一行按指定分隔符分割并输出。</p>\n<p>split</p>\n<p>分割文件为不同的片段。</p>\n<p>paste</p>\n<p>按行合并文件内容。</p>\n<p>sort</p>\n<p>对文件的文本内容排序。</p>\n<p>uniq</p>\n<p>去除掉重复行。</p>\n<p>wc</p>\n<p>统计文件行数、单词数或是字节数。</p>\n<p>iconv</p>\n<p>转换文件编码格式。</p>\n<p>dos2unix</p>\n<p>将DOS格式文件转换成UNIX格式。</p>\n<p>diff</p>\n<p>全拼为difference，比较文件差异，用于文本文件。</p>\n<p>vimdiff</p>\n<p>命令行可视化文件比较工具，用于文本文件。</p>\n<p>rev</p>\n<p>反向输出文件内容。</p>\n<p>grep/egrep</p>\n<p>常用于过滤字符串。</p>\n<p>join</p>\n<p>按两个文件的相同字段合并。</p>\n<p>tr</p>\n<p>替换、删除字符。</p>\n<p>vi/vim</p>\n<p>命令行文本编辑器。</p>\n<p>文件压缩及解压缩命令（4个）</p>\n<p>tar</p>\n<p>打包压缩。</p>\n<p>unzip</p>\n<p>解压文件。</p>\n<p>gzip</p>\n<p>压缩工具。</p>\n<p>zip</p>\n<p>压缩工具。</p>\n<p>信息显示命令（11个）</p>\n<p>uname</p>\n<p>显示操作系统相关信息。</p>\n<p>hostname</p>\n<p>显示或者设置当前系统的主机名。</p>\n<p>dmesg</p>\n<p>显示开机信息，用于诊断系统故障。</p>\n<p>uptime</p>\n<p>显示系统运行时间以及负载。</p>\n<p>stat</p>\n<p>显示文件或文件系统的状态。</p>\n<p>du</p>\n<p>计算磁盘空间使用情况。</p>\n<p>df</p>\n<p>报告文件系统磁盘空间使用情况。</p>\n<p>top</p>\n<p>实时显示系统资源使用情况。</p>\n<p>free</p>\n<p>查看系统内存。</p>\n<p>date</p>\n<p>显示、设置系统时间。</p>\n<p>cal</p>\n<p>查看日历、时间信息。</p>\n<p>搜索文件命令（4个）</p>\n<p>which</p>\n<p>查找二进制文件的命令，按环境变量PATH路径查找。</p>\n<p>find</p>\n<p>从磁盘遍历查找文件或目录。</p>\n<p>whereis</p>\n<p>查找二进制文件的命令，按环境变量PATH路径查找。</p>\n<p>locate</p>\n<p>从数据库/var/lib/mlocate/mlocate.db中查找命令，使用updatedb更新库。</p>\n<p>用户管理命令（10个）</p>\n<p>useradd</p>\n<p>添加用户。</p>\n<p>usermod</p>\n<p>修改系统已经存在用户属性。</p>\n<p>userdel</p>\n<p>删除用户。</p>\n<p>groupadd</p>\n<p>添加用户群组。</p>\n<p>passwd</p>\n<p>修改用户密码。</p>\n<p>chage</p>\n<p>修改用户密码有效期限。</p>\n<p>id</p>\n<p>查看用户的uid/gid及归属的用户群组。</p>\n<p>su</p>\n<p>切换用户身份。</p>\n<p>visudo</p>\n<p>编辑/etc/sudoers文件的专属命令。</p>\n<p>sudo</p>\n<p>以另外一用户身份（默认为root用户）执行事先在sudoers文件中允许的命令。</p>\n<p>基础网络操作命令（11个）</p>\n<p>telnet</p>\n<p>用TELNET协议远程登录。</p>\n<p>ssh</p>\n<p>用SSH加密协议远程登录。</p>\n<p>scp</p>\n<p>全拼为secure copy，用于不同主机之间复制文件。</p>\n<p>wget</p>\n<p>用命令行下载文件。</p>\n<p>ping</p>\n<p>测试主机之间网络的连通性。</p>\n<p>route</p>\n<p>显示和设置linux系统的路由表。</p>\n<p>ifconfig</p>\n<p>查看、配置、启用或禁用网络接口的命令。</p>\n<p>ifup</p>\n<p>启动网卡。</p>\n<p>ifdown</p>\n<p>关闭网卡。</p>\n<p>netstat</p>\n<p>查看网络状态。</p>\n<p>ss</p>\n<p>查看网络状态。</p>\n<p>深入网络操作命令（9个）</p>\n<p>nmap</p>\n<p>网络扫描命令。</p>\n<p>lsof</p>\n<p>全名为list open files，也就是列举系统中已经被打开的文件。</p>\n<p>mail</p>\n<p>发送、接收邮件。</p>\n<p>mutt</p>\n<p>邮件管理命令。</p>\n<p>nslookup</p>\n<p>查询互联网DNS服务器的命令。</p>\n<p>dig</p>\n<p>查找DNS的解析过程。</p>\n<p>host</p>\n<p>查询DNS的命令。</p>\n<p>traceroute</p>\n<p>追踪数据传输路由状况。</p>\n<p>tcpdump</p>\n<p>命令行的抓包工具。</p>\n<p>有关磁盘与文件系统的命令（16个）</p>\n<p>mount</p>\n<p>挂载文件系统。</p>\n<p>umount</p>\n<p>卸载文件系统。</p>\n<p>fsck</p>\n<p>检查并修复Linux文件系统。</p>\n<p>dd</p>\n<p>转换、复制文件。</p>\n<p>dumpe2fs</p>\n<p>导出ext2/ext3/ext4等文件系统信息。</p>\n<p>dump</p>\n<p>ext2/3/4等文件系统备份工具。</p>\n<p>fdisk</p>\n<p>磁盘分区命令，适用于2TB以下磁盘分区。</p>\n<p>parted</p>\n<p>磁盘分区命令，没有磁盘大小限制，常用于2TB以下磁盘分区。</p>\n<p>mkfs</p>\n<p>格式化创建Linux文件系统。</p>\n<p>partprobe</p>\n<p>更新内核的硬盘分区表信息。</p>\n<p>e2fsck</p>\n<p>检查ext2/ext3/ext4等类型文件系统。</p>\n<p>mkswap</p>\n<p>创建Linux的交换分区。</p>\n<p>swapon</p>\n<p>启用交换分区。</p>\n<p>swapoff</p>\n<p>关闭交换分区。</p>\n<p>sync</p>\n<p>将内存缓冲区内的数据写入磁盘。</p>\n<p>resize2fs</p>\n<p>调整ext2/ext3/ext4等文件系统大小。</p>\n<p>系统权限、用户授权相关命令（4个）</p>\n<p>chmod</p>\n<p>改变文件、目录权限。</p>\n<p>chown</p>\n<p>改变文件、目录的属主和属组。</p>\n<p>chgrp</p>\n<p>更改文件用户群组。</p>\n<p>umask</p>\n<p>显示、设置权限掩码。</p>\n<p>查看系统用户登陆信息命令（7个）</p>\n<p>whoami</p>\n<p>显示当前有效用户名称，相当于执行id -un命令。</p>\n<p>who</p>\n<p>显示目前已登录系统的用户信息。</p>\n<p>w</p>\n<p>显示已登陆系统的用户列表，并显示用户正在执行的指令。</p>\n<p>last</p>\n<p>显示已登入系统的用户。</p>\n<p>lastlog</p>\n<p>显示系统中所有用户最近一次的登录信息。</p>\n<p>users</p>\n<p>显示当前登录系统的所有用户的用户列表。</p>\n<p>finger</p>\n<p>查找、显示用户信息。</p>\n<p>内置命令、其它（19个）</p>\n<p>echo</p>\n<p>打印变量，直接输出指定的字符串</p>\n<p>printf</p>\n<p>将结果格式化输出到标准输出中。</p>\n<p>rpm</p>\n<p>管理rpm包命令。</p>\n<p>yum</p>\n<p>自动化简单化地管理rpm包的命令。</p>\n<p>watch</p>\n<p>周期的执行给定的命令，并将命令的输出以全屏方式显示。</p>\n<p>alias</p>\n<p>设置系统别名。</p>\n<p>unalias</p>\n<p>取消系统别名。</p>\n<p>date</p>\n<p>查看、设置系统时间。</p>\n<p>clear</p>\n<p>清除屏幕，简称清屏。</p>\n<p>history</p>\n<p>查看命令执行的历史纪录。</p>\n<p>eject</p>\n<p>弹出光驱。</p>\n<p>time</p>\n<p>计算命令执行时间。</p>\n<p>nc</p>\n<p>功能强大网络工具。</p>\n<p>xargs</p>\n<p>将标准输入转换成命令行的参数。</p>\n<p>exec</p>\n<p>调用并执行指令的命令。</p>\n<p>export</p>\n<p>设置或者显示环境变量。</p>\n<p>unset</p>\n<p>删除变量、函数。</p>\n<p>type</p>\n<p>用于判断另外一个命令是否为内置的命令。</p>\n<p>bc</p>\n<p>命令行科学计算器</p>\n<p>系统管理、性能监视命令（9个）</p>\n<p>chkconfig</p>\n<p>管理Linux系统开机启动项。</p>\n<p>vmstat</p>\n<p>虚拟内存统计。</p>\n<p>mpstat</p>\n<p>显示各个可用CPU的状态统计。</p>\n<p>iostat</p>\n<p>统计系统的IO。</p>\n<p>sar</p>\n<p>全面地获取系统CPU、运行队列、磁盘读写、分页、内存、 CPU中断和网络性能数据。</p>\n<p>ipcs</p>\n<p>用于报告Linux中进程间通信设施的状态，显示信息包括消息列表、共享内存和信号量信息。</p>\n<p>ipcrm</p>\n<p>用来删除一个或更多的消息队列、信号量集或者共享内存标识。</p>\n<p>strace</p>\n<p>用于诊断、调试Linux用户空间跟踪器。我们用它来监控用户空间进程和内核交互，比如系统调用、信号传递、进程状态变更。</p>\n<p>ltrace</p>\n<p>命令会跟踪进程库函数调用，它会显现哪个库函数被调用。</p>\n<p>关机/重启/注销和查看系统信息的命令（6个）</p>\n<p>shutdown</p>\n<p>关机。</p>\n<p>halt</p>\n<p>关机。</p>\n<p>poweroff</p>\n<p>关闭电源。</p>\n<p>logout</p>\n<p>退出当前登录的Shell。</p>\n<p>exit</p>\n<p>退出当前登录的Shell。</p>\n<p>Ctrl+d</p>\n<p>退出当前登录的Shell的快捷键。</p>\n<p>进程管理相关命令（15个）</p>\n<p>bg</p>\n<p>将一个后台暂停的命令，变成继续执行。</p>\n<p>fg</p>\n<p>将后台的命令调至前台继续运行。</p>\n<p>jobs</p>\n<p>查看当前有多少后台运行的命令。</p>\n<p>kill</p>\n<p>终止进程。</p>\n<p>killall</p>\n<p>通过进程名来终止进程。</p>\n<p>pkill</p>\n<p>通过进程名来终止进程。</p>\n<p>crontab</p>\n<p>定时任务命令。</p>\n<p>ps</p>\n<p>显示进程快照。</p>\n<p>pstree</p>\n<p>树形显示进程。</p>\n<p>nice/renice</p>\n<p>调整程序运行的优先级。</p>\n<p>nohup</p>\n<p>忽略挂起信号运行指定。</p>\n<p>pgrep</p>\n<p>查找匹配条件进程。</p>\n<p>runlevel</p>\n<p>查看系统当前运行级别。</p>\n<p>init</p>\n<p>切换运行级别。</p>\n<p>service</p>\n<p>启动、停止、重新启动、关闭系统服务，还可以显示所有系统服务的当前状态。</p>\n"},{"title":"惊奇队长BD1080P超清特效中文字幕迅雷在线下载","url":"168.html","id":"168","date":"2019-06-22T10:52:40.000Z","_content":"\n![惊奇队长BD1080P超清特效中文字幕迅雷在线下载](https://img.viapi.cn/wp/uploads/2019/05/4ed377dc84a81bf3.jpg \"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\") ![惊奇队长BD1080P超清特效中文字幕迅雷在线下载](https://img.viapi.cn/wp/uploads/2019/05/643ba4a227d0fd04.jpg \"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\") ![惊奇队长BD1080P超清特效中文字幕迅雷在线下载](https://img.viapi.cn/wp/uploads/2019/05/24960d4a36099d78.jpg \"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\") 惊奇队长BD特效字幕英语中英双字 导演：安娜·波顿/瑞安·弗雷克 编剧：安娜·波顿/瑞安·弗雷克/吉内瓦·德沃莱特-罗宾森/尼科尔·帕尔曼/梅格·勒福夫/吉因·科兰/罗伊·托马斯 主演：布丽·拉尔森/裘德·洛/塞缪尔·杰克逊/本·门德尔森/安妮特·贝宁/麦肯娜·格瑞丝/克拉克·格雷格/嘉玛·陈 类型：动作/科幻/冒险 官方网站：www.marvel.com/captainmarvel/ 制片国家/地区：美国 语言：英语 上映日期：2019-03-08(美国/中国大陆) 片长：124分钟 又名：Marvel队长(港)/漫威队长/惊奇女士 IMDb链接：tt4154664 豆瓣评分：7.0 惊奇队长BD特效字幕英语中英双字 - 内容介绍： 在围剿斯克鲁人的战斗中，克里人星际战队成员弗斯（布丽·拉尔森BrieLarson饰）不幸成为对方的俘虏。斯克鲁人尝试探究弗斯的记忆，最终发现连弗斯本人都不知道的一段往事，进而也得知名为温迪•劳森博士的女子掌握着他们急于得到的时空引擎。趁对方不备，拥有强大超能力的弗斯摆脱束缚，逃到了代号为C-53的地球，而这里也正是她那段失落的记忆的发生地。未过多久，神盾局探员弗瑞特工（塞缪尔·杰克逊SamuelL.Jackson饰）找上门来，而紧随其后的斯克鲁人更是引发了地球人前所未见的大骚动。 在这一过程中，弗瑞特工意识到事态的严重性，并且帮助弗斯认清本来的自己。倔强的弗斯，终于找到了真正需要保护的东西…… 优酷：\\[video\\]https://v.youku.com/v\\_show/id\\_XNDA4NzI3MzI2NA==.html\\[/video\\]","source":"_posts/e6-83-8a-e5-a5-87-e9-98-9f-e9-95-bfbd1080p-e8-b6-85-e6-b8-85-e7-89-b9-e6-95-88-e4-b8-ad-e6-96-87-e5-ad-97-e5-b9-95-e8-bf-85-e9-9b-b7-e5-9c-a8-e7-ba-bf-e4-b8-8b-e8-bd-bd.md","raw":"---\ntitle: 惊奇队长BD1080P超清特效中文字幕迅雷在线下载\ntags:\n  - 漫威\n  - 电影\n  - 科幻\nurl: 168.html\nid: 168\ncategories:\n  - 影视资源\ndate: 2019-06-22 18:52:40\n---\n\n![惊奇队长BD1080P超清特效中文字幕迅雷在线下载](https://img.viapi.cn/wp/uploads/2019/05/4ed377dc84a81bf3.jpg \"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\") ![惊奇队长BD1080P超清特效中文字幕迅雷在线下载](https://img.viapi.cn/wp/uploads/2019/05/643ba4a227d0fd04.jpg \"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\") ![惊奇队长BD1080P超清特效中文字幕迅雷在线下载](https://img.viapi.cn/wp/uploads/2019/05/24960d4a36099d78.jpg \"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\") 惊奇队长BD特效字幕英语中英双字 导演：安娜·波顿/瑞安·弗雷克 编剧：安娜·波顿/瑞安·弗雷克/吉内瓦·德沃莱特-罗宾森/尼科尔·帕尔曼/梅格·勒福夫/吉因·科兰/罗伊·托马斯 主演：布丽·拉尔森/裘德·洛/塞缪尔·杰克逊/本·门德尔森/安妮特·贝宁/麦肯娜·格瑞丝/克拉克·格雷格/嘉玛·陈 类型：动作/科幻/冒险 官方网站：www.marvel.com/captainmarvel/ 制片国家/地区：美国 语言：英语 上映日期：2019-03-08(美国/中国大陆) 片长：124分钟 又名：Marvel队长(港)/漫威队长/惊奇女士 IMDb链接：tt4154664 豆瓣评分：7.0 惊奇队长BD特效字幕英语中英双字 - 内容介绍： 在围剿斯克鲁人的战斗中，克里人星际战队成员弗斯（布丽·拉尔森BrieLarson饰）不幸成为对方的俘虏。斯克鲁人尝试探究弗斯的记忆，最终发现连弗斯本人都不知道的一段往事，进而也得知名为温迪•劳森博士的女子掌握着他们急于得到的时空引擎。趁对方不备，拥有强大超能力的弗斯摆脱束缚，逃到了代号为C-53的地球，而这里也正是她那段失落的记忆的发生地。未过多久，神盾局探员弗瑞特工（塞缪尔·杰克逊SamuelL.Jackson饰）找上门来，而紧随其后的斯克鲁人更是引发了地球人前所未见的大骚动。 在这一过程中，弗瑞特工意识到事态的严重性，并且帮助弗斯认清本来的自己。倔强的弗斯，终于找到了真正需要保护的东西…… 优酷：\\[video\\]https://v.youku.com/v\\_show/id\\_XNDA4NzI3MzI2NA==.html\\[/video\\]","slug":"e6-83-8a-e5-a5-87-e9-98-9f-e9-95-bfbd1080p-e8-b6-85-e6-b8-85-e7-89-b9-e6-95-88-e4-b8-ad-e6-96-87-e5-ad-97-e5-b9-95-e8-bf-85-e9-9b-b7-e5-9c-a8-e7-ba-bf-e4-b8-8b-e8-bd-bd","published":1,"updated":"2019-09-10T07:46:08.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269b6001jc8gsb2g8etil","content":"<p><img src=\"https://img.viapi.cn/wp/uploads/2019/05/4ed377dc84a81bf3.jpg\" alt=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\" title=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/05/643ba4a227d0fd04.jpg\" alt=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\" title=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/05/24960d4a36099d78.jpg\" alt=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\" title=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\"> 惊奇队长BD特效字幕英语中英双字 导演：安娜·波顿/瑞安·弗雷克 编剧：安娜·波顿/瑞安·弗雷克/吉内瓦·德沃莱特-罗宾森/尼科尔·帕尔曼/梅格·勒福夫/吉因·科兰/罗伊·托马斯 主演：布丽·拉尔森/裘德·洛/塞缪尔·杰克逊/本·门德尔森/安妮特·贝宁/麦肯娜·格瑞丝/克拉克·格雷格/嘉玛·陈 类型：动作/科幻/冒险 官方网站：<a href=\"http://www.marvel.com/captainmarvel/\">www.marvel.com/captainmarvel/</a> 制片国家/地区：美国 语言：英语 上映日期：2019-03-08(美国/中国大陆) 片长：124分钟 又名：Marvel队长(港)/漫威队长/惊奇女士 IMDb链接：tt4154664 豆瓣评分：7.0 惊奇队长BD特效字幕英语中英双字 - 内容介绍： 在围剿斯克鲁人的战斗中，克里人星际战队成员弗斯（布丽·拉尔森BrieLarson饰）不幸成为对方的俘虏。斯克鲁人尝试探究弗斯的记忆，最终发现连弗斯本人都不知道的一段往事，进而也得知名为温迪•劳森博士的女子掌握着他们急于得到的时空引擎。趁对方不备，拥有强大超能力的弗斯摆脱束缚，逃到了代号为C-53的地球，而这里也正是她那段失落的记忆的发生地。未过多久，神盾局探员弗瑞特工（塞缪尔·杰克逊SamuelL.Jackson饰）找上门来，而紧随其后的斯克鲁人更是引发了地球人前所未见的大骚动。 在这一过程中，弗瑞特工意识到事态的严重性，并且帮助弗斯认清本来的自己。倔强的弗斯，终于找到了真正需要保护的东西…… 优酷：[video]<a href=\"https://v.youku.com/v/_show/id/_XNDA4NzI3MzI2NA==.html/[/video/]\">https://v.youku.com/v\\_show/id\\_XNDA4NzI3MzI2NA==.html\\[/video\\]</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><img src=\"https://img.viapi.cn/wp/uploads/2019/05/4ed377dc84a81bf3.jpg\" alt=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\" title=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/05/643ba4a227d0fd04.jpg\" alt=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\" title=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\"> <img src=\"https://img.viapi.cn/wp/uploads/2019/05/24960d4a36099d78.jpg\" alt=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\" title=\"惊奇队长BD1080P超清特效中文字幕迅雷在线下载\"> 惊奇队长BD特效字幕英语中英双字 导演：安娜·波顿/瑞安·弗雷克 编剧：安娜·波顿/瑞安·弗雷克/吉内瓦·德沃莱特-罗宾森/尼科尔·帕尔曼/梅格·勒福夫/吉因·科兰/罗伊·托马斯 主演：布丽·拉尔森/裘德·洛/塞缪尔·杰克逊/本·门德尔森/安妮特·贝宁/麦肯娜·格瑞丝/克拉克·格雷格/嘉玛·陈 类型：动作/科幻/冒险 官方网站：<a href=\"http://www.marvel.com/captainmarvel/\">www.marvel.com/captainmarvel/</a> 制片国家/地区：美国 语言：英语 上映日期：2019-03-08(美国/中国大陆) 片长：124分钟 又名：Marvel队长(港)/漫威队长/惊奇女士 IMDb链接：tt4154664 豆瓣评分：7.0 惊奇队长BD特效字幕英语中英双字 - 内容介绍： 在围剿斯克鲁人的战斗中，克里人星际战队成员弗斯（布丽·拉尔森BrieLarson饰）不幸成为对方的俘虏。斯克鲁人尝试探究弗斯的记忆，最终发现连弗斯本人都不知道的一段往事，进而也得知名为温迪•劳森博士的女子掌握着他们急于得到的时空引擎。趁对方不备，拥有强大超能力的弗斯摆脱束缚，逃到了代号为C-53的地球，而这里也正是她那段失落的记忆的发生地。未过多久，神盾局探员弗瑞特工（塞缪尔·杰克逊SamuelL.Jackson饰）找上门来，而紧随其后的斯克鲁人更是引发了地球人前所未见的大骚动。 在这一过程中，弗瑞特工意识到事态的严重性，并且帮助弗斯认清本来的自己。倔强的弗斯，终于找到了真正需要保护的东西…… 优酷：[video]<a href=\"https://v.youku.com/v/_show/id/_XNDA4NzI3MzI2NA==.html/[/video/]\">https://v.youku.com/v\\_show/id\\_XNDA4NzI3MzI2NA==.html\\[/video\\]</a></p>\n"},{"title":"惊魂电影院 1080P 超清mp4","url":"244.html","id":"244","date":"2019-07-11T12:19:29.000Z","_content":"\n基本信息\n----\n\n中文名      惊魂电影院\n\n外文名      At the cinema\n\n其它译名   厉鬼电影院\n\n出品时间   2015年6月19日\n\n出品公司   北京环球嘉艺文化传媒有限公司\n\n发行公司   北京基点影视文化传媒有限公司\n\n制片地区   中国\n\n导    演      王鸣\n\n编    剧      王鸣\n\n制片人       吕玉安、[罗布次仁](https://baike.baidu.com/item/%E7%BD%97%E5%B8%83%E6%AC%A1%E4%BB%81)\n\n类    型      惊悚 / 恐怖\n\n主    演      [王晔](https://baike.baidu.com/item/%E7%8E%8B%E6%99%94/3664906)，[林晓凡](https://baike.baidu.com/item/%E6%9E%97%E6%99%93%E5%87%A1/6691715)，[姚一奇](https://baike.baidu.com/item/%E5%A7%9A%E4%B8%80%E5%A5%87)，[赵圆圆](https://baike.baidu.com/item/%E8%B5%B5%E5%9C%86%E5%9C%86)，蒋中炜\n\n片    长      90分钟\n\n上映时间    2015年6月19日（中国）\n\n对白语言   汉语普通话\n\n色    彩    彩色\n\n在线播放平台    爱奇艺 腾讯 优酷\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=411f996a522c11dfcadcb771024e09b5/ae51f3deb48f8c54b7289ba63f292df5e1fe7fbb.jpg)\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n剧情简介\n----\n\n据说，午夜的电影院阴气重，有时可能碰见不干净的东西。一天，几个年轻人去一家由殡仪馆改建的影院看一部午夜场恐怖片。没想到，电影中的恐怖事件在现实中同步上演。昏暗的走廊悄然出现飘过的黑影；影院厕所挂满了滴血的人皮；坐在影厅前排的女大学生，突然被电影里的鬼手拽进电影；紧接着，电影里的女鬼突然冲出银幕，开始一场血淋淋的恐怖杀戮。","source":"_posts/e6-83-8a-e9-ad-82-e7-94-b5-e5-bd-b1-e9-99-a2-1080p-e8-b6-85-e6-b8-85mp4.md","raw":"---\ntitle: 惊魂电影院 1080P 超清mp4\ntags:\n  - 电影资源\nurl: 244.html\nid: 244\ncategories:\n  - 影视资源\ndate: 2019-07-11 20:19:29\n---\n\n基本信息\n----\n\n中文名      惊魂电影院\n\n外文名      At the cinema\n\n其它译名   厉鬼电影院\n\n出品时间   2015年6月19日\n\n出品公司   北京环球嘉艺文化传媒有限公司\n\n发行公司   北京基点影视文化传媒有限公司\n\n制片地区   中国\n\n导    演      王鸣\n\n编    剧      王鸣\n\n制片人       吕玉安、[罗布次仁](https://baike.baidu.com/item/%E7%BD%97%E5%B8%83%E6%AC%A1%E4%BB%81)\n\n类    型      惊悚 / 恐怖\n\n主    演      [王晔](https://baike.baidu.com/item/%E7%8E%8B%E6%99%94/3664906)，[林晓凡](https://baike.baidu.com/item/%E6%9E%97%E6%99%93%E5%87%A1/6691715)，[姚一奇](https://baike.baidu.com/item/%E5%A7%9A%E4%B8%80%E5%A5%87)，[赵圆圆](https://baike.baidu.com/item/%E8%B5%B5%E5%9C%86%E5%9C%86)，蒋中炜\n\n片    长      90分钟\n\n上映时间    2015年6月19日（中国）\n\n对白语言   汉语普通话\n\n色    彩    彩色\n\n在线播放平台    爱奇艺 腾讯 优酷\n\n![](https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=411f996a522c11dfcadcb771024e09b5/ae51f3deb48f8c54b7289ba63f292df5e1fe7fbb.jpg)\n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n\n剧情简介\n----\n\n据说，午夜的电影院阴气重，有时可能碰见不干净的东西。一天，几个年轻人去一家由殡仪馆改建的影院看一部午夜场恐怖片。没想到，电影中的恐怖事件在现实中同步上演。昏暗的走廊悄然出现飘过的黑影；影院厕所挂满了滴血的人皮；坐在影厅前排的女大学生，突然被电影里的鬼手拽进电影；紧接着，电影里的女鬼突然冲出银幕，开始一场血淋淋的恐怖杀戮。","slug":"e6-83-8a-e9-ad-82-e7-94-b5-e5-bd-b1-e9-99-a2-1080p-e8-b6-85-e6-b8-85mp4","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269b7001mc8gsdbtzaxny","content":"<h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><p>中文名      惊魂电影院</p>\n<p>外文名      At the cinema</p>\n<p>其它译名   厉鬼电影院</p>\n<p>出品时间   2015年6月19日</p>\n<p>出品公司   北京环球嘉艺文化传媒有限公司</p>\n<p>发行公司   北京基点影视文化传媒有限公司</p>\n<p>制片地区   中国</p>\n<p>导    演      王鸣</p>\n<p>编    剧      王鸣</p>\n<p>制片人       吕玉安、<a href=\"https://baike.baidu.com/item/%E7%BD%97%E5%B8%83%E6%AC%A1%E4%BB%81\">罗布次仁</a></p>\n<p>类    型      惊悚 / 恐怖</p>\n<p>主    演      <a href=\"https://baike.baidu.com/item/%E7%8E%8B%E6%99%94/3664906\">王晔</a>，<a href=\"https://baike.baidu.com/item/%E6%9E%97%E6%99%93%E5%87%A1/6691715\">林晓凡</a>，<a href=\"https://baike.baidu.com/item/%E5%A7%9A%E4%B8%80%E5%A5%87\">姚一奇</a>，<a href=\"https://baike.baidu.com/item/%E8%B5%B5%E5%9C%86%E5%9C%86\">赵圆圆</a>，蒋中炜</p>\n<p>片    长      90分钟</p>\n<p>上映时间    2015年6月19日（中国）</p>\n<p>对白语言   汉语普通话</p>\n<p>色    彩    彩色</p>\n<p>在线播放平台    爱奇艺 腾讯 优酷</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=411f996a522c11dfcadcb771024e09b5/ae51f3deb48f8c54b7289ba63f292df5e1fe7fbb.jpg\"></h2><h2 id=\"剧情简介\"><a href=\"#剧情简介\" class=\"headerlink\" title=\"剧情简介\"></a>剧情简介</h2><p>据说，午夜的电影院阴气重，有时可能碰见不干净的东西。一天，几个年轻人去一家由殡仪馆改建的影院看一部午夜场恐怖片。没想到，电影中的恐怖事件在现实中同步上演。昏暗的走廊悄然出现飘过的黑影；影院厕所挂满了滴血的人皮；坐在影厅前排的女大学生，突然被电影里的鬼手拽进电影；紧接着，电影里的女鬼突然冲出银幕，开始一场血淋淋的恐怖杀戮。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"基本信息\"><a href=\"#基本信息\" class=\"headerlink\" title=\"基本信息\"></a>基本信息</h2><p>中文名      惊魂电影院</p>\n<p>外文名      At the cinema</p>\n<p>其它译名   厉鬼电影院</p>\n<p>出品时间   2015年6月19日</p>\n<p>出品公司   北京环球嘉艺文化传媒有限公司</p>\n<p>发行公司   北京基点影视文化传媒有限公司</p>\n<p>制片地区   中国</p>\n<p>导    演      王鸣</p>\n<p>编    剧      王鸣</p>\n<p>制片人       吕玉安、<a href=\"https://baike.baidu.com/item/%E7%BD%97%E5%B8%83%E6%AC%A1%E4%BB%81\">罗布次仁</a></p>\n<p>类    型      惊悚 / 恐怖</p>\n<p>主    演      <a href=\"https://baike.baidu.com/item/%E7%8E%8B%E6%99%94/3664906\">王晔</a>，<a href=\"https://baike.baidu.com/item/%E6%9E%97%E6%99%93%E5%87%A1/6691715\">林晓凡</a>，<a href=\"https://baike.baidu.com/item/%E5%A7%9A%E4%B8%80%E5%A5%87\">姚一奇</a>，<a href=\"https://baike.baidu.com/item/%E8%B5%B5%E5%9C%86%E5%9C%86\">赵圆圆</a>，蒋中炜</p>\n<p>片    长      90分钟</p>\n<p>上映时间    2015年6月19日（中国）</p>\n<p>对白语言   汉语普通话</p>\n<p>色    彩    彩色</p>\n<p>在线播放平台    爱奇艺 腾讯 优酷</p>\n<h2 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://gss3.bdstatic.com/-Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=411f996a522c11dfcadcb771024e09b5/ae51f3deb48f8c54b7289ba63f292df5e1fe7fbb.jpg\"></h2><h2 id=\"剧情简介\"><a href=\"#剧情简介\" class=\"headerlink\" title=\"剧情简介\"></a>剧情简介</h2><p>据说，午夜的电影院阴气重，有时可能碰见不干净的东西。一天，几个年轻人去一家由殡仪馆改建的影院看一部午夜场恐怖片。没想到，电影中的恐怖事件在现实中同步上演。昏暗的走廊悄然出现飘过的黑影；影院厕所挂满了滴血的人皮；坐在影厅前排的女大学生，突然被电影里的鬼手拽进电影；紧接着，电影里的女鬼突然冲出银幕，开始一场血淋淋的恐怖杀戮。</p>\n"},{"title":"手摸手教你撸一个脚手架","url":"286.html","id":"286","date":"2019-08-09T06:28:12.000Z","_content":"\n> 作者：前端宇宙 公号 / 刘小夕 （本文来自作者投稿）\n\n### **脚手架**\n\n`vue-cli`, `create-react-app`、`react-native-cli` 等都是非常优秀的脚手架，通过脚手架，我们可以快速初始化一个项目，无需自己从零开始一步步配置，有效提升开发体验。尽管这些脚手架非常优秀，但是未必是符合我们的实际应用的，我们可以定制一个属于自己的脚手架(或公司通用脚手架)，来提升自己的开发效率。\n\n> 脚手架的作用\n\n*   减少重复性的工作，不需要复制其他项目再删除无关代码，或者从零创建一个项目和文件。\n    \n*   可以根据交互动态生成项目结构和配置文件。\n    \n*   多人协作更为方便，不需要把文件传来传去。\n    \n\n### **实现的功能**\n\n在开始之前，我们需要明确自己的脚手架需要哪些功能。`vue init template-name project-name` 、`create-react-app project-name`。我们这次编写的脚手架(eos-cli)具备以下能力(脚手架的名字爱叫啥叫啥，我选用了Eos黎明女神):\n\n*   `eos init template-name project-name`  根据远程模板，初始化一个项目(远程模板可配置)\n    \n*   `eos config set` 修改配置信息\n    \n*   `eos config get []` 查看配置信息\n    \n*   `eos --version` 查看当前版本号\n    \n*   `eos -h`\n    \n\n大家可以自行扩展其它的 `commander`，本篇文章旨在教大家如何实现一个脚手架。\n\n> 效果展示\n\n**初始化一个项目**\n\n![手摸手教你撸一个脚手架](https://www.v5ant.com/wp-content/uploads/2019/08/frc-cbf94ad3b582736a0680be846f924535.gif)\n\n**修改.eosrc文件，从 vuejs-template 下载模板**\n\n![手摸手教你撸一个脚手架](https://www.v5ant.com/wp-content/uploads/2019/08/frc-f10ee30efa027e7a3a7e299f60e7d7c6.gif)\n\n### **需要使用的第三方库**\n\n \n\n*   babel-cli/babel-env: 语法转换\n    \n*   commander: 命令行工具\n    \n*   download-git-repo: 用来下载远程模板\n    \n*   ini: 格式转换\n    \n*   inquirer: 交互式命令行工具\n    \n*   ora: 显示loading动画\n    \n*   chalk: 修改控制台输出内容样式\n    \n*   log-symbols: 显示出 √ 或 × 等的图标\n    \n\n关于这些第三方库的说明，可以直接npm上查看相应的说明，此处不一一展开。\n\n### **初始化项目**\n\n创建一个空项目(eos-cli)，使用 `npm init` 进行初始化。\n\n#### 安装依赖\n\n    npm install babel-cli babel-env chalk commander download-git-repo ini inquirer log-symbols ora\n\n#### 目录结构\n\n    ├── bin│   └── www             //可执行文件├── dist    ├── ...             //生成文件└── src    ├── config.js       //管理eos配置文件    ├── index.js        //主流程入口文件    ├── init.js         //init command    ├── main.js         //入口文件    └── utils        ├── constants.js //定义常量        ├── get.js       //获取模板        └── rc.js        //配置文件├── .babelrc             //babel配置文件├── package.json├── README.md\n\n#### babel 配置\n\n开发使用了ES6语法，使用 `babel` 进行转义，\n\n> `.bablerc`\n\n    {    \"presets\": [        [            \"env\",            {                \"targets\": {                    \"node\": \"current\"                }            }        ]    ]}\n\n### **\\`eos\\` 命令**\n\nnode.js 内置了对命令行操作的支持，`package.json` 中的 `bin` 字段可以定义命令名和关联的执行文件。在 `package.json` 中添加 `bin` 字段\n\n> package.json\n\n    {    \"name\": \"eos-cli\",    \"version\": \"1.0.0\",    \"description\": \"脚手架\",    \"main\": \"index.js\",    \"bin\": {        \"eos\": \"./bin/www\"    },    \"scripts\": {        \"compile\": \"babel src -d dist\",        \"watch\": \"npm run compile -- --watch\"    }}\n\n> www 文件\n\n行首加入一行 `#!/usr/bin/env node` 指定当前脚本由node.js进行解析\n\n    #! /usr/bin/env noderequire('../dist/main.js');\n\n#### 链接到全局环境\n\n开发过程中为了方便调试，在当前的 `eos-cli` 目录下执行 `npm link`，将 `eos` 命令链接到全局环境。\n\n#### 启动项目\n\n    npm run watch\n\n### **处理命令行**\n\n利用 `commander` 来处理命令行。\n\n> main\n\n    import program from 'commander';import { VERSION } from './utils/constants';import apply from './index';import chalk from 'chalk';/** * eos commands *    - config *    - init  */let actionMap = {    init: {        description: 'generate a new project from a template',        usages: [            'eos init templateName projectName'        ]    },    config: {        alias: 'cfg',        description: 'config .eosrc',        usages: [            'eos config set <k> <v>',            'eos config get <k>',            'eos config remove <k>'        ]    },    //other commands}// 添加 init / config 命令Object.keys(actionMap).forEach((action) => {    program.command(action)    .description(actionMap[action].description)    .alias(actionMap[action].alias) //别名    .action(() => {        switch (action) {            case 'config':                 //配置                apply(action, ...process.argv.slice(3));                break;            case 'init':                apply(action, ...process.argv.slice(3));                break;            default:                break;        }    });});function help() {    console.log('rnUsage:');    Object.keys(actionMap).forEach((action) => {        actionMap[action].usages.forEach(usage => {            console.log('  - ' + usage);        });    });    console.log('r');}program.usage('<command> [options]');// eos -h program.on('-h', help);program.on('--help', help);// eos -V   VERSION 为 package.json 中的版本号program.version(VERSION, '-V --version').parse(process.argv);// eos 不带参数时if (!process.argv.slice(2).length) {    program.outputHelp(make_green);}function make_green(txt) {    return chalk.green(txt); }\n\n### **下载模板**\n\n`download-git-repo` 支持从 Github、Gitlab 下载远程仓库到本地。\n\n> get.js\n\n    import { getAll } from './rc';import downloadGit from 'download-git-repo';export const downloadLocal = async (templateName, projectName) => {    let config = await getAll();    let api = `${config.registry}/${templateName}`;    return new Promise((resolve, reject) => {        //projectName 为下载到的本地目录        downloadGit(api, projectName, (err) => {            if (err) {                reject(err);            }            resolve();        });    });}\n\n### **\\`init\\` 命令**\n\n#### 命令行交互\n\n在用户执行 init 命令后，向用户提出问题，接收用户的输入并作出相应的处理。命令行交互利用 `inquirer` 来实现:\n\n    inquirer.prompt([    {        name: 'description',        message: 'Please enter the project description: '    },    {        name: 'author',        message: 'Please enter the author name: '    }]).then((answer) => {    //...});\n\n![手摸手教你撸一个脚手架](https://www.v5ant.com/wp-content/uploads/2019/08/frc-f9a19f5daeb6dd3bec736e882a90f76e.jpeg)\n\n#### 视觉美化\n\n在用户输入之后，开始下载模板，这时候使用 `ora` 来提示用户正在下载模板，下载结束之后，也给出提示。\n\n    import ora from 'ora';let loading = ora('downloading template ...');loading.start();//downloadloading.succeed(); //或 loading.fail();\n\n![手摸手教你撸一个脚手架](https://www.v5ant.com/wp-content/uploads/2019/08/frc-4ea3b3306e8550466d72fa6a2d574388.jpeg)\n\n> index.js\n\n    import { downloadLocal } from './utils/get';import ora from 'ora';import inquirer from 'inquirer';import fs from 'fs';import chalk from 'chalk';import symbol from 'log-symbols';let init = async (templateName, projectName) => {    //项目不存在    if (!fs.existsSync(projectName)) {        //命令行交互        inquirer.prompt([            {                name: 'description',                message: 'Please enter the project description: '            },            {                name: 'author',                message: 'Please enter the author name: '            }        ]).then(async (answer) => {            //下载模板 选择模板            //通过配置文件，获取模板信息            let loading = ora('downloading template ...');            loading.start();            downloadLocal(templateName, projectName).then(() => {                loading.succeed();                const fileName = `${projectName}/package.json`;                if(fs.existsSync(fileName)){                    const data = fs.readFileSync(fileName).toString();                    let json = JSON.parse(data);                    json.name = projectName;                    json.author = answer.author;                    json.description = answer.description;                    //修改项目文件夹中 package.json 文件                    fs.writeFileSync(fileName, JSON.stringify(json, null, 't'), 'utf-8');                    console.log(symbol.success, chalk.green('Project initialization finished!'));                }            }, () => {                loading.fail();            });        });    }else {        //项目已经存在        console.log(symbol.error, chalk.red('The project already exists'));    }}module.exports = init;\n\n### **\\`config\\` 配置**\n\n    eos config set registry vuejs-templates\n\nconfig 配置，支持我们使用其它仓库的模板，例如，我们可以使用 vuejs-templates 中的仓库作为模板。这样有一个好处：更新模板无需重新发布脚手架，使用者无需重新安装，并且可以自由选择下载目标。\n\n> config.js\n\n    // 管理 .eosrc 文件 (当前用户目录下)import { get, set, getAll, remove } from './utils/rc';let config = async (action, key, value) => {    switch (action) {        case 'get':            if (key) {                let result = await get(key);                console.log(result);            } else {                let obj = await getAll();                Object.keys(obj).forEach(key => {                    console.log(`${key}=${obj[key]}`);                })            }            break;        case 'set':            set(key, value);            break;        case 'remove':            remove(key);            break;        default:            break;    }}module.exports = config;\n\n> rc.js\n\n.eosrc 文件的增删改查\n\n    import { RC, DEFAULTS } from './constants';import { decode, encode } from 'ini';import { promisify } from 'util';import chalk from 'chalk';import fs from 'fs';const exits = promisify(fs.exists);const readFile = promisify(fs.readFile);const writeFile = promisify(fs.writeFile);//RC 是配置文件//DEFAULTS 是默认的配置export const get = async (key) => {    const exit = await exits(RC);    let opts;    if (exit) {        opts = await readFile(RC, 'utf8');        opts = decode(opts);        return opts[key];    }    return '';}export const getAll = async () => {    const exit = await exits(RC);    let opts;    if (exit) {        opts = await readFile(RC, 'utf8');        opts = decode(opts);        return opts;    }    return {};}export const set = async (key, value) => {    const exit = await exits(RC);    let opts;    if (exit) {        opts = await readFile(RC, 'utf8');        opts = decode(opts);        if(!key) {            console.log(chalk.red(chalk.bold('Error:')), chalk.red('key is required'));            return;        }        if(!value) {            console.log(chalk.red(chalk.bold('Error:')), chalk.red('value is required'));            return;        }        Object.assign(opts, { [key]: value });    } else {        opts = Object.assign(DEFAULTS, { [key]: value });    }    await writeFile(RC, encode(opts), 'utf8');}export const remove = async (key) => {    const exit = await exits(RC);    let opts;    if (exit) {        opts = await readFile(RC, 'utf8');        opts = decode(opts);        delete opts[key];        await writeFile(RC, encode(opts), 'utf8');    }}\n\n### **发布**\n\n`npm publish` 将本脚手架发布至npm上。其它用户可以通过 `npm install eos-cli -g` 全局安装。  \n即可使用 `eos` 命令。\n\n### **项目地址**\n\n本项目完整代码请戳: https://github.com/YvetteLau/Blog/tree/master/eos-cli","source":"_posts/e6-89-8b-e6-91-b8-e6-89-8b-e6-95-99-e4-bd-a0-e6-92-b8-e4-b8-80-e4-b8-aa-e8-84-9a-e6-89-8b-e6-9e-b6.md","raw":"---\ntitle: 手摸手教你撸一个脚手架\nurl: 286.html\nid: 286\ncategories:\n  - 大前端\ndate: 2019-08-09 14:28:12\ntags:\n---\n\n> 作者：前端宇宙 公号 / 刘小夕 （本文来自作者投稿）\n\n### **脚手架**\n\n`vue-cli`, `create-react-app`、`react-native-cli` 等都是非常优秀的脚手架，通过脚手架，我们可以快速初始化一个项目，无需自己从零开始一步步配置，有效提升开发体验。尽管这些脚手架非常优秀，但是未必是符合我们的实际应用的，我们可以定制一个属于自己的脚手架(或公司通用脚手架)，来提升自己的开发效率。\n\n> 脚手架的作用\n\n*   减少重复性的工作，不需要复制其他项目再删除无关代码，或者从零创建一个项目和文件。\n    \n*   可以根据交互动态生成项目结构和配置文件。\n    \n*   多人协作更为方便，不需要把文件传来传去。\n    \n\n### **实现的功能**\n\n在开始之前，我们需要明确自己的脚手架需要哪些功能。`vue init template-name project-name` 、`create-react-app project-name`。我们这次编写的脚手架(eos-cli)具备以下能力(脚手架的名字爱叫啥叫啥，我选用了Eos黎明女神):\n\n*   `eos init template-name project-name`  根据远程模板，初始化一个项目(远程模板可配置)\n    \n*   `eos config set` 修改配置信息\n    \n*   `eos config get []` 查看配置信息\n    \n*   `eos --version` 查看当前版本号\n    \n*   `eos -h`\n    \n\n大家可以自行扩展其它的 `commander`，本篇文章旨在教大家如何实现一个脚手架。\n\n> 效果展示\n\n**初始化一个项目**\n\n![手摸手教你撸一个脚手架](https://www.v5ant.com/wp-content/uploads/2019/08/frc-cbf94ad3b582736a0680be846f924535.gif)\n\n**修改.eosrc文件，从 vuejs-template 下载模板**\n\n![手摸手教你撸一个脚手架](https://www.v5ant.com/wp-content/uploads/2019/08/frc-f10ee30efa027e7a3a7e299f60e7d7c6.gif)\n\n### **需要使用的第三方库**\n\n \n\n*   babel-cli/babel-env: 语法转换\n    \n*   commander: 命令行工具\n    \n*   download-git-repo: 用来下载远程模板\n    \n*   ini: 格式转换\n    \n*   inquirer: 交互式命令行工具\n    \n*   ora: 显示loading动画\n    \n*   chalk: 修改控制台输出内容样式\n    \n*   log-symbols: 显示出 √ 或 × 等的图标\n    \n\n关于这些第三方库的说明，可以直接npm上查看相应的说明，此处不一一展开。\n\n### **初始化项目**\n\n创建一个空项目(eos-cli)，使用 `npm init` 进行初始化。\n\n#### 安装依赖\n\n    npm install babel-cli babel-env chalk commander download-git-repo ini inquirer log-symbols ora\n\n#### 目录结构\n\n    ├── bin│   └── www             //可执行文件├── dist    ├── ...             //生成文件└── src    ├── config.js       //管理eos配置文件    ├── index.js        //主流程入口文件    ├── init.js         //init command    ├── main.js         //入口文件    └── utils        ├── constants.js //定义常量        ├── get.js       //获取模板        └── rc.js        //配置文件├── .babelrc             //babel配置文件├── package.json├── README.md\n\n#### babel 配置\n\n开发使用了ES6语法，使用 `babel` 进行转义，\n\n> `.bablerc`\n\n    {    \"presets\": [        [            \"env\",            {                \"targets\": {                    \"node\": \"current\"                }            }        ]    ]}\n\n### **\\`eos\\` 命令**\n\nnode.js 内置了对命令行操作的支持，`package.json` 中的 `bin` 字段可以定义命令名和关联的执行文件。在 `package.json` 中添加 `bin` 字段\n\n> package.json\n\n    {    \"name\": \"eos-cli\",    \"version\": \"1.0.0\",    \"description\": \"脚手架\",    \"main\": \"index.js\",    \"bin\": {        \"eos\": \"./bin/www\"    },    \"scripts\": {        \"compile\": \"babel src -d dist\",        \"watch\": \"npm run compile -- --watch\"    }}\n\n> www 文件\n\n行首加入一行 `#!/usr/bin/env node` 指定当前脚本由node.js进行解析\n\n    #! /usr/bin/env noderequire('../dist/main.js');\n\n#### 链接到全局环境\n\n开发过程中为了方便调试，在当前的 `eos-cli` 目录下执行 `npm link`，将 `eos` 命令链接到全局环境。\n\n#### 启动项目\n\n    npm run watch\n\n### **处理命令行**\n\n利用 `commander` 来处理命令行。\n\n> main\n\n    import program from 'commander';import { VERSION } from './utils/constants';import apply from './index';import chalk from 'chalk';/** * eos commands *    - config *    - init  */let actionMap = {    init: {        description: 'generate a new project from a template',        usages: [            'eos init templateName projectName'        ]    },    config: {        alias: 'cfg',        description: 'config .eosrc',        usages: [            'eos config set <k> <v>',            'eos config get <k>',            'eos config remove <k>'        ]    },    //other commands}// 添加 init / config 命令Object.keys(actionMap).forEach((action) => {    program.command(action)    .description(actionMap[action].description)    .alias(actionMap[action].alias) //别名    .action(() => {        switch (action) {            case 'config':                 //配置                apply(action, ...process.argv.slice(3));                break;            case 'init':                apply(action, ...process.argv.slice(3));                break;            default:                break;        }    });});function help() {    console.log('rnUsage:');    Object.keys(actionMap).forEach((action) => {        actionMap[action].usages.forEach(usage => {            console.log('  - ' + usage);        });    });    console.log('r');}program.usage('<command> [options]');// eos -h program.on('-h', help);program.on('--help', help);// eos -V   VERSION 为 package.json 中的版本号program.version(VERSION, '-V --version').parse(process.argv);// eos 不带参数时if (!process.argv.slice(2).length) {    program.outputHelp(make_green);}function make_green(txt) {    return chalk.green(txt); }\n\n### **下载模板**\n\n`download-git-repo` 支持从 Github、Gitlab 下载远程仓库到本地。\n\n> get.js\n\n    import { getAll } from './rc';import downloadGit from 'download-git-repo';export const downloadLocal = async (templateName, projectName) => {    let config = await getAll();    let api = `${config.registry}/${templateName}`;    return new Promise((resolve, reject) => {        //projectName 为下载到的本地目录        downloadGit(api, projectName, (err) => {            if (err) {                reject(err);            }            resolve();        });    });}\n\n### **\\`init\\` 命令**\n\n#### 命令行交互\n\n在用户执行 init 命令后，向用户提出问题，接收用户的输入并作出相应的处理。命令行交互利用 `inquirer` 来实现:\n\n    inquirer.prompt([    {        name: 'description',        message: 'Please enter the project description: '    },    {        name: 'author',        message: 'Please enter the author name: '    }]).then((answer) => {    //...});\n\n![手摸手教你撸一个脚手架](https://www.v5ant.com/wp-content/uploads/2019/08/frc-f9a19f5daeb6dd3bec736e882a90f76e.jpeg)\n\n#### 视觉美化\n\n在用户输入之后，开始下载模板，这时候使用 `ora` 来提示用户正在下载模板，下载结束之后，也给出提示。\n\n    import ora from 'ora';let loading = ora('downloading template ...');loading.start();//downloadloading.succeed(); //或 loading.fail();\n\n![手摸手教你撸一个脚手架](https://www.v5ant.com/wp-content/uploads/2019/08/frc-4ea3b3306e8550466d72fa6a2d574388.jpeg)\n\n> index.js\n\n    import { downloadLocal } from './utils/get';import ora from 'ora';import inquirer from 'inquirer';import fs from 'fs';import chalk from 'chalk';import symbol from 'log-symbols';let init = async (templateName, projectName) => {    //项目不存在    if (!fs.existsSync(projectName)) {        //命令行交互        inquirer.prompt([            {                name: 'description',                message: 'Please enter the project description: '            },            {                name: 'author',                message: 'Please enter the author name: '            }        ]).then(async (answer) => {            //下载模板 选择模板            //通过配置文件，获取模板信息            let loading = ora('downloading template ...');            loading.start();            downloadLocal(templateName, projectName).then(() => {                loading.succeed();                const fileName = `${projectName}/package.json`;                if(fs.existsSync(fileName)){                    const data = fs.readFileSync(fileName).toString();                    let json = JSON.parse(data);                    json.name = projectName;                    json.author = answer.author;                    json.description = answer.description;                    //修改项目文件夹中 package.json 文件                    fs.writeFileSync(fileName, JSON.stringify(json, null, 't'), 'utf-8');                    console.log(symbol.success, chalk.green('Project initialization finished!'));                }            }, () => {                loading.fail();            });        });    }else {        //项目已经存在        console.log(symbol.error, chalk.red('The project already exists'));    }}module.exports = init;\n\n### **\\`config\\` 配置**\n\n    eos config set registry vuejs-templates\n\nconfig 配置，支持我们使用其它仓库的模板，例如，我们可以使用 vuejs-templates 中的仓库作为模板。这样有一个好处：更新模板无需重新发布脚手架，使用者无需重新安装，并且可以自由选择下载目标。\n\n> config.js\n\n    // 管理 .eosrc 文件 (当前用户目录下)import { get, set, getAll, remove } from './utils/rc';let config = async (action, key, value) => {    switch (action) {        case 'get':            if (key) {                let result = await get(key);                console.log(result);            } else {                let obj = await getAll();                Object.keys(obj).forEach(key => {                    console.log(`${key}=${obj[key]}`);                })            }            break;        case 'set':            set(key, value);            break;        case 'remove':            remove(key);            break;        default:            break;    }}module.exports = config;\n\n> rc.js\n\n.eosrc 文件的增删改查\n\n    import { RC, DEFAULTS } from './constants';import { decode, encode } from 'ini';import { promisify } from 'util';import chalk from 'chalk';import fs from 'fs';const exits = promisify(fs.exists);const readFile = promisify(fs.readFile);const writeFile = promisify(fs.writeFile);//RC 是配置文件//DEFAULTS 是默认的配置export const get = async (key) => {    const exit = await exits(RC);    let opts;    if (exit) {        opts = await readFile(RC, 'utf8');        opts = decode(opts);        return opts[key];    }    return '';}export const getAll = async () => {    const exit = await exits(RC);    let opts;    if (exit) {        opts = await readFile(RC, 'utf8');        opts = decode(opts);        return opts;    }    return {};}export const set = async (key, value) => {    const exit = await exits(RC);    let opts;    if (exit) {        opts = await readFile(RC, 'utf8');        opts = decode(opts);        if(!key) {            console.log(chalk.red(chalk.bold('Error:')), chalk.red('key is required'));            return;        }        if(!value) {            console.log(chalk.red(chalk.bold('Error:')), chalk.red('value is required'));            return;        }        Object.assign(opts, { [key]: value });    } else {        opts = Object.assign(DEFAULTS, { [key]: value });    }    await writeFile(RC, encode(opts), 'utf8');}export const remove = async (key) => {    const exit = await exits(RC);    let opts;    if (exit) {        opts = await readFile(RC, 'utf8');        opts = decode(opts);        delete opts[key];        await writeFile(RC, encode(opts), 'utf8');    }}\n\n### **发布**\n\n`npm publish` 将本脚手架发布至npm上。其它用户可以通过 `npm install eos-cli -g` 全局安装。  \n即可使用 `eos` 命令。\n\n### **项目地址**\n\n本项目完整代码请戳: https://github.com/YvetteLau/Blog/tree/master/eos-cli","slug":"e6-89-8b-e6-91-b8-e6-89-8b-e6-95-99-e4-bd-a0-e6-92-b8-e4-b8-80-e4-b8-aa-e8-84-9a-e6-89-8b-e6-9e-b6","published":1,"updated":"2019-09-10T07:46:08.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269bd001pc8gs0ctmemmy","content":"<blockquote>\n<p>作者：前端宇宙 公号 / 刘小夕 （本文来自作者投稿）</p>\n</blockquote>\n<h3 id=\"脚手架\"><a href=\"#脚手架\" class=\"headerlink\" title=\"脚手架\"></a><strong>脚手架</strong></h3><p><code>vue-cli</code>, <code>create-react-app</code>、<code>react-native-cli</code> 等都是非常优秀的脚手架，通过脚手架，我们可以快速初始化一个项目，无需自己从零开始一步步配置，有效提升开发体验。尽管这些脚手架非常优秀，但是未必是符合我们的实际应用的，我们可以定制一个属于自己的脚手架(或公司通用脚手架)，来提升自己的开发效率。</p>\n<blockquote>\n<p>脚手架的作用</p>\n</blockquote>\n<ul>\n<li>减少重复性的工作，不需要复制其他项目再删除无关代码，或者从零创建一个项目和文件。</li>\n<li>可以根据交互动态生成项目结构和配置文件。</li>\n<li>多人协作更为方便，不需要把文件传来传去。</li>\n</ul>\n<h3 id=\"实现的功能\"><a href=\"#实现的功能\" class=\"headerlink\" title=\"实现的功能\"></a><strong>实现的功能</strong></h3><p>在开始之前，我们需要明确自己的脚手架需要哪些功能。<code>vue init template-name project-name</code> 、<code>create-react-app project-name</code>。我们这次编写的脚手架(eos-cli)具备以下能力(脚手架的名字爱叫啥叫啥，我选用了Eos黎明女神):</p>\n<ul>\n<li><code>eos init template-name project-name</code>  根据远程模板，初始化一个项目(远程模板可配置)</li>\n<li><code>eos config set</code> 修改配置信息</li>\n<li><code>eos config get []</code> 查看配置信息</li>\n<li><code>eos --version</code> 查看当前版本号</li>\n<li><code>eos -h</code></li>\n</ul>\n<p>大家可以自行扩展其它的 <code>commander</code>，本篇文章旨在教大家如何实现一个脚手架。</p>\n<blockquote>\n<p>效果展示</p>\n</blockquote>\n<p><strong>初始化一个项目</strong></p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-cbf94ad3b582736a0680be846f924535.gif\" alt=\"手摸手教你撸一个脚手架\"></p>\n<p><strong>修改.eosrc文件，从 vuejs-template 下载模板</strong></p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-f10ee30efa027e7a3a7e299f60e7d7c6.gif\" alt=\"手摸手教你撸一个脚手架\"></p>\n<h3 id=\"需要使用的第三方库\"><a href=\"#需要使用的第三方库\" class=\"headerlink\" title=\"需要使用的第三方库\"></a><strong>需要使用的第三方库</strong></h3><p> </p>\n<ul>\n<li>babel-cli/babel-env: 语法转换</li>\n<li>commander: 命令行工具</li>\n<li>download-git-repo: 用来下载远程模板</li>\n<li>ini: 格式转换</li>\n<li>inquirer: 交互式命令行工具</li>\n<li>ora: 显示loading动画</li>\n<li>chalk: 修改控制台输出内容样式</li>\n<li>log-symbols: 显示出 √ 或 × 等的图标</li>\n</ul>\n<p>关于这些第三方库的说明，可以直接npm上查看相应的说明，此处不一一展开。</p>\n<h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a><strong>初始化项目</strong></h3><p>创建一个空项目(eos-cli)，使用 <code>npm init</code> 进行初始化。</p>\n<h4 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h4><pre><code>npm install babel-cli babel-env chalk commander download-git-repo ini inquirer log-symbols ora\n</code></pre>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><pre><code>├── bin│   └── www             //可执行文件├── dist    ├── ...             //生成文件└── src    ├── config.js       //管理eos配置文件    ├── index.js        //主流程入口文件    ├── init.js         //init command    ├── main.js         //入口文件    └── utils        ├── constants.js //定义常量        ├── get.js       //获取模板        └── rc.js        //配置文件├── .babelrc             //babel配置文件├── package.json├── README.md\n</code></pre>\n<h4 id=\"babel-配置\"><a href=\"#babel-配置\" class=\"headerlink\" title=\"babel 配置\"></a>babel 配置</h4><p>开发使用了ES6语法，使用 <code>babel</code> 进行转义，</p>\n<blockquote>\n<p><code>.bablerc</code></p>\n</blockquote>\n<pre><code>&#123;    &quot;presets&quot;: [        [            &quot;env&quot;,            &#123;                &quot;targets&quot;: &#123;                    &quot;node&quot;: &quot;current&quot;                &#125;            &#125;        ]    ]&#125;\n</code></pre>\n<h3 id=\"eos-命令\"><a href=\"#eos-命令\" class=\"headerlink\" title=\"`eos` 命令\"></a><strong>`eos` 命令</strong></h3><p>node.js 内置了对命令行操作的支持，<code>package.json</code> 中的 <code>bin</code> 字段可以定义命令名和关联的执行文件。在 <code>package.json</code> 中添加 <code>bin</code> 字段</p>\n<blockquote>\n<p>package.json</p>\n</blockquote>\n<pre><code>&#123;    &quot;name&quot;: &quot;eos-cli&quot;,    &quot;version&quot;: &quot;1.0.0&quot;,    &quot;description&quot;: &quot;脚手架&quot;,    &quot;main&quot;: &quot;index.js&quot;,    &quot;bin&quot;: &#123;        &quot;eos&quot;: &quot;./bin/www&quot;    &#125;,    &quot;scripts&quot;: &#123;        &quot;compile&quot;: &quot;babel src -d dist&quot;,        &quot;watch&quot;: &quot;npm run compile -- --watch&quot;    &#125;&#125;\n</code></pre>\n<blockquote>\n<p>www 文件</p>\n</blockquote>\n<p>行首加入一行 <code>#!/usr/bin/env node</code> 指定当前脚本由node.js进行解析</p>\n<pre><code>#! /usr/bin/env noderequire(&#39;../dist/main.js&#39;);\n</code></pre>\n<h4 id=\"链接到全局环境\"><a href=\"#链接到全局环境\" class=\"headerlink\" title=\"链接到全局环境\"></a>链接到全局环境</h4><p>开发过程中为了方便调试，在当前的 <code>eos-cli</code> 目录下执行 <code>npm link</code>，将 <code>eos</code> 命令链接到全局环境。</p>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><pre><code>npm run watch\n</code></pre>\n<h3 id=\"处理命令行\"><a href=\"#处理命令行\" class=\"headerlink\" title=\"处理命令行\"></a><strong>处理命令行</strong></h3><p>利用 <code>commander</code> 来处理命令行。</p>\n<blockquote>\n<p>main</p>\n</blockquote>\n<pre><code>import program from &#39;commander&#39;;import &#123; VERSION &#125; from &#39;./utils/constants&#39;;import apply from &#39;./index&#39;;import chalk from &#39;chalk&#39;;/** * eos commands *    - config *    - init  */let actionMap = &#123;    init: &#123;        description: &#39;generate a new project from a template&#39;,        usages: [            &#39;eos init templateName projectName&#39;        ]    &#125;,    config: &#123;        alias: &#39;cfg&#39;,        description: &#39;config .eosrc&#39;,        usages: [            &#39;eos config set &lt;k&gt; &lt;v&gt;&#39;,            &#39;eos config get &lt;k&gt;&#39;,            &#39;eos config remove &lt;k&gt;&#39;        ]    &#125;,    //other commands&#125;// 添加 init / config 命令Object.keys(actionMap).forEach((action) =&gt; &#123;    program.command(action)    .description(actionMap[action].description)    .alias(actionMap[action].alias) //别名    .action(() =&gt; &#123;        switch (action) &#123;            case &#39;config&#39;:                 //配置                apply(action, ...process.argv.slice(3));                break;            case &#39;init&#39;:                apply(action, ...process.argv.slice(3));                break;            default:                break;        &#125;    &#125;);&#125;);function help() &#123;    console.log(&#39;rnUsage:&#39;);    Object.keys(actionMap).forEach((action) =&gt; &#123;        actionMap[action].usages.forEach(usage =&gt; &#123;            console.log(&#39;  - &#39; + usage);        &#125;);    &#125;);    console.log(&#39;r&#39;);&#125;program.usage(&#39;&lt;command&gt; [options]&#39;);// eos -h program.on(&#39;-h&#39;, help);program.on(&#39;--help&#39;, help);// eos -V   VERSION 为 package.json 中的版本号program.version(VERSION, &#39;-V --version&#39;).parse(process.argv);// eos 不带参数时if (!process.argv.slice(2).length) &#123;    program.outputHelp(make_green);&#125;function make_green(txt) &#123;    return chalk.green(txt); &#125;\n</code></pre>\n<h3 id=\"下载模板\"><a href=\"#下载模板\" class=\"headerlink\" title=\"下载模板\"></a><strong>下载模板</strong></h3><p><code>download-git-repo</code> 支持从 Github、Gitlab 下载远程仓库到本地。</p>\n<blockquote>\n<p>get.js</p>\n</blockquote>\n<pre><code>import &#123; getAll &#125; from &#39;./rc&#39;;import downloadGit from &#39;download-git-repo&#39;;export const downloadLocal = async (templateName, projectName) =&gt; &#123;    let config = await getAll();    let api = `$&#123;config.registry&#125;/$&#123;templateName&#125;`;    return new Promise((resolve, reject) =&gt; &#123;        //projectName 为下载到的本地目录        downloadGit(api, projectName, (err) =&gt; &#123;            if (err) &#123;                reject(err);            &#125;            resolve();        &#125;);    &#125;);&#125;\n</code></pre>\n<h3 id=\"init-命令\"><a href=\"#init-命令\" class=\"headerlink\" title=\"`init` 命令\"></a><strong>`init` 命令</strong></h3><h4 id=\"命令行交互\"><a href=\"#命令行交互\" class=\"headerlink\" title=\"命令行交互\"></a>命令行交互</h4><p>在用户执行 init 命令后，向用户提出问题，接收用户的输入并作出相应的处理。命令行交互利用 <code>inquirer</code> 来实现:</p>\n<pre><code>inquirer.prompt([    &#123;        name: &#39;description&#39;,        message: &#39;Please enter the project description: &#39;    &#125;,    &#123;        name: &#39;author&#39;,        message: &#39;Please enter the author name: &#39;    &#125;]).then((answer) =&gt; &#123;    //...&#125;);\n</code></pre>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-f9a19f5daeb6dd3bec736e882a90f76e.jpeg\" alt=\"手摸手教你撸一个脚手架\"></p>\n<h4 id=\"视觉美化\"><a href=\"#视觉美化\" class=\"headerlink\" title=\"视觉美化\"></a>视觉美化</h4><p>在用户输入之后，开始下载模板，这时候使用 <code>ora</code> 来提示用户正在下载模板，下载结束之后，也给出提示。</p>\n<pre><code>import ora from &#39;ora&#39;;let loading = ora(&#39;downloading template ...&#39;);loading.start();//downloadloading.succeed(); //或 loading.fail();\n</code></pre>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-4ea3b3306e8550466d72fa6a2d574388.jpeg\" alt=\"手摸手教你撸一个脚手架\"></p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code>import &#123; downloadLocal &#125; from &#39;./utils/get&#39;;import ora from &#39;ora&#39;;import inquirer from &#39;inquirer&#39;;import fs from &#39;fs&#39;;import chalk from &#39;chalk&#39;;import symbol from &#39;log-symbols&#39;;let init = async (templateName, projectName) =&gt; &#123;    //项目不存在    if (!fs.existsSync(projectName)) &#123;        //命令行交互        inquirer.prompt([            &#123;                name: &#39;description&#39;,                message: &#39;Please enter the project description: &#39;            &#125;,            &#123;                name: &#39;author&#39;,                message: &#39;Please enter the author name: &#39;            &#125;        ]).then(async (answer) =&gt; &#123;            //下载模板 选择模板            //通过配置文件，获取模板信息            let loading = ora(&#39;downloading template ...&#39;);            loading.start();            downloadLocal(templateName, projectName).then(() =&gt; &#123;                loading.succeed();                const fileName = `$&#123;projectName&#125;/package.json`;                if(fs.existsSync(fileName))&#123;                    const data = fs.readFileSync(fileName).toString();                    let json = JSON.parse(data);                    json.name = projectName;                    json.author = answer.author;                    json.description = answer.description;                    //修改项目文件夹中 package.json 文件                    fs.writeFileSync(fileName, JSON.stringify(json, null, &#39;t&#39;), &#39;utf-8&#39;);                    console.log(symbol.success, chalk.green(&#39;Project initialization finished!&#39;));                &#125;            &#125;, () =&gt; &#123;                loading.fail();            &#125;);        &#125;);    &#125;else &#123;        //项目已经存在        console.log(symbol.error, chalk.red(&#39;The project already exists&#39;));    &#125;&#125;module.exports = init;\n</code></pre>\n<h3 id=\"config-配置\"><a href=\"#config-配置\" class=\"headerlink\" title=\"`config` 配置\"></a><strong>`config` 配置</strong></h3><pre><code>eos config set registry vuejs-templates\n</code></pre>\n<p>config 配置，支持我们使用其它仓库的模板，例如，我们可以使用 vuejs-templates 中的仓库作为模板。这样有一个好处：更新模板无需重新发布脚手架，使用者无需重新安装，并且可以自由选择下载目标。</p>\n<blockquote>\n<p>config.js</p>\n</blockquote>\n<pre><code>// 管理 .eosrc 文件 (当前用户目录下)import &#123; get, set, getAll, remove &#125; from &#39;./utils/rc&#39;;let config = async (action, key, value) =&gt; &#123;    switch (action) &#123;        case &#39;get&#39;:            if (key) &#123;                let result = await get(key);                console.log(result);            &#125; else &#123;                let obj = await getAll();                Object.keys(obj).forEach(key =&gt; &#123;                    console.log(`$&#123;key&#125;=$&#123;obj[key]&#125;`);                &#125;)            &#125;            break;        case &#39;set&#39;:            set(key, value);            break;        case &#39;remove&#39;:            remove(key);            break;        default:            break;    &#125;&#125;module.exports = config;\n</code></pre>\n<blockquote>\n<p>rc.js</p>\n</blockquote>\n<p>.eosrc 文件的增删改查</p>\n<pre><code>import &#123; RC, DEFAULTS &#125; from &#39;./constants&#39;;import &#123; decode, encode &#125; from &#39;ini&#39;;import &#123; promisify &#125; from &#39;util&#39;;import chalk from &#39;chalk&#39;;import fs from &#39;fs&#39;;const exits = promisify(fs.exists);const readFile = promisify(fs.readFile);const writeFile = promisify(fs.writeFile);//RC 是配置文件//DEFAULTS 是默认的配置export const get = async (key) =&gt; &#123;    const exit = await exits(RC);    let opts;    if (exit) &#123;        opts = await readFile(RC, &#39;utf8&#39;);        opts = decode(opts);        return opts[key];    &#125;    return &#39;&#39;;&#125;export const getAll = async () =&gt; &#123;    const exit = await exits(RC);    let opts;    if (exit) &#123;        opts = await readFile(RC, &#39;utf8&#39;);        opts = decode(opts);        return opts;    &#125;    return &#123;&#125;;&#125;export const set = async (key, value) =&gt; &#123;    const exit = await exits(RC);    let opts;    if (exit) &#123;        opts = await readFile(RC, &#39;utf8&#39;);        opts = decode(opts);        if(!key) &#123;            console.log(chalk.red(chalk.bold(&#39;Error:&#39;)), chalk.red(&#39;key is required&#39;));            return;        &#125;        if(!value) &#123;            console.log(chalk.red(chalk.bold(&#39;Error:&#39;)), chalk.red(&#39;value is required&#39;));            return;        &#125;        Object.assign(opts, &#123; [key]: value &#125;);    &#125; else &#123;        opts = Object.assign(DEFAULTS, &#123; [key]: value &#125;);    &#125;    await writeFile(RC, encode(opts), &#39;utf8&#39;);&#125;export const remove = async (key) =&gt; &#123;    const exit = await exits(RC);    let opts;    if (exit) &#123;        opts = await readFile(RC, &#39;utf8&#39;);        opts = decode(opts);        delete opts[key];        await writeFile(RC, encode(opts), &#39;utf8&#39;);    &#125;&#125;\n</code></pre>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a><strong>发布</strong></h3><p><code>npm publish</code> 将本脚手架发布至npm上。其它用户可以通过 <code>npm install eos-cli -g</code> 全局安装。<br>即可使用 <code>eos</code> 命令。</p>\n<h3 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a><strong>项目地址</strong></h3><p>本项目完整代码请戳: <a href=\"https://github.com/YvetteLau/Blog/tree/master/eos-cli\">https://github.com/YvetteLau/Blog/tree/master/eos-cli</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<blockquote>\n<p>作者：前端宇宙 公号 / 刘小夕 （本文来自作者投稿）</p>\n</blockquote>\n<h3 id=\"脚手架\"><a href=\"#脚手架\" class=\"headerlink\" title=\"脚手架\"></a><strong>脚手架</strong></h3><p><code>vue-cli</code>, <code>create-react-app</code>、<code>react-native-cli</code> 等都是非常优秀的脚手架，通过脚手架，我们可以快速初始化一个项目，无需自己从零开始一步步配置，有效提升开发体验。尽管这些脚手架非常优秀，但是未必是符合我们的实际应用的，我们可以定制一个属于自己的脚手架(或公司通用脚手架)，来提升自己的开发效率。</p>\n<blockquote>\n<p>脚手架的作用</p>\n</blockquote>\n<ul>\n<li>减少重复性的工作，不需要复制其他项目再删除无关代码，或者从零创建一个项目和文件。</li>\n<li>可以根据交互动态生成项目结构和配置文件。</li>\n<li>多人协作更为方便，不需要把文件传来传去。</li>\n</ul>\n<h3 id=\"实现的功能\"><a href=\"#实现的功能\" class=\"headerlink\" title=\"实现的功能\"></a><strong>实现的功能</strong></h3><p>在开始之前，我们需要明确自己的脚手架需要哪些功能。<code>vue init template-name project-name</code> 、<code>create-react-app project-name</code>。我们这次编写的脚手架(eos-cli)具备以下能力(脚手架的名字爱叫啥叫啥，我选用了Eos黎明女神):</p>\n<ul>\n<li><code>eos init template-name project-name</code>  根据远程模板，初始化一个项目(远程模板可配置)</li>\n<li><code>eos config set</code> 修改配置信息</li>\n<li><code>eos config get []</code> 查看配置信息</li>\n<li><code>eos --version</code> 查看当前版本号</li>\n<li><code>eos -h</code></li>\n</ul>\n<p>大家可以自行扩展其它的 <code>commander</code>，本篇文章旨在教大家如何实现一个脚手架。</p>\n<blockquote>\n<p>效果展示</p>\n</blockquote>\n<p><strong>初始化一个项目</strong></p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-cbf94ad3b582736a0680be846f924535.gif\" alt=\"手摸手教你撸一个脚手架\"></p>\n<p><strong>修改.eosrc文件，从 vuejs-template 下载模板</strong></p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-f10ee30efa027e7a3a7e299f60e7d7c6.gif\" alt=\"手摸手教你撸一个脚手架\"></p>\n<h3 id=\"需要使用的第三方库\"><a href=\"#需要使用的第三方库\" class=\"headerlink\" title=\"需要使用的第三方库\"></a><strong>需要使用的第三方库</strong></h3><p> </p>\n<ul>\n<li>babel-cli/babel-env: 语法转换</li>\n<li>commander: 命令行工具</li>\n<li>download-git-repo: 用来下载远程模板</li>\n<li>ini: 格式转换</li>\n<li>inquirer: 交互式命令行工具</li>\n<li>ora: 显示loading动画</li>\n<li>chalk: 修改控制台输出内容样式</li>\n<li>log-symbols: 显示出 √ 或 × 等的图标</li>\n</ul>\n<p>关于这些第三方库的说明，可以直接npm上查看相应的说明，此处不一一展开。</p>\n<h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a><strong>初始化项目</strong></h3><p>创建一个空项目(eos-cli)，使用 <code>npm init</code> 进行初始化。</p>\n<h4 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h4><pre><code>npm install babel-cli babel-env chalk commander download-git-repo ini inquirer log-symbols ora\n</code></pre>\n<h4 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h4><pre><code>├── bin│   └── www             //可执行文件├── dist    ├── ...             //生成文件└── src    ├── config.js       //管理eos配置文件    ├── index.js        //主流程入口文件    ├── init.js         //init command    ├── main.js         //入口文件    └── utils        ├── constants.js //定义常量        ├── get.js       //获取模板        └── rc.js        //配置文件├── .babelrc             //babel配置文件├── package.json├── README.md\n</code></pre>\n<h4 id=\"babel-配置\"><a href=\"#babel-配置\" class=\"headerlink\" title=\"babel 配置\"></a>babel 配置</h4><p>开发使用了ES6语法，使用 <code>babel</code> 进行转义，</p>\n<blockquote>\n<p><code>.bablerc</code></p>\n</blockquote>\n<pre><code>&#123;    &quot;presets&quot;: [        [            &quot;env&quot;,            &#123;                &quot;targets&quot;: &#123;                    &quot;node&quot;: &quot;current&quot;                &#125;            &#125;        ]    ]&#125;\n</code></pre>\n<h3 id=\"eos-命令\"><a href=\"#eos-命令\" class=\"headerlink\" title=\"`eos` 命令\"></a><strong>`eos` 命令</strong></h3><p>node.js 内置了对命令行操作的支持，<code>package.json</code> 中的 <code>bin</code> 字段可以定义命令名和关联的执行文件。在 <code>package.json</code> 中添加 <code>bin</code> 字段</p>\n<blockquote>\n<p>package.json</p>\n</blockquote>\n<pre><code>&#123;    &quot;name&quot;: &quot;eos-cli&quot;,    &quot;version&quot;: &quot;1.0.0&quot;,    &quot;description&quot;: &quot;脚手架&quot;,    &quot;main&quot;: &quot;index.js&quot;,    &quot;bin&quot;: &#123;        &quot;eos&quot;: &quot;./bin/www&quot;    &#125;,    &quot;scripts&quot;: &#123;        &quot;compile&quot;: &quot;babel src -d dist&quot;,        &quot;watch&quot;: &quot;npm run compile -- --watch&quot;    &#125;&#125;\n</code></pre>\n<blockquote>\n<p>www 文件</p>\n</blockquote>\n<p>行首加入一行 <code>#!/usr/bin/env node</code> 指定当前脚本由node.js进行解析</p>\n<pre><code>#! /usr/bin/env noderequire(&#39;../dist/main.js&#39;);\n</code></pre>\n<h4 id=\"链接到全局环境\"><a href=\"#链接到全局环境\" class=\"headerlink\" title=\"链接到全局环境\"></a>链接到全局环境</h4><p>开发过程中为了方便调试，在当前的 <code>eos-cli</code> 目录下执行 <code>npm link</code>，将 <code>eos</code> 命令链接到全局环境。</p>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><pre><code>npm run watch\n</code></pre>\n<h3 id=\"处理命令行\"><a href=\"#处理命令行\" class=\"headerlink\" title=\"处理命令行\"></a><strong>处理命令行</strong></h3><p>利用 <code>commander</code> 来处理命令行。</p>\n<blockquote>\n<p>main</p>\n</blockquote>\n<pre><code>import program from &#39;commander&#39;;import &#123; VERSION &#125; from &#39;./utils/constants&#39;;import apply from &#39;./index&#39;;import chalk from &#39;chalk&#39;;/** * eos commands *    - config *    - init  */let actionMap = &#123;    init: &#123;        description: &#39;generate a new project from a template&#39;,        usages: [            &#39;eos init templateName projectName&#39;        ]    &#125;,    config: &#123;        alias: &#39;cfg&#39;,        description: &#39;config .eosrc&#39;,        usages: [            &#39;eos config set &lt;k&gt; &lt;v&gt;&#39;,            &#39;eos config get &lt;k&gt;&#39;,            &#39;eos config remove &lt;k&gt;&#39;        ]    &#125;,    //other commands&#125;// 添加 init / config 命令Object.keys(actionMap).forEach((action) =&gt; &#123;    program.command(action)    .description(actionMap[action].description)    .alias(actionMap[action].alias) //别名    .action(() =&gt; &#123;        switch (action) &#123;            case &#39;config&#39;:                 //配置                apply(action, ...process.argv.slice(3));                break;            case &#39;init&#39;:                apply(action, ...process.argv.slice(3));                break;            default:                break;        &#125;    &#125;);&#125;);function help() &#123;    console.log(&#39;rnUsage:&#39;);    Object.keys(actionMap).forEach((action) =&gt; &#123;        actionMap[action].usages.forEach(usage =&gt; &#123;            console.log(&#39;  - &#39; + usage);        &#125;);    &#125;);    console.log(&#39;r&#39;);&#125;program.usage(&#39;&lt;command&gt; [options]&#39;);// eos -h program.on(&#39;-h&#39;, help);program.on(&#39;--help&#39;, help);// eos -V   VERSION 为 package.json 中的版本号program.version(VERSION, &#39;-V --version&#39;).parse(process.argv);// eos 不带参数时if (!process.argv.slice(2).length) &#123;    program.outputHelp(make_green);&#125;function make_green(txt) &#123;    return chalk.green(txt); &#125;\n</code></pre>\n<h3 id=\"下载模板\"><a href=\"#下载模板\" class=\"headerlink\" title=\"下载模板\"></a><strong>下载模板</strong></h3><p><code>download-git-repo</code> 支持从 Github、Gitlab 下载远程仓库到本地。</p>\n<blockquote>\n<p>get.js</p>\n</blockquote>\n<pre><code>import &#123; getAll &#125; from &#39;./rc&#39;;import downloadGit from &#39;download-git-repo&#39;;export const downloadLocal = async (templateName, projectName) =&gt; &#123;    let config = await getAll();    let api = `$&#123;config.registry&#125;/$&#123;templateName&#125;`;    return new Promise((resolve, reject) =&gt; &#123;        //projectName 为下载到的本地目录        downloadGit(api, projectName, (err) =&gt; &#123;            if (err) &#123;                reject(err);            &#125;            resolve();        &#125;);    &#125;);&#125;\n</code></pre>\n<h3 id=\"init-命令\"><a href=\"#init-命令\" class=\"headerlink\" title=\"`init` 命令\"></a><strong>`init` 命令</strong></h3><h4 id=\"命令行交互\"><a href=\"#命令行交互\" class=\"headerlink\" title=\"命令行交互\"></a>命令行交互</h4><p>在用户执行 init 命令后，向用户提出问题，接收用户的输入并作出相应的处理。命令行交互利用 <code>inquirer</code> 来实现:</p>\n<pre><code>inquirer.prompt([    &#123;        name: &#39;description&#39;,        message: &#39;Please enter the project description: &#39;    &#125;,    &#123;        name: &#39;author&#39;,        message: &#39;Please enter the author name: &#39;    &#125;]).then((answer) =&gt; &#123;    //...&#125;);\n</code></pre>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-f9a19f5daeb6dd3bec736e882a90f76e.jpeg\" alt=\"手摸手教你撸一个脚手架\"></p>\n<h4 id=\"视觉美化\"><a href=\"#视觉美化\" class=\"headerlink\" title=\"视觉美化\"></a>视觉美化</h4><p>在用户输入之后，开始下载模板，这时候使用 <code>ora</code> 来提示用户正在下载模板，下载结束之后，也给出提示。</p>\n<pre><code>import ora from &#39;ora&#39;;let loading = ora(&#39;downloading template ...&#39;);loading.start();//downloadloading.succeed(); //或 loading.fail();\n</code></pre>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-4ea3b3306e8550466d72fa6a2d574388.jpeg\" alt=\"手摸手教你撸一个脚手架\"></p>\n<blockquote>\n<p>index.js</p>\n</blockquote>\n<pre><code>import &#123; downloadLocal &#125; from &#39;./utils/get&#39;;import ora from &#39;ora&#39;;import inquirer from &#39;inquirer&#39;;import fs from &#39;fs&#39;;import chalk from &#39;chalk&#39;;import symbol from &#39;log-symbols&#39;;let init = async (templateName, projectName) =&gt; &#123;    //项目不存在    if (!fs.existsSync(projectName)) &#123;        //命令行交互        inquirer.prompt([            &#123;                name: &#39;description&#39;,                message: &#39;Please enter the project description: &#39;            &#125;,            &#123;                name: &#39;author&#39;,                message: &#39;Please enter the author name: &#39;            &#125;        ]).then(async (answer) =&gt; &#123;            //下载模板 选择模板            //通过配置文件，获取模板信息            let loading = ora(&#39;downloading template ...&#39;);            loading.start();            downloadLocal(templateName, projectName).then(() =&gt; &#123;                loading.succeed();                const fileName = `$&#123;projectName&#125;/package.json`;                if(fs.existsSync(fileName))&#123;                    const data = fs.readFileSync(fileName).toString();                    let json = JSON.parse(data);                    json.name = projectName;                    json.author = answer.author;                    json.description = answer.description;                    //修改项目文件夹中 package.json 文件                    fs.writeFileSync(fileName, JSON.stringify(json, null, &#39;t&#39;), &#39;utf-8&#39;);                    console.log(symbol.success, chalk.green(&#39;Project initialization finished!&#39;));                &#125;            &#125;, () =&gt; &#123;                loading.fail();            &#125;);        &#125;);    &#125;else &#123;        //项目已经存在        console.log(symbol.error, chalk.red(&#39;The project already exists&#39;));    &#125;&#125;module.exports = init;\n</code></pre>\n<h3 id=\"config-配置\"><a href=\"#config-配置\" class=\"headerlink\" title=\"`config` 配置\"></a><strong>`config` 配置</strong></h3><pre><code>eos config set registry vuejs-templates\n</code></pre>\n<p>config 配置，支持我们使用其它仓库的模板，例如，我们可以使用 vuejs-templates 中的仓库作为模板。这样有一个好处：更新模板无需重新发布脚手架，使用者无需重新安装，并且可以自由选择下载目标。</p>\n<blockquote>\n<p>config.js</p>\n</blockquote>\n<pre><code>// 管理 .eosrc 文件 (当前用户目录下)import &#123; get, set, getAll, remove &#125; from &#39;./utils/rc&#39;;let config = async (action, key, value) =&gt; &#123;    switch (action) &#123;        case &#39;get&#39;:            if (key) &#123;                let result = await get(key);                console.log(result);            &#125; else &#123;                let obj = await getAll();                Object.keys(obj).forEach(key =&gt; &#123;                    console.log(`$&#123;key&#125;=$&#123;obj[key]&#125;`);                &#125;)            &#125;            break;        case &#39;set&#39;:            set(key, value);            break;        case &#39;remove&#39;:            remove(key);            break;        default:            break;    &#125;&#125;module.exports = config;\n</code></pre>\n<blockquote>\n<p>rc.js</p>\n</blockquote>\n<p>.eosrc 文件的增删改查</p>\n<pre><code>import &#123; RC, DEFAULTS &#125; from &#39;./constants&#39;;import &#123; decode, encode &#125; from &#39;ini&#39;;import &#123; promisify &#125; from &#39;util&#39;;import chalk from &#39;chalk&#39;;import fs from &#39;fs&#39;;const exits = promisify(fs.exists);const readFile = promisify(fs.readFile);const writeFile = promisify(fs.writeFile);//RC 是配置文件//DEFAULTS 是默认的配置export const get = async (key) =&gt; &#123;    const exit = await exits(RC);    let opts;    if (exit) &#123;        opts = await readFile(RC, &#39;utf8&#39;);        opts = decode(opts);        return opts[key];    &#125;    return &#39;&#39;;&#125;export const getAll = async () =&gt; &#123;    const exit = await exits(RC);    let opts;    if (exit) &#123;        opts = await readFile(RC, &#39;utf8&#39;);        opts = decode(opts);        return opts;    &#125;    return &#123;&#125;;&#125;export const set = async (key, value) =&gt; &#123;    const exit = await exits(RC);    let opts;    if (exit) &#123;        opts = await readFile(RC, &#39;utf8&#39;);        opts = decode(opts);        if(!key) &#123;            console.log(chalk.red(chalk.bold(&#39;Error:&#39;)), chalk.red(&#39;key is required&#39;));            return;        &#125;        if(!value) &#123;            console.log(chalk.red(chalk.bold(&#39;Error:&#39;)), chalk.red(&#39;value is required&#39;));            return;        &#125;        Object.assign(opts, &#123; [key]: value &#125;);    &#125; else &#123;        opts = Object.assign(DEFAULTS, &#123; [key]: value &#125;);    &#125;    await writeFile(RC, encode(opts), &#39;utf8&#39;);&#125;export const remove = async (key) =&gt; &#123;    const exit = await exits(RC);    let opts;    if (exit) &#123;        opts = await readFile(RC, &#39;utf8&#39;);        opts = decode(opts);        delete opts[key];        await writeFile(RC, encode(opts), &#39;utf8&#39;);    &#125;&#125;\n</code></pre>\n<h3 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a><strong>发布</strong></h3><p><code>npm publish</code> 将本脚手架发布至npm上。其它用户可以通过 <code>npm install eos-cli -g</code> 全局安装。<br>即可使用 <code>eos</code> 命令。</p>\n<h3 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a><strong>项目地址</strong></h3><p>本项目完整代码请戳: <a href=\"https://github.com/YvetteLau/Blog/tree/master/eos-cli\">https://github.com/YvetteLau/Blog/tree/master/eos-cli</a></p>\n"},{"title":"教你快速撸一个免费HTTPS证书","url":"154.html","id":"154","date":"2019-06-22T09:16:03.000Z","_content":"\nHTTPS 已成为业界标准，这篇博客将教你申请[Let’s Encrypt](https://letsencrypt.org/)的免费 HTTPS 证书。 本文的操作是在 Ubuntu 16.04 下进行，使用 nginx 作为 Web 服务器。【[蚂蚁号](https://www.v5ant.com/ \"蚂蚁号\")】\n\n### 1\\. 安装 Certbot\n\n[Certbot](https://certbot.eff.org/)可以用于管理(申请、更新、配置、撤销和删除等)Let’s Encrypt 证书。这里安装的是带 nginx 插件的 certbot：\n\n    sudo apt-get update\n    sudo apt-get install software-properties-common\n    sudo add-apt-repository -y ppa:certbot/certbot\n    sudo apt-get update\n    sudo apt-get install -y python-certbot-nginx\n\n### 2\\. 配置 Nginx\n\n    server\n    {\n        listen 80;\n        server_name www.v5ant.com;\n    }\n\n重启 nginx:\n\n    IMPORTANT NOTES:\n     - Congratulations! Your certificate and chain have been saved at:\n       /etc/letsencrypt/live/www.v5ant.com/fullchain.pem\n       Your key file has been saved at:\n       /etc/letsencrypt/live/www.v5ant.com/privkey.pem\n       Your cert will expire on 2018-09-29. To obtain a new or tweaked\n       version of this certificate in the future, simply run certbot again\n       with the \"certonly\" option. To non-interactively renew *all* of\n       your certificates, run \"certbot renew\"\n     - If you like Certbot, please consider supporting our work by:\n    \n       Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate\n       Donating to EFF:                    https://eff.org/donate-le\n\nHTTPS 证书相关的文件在/etc/letsencrypt/目录中：\n\n    find /etc/letsencrypt/ -name \"*www.v5ant.com*\"\n    /etc/letsencrypt/renewal/www.v5ant.com.conf\n    /etc/letsencrypt/archive/www.v5ant.com\n    /etc/letsencrypt/live/www.v5ant.com\n\ncertbot 会自动修改 nginx 配置文件：\n\n    server\n    {\n        listen 80;\n        server_name www.v5ant.com;\n    \n        listen 443 ssl; # managed by Certbot\n        ssl_certificate /etc/letsencrypt/live/www.v5ant.com/fullchain.pem; # managed by Certbot\n        ssl_certificate_key /etc/letsencrypt/live/www.v5ant.com/privkey.pem; # managed by Certbot\n        include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n    }\n\n### 参考\n\n*   [Certbot 文档：Nginx on Ubuntu 16.04 (xenial)](https://certbot.eff.org/lets-encrypt/ubuntuxenial-nginx)","source":"_posts/e6-95-99-e4-bd-a0-e5-bf-ab-e9-80-9f-e6-92-b8-e4-b8-80-e4-b8-aa-e5-85-8d-e8-b4-b9https-e8-af-81-e4-b9-a6.md","raw":"---\ntitle: 教你快速撸一个免费HTTPS证书\nurl: 154.html\nid: 154\ncategories:\n  - 服务端\ndate: 2019-06-22 17:16:03\ntags:\n---\n\nHTTPS 已成为业界标准，这篇博客将教你申请[Let’s Encrypt](https://letsencrypt.org/)的免费 HTTPS 证书。 本文的操作是在 Ubuntu 16.04 下进行，使用 nginx 作为 Web 服务器。【[蚂蚁号](https://www.v5ant.com/ \"蚂蚁号\")】\n\n### 1\\. 安装 Certbot\n\n[Certbot](https://certbot.eff.org/)可以用于管理(申请、更新、配置、撤销和删除等)Let’s Encrypt 证书。这里安装的是带 nginx 插件的 certbot：\n\n    sudo apt-get update\n    sudo apt-get install software-properties-common\n    sudo add-apt-repository -y ppa:certbot/certbot\n    sudo apt-get update\n    sudo apt-get install -y python-certbot-nginx\n\n### 2\\. 配置 Nginx\n\n    server\n    {\n        listen 80;\n        server_name www.v5ant.com;\n    }\n\n重启 nginx:\n\n    IMPORTANT NOTES:\n     - Congratulations! Your certificate and chain have been saved at:\n       /etc/letsencrypt/live/www.v5ant.com/fullchain.pem\n       Your key file has been saved at:\n       /etc/letsencrypt/live/www.v5ant.com/privkey.pem\n       Your cert will expire on 2018-09-29. To obtain a new or tweaked\n       version of this certificate in the future, simply run certbot again\n       with the \"certonly\" option. To non-interactively renew *all* of\n       your certificates, run \"certbot renew\"\n     - If you like Certbot, please consider supporting our work by:\n    \n       Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate\n       Donating to EFF:                    https://eff.org/donate-le\n\nHTTPS 证书相关的文件在/etc/letsencrypt/目录中：\n\n    find /etc/letsencrypt/ -name \"*www.v5ant.com*\"\n    /etc/letsencrypt/renewal/www.v5ant.com.conf\n    /etc/letsencrypt/archive/www.v5ant.com\n    /etc/letsencrypt/live/www.v5ant.com\n\ncertbot 会自动修改 nginx 配置文件：\n\n    server\n    {\n        listen 80;\n        server_name www.v5ant.com;\n    \n        listen 443 ssl; # managed by Certbot\n        ssl_certificate /etc/letsencrypt/live/www.v5ant.com/fullchain.pem; # managed by Certbot\n        ssl_certificate_key /etc/letsencrypt/live/www.v5ant.com/privkey.pem; # managed by Certbot\n        include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n        ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n    }\n\n### 参考\n\n*   [Certbot 文档：Nginx on Ubuntu 16.04 (xenial)](https://certbot.eff.org/lets-encrypt/ubuntuxenial-nginx)","slug":"e6-95-99-e4-bd-a0-e5-bf-ab-e9-80-9f-e6-92-b8-e4-b8-80-e4-b8-aa-e5-85-8d-e8-b4-b9https-e8-af-81-e4-b9-a6","published":1,"updated":"2019-09-10T07:46:08.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269bg001sc8gs6plu6ng4","content":"<p>HTTPS 已成为业界标准，这篇博客将教你申请<a href=\"https://letsencrypt.org/\">Let’s Encrypt</a>的免费 HTTPS 证书。 本文的操作是在 Ubuntu 16.04 下进行，使用 nginx 作为 Web 服务器。【<a href=\"https://www.v5ant.com/\" title=\"蚂蚁号\">蚂蚁号</a>】</p>\n<h3 id=\"1-安装-Certbot\"><a href=\"#1-安装-Certbot\" class=\"headerlink\" title=\"1. 安装 Certbot\"></a>1. 安装 Certbot</h3><p><a href=\"https://certbot.eff.org/\">Certbot</a>可以用于管理(申请、更新、配置、撤销和删除等)Let’s Encrypt 证书。这里安装的是带 nginx 插件的 certbot：</p>\n<pre><code>sudo apt-get update\nsudo apt-get install software-properties-common\nsudo add-apt-repository -y ppa:certbot/certbot\nsudo apt-get update\nsudo apt-get install -y python-certbot-nginx\n</code></pre>\n<h3 id=\"2-配置-Nginx\"><a href=\"#2-配置-Nginx\" class=\"headerlink\" title=\"2. 配置 Nginx\"></a>2. 配置 Nginx</h3><pre><code>server\n&#123;\n    listen 80;\n    server_name www.v5ant.com;\n&#125;\n</code></pre>\n<p>重启 nginx:</p>\n<pre><code>IMPORTANT NOTES:\n - Congratulations! Your certificate and chain have been saved at:\n   /etc/letsencrypt/live/www.v5ant.com/fullchain.pem\n   Your key file has been saved at:\n   /etc/letsencrypt/live/www.v5ant.com/privkey.pem\n   Your cert will expire on 2018-09-29. To obtain a new or tweaked\n   version of this certificate in the future, simply run certbot again\n   with the &quot;certonly&quot; option. To non-interactively renew *all* of\n   your certificates, run &quot;certbot renew&quot;\n - If you like Certbot, please consider supporting our work by:\n\n   Donating to ISRG / Let&#39;s Encrypt:   https://letsencrypt.org/donate\n   Donating to EFF:                    https://eff.org/donate-le\n</code></pre>\n<p>HTTPS 证书相关的文件在/etc/letsencrypt/目录中：</p>\n<pre><code>find /etc/letsencrypt/ -name &quot;*www.v5ant.com*&quot;\n/etc/letsencrypt/renewal/www.v5ant.com.conf\n/etc/letsencrypt/archive/www.v5ant.com\n/etc/letsencrypt/live/www.v5ant.com\n</code></pre>\n<p>certbot 会自动修改 nginx 配置文件：</p>\n<pre><code>server\n&#123;\n    listen 80;\n    server_name www.v5ant.com;\n\n    listen 443 ssl; # managed by Certbot\n    ssl_certificate /etc/letsencrypt/live/www.v5ant.com/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/www.v5ant.com/privkey.pem; # managed by Certbot\n    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n&#125;\n</code></pre>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li>  <a href=\"https://certbot.eff.org/lets-encrypt/ubuntuxenial-nginx\">Certbot 文档：Nginx on Ubuntu 16.04 (xenial)</a></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>HTTPS 已成为业界标准，这篇博客将教你申请<a href=\"https://letsencrypt.org/\">Let’s Encrypt</a>的免费 HTTPS 证书。 本文的操作是在 Ubuntu 16.04 下进行，使用 nginx 作为 Web 服务器。【<a href=\"https://www.v5ant.com/\" title=\"蚂蚁号\">蚂蚁号</a>】</p>\n<h3 id=\"1-安装-Certbot\"><a href=\"#1-安装-Certbot\" class=\"headerlink\" title=\"1. 安装 Certbot\"></a>1. 安装 Certbot</h3><p><a href=\"https://certbot.eff.org/\">Certbot</a>可以用于管理(申请、更新、配置、撤销和删除等)Let’s Encrypt 证书。这里安装的是带 nginx 插件的 certbot：</p>\n<pre><code>sudo apt-get update\nsudo apt-get install software-properties-common\nsudo add-apt-repository -y ppa:certbot/certbot\nsudo apt-get update\nsudo apt-get install -y python-certbot-nginx\n</code></pre>\n<h3 id=\"2-配置-Nginx\"><a href=\"#2-配置-Nginx\" class=\"headerlink\" title=\"2. 配置 Nginx\"></a>2. 配置 Nginx</h3><pre><code>server\n&#123;\n    listen 80;\n    server_name www.v5ant.com;\n&#125;\n</code></pre>\n<p>重启 nginx:</p>\n<pre><code>IMPORTANT NOTES:\n - Congratulations! Your certificate and chain have been saved at:\n   /etc/letsencrypt/live/www.v5ant.com/fullchain.pem\n   Your key file has been saved at:\n   /etc/letsencrypt/live/www.v5ant.com/privkey.pem\n   Your cert will expire on 2018-09-29. To obtain a new or tweaked\n   version of this certificate in the future, simply run certbot again\n   with the &quot;certonly&quot; option. To non-interactively renew *all* of\n   your certificates, run &quot;certbot renew&quot;\n - If you like Certbot, please consider supporting our work by:\n\n   Donating to ISRG / Let&#39;s Encrypt:   https://letsencrypt.org/donate\n   Donating to EFF:                    https://eff.org/donate-le\n</code></pre>\n<p>HTTPS 证书相关的文件在/etc/letsencrypt/目录中：</p>\n<pre><code>find /etc/letsencrypt/ -name &quot;*www.v5ant.com*&quot;\n/etc/letsencrypt/renewal/www.v5ant.com.conf\n/etc/letsencrypt/archive/www.v5ant.com\n/etc/letsencrypt/live/www.v5ant.com\n</code></pre>\n<p>certbot 会自动修改 nginx 配置文件：</p>\n<pre><code>server\n&#123;\n    listen 80;\n    server_name www.v5ant.com;\n\n    listen 443 ssl; # managed by Certbot\n    ssl_certificate /etc/letsencrypt/live/www.v5ant.com/fullchain.pem; # managed by Certbot\n    ssl_certificate_key /etc/letsencrypt/live/www.v5ant.com/privkey.pem; # managed by Certbot\n    include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot\n    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot\n&#125;\n</code></pre>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li>  <a href=\"https://certbot.eff.org/lets-encrypt/ubuntuxenial-nginx\">Certbot 文档：Nginx on Ubuntu 16.04 (xenial)</a></li>\n</ul>\n"},{"title":"教你搭建一套属于自己的视频网站-小白教程大神绕道","url":"145.html","id":"145","date":"2019-06-22T09:10:12.000Z","_content":"\n前言\n--\n\n对于大部分基础前端开发者同学来说对PHP，mysql，Linux这些都不太熟悉，想要搭建一套属于自己的完整网站程序比较吃力，那么希望这篇文章可以帮到你。 我们需要先了解一个概念** CMS ，** CMS是\"Content Management System\"的缩写，意为\"内容管理系统\"。简单理解就是一种位于WEB前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）整合的一套软件系统。cms有很多种类资讯新闻类，政府类，B2B,B2C电子商务类，博客类，视频类等等... 不说废话了今天我们就弄一个视频类的玩着也有趣很多，我搭建的名字叫【[蚂蚁影院](http://mv.v5ant.com/)】是不是很听起来很不错????。\n\n一.基础工作准备\n--------\n\n网站三要素：**空间，域名，程序**\n\n### 准备空间\n\n空间去哪买？ 目前国内主流的也就是亚马逊,阿里云，腾讯云，百度云，景安网络，西部数码.. 机器类目繁多怎么买？ 一般也就虚拟**空间，vps，云主机 ** **虚拟空间**，也称虚拟主机（Virtual Host Virtual Server）是使用特殊的软硬件技术，把一台计算机主机     分成一台台\"虚    拟\"的主机，每一台虚拟主机都具有独立的域名和IP地址（或共享的IP地址），具有        完   整的Internet服务器能。 **VPS**是服务器划分的一块，但是有独立的操作系统，可以理解为是一个小电脑； **云主机**和其他普通主机基本概念相同，就是云主机是新一代的主机租用服务 价格大概是这样的 **虚拟空间 < VPS < 云主机 , ** 我们就是简单弄一个玩其实虚拟空间就能跑起来关键便宜，应该虚拟空间是只能放一个站而且有一些其他限制比如PHP版本什么都，有的还不支持Linux反正看清楚再买了。主机就爽了????可以放N个网站系统也可以随便装的看你们需求了。\n\n### 准备域名\n\n域名一般就去万网，新网注册就可以，主机运营商一般都可以买域名。需要注意的是大陆空间需要备案，而有的特殊后缀的域名是不支持备案的所以就安安稳稳买.com就好了????\n\n### 准备程序\n\n今天我们教程使用的程序是苹果cms，苹果CMS程序是一套采用PHP+MYSQL环境下运行的快速建站系统。地址：http://www.maccms.com ，下载最新版v10就可以。\n\n二.服务器部署\n-------\n\n本教程是以ubuntu系统为例写的，因此建议在申请VPS时，操作系统选择ubuntu18.04. 在安装苹果CMS之前，要先要在你的VPS上搭建LAMP环境。所谓的LAMP指的Linux+Apache+Mysql+PHP. 其中，你的操作系统ubuntu就是Linux。Apache是http服务器，浏览器通过服务器（也就是你的VPS）上的apache提供的服务才能获取到网页资源，从而显示在你的电脑屏幕上。Mysql是数据库，你的网站（这里即是苹果CMS）动态运行时所存取的数据都是由数据库来管理的。PHP与Apache相互配合为用户提供动态的网页，我们要安装的苹果CMS就是php语言编写的，他的运行必须依赖于PHP环境。 关于LAMP环境的搭建方法，网上有太多的教程，这里不介绍具体的安装方法，请自行在百度中搜索，其安装很简单，在ubuntu下使用apt-get命令即可安装。\n\n三.安装苹果CMS\n---------\n\n首先，到苹果CMS官网上下载安装包，然后使用scp命令将安装包拷贝到你的VPS的 /var/www/html目录下并解压（当然你也可以直接在vps上使用wget命令下载安装包），解压成功后，先在vps上执行命令 chmod -R 777 /var/www/html 修改文件权限。然后在你的浏览器中访问 http://你的vps的ip地址或域名/install.php 即可进入安装界面，如下所示： ![image.png](http://cdn.v5ant.com/ueditor/images/1118806560458543104.png) 然后，点击“同意协议并安装系统”，此时进入下面的环境监测界面。安装程序会检查一下你的vps上所安装的插件是否符合苹果CMS的要求，只有符合要求时，苹果CMS才能正常运行，因此这一步的检测是必要的。 ![image.png](http://cdn.v5ant.com/ueditor/images/1118806754055032832.png) 当然，既然是检测环境，当然会有某些检查项不符合要求的情况，如果哪一项不符合要求，这里会用红色高亮的色带将其标识出来。一般检测不通过都是因为系统中缺少某些插件，使用apt-get命令将这些插件安装好后，重新开始安装即可。例如，当zip这一项检测失败时，在vps上执行 apt-get install php-zip 命令；若xml这一项检测失败，则在vps上执行 apt-get install php-xml 命令，其它模块检测失败都可以用这种方式来安装。当这一步检测全部成功后，即可点击“进行下一步”按钮，此时进入如下界面： ![image.png](http://cdn.v5ant.com/ueditor/images/1118806876012810240.png) 这里有关数据库的信息，按照你的MySQL中的实际配置填写就好，目的是让苹果CMS通过这些参数能够登录到你的MySQL上，只有这样，苹果CMS才能使用数据库读写所需的数据。 下面的管理员账号密码是你日后用来登录苹果CMS后台时所需的用户名和密码，请设置一个足够长，并且足够安全，不易被破解的密码并牢记它。 最后，点击“立即执行安装”按钮，稍等片刻即安装成功。此时，在浏览器中输入 http://你的vps的ip地址或域名/index.php 即可看到苹果CMS的主页（即前台界面）。这个页面就是外界访问你的站点时看到的首页。 在浏览器中输入 http://你的vps的ip地址或域名/admin.php 即可登录苹果CMS后台管理界面。在后台管理页面，你可以做与你的站点相关的一切设置，包括采集视频、设置播放器、更换模板、设置SEO优化等等。这部分内容十分繁杂，只有成功采集到视频数据后，你的网站上才有内容，别人才能够在你的网站上观看视频，否则你的网站就是空的，没什么实质性内容。 这里只简单介绍一下如何采集系统自带的资源站的数据，如下如所示的步骤操作即可： 采集时可能会报错“分类未绑定”，这是因为你的站点的电影分类与资源站上的电影分类没有建立一一对应关系，因此，苹果CMS并不知道资源站上的A分类对应到你的站点上是哪一个分类。此时只需绑定分类即可，这些操作都不难，稍加摸索即可上手。 网站设置好后的效果，可以参看我的站点：蚂蚁影院（[点击前往](http://mv.v5ant.com/)） 本教程主要讲解苹果CMS的安装和配置，至于（自定义）采集视频、站点的高级设置、网站SEO优化等高阶话题，可以参看其它资料，或者登陆苹果CMS官方论坛寻求帮助。总之，网上关于这方面的文章有很多，再此不再赘述。","source":"_posts/e6-95-99-e4-bd-a0-e6-90-ad-e5-bb-ba-e4-b8-80-e5-a5-97-e5-b1-9e-e4-ba-8e-e8-87-aa-e5-b7-b1-e7-9a-84-e8-a7-86-e9-a2-91-e7-bd-91-e7-ab-99-e5-b0-8f-e7-99-bd-e6-95-99-e7-a8-8b-e5-a4-a7-e7-a5-9e-e7-bb-95.md","raw":"---\ntitle: 教你搭建一套属于自己的视频网站-小白教程大神绕道\nurl: 145.html\nid: 145\ncategories:\n  - 大前端\ndate: 2019-06-22 17:10:12\ntags:\n---\n\n前言\n--\n\n对于大部分基础前端开发者同学来说对PHP，mysql，Linux这些都不太熟悉，想要搭建一套属于自己的完整网站程序比较吃力，那么希望这篇文章可以帮到你。 我们需要先了解一个概念** CMS ，** CMS是\"Content Management System\"的缩写，意为\"内容管理系统\"。简单理解就是一种位于WEB前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）整合的一套软件系统。cms有很多种类资讯新闻类，政府类，B2B,B2C电子商务类，博客类，视频类等等... 不说废话了今天我们就弄一个视频类的玩着也有趣很多，我搭建的名字叫【[蚂蚁影院](http://mv.v5ant.com/)】是不是很听起来很不错????。\n\n一.基础工作准备\n--------\n\n网站三要素：**空间，域名，程序**\n\n### 准备空间\n\n空间去哪买？ 目前国内主流的也就是亚马逊,阿里云，腾讯云，百度云，景安网络，西部数码.. 机器类目繁多怎么买？ 一般也就虚拟**空间，vps，云主机 ** **虚拟空间**，也称虚拟主机（Virtual Host Virtual Server）是使用特殊的软硬件技术，把一台计算机主机     分成一台台\"虚    拟\"的主机，每一台虚拟主机都具有独立的域名和IP地址（或共享的IP地址），具有        完   整的Internet服务器能。 **VPS**是服务器划分的一块，但是有独立的操作系统，可以理解为是一个小电脑； **云主机**和其他普通主机基本概念相同，就是云主机是新一代的主机租用服务 价格大概是这样的 **虚拟空间 < VPS < 云主机 , ** 我们就是简单弄一个玩其实虚拟空间就能跑起来关键便宜，应该虚拟空间是只能放一个站而且有一些其他限制比如PHP版本什么都，有的还不支持Linux反正看清楚再买了。主机就爽了????可以放N个网站系统也可以随便装的看你们需求了。\n\n### 准备域名\n\n域名一般就去万网，新网注册就可以，主机运营商一般都可以买域名。需要注意的是大陆空间需要备案，而有的特殊后缀的域名是不支持备案的所以就安安稳稳买.com就好了????\n\n### 准备程序\n\n今天我们教程使用的程序是苹果cms，苹果CMS程序是一套采用PHP+MYSQL环境下运行的快速建站系统。地址：http://www.maccms.com ，下载最新版v10就可以。\n\n二.服务器部署\n-------\n\n本教程是以ubuntu系统为例写的，因此建议在申请VPS时，操作系统选择ubuntu18.04. 在安装苹果CMS之前，要先要在你的VPS上搭建LAMP环境。所谓的LAMP指的Linux+Apache+Mysql+PHP. 其中，你的操作系统ubuntu就是Linux。Apache是http服务器，浏览器通过服务器（也就是你的VPS）上的apache提供的服务才能获取到网页资源，从而显示在你的电脑屏幕上。Mysql是数据库，你的网站（这里即是苹果CMS）动态运行时所存取的数据都是由数据库来管理的。PHP与Apache相互配合为用户提供动态的网页，我们要安装的苹果CMS就是php语言编写的，他的运行必须依赖于PHP环境。 关于LAMP环境的搭建方法，网上有太多的教程，这里不介绍具体的安装方法，请自行在百度中搜索，其安装很简单，在ubuntu下使用apt-get命令即可安装。\n\n三.安装苹果CMS\n---------\n\n首先，到苹果CMS官网上下载安装包，然后使用scp命令将安装包拷贝到你的VPS的 /var/www/html目录下并解压（当然你也可以直接在vps上使用wget命令下载安装包），解压成功后，先在vps上执行命令 chmod -R 777 /var/www/html 修改文件权限。然后在你的浏览器中访问 http://你的vps的ip地址或域名/install.php 即可进入安装界面，如下所示： ![image.png](http://cdn.v5ant.com/ueditor/images/1118806560458543104.png) 然后，点击“同意协议并安装系统”，此时进入下面的环境监测界面。安装程序会检查一下你的vps上所安装的插件是否符合苹果CMS的要求，只有符合要求时，苹果CMS才能正常运行，因此这一步的检测是必要的。 ![image.png](http://cdn.v5ant.com/ueditor/images/1118806754055032832.png) 当然，既然是检测环境，当然会有某些检查项不符合要求的情况，如果哪一项不符合要求，这里会用红色高亮的色带将其标识出来。一般检测不通过都是因为系统中缺少某些插件，使用apt-get命令将这些插件安装好后，重新开始安装即可。例如，当zip这一项检测失败时，在vps上执行 apt-get install php-zip 命令；若xml这一项检测失败，则在vps上执行 apt-get install php-xml 命令，其它模块检测失败都可以用这种方式来安装。当这一步检测全部成功后，即可点击“进行下一步”按钮，此时进入如下界面： ![image.png](http://cdn.v5ant.com/ueditor/images/1118806876012810240.png) 这里有关数据库的信息，按照你的MySQL中的实际配置填写就好，目的是让苹果CMS通过这些参数能够登录到你的MySQL上，只有这样，苹果CMS才能使用数据库读写所需的数据。 下面的管理员账号密码是你日后用来登录苹果CMS后台时所需的用户名和密码，请设置一个足够长，并且足够安全，不易被破解的密码并牢记它。 最后，点击“立即执行安装”按钮，稍等片刻即安装成功。此时，在浏览器中输入 http://你的vps的ip地址或域名/index.php 即可看到苹果CMS的主页（即前台界面）。这个页面就是外界访问你的站点时看到的首页。 在浏览器中输入 http://你的vps的ip地址或域名/admin.php 即可登录苹果CMS后台管理界面。在后台管理页面，你可以做与你的站点相关的一切设置，包括采集视频、设置播放器、更换模板、设置SEO优化等等。这部分内容十分繁杂，只有成功采集到视频数据后，你的网站上才有内容，别人才能够在你的网站上观看视频，否则你的网站就是空的，没什么实质性内容。 这里只简单介绍一下如何采集系统自带的资源站的数据，如下如所示的步骤操作即可： 采集时可能会报错“分类未绑定”，这是因为你的站点的电影分类与资源站上的电影分类没有建立一一对应关系，因此，苹果CMS并不知道资源站上的A分类对应到你的站点上是哪一个分类。此时只需绑定分类即可，这些操作都不难，稍加摸索即可上手。 网站设置好后的效果，可以参看我的站点：蚂蚁影院（[点击前往](http://mv.v5ant.com/)） 本教程主要讲解苹果CMS的安装和配置，至于（自定义）采集视频、站点的高级设置、网站SEO优化等高阶话题，可以参看其它资料，或者登陆苹果CMS官方论坛寻求帮助。总之，网上关于这方面的文章有很多，再此不再赘述。","slug":"e6-95-99-e4-bd-a0-e6-90-ad-e5-bb-ba-e4-b8-80-e5-a5-97-e5-b1-9e-e4-ba-8e-e8-87-aa-e5-b7-b1-e7-9a-84-e8-a7-86-e9-a2-91-e7-bd-91-e7-ab-99-e5-b0-8f-e7-99-bd-e6-95-99-e7-a8-8b-e5-a4-a7-e7-a5-9e-e7-bb-95","published":1,"updated":"2019-09-10T07:46:08.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269bj001vc8gs56b0e99i","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于大部分基础前端开发者同学来说对PHP，mysql，Linux这些都不太熟悉，想要搭建一套属于自己的完整网站程序比较吃力，那么希望这篇文章可以帮到你。 我们需要先了解一个概念** CMS ，** CMS是”Content Management System”的缩写，意为”内容管理系统”。简单理解就是一种位于WEB前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）整合的一套软件系统。cms有很多种类资讯新闻类，政府类，B2B,B2C电子商务类，博客类，视频类等等… 不说废话了今天我们就弄一个视频类的玩着也有趣很多，我搭建的名字叫【<a href=\"http://mv.v5ant.com/\">蚂蚁影院</a>】是不是很听起来很不错????。</p>\n<h2 id=\"一-基础工作准备\"><a href=\"#一-基础工作准备\" class=\"headerlink\" title=\"一.基础工作准备\"></a>一.基础工作准备</h2><p>网站三要素：<strong>空间，域名，程序</strong></p>\n<h3 id=\"准备空间\"><a href=\"#准备空间\" class=\"headerlink\" title=\"准备空间\"></a>准备空间</h3><p>空间去哪买？ 目前国内主流的也就是亚马逊,阿里云，腾讯云，百度云，景安网络，西部数码.. 机器类目繁多怎么买？ 一般也就虚拟**空间，vps，云主机 ** <strong>虚拟空间</strong>，也称虚拟主机（Virtual Host Virtual Server）是使用特殊的软硬件技术，把一台计算机主机     分成一台台”虚    拟”的主机，每一台虚拟主机都具有独立的域名和IP地址（或共享的IP地址），具有        完   整的Internet服务器能。 <strong>VPS</strong>是服务器划分的一块，但是有独立的操作系统，可以理解为是一个小电脑； <strong>云主机</strong>和其他普通主机基本概念相同，就是云主机是新一代的主机租用服务 价格大概是这样的 **虚拟空间 &lt; VPS &lt; 云主机 , ** 我们就是简单弄一个玩其实虚拟空间就能跑起来关键便宜，应该虚拟空间是只能放一个站而且有一些其他限制比如PHP版本什么都，有的还不支持Linux反正看清楚再买了。主机就爽了????可以放N个网站系统也可以随便装的看你们需求了。</p>\n<h3 id=\"准备域名\"><a href=\"#准备域名\" class=\"headerlink\" title=\"准备域名\"></a>准备域名</h3><p>域名一般就去万网，新网注册就可以，主机运营商一般都可以买域名。需要注意的是大陆空间需要备案，而有的特殊后缀的域名是不支持备案的所以就安安稳稳买.com就好了????</p>\n<h3 id=\"准备程序\"><a href=\"#准备程序\" class=\"headerlink\" title=\"准备程序\"></a>准备程序</h3><p>今天我们教程使用的程序是苹果cms，苹果CMS程序是一套采用PHP+MYSQL环境下运行的快速建站系统。地址：<a href=\"http://www.maccms.com/\">http://www.maccms.com</a> ，下载最新版v10就可以。</p>\n<h2 id=\"二-服务器部署\"><a href=\"#二-服务器部署\" class=\"headerlink\" title=\"二.服务器部署\"></a>二.服务器部署</h2><p>本教程是以ubuntu系统为例写的，因此建议在申请VPS时，操作系统选择ubuntu18.04. 在安装苹果CMS之前，要先要在你的VPS上搭建LAMP环境。所谓的LAMP指的Linux+Apache+Mysql+PHP. 其中，你的操作系统ubuntu就是Linux。Apache是http服务器，浏览器通过服务器（也就是你的VPS）上的apache提供的服务才能获取到网页资源，从而显示在你的电脑屏幕上。Mysql是数据库，你的网站（这里即是苹果CMS）动态运行时所存取的数据都是由数据库来管理的。PHP与Apache相互配合为用户提供动态的网页，我们要安装的苹果CMS就是php语言编写的，他的运行必须依赖于PHP环境。 关于LAMP环境的搭建方法，网上有太多的教程，这里不介绍具体的安装方法，请自行在百度中搜索，其安装很简单，在ubuntu下使用apt-get命令即可安装。</p>\n<h2 id=\"三-安装苹果CMS\"><a href=\"#三-安装苹果CMS\" class=\"headerlink\" title=\"三.安装苹果CMS\"></a>三.安装苹果CMS</h2><p>首先，到苹果CMS官网上下载安装包，然后使用scp命令将安装包拷贝到你的VPS的 /var/www/html目录下并解压（当然你也可以直接在vps上使用wget命令下载安装包），解压成功后，先在vps上执行命令 chmod -R 777 /var/www/html 修改文件权限。然后在你的浏览器中访问 http://你的vps的ip地址或域名/install.php 即可进入安装界面，如下所示： <img src=\"http://cdn.v5ant.com/ueditor/images/1118806560458543104.png\" alt=\"image.png\"> 然后，点击“同意协议并安装系统”，此时进入下面的环境监测界面。安装程序会检查一下你的vps上所安装的插件是否符合苹果CMS的要求，只有符合要求时，苹果CMS才能正常运行，因此这一步的检测是必要的。 <img src=\"http://cdn.v5ant.com/ueditor/images/1118806754055032832.png\" alt=\"image.png\"> 当然，既然是检测环境，当然会有某些检查项不符合要求的情况，如果哪一项不符合要求，这里会用红色高亮的色带将其标识出来。一般检测不通过都是因为系统中缺少某些插件，使用apt-get命令将这些插件安装好后，重新开始安装即可。例如，当zip这一项检测失败时，在vps上执行 apt-get install php-zip 命令；若xml这一项检测失败，则在vps上执行 apt-get install php-xml 命令，其它模块检测失败都可以用这种方式来安装。当这一步检测全部成功后，即可点击“进行下一步”按钮，此时进入如下界面： <img src=\"http://cdn.v5ant.com/ueditor/images/1118806876012810240.png\" alt=\"image.png\"> 这里有关数据库的信息，按照你的MySQL中的实际配置填写就好，目的是让苹果CMS通过这些参数能够登录到你的MySQL上，只有这样，苹果CMS才能使用数据库读写所需的数据。 下面的管理员账号密码是你日后用来登录苹果CMS后台时所需的用户名和密码，请设置一个足够长，并且足够安全，不易被破解的密码并牢记它。 最后，点击“立即执行安装”按钮，稍等片刻即安装成功。此时，在浏览器中输入 http://你的vps的ip地址或域名/index.php 即可看到苹果CMS的主页（即前台界面）。这个页面就是外界访问你的站点时看到的首页。 在浏览器中输入 http://你的vps的ip地址或域名/admin.php 即可登录苹果CMS后台管理界面。在后台管理页面，你可以做与你的站点相关的一切设置，包括采集视频、设置播放器、更换模板、设置SEO优化等等。这部分内容十分繁杂，只有成功采集到视频数据后，你的网站上才有内容，别人才能够在你的网站上观看视频，否则你的网站就是空的，没什么实质性内容。 这里只简单介绍一下如何采集系统自带的资源站的数据，如下如所示的步骤操作即可： 采集时可能会报错“分类未绑定”，这是因为你的站点的电影分类与资源站上的电影分类没有建立一一对应关系，因此，苹果CMS并不知道资源站上的A分类对应到你的站点上是哪一个分类。此时只需绑定分类即可，这些操作都不难，稍加摸索即可上手。 网站设置好后的效果，可以参看我的站点：蚂蚁影院（<a href=\"http://mv.v5ant.com/\">点击前往</a>） 本教程主要讲解苹果CMS的安装和配置，至于（自定义）采集视频、站点的高级设置、网站SEO优化等高阶话题，可以参看其它资料，或者登陆苹果CMS官方论坛寻求帮助。总之，网上关于这方面的文章有很多，再此不再赘述。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于大部分基础前端开发者同学来说对PHP，mysql，Linux这些都不太熟悉，想要搭建一套属于自己的完整网站程序比较吃力，那么希望这篇文章可以帮到你。 我们需要先了解一个概念** CMS ，** CMS是”Content Management System”的缩写，意为”内容管理系统”。简单理解就是一种位于WEB前端（Web 服务器）和后端办公系统或流程（内容创作、编辑）整合的一套软件系统。cms有很多种类资讯新闻类，政府类，B2B,B2C电子商务类，博客类，视频类等等… 不说废话了今天我们就弄一个视频类的玩着也有趣很多，我搭建的名字叫【<a href=\"http://mv.v5ant.com/\">蚂蚁影院</a>】是不是很听起来很不错????。</p>\n<h2 id=\"一-基础工作准备\"><a href=\"#一-基础工作准备\" class=\"headerlink\" title=\"一.基础工作准备\"></a>一.基础工作准备</h2><p>网站三要素：<strong>空间，域名，程序</strong></p>\n<h3 id=\"准备空间\"><a href=\"#准备空间\" class=\"headerlink\" title=\"准备空间\"></a>准备空间</h3><p>空间去哪买？ 目前国内主流的也就是亚马逊,阿里云，腾讯云，百度云，景安网络，西部数码.. 机器类目繁多怎么买？ 一般也就虚拟**空间，vps，云主机 ** <strong>虚拟空间</strong>，也称虚拟主机（Virtual Host Virtual Server）是使用特殊的软硬件技术，把一台计算机主机     分成一台台”虚    拟”的主机，每一台虚拟主机都具有独立的域名和IP地址（或共享的IP地址），具有        完   整的Internet服务器能。 <strong>VPS</strong>是服务器划分的一块，但是有独立的操作系统，可以理解为是一个小电脑； <strong>云主机</strong>和其他普通主机基本概念相同，就是云主机是新一代的主机租用服务 价格大概是这样的 **虚拟空间 &lt; VPS &lt; 云主机 , ** 我们就是简单弄一个玩其实虚拟空间就能跑起来关键便宜，应该虚拟空间是只能放一个站而且有一些其他限制比如PHP版本什么都，有的还不支持Linux反正看清楚再买了。主机就爽了????可以放N个网站系统也可以随便装的看你们需求了。</p>\n<h3 id=\"准备域名\"><a href=\"#准备域名\" class=\"headerlink\" title=\"准备域名\"></a>准备域名</h3><p>域名一般就去万网，新网注册就可以，主机运营商一般都可以买域名。需要注意的是大陆空间需要备案，而有的特殊后缀的域名是不支持备案的所以就安安稳稳买.com就好了????</p>\n<h3 id=\"准备程序\"><a href=\"#准备程序\" class=\"headerlink\" title=\"准备程序\"></a>准备程序</h3><p>今天我们教程使用的程序是苹果cms，苹果CMS程序是一套采用PHP+MYSQL环境下运行的快速建站系统。地址：<a href=\"http://www.maccms.com/\">http://www.maccms.com</a> ，下载最新版v10就可以。</p>\n<h2 id=\"二-服务器部署\"><a href=\"#二-服务器部署\" class=\"headerlink\" title=\"二.服务器部署\"></a>二.服务器部署</h2><p>本教程是以ubuntu系统为例写的，因此建议在申请VPS时，操作系统选择ubuntu18.04. 在安装苹果CMS之前，要先要在你的VPS上搭建LAMP环境。所谓的LAMP指的Linux+Apache+Mysql+PHP. 其中，你的操作系统ubuntu就是Linux。Apache是http服务器，浏览器通过服务器（也就是你的VPS）上的apache提供的服务才能获取到网页资源，从而显示在你的电脑屏幕上。Mysql是数据库，你的网站（这里即是苹果CMS）动态运行时所存取的数据都是由数据库来管理的。PHP与Apache相互配合为用户提供动态的网页，我们要安装的苹果CMS就是php语言编写的，他的运行必须依赖于PHP环境。 关于LAMP环境的搭建方法，网上有太多的教程，这里不介绍具体的安装方法，请自行在百度中搜索，其安装很简单，在ubuntu下使用apt-get命令即可安装。</p>\n<h2 id=\"三-安装苹果CMS\"><a href=\"#三-安装苹果CMS\" class=\"headerlink\" title=\"三.安装苹果CMS\"></a>三.安装苹果CMS</h2><p>首先，到苹果CMS官网上下载安装包，然后使用scp命令将安装包拷贝到你的VPS的 /var/www/html目录下并解压（当然你也可以直接在vps上使用wget命令下载安装包），解压成功后，先在vps上执行命令 chmod -R 777 /var/www/html 修改文件权限。然后在你的浏览器中访问 http://你的vps的ip地址或域名/install.php 即可进入安装界面，如下所示： <img src=\"http://cdn.v5ant.com/ueditor/images/1118806560458543104.png\" alt=\"image.png\"> 然后，点击“同意协议并安装系统”，此时进入下面的环境监测界面。安装程序会检查一下你的vps上所安装的插件是否符合苹果CMS的要求，只有符合要求时，苹果CMS才能正常运行，因此这一步的检测是必要的。 <img src=\"http://cdn.v5ant.com/ueditor/images/1118806754055032832.png\" alt=\"image.png\"> 当然，既然是检测环境，当然会有某些检查项不符合要求的情况，如果哪一项不符合要求，这里会用红色高亮的色带将其标识出来。一般检测不通过都是因为系统中缺少某些插件，使用apt-get命令将这些插件安装好后，重新开始安装即可。例如，当zip这一项检测失败时，在vps上执行 apt-get install php-zip 命令；若xml这一项检测失败，则在vps上执行 apt-get install php-xml 命令，其它模块检测失败都可以用这种方式来安装。当这一步检测全部成功后，即可点击“进行下一步”按钮，此时进入如下界面： <img src=\"http://cdn.v5ant.com/ueditor/images/1118806876012810240.png\" alt=\"image.png\"> 这里有关数据库的信息，按照你的MySQL中的实际配置填写就好，目的是让苹果CMS通过这些参数能够登录到你的MySQL上，只有这样，苹果CMS才能使用数据库读写所需的数据。 下面的管理员账号密码是你日后用来登录苹果CMS后台时所需的用户名和密码，请设置一个足够长，并且足够安全，不易被破解的密码并牢记它。 最后，点击“立即执行安装”按钮，稍等片刻即安装成功。此时，在浏览器中输入 http://你的vps的ip地址或域名/index.php 即可看到苹果CMS的主页（即前台界面）。这个页面就是外界访问你的站点时看到的首页。 在浏览器中输入 http://你的vps的ip地址或域名/admin.php 即可登录苹果CMS后台管理界面。在后台管理页面，你可以做与你的站点相关的一切设置，包括采集视频、设置播放器、更换模板、设置SEO优化等等。这部分内容十分繁杂，只有成功采集到视频数据后，你的网站上才有内容，别人才能够在你的网站上观看视频，否则你的网站就是空的，没什么实质性内容。 这里只简单介绍一下如何采集系统自带的资源站的数据，如下如所示的步骤操作即可： 采集时可能会报错“分类未绑定”，这是因为你的站点的电影分类与资源站上的电影分类没有建立一一对应关系，因此，苹果CMS并不知道资源站上的A分类对应到你的站点上是哪一个分类。此时只需绑定分类即可，这些操作都不难，稍加摸索即可上手。 网站设置好后的效果，可以参看我的站点：蚂蚁影院（<a href=\"http://mv.v5ant.com/\">点击前往</a>） 本教程主要讲解苹果CMS的安装和配置，至于（自定义）采集视频、站点的高级设置、网站SEO优化等高阶话题，可以参看其它资料，或者登陆苹果CMS官方论坛寻求帮助。总之，网上关于这方面的文章有很多，再此不再赘述。</p>\n"},{"title":"新游派 | 本周不容错过的 5 款新游戏","url":"183.html","id":"183","date":"2019-06-24T12:37:01.000Z","_content":"\n青璃\n\n_移动平台 / 动作、解密 / 中文_ 年初，网易与故宫博物院联合推出的《绘真·妙笔千山》 ，受到了广泛好评。本周推出的动作解谜游戏《青璃》延续了《绘真·妙笔千山》如诗如画的意境，不同于后者的 2D 绘画风格，《青璃》采用了全 3D 的视角，呈现一个更加立体的江湖。 游戏中，你将扮演剑客青衣，在一场战斗中救下了失忆的白衣女子莫璃。你将陪同她四处游历，寻找记忆，在这个过程中你会遇到许多追杀你的敌人，你需要用自己高超的剑法将其击败。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/3a4fdaf93a3a71b4b28f8171e579eb88.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n作为一款解谜游戏，《青璃》的谜题难度不算特别高。只要你细心观察，基本不会卡关。除了主线谜题外，你还得留心路上的药草，采集药草喂给莫璃可以解锁她的隐藏动作。 游戏的战斗体验相当爽快，无论是刀刀到肉的打击感，极具冲击感的镜头切换，都为玩家带来了一场酣畅淋漓的战斗。《青璃》的对战并不是无脑攻击就行的，你需要观察敌人的动作，在恰当的时机发起攻击。 整体来看，《青璃》游戏体验尚可，但在一些细节上仍有待打磨，最影响游戏体验的就是战斗中的镜头切换。虽然这个设定增强了战斗的观感，但在狭窄的场景中，镜头总会切换到建筑后方，阻挡玩家的视线。 你可以在 [App Store](https://apps.apple.com/cn/app/%E9%9D%92%E7%92%83/id1452989059) 免费下载《青璃》（Android 版目前 [预约](https://ql.163.com/) 中），游戏支持中文，游戏流程约 2 小时。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/48e2b00434f4c3711cff28f1f8dc9006.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n字母人\n\n_全平台 / 解谜、横版、冒险 / 中文_ 《字母人》是一款由 PC、主机平台移植到移动平台的解谜游戏，曾荣获多个游戏奖项。游戏将英文单词与解谜相结合，玩家将扮演一名由「Hero」组成的字母人完成解谜冒险。游戏的 2D 剪影画风加上蒸汽朋克的要素，难免会让人想起《Limbo》。在一些谜题的设计上，二者也确实有相似之处。 游戏最大的卖点便是字母加解谜的奇妙组合。其中的字母组合也并非无意义的象形，而是将单词与物品相结合，比如你可以看到由「Gate」组成的门、由「Switch」组成的开关等。物品与文字相互提示，让机关更加显眼。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/477e52fd71ed5c359d8e13705eb282a5.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n尽管机关变得显眼了，但谜题的难度并没有因此而下降。在游戏中，你需要移动地上的字母，将它们拼成一个单词并放置在合适的区域才能打开机关。在追逐战中，你更需要眼疾手快，在怪物追上你之前开启机关，逃出生天。 在游戏中，你可以收集散落在在关卡各处的箴言，并在通关结算时查看自己的收集情况。此处有一个小提醒，当你在前进的道路上遇到岔路时，不妨先朝着有回头路的那边走，往往能找到隐藏的箴言。 由于游戏包含基于英文单词的解谜，对玩家的英语水平有一定程度的要求。如果不追求全收集，配合游戏内的提示机制，基本不用担心自己的英语水平会影响解谜。 你可以在 [App Store](https://apps.apple.com/cn/app/%E5%AD%97%E6%AF%8D%E4%BA%BA-typoman/id1365392834)（¥ 12）和 [TapTap](https://www.taptap.com/app/72825)（将于 6 月 21 日上架，售价 ¥12） 购买《字母人》，游戏支持中文。6 月 20 日前，你可以在 App Store 以半价购入游戏。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/5a06b7adef5ee17c126b06806c7c07bf.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n \n\nSoviet Souls\n\n_PC、移动平台 / 冒险、射击 / 英文_ 游戏故事发生在 2025 年，正在工作的「普汀」遇上了穿越而来的「斯塔林」和「涅宁」。三人为了从某个邪恶的猪猪军团中解救水生火热的国家，展开了一场冒险。 游戏中共有三名可操控角色，你可以在每一关开始前进行选择，每个角色都拥有独特的攻击技能。游戏的目标是收集场景中的勋章并抵达终点。在冒险途中，会有枪兵猪、飞行猪等不同的敌人对你造成伤害，你也要时刻留意不断移动的机关。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/55cce2110e577b4c5cbcb54869427b59.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n游戏中藏着许多幽默梗，无论是《致命武器》中的「I’m too old for this sh*t」，还是超级马里奥风格的关卡，都足以玩家会心一笑。尽管游戏看上去是一款黑色幽默性质的闯关游戏，但它的难度不容小觑，稍有不慎就有可能迎来失败。 游戏共有 32 关，你可以在其中游历「索维埃共和国」的知名地点。如果你遇到难以通过的关卡，不妨尝试在商店中升级角色生命值和技能。游戏拥有双结局设定，你的游戏表现将决定国家的命运。为了拯救国家与水火之中，高喊「乌拉」一起冲锋吧。 你可以在 [App Store](https://apps.apple.com/cn/app/soviet-souls/id1466122041)（¥12）和 [Steam](https://store.steampowered.com/app/1066210/Soviet_Souls/?curator_clanid=32668148)（¥26） 购买 Soviet Souls，游戏暂无中文。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/030e5b255c833ed9de9c6db12caebee4.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n \n\n英雄传说又一则 Yet Another Hero Legend\n\n_PC / 解谜、角色扮演、策略 / 中文_ 《英雄传说又一则》是一款诞生于国内 Project1 论坛的独立游戏。游戏玩法是以推箱子式的谜题设计为基础进行再创作的解谜游戏，并尝试用简短的文本阐释了一个颇具风味的世界观、以及一位曾被称为「英雄」的主角的战后余生。 游戏画面十分简陋，可视部分基本上只有线框格和角色图标，另外窗口被固定为奇特的纵矩形。简单的画面反而凸显了作品的其他部分，游戏中寥寥的演出结合配乐所营造的氛围效果却十分到位。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/f6b18756a328bcf767779fb3d7f61f33.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n作为一款小品级的独立游戏作品，包含 A、B 两条主线总共 20 个关卡，8 关额外关卡和数个隐藏关卡（具体不剧透，有一定惊喜感），此外还内置一个关卡编辑器，成就列表更是增加了数个关卡的额外目标。关卡设计不论是「质」还是「量」都有对得起价格的表现。谜题难度不低，卡在某个前期关卡近一个小时也是正常的。 可能关卡设计唯一明显的失败在于引导，玩家初期接触的过程中没有足够的文字解释、同时也无法在前期关卡中快速领会到每个新元素的特性。而只有熟记了所有特性，玩家才能更直接的去面对、计算后续的关卡的解法。 但综合而言，《英雄传说又一则》是一款完整且质量过硬，值得一试的小品级解谜游戏，加上开发团队承诺后续的开发，个人十分推荐感兴趣的玩家入手。 你可以在 [Steam](https://store.steampowered.com/app/1083750/Yet_Another_Hero_Legend) 购买《英雄传说又一则》，原价 ¥11，有官方中文。\n\n节奏海拉鲁 Cadence of Hyrule\n\n_Nintendo Switch / 音乐、冒险、角色扮演 / 中文_ 《节奏地牢》x《塞尔达传说》可以说是相当出人意料的一个组合。在这之前或许没几个玩家会想到任天堂手下的《塞尔达传说》（后文省略为《塞尔达》）这种级别的 IP 能够与一家独立游戏团队合作推出一款联动作品吧，更不用说是像《节奏地牢》这样独特的作品了。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/6a4911214ff6a84cc3341936c1fd7b03.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n在发售前大多数的猜想都基于这会是一款换皮的《节奏地牢》，可实际情况却更像是反过来。在游戏体验中，《节奏海拉鲁》是一款在《塞尔达》系列的设定和世界观的基础上融入了《节奏地牢》玩法的、完整的新游戏。 游戏的基本玩法上继承了《节奏地牢》的形式：当玩家进入战斗时，需要按照音乐的节奏输入操作，场景内所有的物体行动规则也会依据这一节奏进行。玩家可以根据这样的「半即时战斗」形式来更有策略性地进行战术规划和解谜，并且会在完全跟紧节拍时获得额外奖励。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/e49c9a41473fd7b1080ced22a3a2d823.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n游戏巧妙地将 Rogulike 元素透过随机地牢和半永久死亡的方式植入了《塞尔达》原本的游戏系统中。当你打开大地图、用炸弹炸开隐藏神庙入口、在迷失森林中迷路时，《塞尔达》原汁原味的味道扑面而来；但当你在多次死亡中变更装备、在程序生成的随机地牢中探索、用铲子挖掘沙地找隐藏道具时，你又会明白这也是《节奏地牢》。这是一种很难用简单的几句话解释的清楚的、微妙的平衡感，是一次堪称完美的 IP 融合体验。后续我应该会单独再写一篇文章来介绍这款有趣的作品。 你可以在 [eShop](https://www.nintendo.com/games/detail/cadence-of-hyrule-crypt-of-the-necrodancer-featuring-the-legend-of-zelda-switch/) 购买《节奏海拉鲁》，有中文支持，美区价格 USD 24.99，日区价格 JPY 2980.00。\n\n你可能会感兴趣\n\n任天堂最新手游《马力欧医生世界》7 月 10 日登陆移动平台\n\n6 月 18 日，任天堂正式宣布《马力欧医生世界（Dr. Mario World）》将于 7 月 10 日登陆 iOS/Android 平台，该作是根据同名经典 FC 作品推出的移动端新作，玩家需要控制药丸消除病毒，与三消类游戏玩法类似，看起来十分益智。 游戏加入了全新的技能和道具，以及不同拥有过技能的任天堂经典角色。当然，作为一款免费游戏，氪金钻石要素也加入了其中，钻石可以用于获取额外道具、复活或是获取额外体力。 目前，该作已经在 [App Store](https://apps.apple.com/us/app/dr-mario-world/id1440129313) 和 [Google Play](https://play.google.com/store/apps/details?id=com.nintendo.zama) 开启预约。  \n\n召集所有巫师！????‍♂️《哈利波特：巫师联盟》6 月 21 日正式上架\n\n6 月 19 日，Niantic 宣布，《哈利波特：巫师联盟（Harry Potter: Wizards Unite）》将于 6 月 21 日正式上线，该作由曾经制作了《Pokémon Go》的 Niantic 与华纳游戏联合开发，通过探索真实的街区，玩家可以学会法术并会遭遇原著中的标志性怪物和敌人。 另外，官方在今天放出了一段真人预告短片，黑魔法不断侵蚀的麻瓜世界时，几位青年人拿出魔杖和食死徒们战斗，最后还出现了一位大家熟悉的老朋友，三分钟的预告可以说十分精彩。  \n\n《怪物猎人世界》大型的扩充资料篇「冰原」本周末开启测试\n\n6 月 19 日，CAPCOM 宣布，《怪物猎人世界》大型的扩充资料篇「冰原」将于本周末开启测试，具体的时间为 6 月 21 日～24日（仅限 PS Plus会员）与 6 月 28 日～7 月 1 日（所有玩家）。试玩版提供了大凶豺龙、猛牛龙与轰龙三个任务，玩家可以体验飞翔爪以及全武器种类新动作等全新要素。该大型扩展将在今年 9 月 6 日推出。本次测试仅限 PS4 平台，Beta 目前已经开始预载，你可以点击 [这里](https://store.playstation.com/zh-hant-hk/product/HP0102-CUSA15651_00-MHWICEBORNBETA00) 下载。","source":"_posts/e6-96-b0-e6-b8-b8-e6-b4-be-e6-9c-ac-e5-91-a8-e4-b8-8d-e5-ae-b9-e9-94-99-e8-bf-87-e7-9a-84-5-e6-ac-be-e6-96-b0-e6-b8-b8-e6-88-8f.md","raw":"---\ntitle: 新游派 | 本周不容错过的 5 款新游戏\ntags:\n  - 游戏\nurl: 183.html\nid: 183\ncategories:\n  - 杂谈\ndate: 2019-06-24 20:37:01\n---\n\n青璃\n\n_移动平台 / 动作、解密 / 中文_ 年初，网易与故宫博物院联合推出的《绘真·妙笔千山》 ，受到了广泛好评。本周推出的动作解谜游戏《青璃》延续了《绘真·妙笔千山》如诗如画的意境，不同于后者的 2D 绘画风格，《青璃》采用了全 3D 的视角，呈现一个更加立体的江湖。 游戏中，你将扮演剑客青衣，在一场战斗中救下了失忆的白衣女子莫璃。你将陪同她四处游历，寻找记忆，在这个过程中你会遇到许多追杀你的敌人，你需要用自己高超的剑法将其击败。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/3a4fdaf93a3a71b4b28f8171e579eb88.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n作为一款解谜游戏，《青璃》的谜题难度不算特别高。只要你细心观察，基本不会卡关。除了主线谜题外，你还得留心路上的药草，采集药草喂给莫璃可以解锁她的隐藏动作。 游戏的战斗体验相当爽快，无论是刀刀到肉的打击感，极具冲击感的镜头切换，都为玩家带来了一场酣畅淋漓的战斗。《青璃》的对战并不是无脑攻击就行的，你需要观察敌人的动作，在恰当的时机发起攻击。 整体来看，《青璃》游戏体验尚可，但在一些细节上仍有待打磨，最影响游戏体验的就是战斗中的镜头切换。虽然这个设定增强了战斗的观感，但在狭窄的场景中，镜头总会切换到建筑后方，阻挡玩家的视线。 你可以在 [App Store](https://apps.apple.com/cn/app/%E9%9D%92%E7%92%83/id1452989059) 免费下载《青璃》（Android 版目前 [预约](https://ql.163.com/) 中），游戏支持中文，游戏流程约 2 小时。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/48e2b00434f4c3711cff28f1f8dc9006.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n字母人\n\n_全平台 / 解谜、横版、冒险 / 中文_ 《字母人》是一款由 PC、主机平台移植到移动平台的解谜游戏，曾荣获多个游戏奖项。游戏将英文单词与解谜相结合，玩家将扮演一名由「Hero」组成的字母人完成解谜冒险。游戏的 2D 剪影画风加上蒸汽朋克的要素，难免会让人想起《Limbo》。在一些谜题的设计上，二者也确实有相似之处。 游戏最大的卖点便是字母加解谜的奇妙组合。其中的字母组合也并非无意义的象形，而是将单词与物品相结合，比如你可以看到由「Gate」组成的门、由「Switch」组成的开关等。物品与文字相互提示，让机关更加显眼。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/477e52fd71ed5c359d8e13705eb282a5.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n尽管机关变得显眼了，但谜题的难度并没有因此而下降。在游戏中，你需要移动地上的字母，将它们拼成一个单词并放置在合适的区域才能打开机关。在追逐战中，你更需要眼疾手快，在怪物追上你之前开启机关，逃出生天。 在游戏中，你可以收集散落在在关卡各处的箴言，并在通关结算时查看自己的收集情况。此处有一个小提醒，当你在前进的道路上遇到岔路时，不妨先朝着有回头路的那边走，往往能找到隐藏的箴言。 由于游戏包含基于英文单词的解谜，对玩家的英语水平有一定程度的要求。如果不追求全收集，配合游戏内的提示机制，基本不用担心自己的英语水平会影响解谜。 你可以在 [App Store](https://apps.apple.com/cn/app/%E5%AD%97%E6%AF%8D%E4%BA%BA-typoman/id1365392834)（¥ 12）和 [TapTap](https://www.taptap.com/app/72825)（将于 6 月 21 日上架，售价 ¥12） 购买《字母人》，游戏支持中文。6 月 20 日前，你可以在 App Store 以半价购入游戏。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/5a06b7adef5ee17c126b06806c7c07bf.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n \n\nSoviet Souls\n\n_PC、移动平台 / 冒险、射击 / 英文_ 游戏故事发生在 2025 年，正在工作的「普汀」遇上了穿越而来的「斯塔林」和「涅宁」。三人为了从某个邪恶的猪猪军团中解救水生火热的国家，展开了一场冒险。 游戏中共有三名可操控角色，你可以在每一关开始前进行选择，每个角色都拥有独特的攻击技能。游戏的目标是收集场景中的勋章并抵达终点。在冒险途中，会有枪兵猪、飞行猪等不同的敌人对你造成伤害，你也要时刻留意不断移动的机关。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/55cce2110e577b4c5cbcb54869427b59.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n游戏中藏着许多幽默梗，无论是《致命武器》中的「I’m too old for this sh*t」，还是超级马里奥风格的关卡，都足以玩家会心一笑。尽管游戏看上去是一款黑色幽默性质的闯关游戏，但它的难度不容小觑，稍有不慎就有可能迎来失败。 游戏共有 32 关，你可以在其中游历「索维埃共和国」的知名地点。如果你遇到难以通过的关卡，不妨尝试在商店中升级角色生命值和技能。游戏拥有双结局设定，你的游戏表现将决定国家的命运。为了拯救国家与水火之中，高喊「乌拉」一起冲锋吧。 你可以在 [App Store](https://apps.apple.com/cn/app/soviet-souls/id1466122041)（¥12）和 [Steam](https://store.steampowered.com/app/1066210/Soviet_Souls/?curator_clanid=32668148)（¥26） 购买 Soviet Souls，游戏暂无中文。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/030e5b255c833ed9de9c6db12caebee4.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n \n\n英雄传说又一则 Yet Another Hero Legend\n\n_PC / 解谜、角色扮演、策略 / 中文_ 《英雄传说又一则》是一款诞生于国内 Project1 论坛的独立游戏。游戏玩法是以推箱子式的谜题设计为基础进行再创作的解谜游戏，并尝试用简短的文本阐释了一个颇具风味的世界观、以及一位曾被称为「英雄」的主角的战后余生。 游戏画面十分简陋，可视部分基本上只有线框格和角色图标，另外窗口被固定为奇特的纵矩形。简单的画面反而凸显了作品的其他部分，游戏中寥寥的演出结合配乐所营造的氛围效果却十分到位。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/f6b18756a328bcf767779fb3d7f61f33.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n作为一款小品级的独立游戏作品，包含 A、B 两条主线总共 20 个关卡，8 关额外关卡和数个隐藏关卡（具体不剧透，有一定惊喜感），此外还内置一个关卡编辑器，成就列表更是增加了数个关卡的额外目标。关卡设计不论是「质」还是「量」都有对得起价格的表现。谜题难度不低，卡在某个前期关卡近一个小时也是正常的。 可能关卡设计唯一明显的失败在于引导，玩家初期接触的过程中没有足够的文字解释、同时也无法在前期关卡中快速领会到每个新元素的特性。而只有熟记了所有特性，玩家才能更直接的去面对、计算后续的关卡的解法。 但综合而言，《英雄传说又一则》是一款完整且质量过硬，值得一试的小品级解谜游戏，加上开发团队承诺后续的开发，个人十分推荐感兴趣的玩家入手。 你可以在 [Steam](https://store.steampowered.com/app/1083750/Yet_Another_Hero_Legend) 购买《英雄传说又一则》，原价 ¥11，有官方中文。\n\n节奏海拉鲁 Cadence of Hyrule\n\n_Nintendo Switch / 音乐、冒险、角色扮演 / 中文_ 《节奏地牢》x《塞尔达传说》可以说是相当出人意料的一个组合。在这之前或许没几个玩家会想到任天堂手下的《塞尔达传说》（后文省略为《塞尔达》）这种级别的 IP 能够与一家独立游戏团队合作推出一款联动作品吧，更不用说是像《节奏地牢》这样独特的作品了。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/6a4911214ff6a84cc3341936c1fd7b03.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n在发售前大多数的猜想都基于这会是一款换皮的《节奏地牢》，可实际情况却更像是反过来。在游戏体验中，《节奏海拉鲁》是一款在《塞尔达》系列的设定和世界观的基础上融入了《节奏地牢》玩法的、完整的新游戏。 游戏的基本玩法上继承了《节奏地牢》的形式：当玩家进入战斗时，需要按照音乐的节奏输入操作，场景内所有的物体行动规则也会依据这一节奏进行。玩家可以根据这样的「半即时战斗」形式来更有策略性地进行战术规划和解谜，并且会在完全跟紧节拍时获得额外奖励。\n\n![新游派 | 本周不容错过的 5 款新游戏](https://cdn.sspai.com/2019/06/19/e49c9a41473fd7b1080ced22a3a2d823.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"新游派 | 本周不容错过的 5 款新游戏\")\n\n游戏巧妙地将 Rogulike 元素透过随机地牢和半永久死亡的方式植入了《塞尔达》原本的游戏系统中。当你打开大地图、用炸弹炸开隐藏神庙入口、在迷失森林中迷路时，《塞尔达》原汁原味的味道扑面而来；但当你在多次死亡中变更装备、在程序生成的随机地牢中探索、用铲子挖掘沙地找隐藏道具时，你又会明白这也是《节奏地牢》。这是一种很难用简单的几句话解释的清楚的、微妙的平衡感，是一次堪称完美的 IP 融合体验。后续我应该会单独再写一篇文章来介绍这款有趣的作品。 你可以在 [eShop](https://www.nintendo.com/games/detail/cadence-of-hyrule-crypt-of-the-necrodancer-featuring-the-legend-of-zelda-switch/) 购买《节奏海拉鲁》，有中文支持，美区价格 USD 24.99，日区价格 JPY 2980.00。\n\n你可能会感兴趣\n\n任天堂最新手游《马力欧医生世界》7 月 10 日登陆移动平台\n\n6 月 18 日，任天堂正式宣布《马力欧医生世界（Dr. Mario World）》将于 7 月 10 日登陆 iOS/Android 平台，该作是根据同名经典 FC 作品推出的移动端新作，玩家需要控制药丸消除病毒，与三消类游戏玩法类似，看起来十分益智。 游戏加入了全新的技能和道具，以及不同拥有过技能的任天堂经典角色。当然，作为一款免费游戏，氪金钻石要素也加入了其中，钻石可以用于获取额外道具、复活或是获取额外体力。 目前，该作已经在 [App Store](https://apps.apple.com/us/app/dr-mario-world/id1440129313) 和 [Google Play](https://play.google.com/store/apps/details?id=com.nintendo.zama) 开启预约。  \n\n召集所有巫师！????‍♂️《哈利波特：巫师联盟》6 月 21 日正式上架\n\n6 月 19 日，Niantic 宣布，《哈利波特：巫师联盟（Harry Potter: Wizards Unite）》将于 6 月 21 日正式上线，该作由曾经制作了《Pokémon Go》的 Niantic 与华纳游戏联合开发，通过探索真实的街区，玩家可以学会法术并会遭遇原著中的标志性怪物和敌人。 另外，官方在今天放出了一段真人预告短片，黑魔法不断侵蚀的麻瓜世界时，几位青年人拿出魔杖和食死徒们战斗，最后还出现了一位大家熟悉的老朋友，三分钟的预告可以说十分精彩。  \n\n《怪物猎人世界》大型的扩充资料篇「冰原」本周末开启测试\n\n6 月 19 日，CAPCOM 宣布，《怪物猎人世界》大型的扩充资料篇「冰原」将于本周末开启测试，具体的时间为 6 月 21 日～24日（仅限 PS Plus会员）与 6 月 28 日～7 月 1 日（所有玩家）。试玩版提供了大凶豺龙、猛牛龙与轰龙三个任务，玩家可以体验飞翔爪以及全武器种类新动作等全新要素。该大型扩展将在今年 9 月 6 日推出。本次测试仅限 PS4 平台，Beta 目前已经开始预载，你可以点击 [这里](https://store.playstation.com/zh-hant-hk/product/HP0102-CUSA15651_00-MHWICEBORNBETA00) 下载。","slug":"e6-96-b0-e6-b8-b8-e6-b4-be-e6-9c-ac-e5-91-a8-e4-b8-8d-e5-ae-b9-e9-94-99-e8-bf-87-e7-9a-84-5-e6-ac-be-e6-96-b0-e6-b8-b8-e6-88-8f","published":1,"updated":"2019-09-10T07:46:08.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269bl001yc8gsbpd052gs","content":"<p>青璃</p>\n<p><em>移动平台 / 动作、解密 / 中文</em> 年初，网易与故宫博物院联合推出的《绘真·妙笔千山》 ，受到了广泛好评。本周推出的动作解谜游戏《青璃》延续了《绘真·妙笔千山》如诗如画的意境，不同于后者的 2D 绘画风格，《青璃》采用了全 3D 的视角，呈现一个更加立体的江湖。 游戏中，你将扮演剑客青衣，在一场战斗中救下了失忆的白衣女子莫璃。你将陪同她四处游历，寻找记忆，在这个过程中你会遇到许多追杀你的敌人，你需要用自己高超的剑法将其击败。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/3a4fdaf93a3a71b4b28f8171e579eb88.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>作为一款解谜游戏，《青璃》的谜题难度不算特别高。只要你细心观察，基本不会卡关。除了主线谜题外，你还得留心路上的药草，采集药草喂给莫璃可以解锁她的隐藏动作。 游戏的战斗体验相当爽快，无论是刀刀到肉的打击感，极具冲击感的镜头切换，都为玩家带来了一场酣畅淋漓的战斗。《青璃》的对战并不是无脑攻击就行的，你需要观察敌人的动作，在恰当的时机发起攻击。 整体来看，《青璃》游戏体验尚可，但在一些细节上仍有待打磨，最影响游戏体验的就是战斗中的镜头切换。虽然这个设定增强了战斗的观感，但在狭窄的场景中，镜头总会切换到建筑后方，阻挡玩家的视线。 你可以在 <a href=\"https://apps.apple.com/cn/app/%E9%9D%92%E7%92%83/id1452989059\">App Store</a> 免费下载《青璃》（Android 版目前 <a href=\"https://ql.163.com/\">预约</a> 中），游戏支持中文，游戏流程约 2 小时。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/48e2b00434f4c3711cff28f1f8dc9006.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>字母人</p>\n<p><em>全平台 / 解谜、横版、冒险 / 中文</em> 《字母人》是一款由 PC、主机平台移植到移动平台的解谜游戏，曾荣获多个游戏奖项。游戏将英文单词与解谜相结合，玩家将扮演一名由「Hero」组成的字母人完成解谜冒险。游戏的 2D 剪影画风加上蒸汽朋克的要素，难免会让人想起《Limbo》。在一些谜题的设计上，二者也确实有相似之处。 游戏最大的卖点便是字母加解谜的奇妙组合。其中的字母组合也并非无意义的象形，而是将单词与物品相结合，比如你可以看到由「Gate」组成的门、由「Switch」组成的开关等。物品与文字相互提示，让机关更加显眼。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/477e52fd71ed5c359d8e13705eb282a5.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>尽管机关变得显眼了，但谜题的难度并没有因此而下降。在游戏中，你需要移动地上的字母，将它们拼成一个单词并放置在合适的区域才能打开机关。在追逐战中，你更需要眼疾手快，在怪物追上你之前开启机关，逃出生天。 在游戏中，你可以收集散落在在关卡各处的箴言，并在通关结算时查看自己的收集情况。此处有一个小提醒，当你在前进的道路上遇到岔路时，不妨先朝着有回头路的那边走，往往能找到隐藏的箴言。 由于游戏包含基于英文单词的解谜，对玩家的英语水平有一定程度的要求。如果不追求全收集，配合游戏内的提示机制，基本不用担心自己的英语水平会影响解谜。 你可以在 <a href=\"https://apps.apple.com/cn/app/%E5%AD%97%E6%AF%8D%E4%BA%BA-typoman/id1365392834\">App Store</a>（¥ 12）和 <a href=\"https://www.taptap.com/app/72825\">TapTap</a>（将于 6 月 21 日上架，售价 ¥12） 购买《字母人》，游戏支持中文。6 月 20 日前，你可以在 App Store 以半价购入游戏。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/5a06b7adef5ee17c126b06806c7c07bf.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p> </p>\n<p>Soviet Souls</p>\n<p><em>PC、移动平台 / 冒险、射击 / 英文</em> 游戏故事发生在 2025 年，正在工作的「普汀」遇上了穿越而来的「斯塔林」和「涅宁」。三人为了从某个邪恶的猪猪军团中解救水生火热的国家，展开了一场冒险。 游戏中共有三名可操控角色，你可以在每一关开始前进行选择，每个角色都拥有独特的攻击技能。游戏的目标是收集场景中的勋章并抵达终点。在冒险途中，会有枪兵猪、飞行猪等不同的敌人对你造成伤害，你也要时刻留意不断移动的机关。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/55cce2110e577b4c5cbcb54869427b59.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>游戏中藏着许多幽默梗，无论是《致命武器》中的「I’m too old for this sh*t」，还是超级马里奥风格的关卡，都足以玩家会心一笑。尽管游戏看上去是一款黑色幽默性质的闯关游戏，但它的难度不容小觑，稍有不慎就有可能迎来失败。 游戏共有 32 关，你可以在其中游历「索维埃共和国」的知名地点。如果你遇到难以通过的关卡，不妨尝试在商店中升级角色生命值和技能。游戏拥有双结局设定，你的游戏表现将决定国家的命运。为了拯救国家与水火之中，高喊「乌拉」一起冲锋吧。 你可以在 <a href=\"https://apps.apple.com/cn/app/soviet-souls/id1466122041\">App Store</a>（¥12）和 <a href=\"https://store.steampowered.com/app/1066210/Soviet_Souls/?curator_clanid=32668148\">Steam</a>（¥26） 购买 Soviet Souls，游戏暂无中文。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/030e5b255c833ed9de9c6db12caebee4.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p> </p>\n<p>英雄传说又一则 Yet Another Hero Legend</p>\n<p><em>PC / 解谜、角色扮演、策略 / 中文</em> 《英雄传说又一则》是一款诞生于国内 Project1 论坛的独立游戏。游戏玩法是以推箱子式的谜题设计为基础进行再创作的解谜游戏，并尝试用简短的文本阐释了一个颇具风味的世界观、以及一位曾被称为「英雄」的主角的战后余生。 游戏画面十分简陋，可视部分基本上只有线框格和角色图标，另外窗口被固定为奇特的纵矩形。简单的画面反而凸显了作品的其他部分，游戏中寥寥的演出结合配乐所营造的氛围效果却十分到位。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/f6b18756a328bcf767779fb3d7f61f33.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>作为一款小品级的独立游戏作品，包含 A、B 两条主线总共 20 个关卡，8 关额外关卡和数个隐藏关卡（具体不剧透，有一定惊喜感），此外还内置一个关卡编辑器，成就列表更是增加了数个关卡的额外目标。关卡设计不论是「质」还是「量」都有对得起价格的表现。谜题难度不低，卡在某个前期关卡近一个小时也是正常的。 可能关卡设计唯一明显的失败在于引导，玩家初期接触的过程中没有足够的文字解释、同时也无法在前期关卡中快速领会到每个新元素的特性。而只有熟记了所有特性，玩家才能更直接的去面对、计算后续的关卡的解法。 但综合而言，《英雄传说又一则》是一款完整且质量过硬，值得一试的小品级解谜游戏，加上开发团队承诺后续的开发，个人十分推荐感兴趣的玩家入手。 你可以在 <a href=\"https://store.steampowered.com/app/1083750/Yet_Another_Hero_Legend\">Steam</a> 购买《英雄传说又一则》，原价 ¥11，有官方中文。</p>\n<p>节奏海拉鲁 Cadence of Hyrule</p>\n<p><em>Nintendo Switch / 音乐、冒险、角色扮演 / 中文</em> 《节奏地牢》x《塞尔达传说》可以说是相当出人意料的一个组合。在这之前或许没几个玩家会想到任天堂手下的《塞尔达传说》（后文省略为《塞尔达》）这种级别的 IP 能够与一家独立游戏团队合作推出一款联动作品吧，更不用说是像《节奏地牢》这样独特的作品了。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/6a4911214ff6a84cc3341936c1fd7b03.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>在发售前大多数的猜想都基于这会是一款换皮的《节奏地牢》，可实际情况却更像是反过来。在游戏体验中，《节奏海拉鲁》是一款在《塞尔达》系列的设定和世界观的基础上融入了《节奏地牢》玩法的、完整的新游戏。 游戏的基本玩法上继承了《节奏地牢》的形式：当玩家进入战斗时，需要按照音乐的节奏输入操作，场景内所有的物体行动规则也会依据这一节奏进行。玩家可以根据这样的「半即时战斗」形式来更有策略性地进行战术规划和解谜，并且会在完全跟紧节拍时获得额外奖励。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/e49c9a41473fd7b1080ced22a3a2d823.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>游戏巧妙地将 Rogulike 元素透过随机地牢和半永久死亡的方式植入了《塞尔达》原本的游戏系统中。当你打开大地图、用炸弹炸开隐藏神庙入口、在迷失森林中迷路时，《塞尔达》原汁原味的味道扑面而来；但当你在多次死亡中变更装备、在程序生成的随机地牢中探索、用铲子挖掘沙地找隐藏道具时，你又会明白这也是《节奏地牢》。这是一种很难用简单的几句话解释的清楚的、微妙的平衡感，是一次堪称完美的 IP 融合体验。后续我应该会单独再写一篇文章来介绍这款有趣的作品。 你可以在 <a href=\"https://www.nintendo.com/games/detail/cadence-of-hyrule-crypt-of-the-necrodancer-featuring-the-legend-of-zelda-switch/\">eShop</a> 购买《节奏海拉鲁》，有中文支持，美区价格 USD 24.99，日区价格 JPY 2980.00。</p>\n<p>你可能会感兴趣</p>\n<p>任天堂最新手游《马力欧医生世界》7 月 10 日登陆移动平台</p>\n<p>6 月 18 日，任天堂正式宣布《马力欧医生世界（Dr. Mario World）》将于 7 月 10 日登陆 iOS/Android 平台，该作是根据同名经典 FC 作品推出的移动端新作，玩家需要控制药丸消除病毒，与三消类游戏玩法类似，看起来十分益智。 游戏加入了全新的技能和道具，以及不同拥有过技能的任天堂经典角色。当然，作为一款免费游戏，氪金钻石要素也加入了其中，钻石可以用于获取额外道具、复活或是获取额外体力。 目前，该作已经在 <a href=\"https://apps.apple.com/us/app/dr-mario-world/id1440129313\">App Store</a> 和 <a href=\"https://play.google.com/store/apps/details?id=com.nintendo.zama\">Google Play</a> 开启预约。  </p>\n<p>召集所有巫师！????‍♂️《哈利波特：巫师联盟》6 月 21 日正式上架</p>\n<p>6 月 19 日，Niantic 宣布，《哈利波特：巫师联盟（Harry Potter: Wizards Unite）》将于 6 月 21 日正式上线，该作由曾经制作了《Pokémon Go》的 Niantic 与华纳游戏联合开发，通过探索真实的街区，玩家可以学会法术并会遭遇原著中的标志性怪物和敌人。 另外，官方在今天放出了一段真人预告短片，黑魔法不断侵蚀的麻瓜世界时，几位青年人拿出魔杖和食死徒们战斗，最后还出现了一位大家熟悉的老朋友，三分钟的预告可以说十分精彩。  </p>\n<p>《怪物猎人世界》大型的扩充资料篇「冰原」本周末开启测试</p>\n<p>6 月 19 日，CAPCOM 宣布，《怪物猎人世界》大型的扩充资料篇「冰原」将于本周末开启测试，具体的时间为 6 月 21 日～24日（仅限 PS Plus会员）与 6 月 28 日～7 月 1 日（所有玩家）。试玩版提供了大凶豺龙、猛牛龙与轰龙三个任务，玩家可以体验飞翔爪以及全武器种类新动作等全新要素。该大型扩展将在今年 9 月 6 日推出。本次测试仅限 PS4 平台，Beta 目前已经开始预载，你可以点击 <a href=\"https://store.playstation.com/zh-hant-hk/product/HP0102-CUSA15651_00-MHWICEBORNBETA00\">这里</a> 下载。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>青璃</p>\n<p><em>移动平台 / 动作、解密 / 中文</em> 年初，网易与故宫博物院联合推出的《绘真·妙笔千山》 ，受到了广泛好评。本周推出的动作解谜游戏《青璃》延续了《绘真·妙笔千山》如诗如画的意境，不同于后者的 2D 绘画风格，《青璃》采用了全 3D 的视角，呈现一个更加立体的江湖。 游戏中，你将扮演剑客青衣，在一场战斗中救下了失忆的白衣女子莫璃。你将陪同她四处游历，寻找记忆，在这个过程中你会遇到许多追杀你的敌人，你需要用自己高超的剑法将其击败。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/3a4fdaf93a3a71b4b28f8171e579eb88.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>作为一款解谜游戏，《青璃》的谜题难度不算特别高。只要你细心观察，基本不会卡关。除了主线谜题外，你还得留心路上的药草，采集药草喂给莫璃可以解锁她的隐藏动作。 游戏的战斗体验相当爽快，无论是刀刀到肉的打击感，极具冲击感的镜头切换，都为玩家带来了一场酣畅淋漓的战斗。《青璃》的对战并不是无脑攻击就行的，你需要观察敌人的动作，在恰当的时机发起攻击。 整体来看，《青璃》游戏体验尚可，但在一些细节上仍有待打磨，最影响游戏体验的就是战斗中的镜头切换。虽然这个设定增强了战斗的观感，但在狭窄的场景中，镜头总会切换到建筑后方，阻挡玩家的视线。 你可以在 <a href=\"https://apps.apple.com/cn/app/%E9%9D%92%E7%92%83/id1452989059\">App Store</a> 免费下载《青璃》（Android 版目前 <a href=\"https://ql.163.com/\">预约</a> 中），游戏支持中文，游戏流程约 2 小时。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/48e2b00434f4c3711cff28f1f8dc9006.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>字母人</p>\n<p><em>全平台 / 解谜、横版、冒险 / 中文</em> 《字母人》是一款由 PC、主机平台移植到移动平台的解谜游戏，曾荣获多个游戏奖项。游戏将英文单词与解谜相结合，玩家将扮演一名由「Hero」组成的字母人完成解谜冒险。游戏的 2D 剪影画风加上蒸汽朋克的要素，难免会让人想起《Limbo》。在一些谜题的设计上，二者也确实有相似之处。 游戏最大的卖点便是字母加解谜的奇妙组合。其中的字母组合也并非无意义的象形，而是将单词与物品相结合，比如你可以看到由「Gate」组成的门、由「Switch」组成的开关等。物品与文字相互提示，让机关更加显眼。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/477e52fd71ed5c359d8e13705eb282a5.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>尽管机关变得显眼了，但谜题的难度并没有因此而下降。在游戏中，你需要移动地上的字母，将它们拼成一个单词并放置在合适的区域才能打开机关。在追逐战中，你更需要眼疾手快，在怪物追上你之前开启机关，逃出生天。 在游戏中，你可以收集散落在在关卡各处的箴言，并在通关结算时查看自己的收集情况。此处有一个小提醒，当你在前进的道路上遇到岔路时，不妨先朝着有回头路的那边走，往往能找到隐藏的箴言。 由于游戏包含基于英文单词的解谜，对玩家的英语水平有一定程度的要求。如果不追求全收集，配合游戏内的提示机制，基本不用担心自己的英语水平会影响解谜。 你可以在 <a href=\"https://apps.apple.com/cn/app/%E5%AD%97%E6%AF%8D%E4%BA%BA-typoman/id1365392834\">App Store</a>（¥ 12）和 <a href=\"https://www.taptap.com/app/72825\">TapTap</a>（将于 6 月 21 日上架，售价 ¥12） 购买《字母人》，游戏支持中文。6 月 20 日前，你可以在 App Store 以半价购入游戏。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/5a06b7adef5ee17c126b06806c7c07bf.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p> </p>\n<p>Soviet Souls</p>\n<p><em>PC、移动平台 / 冒险、射击 / 英文</em> 游戏故事发生在 2025 年，正在工作的「普汀」遇上了穿越而来的「斯塔林」和「涅宁」。三人为了从某个邪恶的猪猪军团中解救水生火热的国家，展开了一场冒险。 游戏中共有三名可操控角色，你可以在每一关开始前进行选择，每个角色都拥有独特的攻击技能。游戏的目标是收集场景中的勋章并抵达终点。在冒险途中，会有枪兵猪、飞行猪等不同的敌人对你造成伤害，你也要时刻留意不断移动的机关。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/55cce2110e577b4c5cbcb54869427b59.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>游戏中藏着许多幽默梗，无论是《致命武器》中的「I’m too old for this sh*t」，还是超级马里奥风格的关卡，都足以玩家会心一笑。尽管游戏看上去是一款黑色幽默性质的闯关游戏，但它的难度不容小觑，稍有不慎就有可能迎来失败。 游戏共有 32 关，你可以在其中游历「索维埃共和国」的知名地点。如果你遇到难以通过的关卡，不妨尝试在商店中升级角色生命值和技能。游戏拥有双结局设定，你的游戏表现将决定国家的命运。为了拯救国家与水火之中，高喊「乌拉」一起冲锋吧。 你可以在 <a href=\"https://apps.apple.com/cn/app/soviet-souls/id1466122041\">App Store</a>（¥12）和 <a href=\"https://store.steampowered.com/app/1066210/Soviet_Souls/?curator_clanid=32668148\">Steam</a>（¥26） 购买 Soviet Souls，游戏暂无中文。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/030e5b255c833ed9de9c6db12caebee4.jpg?imageMogr2/quality/95/thumbnail/!180x180r/gravity/Center/crop/180x180\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p> </p>\n<p>英雄传说又一则 Yet Another Hero Legend</p>\n<p><em>PC / 解谜、角色扮演、策略 / 中文</em> 《英雄传说又一则》是一款诞生于国内 Project1 论坛的独立游戏。游戏玩法是以推箱子式的谜题设计为基础进行再创作的解谜游戏，并尝试用简短的文本阐释了一个颇具风味的世界观、以及一位曾被称为「英雄」的主角的战后余生。 游戏画面十分简陋，可视部分基本上只有线框格和角色图标，另外窗口被固定为奇特的纵矩形。简单的画面反而凸显了作品的其他部分，游戏中寥寥的演出结合配乐所营造的氛围效果却十分到位。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/f6b18756a328bcf767779fb3d7f61f33.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>作为一款小品级的独立游戏作品，包含 A、B 两条主线总共 20 个关卡，8 关额外关卡和数个隐藏关卡（具体不剧透，有一定惊喜感），此外还内置一个关卡编辑器，成就列表更是增加了数个关卡的额外目标。关卡设计不论是「质」还是「量」都有对得起价格的表现。谜题难度不低，卡在某个前期关卡近一个小时也是正常的。 可能关卡设计唯一明显的失败在于引导，玩家初期接触的过程中没有足够的文字解释、同时也无法在前期关卡中快速领会到每个新元素的特性。而只有熟记了所有特性，玩家才能更直接的去面对、计算后续的关卡的解法。 但综合而言，《英雄传说又一则》是一款完整且质量过硬，值得一试的小品级解谜游戏，加上开发团队承诺后续的开发，个人十分推荐感兴趣的玩家入手。 你可以在 <a href=\"https://store.steampowered.com/app/1083750/Yet_Another_Hero_Legend\">Steam</a> 购买《英雄传说又一则》，原价 ¥11，有官方中文。</p>\n<p>节奏海拉鲁 Cadence of Hyrule</p>\n<p><em>Nintendo Switch / 音乐、冒险、角色扮演 / 中文</em> 《节奏地牢》x《塞尔达传说》可以说是相当出人意料的一个组合。在这之前或许没几个玩家会想到任天堂手下的《塞尔达传说》（后文省略为《塞尔达》）这种级别的 IP 能够与一家独立游戏团队合作推出一款联动作品吧，更不用说是像《节奏地牢》这样独特的作品了。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/6a4911214ff6a84cc3341936c1fd7b03.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>在发售前大多数的猜想都基于这会是一款换皮的《节奏地牢》，可实际情况却更像是反过来。在游戏体验中，《节奏海拉鲁》是一款在《塞尔达》系列的设定和世界观的基础上融入了《节奏地牢》玩法的、完整的新游戏。 游戏的基本玩法上继承了《节奏地牢》的形式：当玩家进入战斗时，需要按照音乐的节奏输入操作，场景内所有的物体行动规则也会依据这一节奏进行。玩家可以根据这样的「半即时战斗」形式来更有策略性地进行战术规划和解谜，并且会在完全跟紧节拍时获得额外奖励。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/19/e49c9a41473fd7b1080ced22a3a2d823.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"新游派 | 本周不容错过的 5 款新游戏\" title=\"新游派 | 本周不容错过的 5 款新游戏\"></p>\n<p>游戏巧妙地将 Rogulike 元素透过随机地牢和半永久死亡的方式植入了《塞尔达》原本的游戏系统中。当你打开大地图、用炸弹炸开隐藏神庙入口、在迷失森林中迷路时，《塞尔达》原汁原味的味道扑面而来；但当你在多次死亡中变更装备、在程序生成的随机地牢中探索、用铲子挖掘沙地找隐藏道具时，你又会明白这也是《节奏地牢》。这是一种很难用简单的几句话解释的清楚的、微妙的平衡感，是一次堪称完美的 IP 融合体验。后续我应该会单独再写一篇文章来介绍这款有趣的作品。 你可以在 <a href=\"https://www.nintendo.com/games/detail/cadence-of-hyrule-crypt-of-the-necrodancer-featuring-the-legend-of-zelda-switch/\">eShop</a> 购买《节奏海拉鲁》，有中文支持，美区价格 USD 24.99，日区价格 JPY 2980.00。</p>\n<p>你可能会感兴趣</p>\n<p>任天堂最新手游《马力欧医生世界》7 月 10 日登陆移动平台</p>\n<p>6 月 18 日，任天堂正式宣布《马力欧医生世界（Dr. Mario World）》将于 7 月 10 日登陆 iOS/Android 平台，该作是根据同名经典 FC 作品推出的移动端新作，玩家需要控制药丸消除病毒，与三消类游戏玩法类似，看起来十分益智。 游戏加入了全新的技能和道具，以及不同拥有过技能的任天堂经典角色。当然，作为一款免费游戏，氪金钻石要素也加入了其中，钻石可以用于获取额外道具、复活或是获取额外体力。 目前，该作已经在 <a href=\"https://apps.apple.com/us/app/dr-mario-world/id1440129313\">App Store</a> 和 <a href=\"https://play.google.com/store/apps/details?id=com.nintendo.zama\">Google Play</a> 开启预约。  </p>\n<p>召集所有巫师！????‍♂️《哈利波特：巫师联盟》6 月 21 日正式上架</p>\n<p>6 月 19 日，Niantic 宣布，《哈利波特：巫师联盟（Harry Potter: Wizards Unite）》将于 6 月 21 日正式上线，该作由曾经制作了《Pokémon Go》的 Niantic 与华纳游戏联合开发，通过探索真实的街区，玩家可以学会法术并会遭遇原著中的标志性怪物和敌人。 另外，官方在今天放出了一段真人预告短片，黑魔法不断侵蚀的麻瓜世界时，几位青年人拿出魔杖和食死徒们战斗，最后还出现了一位大家熟悉的老朋友，三分钟的预告可以说十分精彩。  </p>\n<p>《怪物猎人世界》大型的扩充资料篇「冰原」本周末开启测试</p>\n<p>6 月 19 日，CAPCOM 宣布，《怪物猎人世界》大型的扩充资料篇「冰原」将于本周末开启测试，具体的时间为 6 月 21 日～24日（仅限 PS Plus会员）与 6 月 28 日～7 月 1 日（所有玩家）。试玩版提供了大凶豺龙、猛牛龙与轰龙三个任务，玩家可以体验飞翔爪以及全武器种类新动作等全新要素。该大型扩展将在今年 9 月 6 日推出。本次测试仅限 PS4 平台，Beta 目前已经开始预载，你可以点击 <a href=\"https://store.playstation.com/zh-hant-hk/product/HP0102-CUSA15651_00-MHWICEBORNBETA00\">这里</a> 下载。</p>\n"},{"title":"最新版 XyPlayer 智能解析 X3.8 正式版 分享","url":"137.html","id":"137","date":"2019-06-22T08:59:02.000Z","_content":"\n**简介：** 还在为您的解析接口不稳定而发愁吗？即刻拥有 xyplayer 智能解析这一切都不是问题,  本解析可以让您的影视站拥有智能多线切换功能，支持解析各主流网站 VIP 视频。 主要特性功能如下： **特性** *  无需安装，无需数据库，上传即用。 *  强大的后台管理,支持修改各项配置。 *  支持切换模版，内置两套模版，可随意切换。 *  支持切换播放器，内置多种播放器(dplayer,ckplayer,H5 等),可随意切换。 *  支持缓存(文件缓存或 redis 缓存),实现视频秒加载。 *  支持 QQ 群机器人对接，预置接口并提供酷 Q 对应插件。 *   支持微信个人公众号对接,预置接口并提供对应插件。 *  支持反调试，保证数据安全。 模块 *  防火墙模块，可以用来授权网站，APP 等。 *   链接跳转模块，可以指定视频链接跳转到设置链接,优先级最高。 *   对接模块，可以对接一次解析为我所用,另有 cms 一次解析插件配合使用，优先级其次。 *  云播放模块，根据视频链接或视频标题搜索播放资源站资源,无广告,可自定义资源站,支持剧集连播,优先级其次。 *  解析模块,  可自定义第三方解析接口,优先级最低。 *  广告过滤模块,  支持自定义规则(实验室功能，不是很完善)。 ![](http://cdn.v5ant.com/ueditor/images/1125326093268684800.png) ![](http://cdn.v5ant.com/ueditor/images/1125326093788778496.png)   **2019.3.24 更新** \\* 修复 v.php 调用失败的 bug； _ 优化播放调用，修复若干 bug; _ 异常处理优化，使用 fundebug 插件收集异常信息； _ 播放器优化,发生异常会调用 H5 播放器解决兼容问题; _ 播放设置-线路设置 添加线路切换提示信息及显示时长设置； _ 修复特殊格式视频无法播放的 BUG; _ 修复大部分已知 BUG,其他细节优化； _ 修复上个版本视频卡顿的问题； _ 优化播放器调用，现在 url 参数无需加密调用; _ 优化微信插件，修复 BUG; **2019.3.19 更新** \\* 修复无法设置默认解析的 bug; _ 修复视频可能有黑边的的 bug; _ 修复 ckplayer 播放器 p2p 信息设置无效的 bug; \\*ckplayerx 控制栏添加上下集和选集按钮; \\* 配置代码优化，无配置文件可用默认帐号登录恢复配置，以后升级版本将不带配置文件可直接覆盖升级； _ 播放器优化，主要是 ckplayerx 和 dplayer,独立出官方集成 p2p 版本并升级到最新版本； _ 链接跳转现在支持输入视频标题,可以实现链接到资源站的直接搜索； _ 其他细节优化； **2019-3-13** \\* 防火墙代码优化，新添加版权保护,框架访问,API 保护等规则； _ 播放设置优化，Dplayer 播放器添加弹幕，logo 等设置； _ 修复无法播放 mp4 的问题; _ 修复自定义播放器无法使用的问题; _ 修复硬盘缓存有效期与设置不符的 BUG； _ 优化核心代码，避免核心文件被误杀； _ 优化搜索页面，优化记忆播放； _ 默认资源优化，全部采用 https 资源； _ 直播代码优化,添加 m3u8 跨域访问方法； _ 后台播放器设置添加 P2P 信息开关和记忆播放开关; _ 后台-播放设置-其它设置 添加解析调用提示设置，设置后会覆盖解析显示 2 秒后隐藏； _ 搜索页面美化,添加支持输入视频地址; _ 播放器添加记忆播放的功能； _ 添加对乐多资源的直接解析； _ 修复已知 BUG，其他细节优化; _ 搜索页面美化，修复 BUG; _ 修复手机端在开启公告后不能选集的 BUG; _ 修复自定义播放器无法保存的 BUG; _ 模版 byg 配置项添加设置 LOGO,默认隐藏； _ 播放设置添加服务器报错开关,经常提示报错可以关闭； _ 其他细节优化; _ 搜索页面美化，加入运行时间； _ 云播放添加来源标签转换； * 播放设置添加解析开关; *修复域名黑名单获取来源失败时不拦截的 bug; _ dplayerx 添加 p2p 连接信息； _ 云播放加入 P2P 加速支持, 设置路径：基本设置-播放设置-播放器设置-其他设置; _ CMS 解析插件加入对赞片的支持，感谢会员家乡味提供的代码; _ 搜索页面-手机端优化； _ 报错提示优化，加入反馈功能; _ 云播放算法优化； _ 搜索页面美化; _ 后台-云播放设置 优化来源过滤； _ 修复云规则版本信息不更新的 bug; _ 后台-云播设置, 添加资源标题及来源过滤; _ 后台-播放设置-其他设置, 添加云播标题设置,用于修改线路切换里云播放的显示名称; _ 解析线路及云播资源站设置添加显示名称支持； \\* 配置文件敏感项加密存储，保证数据安全; \\[collapse\\] 文档地址： [https://docs.xymov.net/1209554 ](https://docs.xymov.net/1209554)\n","source":"_posts/e6-9c-80-e6-96-b0-e7-89-88-xyplayer-e6-99-ba-e8-83-bd-e8-a7-a3-e6-9e-90-x3-8-e6-ad-a3-e5-bc-8f-e7-89-88-e5-88-86-e4-ba-ab.md","raw":"---\ntitle: 最新版 XyPlayer 智能解析 X3.8 正式版 分享\ntags:\n  - 解析，免费VIP\nurl: 137.html\nid: 137\ncategories:\n  - 精选资源\ndate: 2019-06-22 16:59:02\n---\n\n**简介：** 还在为您的解析接口不稳定而发愁吗？即刻拥有 xyplayer 智能解析这一切都不是问题,  本解析可以让您的影视站拥有智能多线切换功能，支持解析各主流网站 VIP 视频。 主要特性功能如下： **特性** *  无需安装，无需数据库，上传即用。 *  强大的后台管理,支持修改各项配置。 *  支持切换模版，内置两套模版，可随意切换。 *  支持切换播放器，内置多种播放器(dplayer,ckplayer,H5 等),可随意切换。 *  支持缓存(文件缓存或 redis 缓存),实现视频秒加载。 *  支持 QQ 群机器人对接，预置接口并提供酷 Q 对应插件。 *   支持微信个人公众号对接,预置接口并提供对应插件。 *  支持反调试，保证数据安全。 模块 *  防火墙模块，可以用来授权网站，APP 等。 *   链接跳转模块，可以指定视频链接跳转到设置链接,优先级最高。 *   对接模块，可以对接一次解析为我所用,另有 cms 一次解析插件配合使用，优先级其次。 *  云播放模块，根据视频链接或视频标题搜索播放资源站资源,无广告,可自定义资源站,支持剧集连播,优先级其次。 *  解析模块,  可自定义第三方解析接口,优先级最低。 *  广告过滤模块,  支持自定义规则(实验室功能，不是很完善)。 ![](http://cdn.v5ant.com/ueditor/images/1125326093268684800.png) ![](http://cdn.v5ant.com/ueditor/images/1125326093788778496.png)   **2019.3.24 更新** \\* 修复 v.php 调用失败的 bug； _ 优化播放调用，修复若干 bug; _ 异常处理优化，使用 fundebug 插件收集异常信息； _ 播放器优化,发生异常会调用 H5 播放器解决兼容问题; _ 播放设置-线路设置 添加线路切换提示信息及显示时长设置； _ 修复特殊格式视频无法播放的 BUG; _ 修复大部分已知 BUG,其他细节优化； _ 修复上个版本视频卡顿的问题； _ 优化播放器调用，现在 url 参数无需加密调用; _ 优化微信插件，修复 BUG; **2019.3.19 更新** \\* 修复无法设置默认解析的 bug; _ 修复视频可能有黑边的的 bug; _ 修复 ckplayer 播放器 p2p 信息设置无效的 bug; \\*ckplayerx 控制栏添加上下集和选集按钮; \\* 配置代码优化，无配置文件可用默认帐号登录恢复配置，以后升级版本将不带配置文件可直接覆盖升级； _ 播放器优化，主要是 ckplayerx 和 dplayer,独立出官方集成 p2p 版本并升级到最新版本； _ 链接跳转现在支持输入视频标题,可以实现链接到资源站的直接搜索； _ 其他细节优化； **2019-3-13** \\* 防火墙代码优化，新添加版权保护,框架访问,API 保护等规则； _ 播放设置优化，Dplayer 播放器添加弹幕，logo 等设置； _ 修复无法播放 mp4 的问题; _ 修复自定义播放器无法使用的问题; _ 修复硬盘缓存有效期与设置不符的 BUG； _ 优化核心代码，避免核心文件被误杀； _ 优化搜索页面，优化记忆播放； _ 默认资源优化，全部采用 https 资源； _ 直播代码优化,添加 m3u8 跨域访问方法； _ 后台播放器设置添加 P2P 信息开关和记忆播放开关; _ 后台-播放设置-其它设置 添加解析调用提示设置，设置后会覆盖解析显示 2 秒后隐藏； _ 搜索页面美化,添加支持输入视频地址; _ 播放器添加记忆播放的功能； _ 添加对乐多资源的直接解析； _ 修复已知 BUG，其他细节优化; _ 搜索页面美化，修复 BUG; _ 修复手机端在开启公告后不能选集的 BUG; _ 修复自定义播放器无法保存的 BUG; _ 模版 byg 配置项添加设置 LOGO,默认隐藏； _ 播放设置添加服务器报错开关,经常提示报错可以关闭； _ 其他细节优化; _ 搜索页面美化，加入运行时间； _ 云播放添加来源标签转换； * 播放设置添加解析开关; *修复域名黑名单获取来源失败时不拦截的 bug; _ dplayerx 添加 p2p 连接信息； _ 云播放加入 P2P 加速支持, 设置路径：基本设置-播放设置-播放器设置-其他设置; _ CMS 解析插件加入对赞片的支持，感谢会员家乡味提供的代码; _ 搜索页面-手机端优化； _ 报错提示优化，加入反馈功能; _ 云播放算法优化； _ 搜索页面美化; _ 后台-云播放设置 优化来源过滤； _ 修复云规则版本信息不更新的 bug; _ 后台-云播设置, 添加资源标题及来源过滤; _ 后台-播放设置-其他设置, 添加云播标题设置,用于修改线路切换里云播放的显示名称; _ 解析线路及云播资源站设置添加显示名称支持； \\* 配置文件敏感项加密存储，保证数据安全; \\[collapse\\] 文档地址： [https://docs.xymov.net/1209554 ](https://docs.xymov.net/1209554)\n","slug":"e6-9c-80-e6-96-b0-e7-89-88-xyplayer-e6-99-ba-e8-83-bd-e8-a7-a3-e6-9e-90-x3-8-e6-ad-a3-e5-bc-8f-e7-89-88-e5-88-86-e4-ba-ab","published":1,"updated":"2019-09-11T03:13:04.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269bs0020c8gs3v7ta2jz","content":"<p><strong>简介：</strong> 还在为您的解析接口不稳定而发愁吗？即刻拥有 xyplayer 智能解析这一切都不是问题,  本解析可以让您的影视站拥有智能多线切换功能，支持解析各主流网站 VIP 视频。 主要特性功能如下： <strong>特性</strong> *  无需安装，无需数据库，上传即用。 *  强大的后台管理,支持修改各项配置。 *  支持切换模版，内置两套模版，可随意切换。 *  支持切换播放器，内置多种播放器(dplayer,ckplayer,H5 等),可随意切换。 *  支持缓存(文件缓存或 redis 缓存),实现视频秒加载。 *  支持 QQ 群机器人对接，预置接口并提供酷 Q 对应插件。 *   支持微信个人公众号对接,预置接口并提供对应插件。 *  支持反调试，保证数据安全。 模块 *  防火墙模块，可以用来授权网站，APP 等。 *   链接跳转模块，可以指定视频链接跳转到设置链接,优先级最高。 *   对接模块，可以对接一次解析为我所用,另有 cms 一次解析插件配合使用，优先级其次。 *  云播放模块，根据视频链接或视频标题搜索播放资源站资源,无广告,可自定义资源站,支持剧集连播,优先级其次。 *  解析模块,  可自定义第三方解析接口,优先级最低。 *  广告过滤模块,  支持自定义规则(实验室功能，不是很完善)。 <img src=\"http://cdn.v5ant.com/ueditor/images/1125326093268684800.png\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1125326093788778496.png\">   <strong>2019.3.24 更新</strong> * 修复 v.php 调用失败的 bug； _ 优化播放调用，修复若干 bug; _ 异常处理优化，使用 fundebug 插件收集异常信息； _ 播放器优化,发生异常会调用 H5 播放器解决兼容问题; _ 播放设置-线路设置 添加线路切换提示信息及显示时长设置； _ 修复特殊格式视频无法播放的 BUG; _ 修复大部分已知 BUG,其他细节优化； _ 修复上个版本视频卡顿的问题； _ 优化播放器调用，现在 url 参数无需加密调用; _ 优化微信插件，修复 BUG; <strong>2019.3.19 更新</strong> * 修复无法设置默认解析的 bug; _ 修复视频可能有黑边的的 bug; _ 修复 ckplayer 播放器 p2p 信息设置无效的 bug; *ckplayerx 控制栏添加上下集和选集按钮; * 配置代码优化，无配置文件可用默认帐号登录恢复配置，以后升级版本将不带配置文件可直接覆盖升级； _ 播放器优化，主要是 ckplayerx 和 dplayer,独立出官方集成 p2p 版本并升级到最新版本； _ 链接跳转现在支持输入视频标题,可以实现链接到资源站的直接搜索； _ 其他细节优化； <strong>2019-3-13</strong> * 防火墙代码优化，新添加版权保护,框架访问,API 保护等规则； _ 播放设置优化，Dplayer 播放器添加弹幕，logo 等设置； _ 修复无法播放 mp4 的问题; _ 修复自定义播放器无法使用的问题; _ 修复硬盘缓存有效期与设置不符的 BUG； _ 优化核心代码，避免核心文件被误杀； _ 优化搜索页面，优化记忆播放； _ 默认资源优化，全部采用 https 资源； _ 直播代码优化,添加 m3u8 跨域访问方法； _ 后台播放器设置添加 P2P 信息开关和记忆播放开关; _ 后台-播放设置-其它设置 添加解析调用提示设置，设置后会覆盖解析显示 2 秒后隐藏； _ 搜索页面美化,添加支持输入视频地址; _ 播放器添加记忆播放的功能； _ 添加对乐多资源的直接解析； _ 修复已知 BUG，其他细节优化; _ 搜索页面美化，修复 BUG; _ 修复手机端在开启公告后不能选集的 BUG; _ 修复自定义播放器无法保存的 BUG; _ 模版 byg 配置项添加设置 LOGO,默认隐藏； _ 播放设置添加服务器报错开关,经常提示报错可以关闭； _ 其他细节优化; _ 搜索页面美化，加入运行时间； _ 云播放添加来源标签转换； * 播放设置添加解析开关; *修复域名黑名单获取来源失败时不拦截的 bug; _ dplayerx 添加 p2p 连接信息； _ 云播放加入 P2P 加速支持, 设置路径：基本设置-播放设置-播放器设置-其他设置; _ CMS 解析插件加入对赞片的支持，感谢会员家乡味提供的代码; _ 搜索页面-手机端优化； _ 报错提示优化，加入反馈功能; _ 云播放算法优化； _ 搜索页面美化; _ 后台-云播放设置 优化来源过滤； _ 修复云规则版本信息不更新的 bug; _ 后台-云播设置, 添加资源标题及来源过滤; _ 后台-播放设置-其他设置, 添加云播标题设置,用于修改线路切换里云播放的显示名称; _ 解析线路及云播资源站设置添加显示名称支持； * 配置文件敏感项加密存储，保证数据安全; [collapse] 文档地址： <a href=\"https://docs.xymov.net/1209554\">https://docs.xymov.net/1209554 </a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><strong>简介：</strong> 还在为您的解析接口不稳定而发愁吗？即刻拥有 xyplayer 智能解析这一切都不是问题,  本解析可以让您的影视站拥有智能多线切换功能，支持解析各主流网站 VIP 视频。 主要特性功能如下： <strong>特性</strong> *  无需安装，无需数据库，上传即用。 *  强大的后台管理,支持修改各项配置。 *  支持切换模版，内置两套模版，可随意切换。 *  支持切换播放器，内置多种播放器(dplayer,ckplayer,H5 等),可随意切换。 *  支持缓存(文件缓存或 redis 缓存),实现视频秒加载。 *  支持 QQ 群机器人对接，预置接口并提供酷 Q 对应插件。 *   支持微信个人公众号对接,预置接口并提供对应插件。 *  支持反调试，保证数据安全。 模块 *  防火墙模块，可以用来授权网站，APP 等。 *   链接跳转模块，可以指定视频链接跳转到设置链接,优先级最高。 *   对接模块，可以对接一次解析为我所用,另有 cms 一次解析插件配合使用，优先级其次。 *  云播放模块，根据视频链接或视频标题搜索播放资源站资源,无广告,可自定义资源站,支持剧集连播,优先级其次。 *  解析模块,  可自定义第三方解析接口,优先级最低。 *  广告过滤模块,  支持自定义规则(实验室功能，不是很完善)。 <img src=\"http://cdn.v5ant.com/ueditor/images/1125326093268684800.png\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1125326093788778496.png\">   <strong>2019.3.24 更新</strong> * 修复 v.php 调用失败的 bug； _ 优化播放调用，修复若干 bug; _ 异常处理优化，使用 fundebug 插件收集异常信息； _ 播放器优化,发生异常会调用 H5 播放器解决兼容问题; _ 播放设置-线路设置 添加线路切换提示信息及显示时长设置； _ 修复特殊格式视频无法播放的 BUG; _ 修复大部分已知 BUG,其他细节优化； _ 修复上个版本视频卡顿的问题； _ 优化播放器调用，现在 url 参数无需加密调用; _ 优化微信插件，修复 BUG; <strong>2019.3.19 更新</strong> * 修复无法设置默认解析的 bug; _ 修复视频可能有黑边的的 bug; _ 修复 ckplayer 播放器 p2p 信息设置无效的 bug; *ckplayerx 控制栏添加上下集和选集按钮; * 配置代码优化，无配置文件可用默认帐号登录恢复配置，以后升级版本将不带配置文件可直接覆盖升级； _ 播放器优化，主要是 ckplayerx 和 dplayer,独立出官方集成 p2p 版本并升级到最新版本； _ 链接跳转现在支持输入视频标题,可以实现链接到资源站的直接搜索； _ 其他细节优化； <strong>2019-3-13</strong> * 防火墙代码优化，新添加版权保护,框架访问,API 保护等规则； _ 播放设置优化，Dplayer 播放器添加弹幕，logo 等设置； _ 修复无法播放 mp4 的问题; _ 修复自定义播放器无法使用的问题; _ 修复硬盘缓存有效期与设置不符的 BUG； _ 优化核心代码，避免核心文件被误杀； _ 优化搜索页面，优化记忆播放； _ 默认资源优化，全部采用 https 资源； _ 直播代码优化,添加 m3u8 跨域访问方法； _ 后台播放器设置添加 P2P 信息开关和记忆播放开关; _ 后台-播放设置-其它设置 添加解析调用提示设置，设置后会覆盖解析显示 2 秒后隐藏； _ 搜索页面美化,添加支持输入视频地址; _ 播放器添加记忆播放的功能； _ 添加对乐多资源的直接解析； _ 修复已知 BUG，其他细节优化; _ 搜索页面美化，修复 BUG; _ 修复手机端在开启公告后不能选集的 BUG; _ 修复自定义播放器无法保存的 BUG; _ 模版 byg 配置项添加设置 LOGO,默认隐藏； _ 播放设置添加服务器报错开关,经常提示报错可以关闭； _ 其他细节优化; _ 搜索页面美化，加入运行时间； _ 云播放添加来源标签转换； * 播放设置添加解析开关; *修复域名黑名单获取来源失败时不拦截的 bug; _ dplayerx 添加 p2p 连接信息； _ 云播放加入 P2P 加速支持, 设置路径：基本设置-播放设置-播放器设置-其他设置; _ CMS 解析插件加入对赞片的支持，感谢会员家乡味提供的代码; _ 搜索页面-手机端优化； _ 报错提示优化，加入反馈功能; _ 云播放算法优化； _ 搜索页面美化; _ 后台-云播放设置 优化来源过滤； _ 修复云规则版本信息不更新的 bug; _ 后台-云播设置, 添加资源标题及来源过滤; _ 后台-播放设置-其他设置, 添加云播标题设置,用于修改线路切换里云播放的显示名称; _ 解析线路及云播资源站设置添加显示名称支持； * 配置文件敏感项加密存储，保证数据安全; [collapse] 文档地址： <a href=\"https://docs.xymov.net/1209554\">https://docs.xymov.net/1209554 </a></p>\n"},{"title":"最新知宇自动发卡系统源码[已集成彩虹易支付]","url":"394.html","id":"394","date":"2019-09-02T09:03:14.000Z","_content":"\n> 知宇自动发卡系统是基于 TP5 开发的全新发卡系统，拥有多用户，多支付通道对接功能，全响应式界面，简约易操作，一站式寄售卡系统。目前已经集成了彩虹易支付接口。\n\n<!-- more -->\n\n## 安装说明：\n\nPHP 版本不低于 PHP5.4，推荐使用 PHP7 以达到最优效果\n\n运行需支持 PATHINFO\n\n需要支持伪静态，Apache 默认自带，不需要单独设置，nginx 伪静态规则请选 ThinkPHP。\n\n数据库配置文件：application/database.php\n\n数据库备份文件：zyu.sql\n\n安装时需要将数据库备份文件导入数据库，并修改数据库配置文件。\n","source":"_posts/e6-9c-80-e6-96-b0-e7-9f-a5-e5-ae-87-e8-87-aa-e5-8a-a8-e5-8f-91-e5-8d-a1-e7-b3-bb-e7-bb-9f-e6-ba-90-e7-a0-81-e5-b7-b2-e9-9b-86-e6-88-90-e5-bd-a9-e8-99-b9-e6-98-93-e6-94-af-e4-bb-98.md","raw":"---\ntitle: '最新知宇自动发卡系统源码[已集成彩虹易支付]'\ntags:\n  - 发卡系统\nurl: 394.html\nid: 394\ncategories:\n  - 精选资源\ndate: 2019-09-02 17:03:14\n---\n\n> 知宇自动发卡系统是基于 TP5 开发的全新发卡系统，拥有多用户，多支付通道对接功能，全响应式界面，简约易操作，一站式寄售卡系统。目前已经集成了彩虹易支付接口。\n\n<!-- more -->\n\n## 安装说明：\n\nPHP 版本不低于 PHP5.4，推荐使用 PHP7 以达到最优效果\n\n运行需支持 PATHINFO\n\n需要支持伪静态，Apache 默认自带，不需要单独设置，nginx 伪静态规则请选 ThinkPHP。\n\n数据库配置文件：application/database.php\n\n数据库备份文件：zyu.sql\n\n安装时需要将数据库备份文件导入数据库，并修改数据库配置文件。\n","slug":"e6-9c-80-e6-96-b0-e7-9f-a5-e5-ae-87-e8-87-aa-e5-8a-a8-e5-8f-91-e5-8d-a1-e7-b3-bb-e7-bb-9f-e6-ba-90-e7-a0-81-e5-b7-b2-e9-9b-86-e6-88-90-e5-bd-a9-e8-99-b9-e6-98-93-e6-94-af-e4-bb-98","published":1,"updated":"2019-09-11T08:46:15.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269bu0023c8gs8gld6ine","content":"<blockquote>\n<p>知宇自动发卡系统是基于 TP5 开发的全新发卡系统，拥有多用户，多支付通道对接功能，全响应式界面，简约易操作，一站式寄售卡系统。目前已经集成了彩虹易支付接口。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"安装说明：\"><a href=\"#安装说明：\" class=\"headerlink\" title=\"安装说明：\"></a>安装说明：</h2><p>PHP 版本不低于 PHP5.4，推荐使用 PHP7 以达到最优效果</p>\n<p>运行需支持 PATHINFO</p>\n<p>需要支持伪静态，Apache 默认自带，不需要单独设置，nginx 伪静态规则请选 ThinkPHP。</p>\n<p>数据库配置文件：application/database.php</p>\n<p>数据库备份文件：zyu.sql</p>\n<p>安装时需要将数据库备份文件导入数据库，并修改数据库配置文件。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<blockquote>\n<p>知宇自动发卡系统是基于 TP5 开发的全新发卡系统，拥有多用户，多支付通道对接功能，全响应式界面，简约易操作，一站式寄售卡系统。目前已经集成了彩虹易支付接口。</p>\n</blockquote>","more":"<h2 id=\"安装说明：\"><a href=\"#安装说明：\" class=\"headerlink\" title=\"安装说明：\"></a>安装说明：</h2><p>PHP 版本不低于 PHP5.4，推荐使用 PHP7 以达到最优效果</p>\n<p>运行需支持 PATHINFO</p>\n<p>需要支持伪静态，Apache 默认自带，不需要单独设置，nginx 伪静态规则请选 ThinkPHP。</p>\n<p>数据库配置文件：application/database.php</p>\n<p>数据库备份文件：zyu.sql</p>\n<p>安装时需要将数据库备份文件导入数据库，并修改数据库配置文件。</p>"},{"title":"最长一枪- HDTC国语中字版-最新上架","url":"416.html","id":"416","date":"2019-09-06T09:45:58.000Z","_content":"\n# 最长一枪\n\n> 从没失过手的杀手老赵（王志文 饰），得了帕金森，准备退休，却同时接到两个订单同一时间，同一地点。一个订单的目标，却是另一订单的委托人。为了弥补心中一个久远的愧疚，老赵决定利用这最后的机会，倾力一搏，把...\n\n<!-- more -->\n\n主演：\n\n导演：\n\n发行地区\n\n对白语言：\n\n王志文,余男,Lichun,Lee,许亚军,夏克立,高捷,余皑磊,赵铭岳,白澍,王冠杰,康斯坦丁·科玖霍夫,法比安·卢查瑞尼\n\n徐顺利\n\n大陆\n\n国语\n{% iframe http://jx.v5ant.com?v=https://wuji.zhulong-zuida.com/20190906/7542_652e2a58/index.m3u8  %}\n\n![](https://www.imov.vip/upload/vod/20190906-1/67ebd32fe36ec7786985f548309b70e8.jpg)\n","source":"_posts/e6-9c-80-e9-95-bf-e4-b8-80-e6-9e-aa-hdtc-e5-9b-bd-e8-af-ad-e4-b8-ad-e5-ad-97-e7-89-88-e6-9c-80-e6-96-b0-e4-b8-8a-e6-9e-b6.md","raw":"---\ntitle: 最长一枪- HDTC国语中字版-最新上架\ntags:\n  - 在线播放\n  - 影视\nurl: 416.html\nid: 416\ncategories:\n  - 影视资源\ndate: 2019-09-06 17:45:58\n---\n\n# 最长一枪\n\n> 从没失过手的杀手老赵（王志文 饰），得了帕金森，准备退休，却同时接到两个订单同一时间，同一地点。一个订单的目标，却是另一订单的委托人。为了弥补心中一个久远的愧疚，老赵决定利用这最后的机会，倾力一搏，把...\n\n<!-- more -->\n\n主演：\n\n导演：\n\n发行地区\n\n对白语言：\n\n王志文,余男,Lichun,Lee,许亚军,夏克立,高捷,余皑磊,赵铭岳,白澍,王冠杰,康斯坦丁·科玖霍夫,法比安·卢查瑞尼\n\n徐顺利\n\n大陆\n\n国语\n{% iframe http://jx.v5ant.com?v=https://wuji.zhulong-zuida.com/20190906/7542_652e2a58/index.m3u8  %}\n\n![](https://www.imov.vip/upload/vod/20190906-1/67ebd32fe36ec7786985f548309b70e8.jpg)\n","slug":"e6-9c-80-e9-95-bf-e4-b8-80-e6-9e-aa-hdtc-e5-9b-bd-e8-af-ad-e4-b8-ad-e5-ad-97-e7-89-88-e6-9c-80-e6-96-b0-e4-b8-8a-e6-9e-b6","published":1,"updated":"2019-09-11T08:40:04.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269bw0026c8gsazrefb2l","content":"<h1 id=\"最长一枪\"><a href=\"#最长一枪\" class=\"headerlink\" title=\"最长一枪\"></a>最长一枪</h1><blockquote>\n<p>从没失过手的杀手老赵（王志文 饰），得了帕金森，准备退休，却同时接到两个订单同一时间，同一地点。一个订单的目标，却是另一订单的委托人。为了弥补心中一个久远的愧疚，老赵决定利用这最后的机会，倾力一搏，把…</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>主演：</p>\n<p>导演：</p>\n<p>发行地区</p>\n<p>对白语言：</p>\n<p>王志文,余男,Lichun,Lee,许亚军,夏克立,高捷,余皑磊,赵铭岳,白澍,王冠杰,康斯坦丁·科玖霍夫,法比安·卢查瑞尼</p>\n<p>徐顺利</p>\n<p>大陆</p>\n<p>国语</p>\n<iframe src=\"http://jx.v5ant.com/?v=https://wuji.zhulong-zuida.com/20190906/7542_652e2a58/index.m3u8\" width=\"100%\" height=\"300\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n\n<p><img src=\"https://www.imov.vip/upload/vod/20190906-1/67ebd32fe36ec7786985f548309b70e8.jpg\"></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<h1 id=\"最长一枪\"><a href=\"#最长一枪\" class=\"headerlink\" title=\"最长一枪\"></a>最长一枪</h1><blockquote>\n<p>从没失过手的杀手老赵（王志文 饰），得了帕金森，准备退休，却同时接到两个订单同一时间，同一地点。一个订单的目标，却是另一订单的委托人。为了弥补心中一个久远的愧疚，老赵决定利用这最后的机会，倾力一搏，把…</p>\n</blockquote>","more":"<p>主演：</p>\n<p>导演：</p>\n<p>发行地区</p>\n<p>对白语言：</p>\n<p>王志文,余男,Lichun,Lee,许亚军,夏克立,高捷,余皑磊,赵铭岳,白澍,王冠杰,康斯坦丁·科玖霍夫,法比安·卢查瑞尼</p>\n<p>徐顺利</p>\n<p>大陆</p>\n<p>国语</p>\n<iframe src=\"http://jx.v5ant.com/?v=https://wuji.zhulong-zuida.com/20190906/7542_652e2a58/index.m3u8\" width=\"100%\" height=\"300\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n\n<p><img src=\"https://www.imov.vip/upload/vod/20190906-1/67ebd32fe36ec7786985f548309b70e8.jpg\"></p>"},{"title":"有了这份上班摸鱼指南，不用再怕工作「划水」被抓现行","url":"156.html","id":"156","date":"2019-06-22T09:18:07.000Z","_content":"\n古语云：授人以鱼，不如授人以渔。又有言曰，凡有劳者，必好摸焉。今天是愚人节，相信你一定也在无聊地刷着网上的各种有趣的假新闻无心工作。针对被 996 和被无休止加班折磨的你，我又特地整理了这份上班摸鱼指南，收录各种「带薪休假」技巧，请各位领导看到本文自觉关闭页面。\n\n上网的正确姿势\n-------\n\n### 无图才有真相\n\n整日面对枯燥的报表，难免会产生倦怠情绪。心理专家建议，此时，应该打开几个常去的网站，休憩身心，方能提高工作效率。如果你担心太明目张胆，不妨以无图模式浏览网页，增大可视面积的同时预防 [NSFW](https://baike.baidu.com/item/NSFW/5576169?fr=aladdin \"NSFW\") 内容出现。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/b91dd3c0c5dfeba521c93829359cc8bb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 若要开启 Chrome 的无图模式，只需访问 `chrome://settings/content/images`，关闭开关即可。你也可以点击地址栏左侧小锁，进入网站设置，从而针对特定站点屏蔽图片。在 Firefox 等浏览器中，也有类似设置。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/7027d9a1388889c2e9bd0f3abccc1056.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 当然，这种方式依然略显繁琐，因此，我更推荐通过扩展过滤图片。以少数派多次推荐的 [简悦](https://sspai.com/search/article?q=%E7%AE%80%E6%82%A6 \"简悦\") 为例，你可以在其 [插件中心](https://simpread.ksria.cn/plugins/details/0vnL8VbCgs \"插件中心\") 下载安装「无图版」插件，从而在阅读模式中屏蔽图片，更加便捷。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/b33b8bf4f3f73fa8ba11ef8205652333.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 命令行也可以看新闻\n\n如果你是一位苦逼程序员，上班时间开着浏览器可就不那么自然了。好在已有无数先辈们意识到了这个问题，并在敲键盘之余造出了各种轮子。举例来说，[haxor-news](https://github.com/donnemartin/haxor-news \"haxor-news\") 将 [Hacker News](https://news.ycombinator.com/ \"Hacker News\") 搬到了命令行；而 [Instagram Terminal Feed](https://github.com/billcccheng/instagram-terminal-news-feed \"Instagram Terminal Feed\") 则允许你在命令行浏览 Instagram 信息流，甚至包含了字符串拼就的图片预览，着实令人钦佩。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/10d2fbf4df4c96587f62150304f236e2.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 如果你对以上两个网站不感兴趣，不妨试试 [Newsboat](https://newsboat.org/ \"Newsboat\")，它可以让你在终端阅读任意 RSS 订阅内容，称得上是海纳百川了。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/a627da3c969dbd5b2c7ed3ed3078ed8e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 若你还是欲求不满，可以利用上班时间给自己写一个命令行划水小程序，既可以缓解工作疲劳，又可以收获众人 Star，为日后跳槽加分。\n\n### 沙雕网友，在线吹水\n\n好不容易交上设计稿，甲方却说要全部推倒重来——如此不平之事，不在群里吐槽几句怎么能忍。然而，许多公司早已屏蔽了 QQ、微信等常用社交网站域名，偷偷掏出手机又风险过大。幸好，我们还能找到一些开箱即用的在线聊天网站，例如 [Telegram Web](https://web.telegram.org/ \"Telegram Web\")、[V2EX](https://www.v2ex.com/ \"V2EX\")、[NGA](https://bbs.nga.cn/ \"NGA\")、[Stage1st](https://bbs.saraba1st.com/2b/forum.php \"Stage1st\") 和 [A岛匿名版](http://adnmb1.com/Forum \"A岛匿名版\") 等。与人斗智，其乐无穷。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/e2e42b2c0b43f9782c1f147ef5584373.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n划水也要充实自己\n--------\n\n### 老板你看我在码字\n\n如果你是一名文字工作者，电脑上开着几个 Word 窗口再正常不过了，而这，也成为了我们摸鱼时的突破点。只需要下载好想读的小说，用 Word 或其它文本编辑器打开，就可以名正言顺地提高姿势水平了。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/05abb4d1c61d403331f462e3a4cdb4f2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 什么，你嫌找离线资源太麻烦？不用担心，[网易云阅读](https://yuedu.163.com/ \"网易云阅读\") 贴心地为你准备了 Word 主题模式，只需轻点上方按钮，就能一键切换。当然，这种方式的局限性也显而易见，那就是只能模拟 Windows 7 和 Office 2010 界面，非常容易露馅。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/b82a2332bd62cf50d97d6c6e32ee1936.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 代码与书籍齐飞\n\n作为一名程序员，整天对着 Word 显然容易引火烧身。不过，我们可以换种思路，利用大多数代码编辑器自带的左右分栏功能，在敲代码的同时瞄几眼小说，锻炼多线程思维能力，保佑编译一次通过。如果你更硬核一点，还可以试试在日志里看小说等奇巧淫技，充分发挥主观能动性。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/e378bb66983ac55e4f03685e5d48e14a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 身在工位，耳听八方\n\n尽管严格限制了种种摸鱼行为，但不少公司都允许你在上班时间听音乐，以舒缓身心，提高工作效率。除了轻音乐之外，其实，你还可以将播客、有声小说等内容下载至手机，汲取本职工作以外的精神食粮。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/6b44452dca256205b7f23e7a34409756.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n加班当然玩游戏\n-------\n\n### 控制台也能玩出花\n\n如果你不幸国庆也要加班，心中难免愤懑不堪，亲切问候领导亲属。这时，不妨吸几口「电子海洛因」，排忧解难。当然，一般的电子游戏都过于明目张胆，但还有一批自 DOS 时代潜伏至今的「控制台游戏」，虽然画面简陋，但胜在隐蔽性强。如魔塔、俄罗斯方块、贪吃蛇、2048 等著名游戏都有相应版本实现，直接搜索就能找到。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/ec0b8d83c862f94a5c8d47b21b6e1121.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 此外，还有玩家收集整理了 1800 余款精品 DOS 游戏，囊括了《仙剑奇侠传》、《模拟城市》、《主题医院》、《三国志》和《大航海时代》等陪伴了一代人的经典，你可以直接通过浏览器访问 [该网页](https://dos.zczc.cz/ \"该网页\") 回味。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/ba33a1ce4d3ef883d570ec2abf402722.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 大灾变：劫后余生\n\n如果你是真正的硬核玩家，不妨试试[《大灾变：劫后余生》](http://cn.cataclysmdda.com/pages/13/display \"《大灾变：劫后余生》\")这款开放世界 Roguelike 游戏，在末日后的世界克服重重险阻，努力活下去。 尽管《大灾变：劫后余生》的全部画面均由字符串拼就、没有背景音乐，游戏的键位也反人类地类似 vim，整体像是从上世纪 70 年代穿越而来。但凭借出彩的剧情、丰富的机制和极强的代入感，这款游戏仍吸引了一大批忠实拥趸，希望你也喜欢。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/9e8b97a63a56b17601fcbb1a8cdc46a4.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### YORG.io\n\nYORG.io 是另一款有趣的网页游戏，它融合了 CLG、塔防、生存、僵尸等多种要素。你需要利用白天时间开采资源，并在夜间使用防御塔保护你的建筑。你可以改变游戏中的时间流速，并在白天暂停游戏。期间，你可以建造、卖出和升级建筑，但不会有任何资源收入。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/e39aedae7217108caacb6f5276435594.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 用好 Touch Bar\n\n在 2016 款及其后的 MacBook Pro 中，苹果使用触控栏（即 Multi-Touch Bar）取代了键盘上方的 Fn 功能区。如果你正在使用该系列机型办公，便已经拥有了一块得天独厚的娱乐宝地。 举例来说，[TouchBarDino](https://github.com/yuhuili/TouchBarDino \"TouchBarDino\") 将 Chrome 断网时的小恐龙游戏搬到触控栏上，[Pac-Bar](https://github.com/henryefranks/pac-bar \"Pac-Bar\") 让你在上面玩吃豆人，你也可以选择借助 [Touch Bar Space Fight](https://github.com/insidegui/TouchBarSpaceFight \"Touch Bar Space Fight\") 打一场太空战争。当然，不要让上司发现你始终低着头哦。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/9755868e8799222a67d6b7b112d43e81.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 如果你想了解更多触控栏的有趣用法，可以阅读少数派之前的 [这篇文章](https://sspai.com/post/44435 \"这篇文章\")。\n\n科学破解领导突袭\n--------\n\n### 一键切换标签页\n\n上司已经逼近，浏览器却开着七八个摸鱼网页，值此危急存亡之际，偏偏又点不中标签上的小叉号……为了避免这一风险，我们需要想办法快速关闭当前标签页组，同时打开预设的工作网页。 在这里，我要推荐的是 Chrome 扩展 [Toby](https://chrome.google.com/webstore/detail/toby-for-chrome/hddnkoipeenegfoeaoibdmnaalmgkpip \"Toby\")，只需要点击图标，选择「Save Session」，就可以快速关闭并保存当前窗口内所有标签页，不留一丝痕迹。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/22e7ab1d0d89884bab609ad7394b1f99.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 随后，你可以在 Toby 的扩展页面浏览刚才关闭的标签页组，并一键打开。你也可以利用这一技巧提前设置几组工作窗口，实现快速切换的目的。 关联阅读：[如何更好地管理「标签页」，我选择 Toby](https://sspai.com/post/44105 \"如何更好地管理「标签页」，我选择 Toby\") ![请输入图片标题](https://cdn.sspai.com/2019/03/06/a4d591aedc59a04f2567019e4f05c485.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 虚拟桌面保平安\n\n纵使远离了标签页困境，一直开着浏览器也不怎么像样。好在 Windows 10 和 macOS 均原生支持虚拟桌面，你可以将当前运行程序拆为工作和娱乐两块，并通过快捷键、鼠标或触控板手势等切换桌面，隐蔽性 Max。 在 Windows 10 中，你可以通过按下 `Ctrl-Win-D` 创建一个新的虚拟桌面；使用 `Ctrl-Win-←/→`切换至前一个或后一个虚拟桌面；或使用 `Ctrl-Win-F4` 关闭当前虚拟桌面。当然，你也可以直接按下任务栏上的「任务视图」按钮，用更直观的方式管理虚拟桌面。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/fa4d79e919f7b4886b3919e750340d2a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 虚拟桌面特性很早以前就来到了 macOS，你也可以使用 `⌃Control-←/→` 在多个桌面间切换。不过，我想长期使用 MacBook 的诸位更习惯的方式，是在触控板上四指左右轻扫切换，更加自然流畅。这同样是微软官方推荐手势，但由于 Windows 阵营过于繁杂，我不保证适用于所有笔记本。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/eb7629c7a91a68f3a4e7b04b67292d1e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 在少数派的 [这篇文章](https://sspai.com/post/45594 \"这篇文章\") 中，还介绍了如何通过鼠标宏等方式切换 Windows 虚拟桌面，欢迎继续阅读。\n\n### TACTICAL BOSS INCOMING\n\n与其临阵磨枪，不如时刻备战。这一真理也被程序员们熟稔，并研发了 [BossSensor](https://github.com/Hironsan/BossSensor \"BossSensor\") 这款神器。只需将若干领导照片放置在工作目录，通过机器学习训练识别模型，就能在摄像头捕捉目标后一键切换至预设的工作环境，用科技让生活更美好。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/d6e24e143daf6151ee78e4c347744e9d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 当然，以上技巧仅供娱乐，还请大家好好学习，堇业上工，莫要因小失大。","source":"_posts/e6-9c-89-e4-ba-86-e8-bf-99-e4-bb-bd-e4-b8-8a-e7-8f-ad-e6-91-b8-e9-b1-bc-e6-8c-87-e5-8d-97-ef-bc-8c-e4-b8-8d-e7-94-a8-e5-86-8d-e6-80-95-e5-b7-a5-e4-bd-9c-e3-80-8c-e5-88-92-e6-b0-b4-e3-80-8d-e8-a2-ab.md","raw":"---\ntitle: 有了这份上班摸鱼指南，不用再怕工作「划水」被抓现行\nurl: 156.html\nid: 156\ncategories:\n  - 杂谈\ndate: 2019-06-22 17:18:07\ntags:\n---\n\n古语云：授人以鱼，不如授人以渔。又有言曰，凡有劳者，必好摸焉。今天是愚人节，相信你一定也在无聊地刷着网上的各种有趣的假新闻无心工作。针对被 996 和被无休止加班折磨的你，我又特地整理了这份上班摸鱼指南，收录各种「带薪休假」技巧，请各位领导看到本文自觉关闭页面。\n\n上网的正确姿势\n-------\n\n### 无图才有真相\n\n整日面对枯燥的报表，难免会产生倦怠情绪。心理专家建议，此时，应该打开几个常去的网站，休憩身心，方能提高工作效率。如果你担心太明目张胆，不妨以无图模式浏览网页，增大可视面积的同时预防 [NSFW](https://baike.baidu.com/item/NSFW/5576169?fr=aladdin \"NSFW\") 内容出现。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/b91dd3c0c5dfeba521c93829359cc8bb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 若要开启 Chrome 的无图模式，只需访问 `chrome://settings/content/images`，关闭开关即可。你也可以点击地址栏左侧小锁，进入网站设置，从而针对特定站点屏蔽图片。在 Firefox 等浏览器中，也有类似设置。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/7027d9a1388889c2e9bd0f3abccc1056.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 当然，这种方式依然略显繁琐，因此，我更推荐通过扩展过滤图片。以少数派多次推荐的 [简悦](https://sspai.com/search/article?q=%E7%AE%80%E6%82%A6 \"简悦\") 为例，你可以在其 [插件中心](https://simpread.ksria.cn/plugins/details/0vnL8VbCgs \"插件中心\") 下载安装「无图版」插件，从而在阅读模式中屏蔽图片，更加便捷。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/b33b8bf4f3f73fa8ba11ef8205652333.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 命令行也可以看新闻\n\n如果你是一位苦逼程序员，上班时间开着浏览器可就不那么自然了。好在已有无数先辈们意识到了这个问题，并在敲键盘之余造出了各种轮子。举例来说，[haxor-news](https://github.com/donnemartin/haxor-news \"haxor-news\") 将 [Hacker News](https://news.ycombinator.com/ \"Hacker News\") 搬到了命令行；而 [Instagram Terminal Feed](https://github.com/billcccheng/instagram-terminal-news-feed \"Instagram Terminal Feed\") 则允许你在命令行浏览 Instagram 信息流，甚至包含了字符串拼就的图片预览，着实令人钦佩。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/10d2fbf4df4c96587f62150304f236e2.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 如果你对以上两个网站不感兴趣，不妨试试 [Newsboat](https://newsboat.org/ \"Newsboat\")，它可以让你在终端阅读任意 RSS 订阅内容，称得上是海纳百川了。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/a627da3c969dbd5b2c7ed3ed3078ed8e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 若你还是欲求不满，可以利用上班时间给自己写一个命令行划水小程序，既可以缓解工作疲劳，又可以收获众人 Star，为日后跳槽加分。\n\n### 沙雕网友，在线吹水\n\n好不容易交上设计稿，甲方却说要全部推倒重来——如此不平之事，不在群里吐槽几句怎么能忍。然而，许多公司早已屏蔽了 QQ、微信等常用社交网站域名，偷偷掏出手机又风险过大。幸好，我们还能找到一些开箱即用的在线聊天网站，例如 [Telegram Web](https://web.telegram.org/ \"Telegram Web\")、[V2EX](https://www.v2ex.com/ \"V2EX\")、[NGA](https://bbs.nga.cn/ \"NGA\")、[Stage1st](https://bbs.saraba1st.com/2b/forum.php \"Stage1st\") 和 [A岛匿名版](http://adnmb1.com/Forum \"A岛匿名版\") 等。与人斗智，其乐无穷。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/e2e42b2c0b43f9782c1f147ef5584373.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n划水也要充实自己\n--------\n\n### 老板你看我在码字\n\n如果你是一名文字工作者，电脑上开着几个 Word 窗口再正常不过了，而这，也成为了我们摸鱼时的突破点。只需要下载好想读的小说，用 Word 或其它文本编辑器打开，就可以名正言顺地提高姿势水平了。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/05abb4d1c61d403331f462e3a4cdb4f2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 什么，你嫌找离线资源太麻烦？不用担心，[网易云阅读](https://yuedu.163.com/ \"网易云阅读\") 贴心地为你准备了 Word 主题模式，只需轻点上方按钮，就能一键切换。当然，这种方式的局限性也显而易见，那就是只能模拟 Windows 7 和 Office 2010 界面，非常容易露馅。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/b82a2332bd62cf50d97d6c6e32ee1936.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 代码与书籍齐飞\n\n作为一名程序员，整天对着 Word 显然容易引火烧身。不过，我们可以换种思路，利用大多数代码编辑器自带的左右分栏功能，在敲代码的同时瞄几眼小说，锻炼多线程思维能力，保佑编译一次通过。如果你更硬核一点，还可以试试在日志里看小说等奇巧淫技，充分发挥主观能动性。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/e378bb66983ac55e4f03685e5d48e14a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 身在工位，耳听八方\n\n尽管严格限制了种种摸鱼行为，但不少公司都允许你在上班时间听音乐，以舒缓身心，提高工作效率。除了轻音乐之外，其实，你还可以将播客、有声小说等内容下载至手机，汲取本职工作以外的精神食粮。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/6b44452dca256205b7f23e7a34409756.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n加班当然玩游戏\n-------\n\n### 控制台也能玩出花\n\n如果你不幸国庆也要加班，心中难免愤懑不堪，亲切问候领导亲属。这时，不妨吸几口「电子海洛因」，排忧解难。当然，一般的电子游戏都过于明目张胆，但还有一批自 DOS 时代潜伏至今的「控制台游戏」，虽然画面简陋，但胜在隐蔽性强。如魔塔、俄罗斯方块、贪吃蛇、2048 等著名游戏都有相应版本实现，直接搜索就能找到。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/ec0b8d83c862f94a5c8d47b21b6e1121.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 此外，还有玩家收集整理了 1800 余款精品 DOS 游戏，囊括了《仙剑奇侠传》、《模拟城市》、《主题医院》、《三国志》和《大航海时代》等陪伴了一代人的经典，你可以直接通过浏览器访问 [该网页](https://dos.zczc.cz/ \"该网页\") 回味。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/ba33a1ce4d3ef883d570ec2abf402722.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 大灾变：劫后余生\n\n如果你是真正的硬核玩家，不妨试试[《大灾变：劫后余生》](http://cn.cataclysmdda.com/pages/13/display \"《大灾变：劫后余生》\")这款开放世界 Roguelike 游戏，在末日后的世界克服重重险阻，努力活下去。 尽管《大灾变：劫后余生》的全部画面均由字符串拼就、没有背景音乐，游戏的键位也反人类地类似 vim，整体像是从上世纪 70 年代穿越而来。但凭借出彩的剧情、丰富的机制和极强的代入感，这款游戏仍吸引了一大批忠实拥趸，希望你也喜欢。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/9e8b97a63a56b17601fcbb1a8cdc46a4.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### YORG.io\n\nYORG.io 是另一款有趣的网页游戏，它融合了 CLG、塔防、生存、僵尸等多种要素。你需要利用白天时间开采资源，并在夜间使用防御塔保护你的建筑。你可以改变游戏中的时间流速，并在白天暂停游戏。期间，你可以建造、卖出和升级建筑，但不会有任何资源收入。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/e39aedae7217108caacb6f5276435594.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 用好 Touch Bar\n\n在 2016 款及其后的 MacBook Pro 中，苹果使用触控栏（即 Multi-Touch Bar）取代了键盘上方的 Fn 功能区。如果你正在使用该系列机型办公，便已经拥有了一块得天独厚的娱乐宝地。 举例来说，[TouchBarDino](https://github.com/yuhuili/TouchBarDino \"TouchBarDino\") 将 Chrome 断网时的小恐龙游戏搬到触控栏上，[Pac-Bar](https://github.com/henryefranks/pac-bar \"Pac-Bar\") 让你在上面玩吃豆人，你也可以选择借助 [Touch Bar Space Fight](https://github.com/insidegui/TouchBarSpaceFight \"Touch Bar Space Fight\") 打一场太空战争。当然，不要让上司发现你始终低着头哦。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/9755868e8799222a67d6b7b112d43e81.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 如果你想了解更多触控栏的有趣用法，可以阅读少数派之前的 [这篇文章](https://sspai.com/post/44435 \"这篇文章\")。\n\n科学破解领导突袭\n--------\n\n### 一键切换标签页\n\n上司已经逼近，浏览器却开着七八个摸鱼网页，值此危急存亡之际，偏偏又点不中标签上的小叉号……为了避免这一风险，我们需要想办法快速关闭当前标签页组，同时打开预设的工作网页。 在这里，我要推荐的是 Chrome 扩展 [Toby](https://chrome.google.com/webstore/detail/toby-for-chrome/hddnkoipeenegfoeaoibdmnaalmgkpip \"Toby\")，只需要点击图标，选择「Save Session」，就可以快速关闭并保存当前窗口内所有标签页，不留一丝痕迹。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/22e7ab1d0d89884bab609ad7394b1f99.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 随后，你可以在 Toby 的扩展页面浏览刚才关闭的标签页组，并一键打开。你也可以利用这一技巧提前设置几组工作窗口，实现快速切换的目的。 关联阅读：[如何更好地管理「标签页」，我选择 Toby](https://sspai.com/post/44105 \"如何更好地管理「标签页」，我选择 Toby\") ![请输入图片标题](https://cdn.sspai.com/2019/03/06/a4d591aedc59a04f2567019e4f05c485.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\")\n\n### 虚拟桌面保平安\n\n纵使远离了标签页困境，一直开着浏览器也不怎么像样。好在 Windows 10 和 macOS 均原生支持虚拟桌面，你可以将当前运行程序拆为工作和娱乐两块，并通过快捷键、鼠标或触控板手势等切换桌面，隐蔽性 Max。 在 Windows 10 中，你可以通过按下 `Ctrl-Win-D` 创建一个新的虚拟桌面；使用 `Ctrl-Win-←/→`切换至前一个或后一个虚拟桌面；或使用 `Ctrl-Win-F4` 关闭当前虚拟桌面。当然，你也可以直接按下任务栏上的「任务视图」按钮，用更直观的方式管理虚拟桌面。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/fa4d79e919f7b4886b3919e750340d2a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 虚拟桌面特性很早以前就来到了 macOS，你也可以使用 `⌃Control-←/→` 在多个桌面间切换。不过，我想长期使用 MacBook 的诸位更习惯的方式，是在触控板上四指左右轻扫切换，更加自然流畅。这同样是微软官方推荐手势，但由于 Windows 阵营过于繁杂，我不保证适用于所有笔记本。 ![请输入图片标题](https://cdn.sspai.com/2019/03/06/eb7629c7a91a68f3a4e7b04b67292d1e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 在少数派的 [这篇文章](https://sspai.com/post/45594 \"这篇文章\") 中，还介绍了如何通过鼠标宏等方式切换 Windows 虚拟桌面，欢迎继续阅读。\n\n### TACTICAL BOSS INCOMING\n\n与其临阵磨枪，不如时刻备战。这一真理也被程序员们熟稔，并研发了 [BossSensor](https://github.com/Hironsan/BossSensor \"BossSensor\") 这款神器。只需将若干领导照片放置在工作目录，通过机器学习训练识别模型，就能在摄像头捕捉目标后一键切换至预设的工作环境，用科技让生活更美好。 ![请输入图片标题](https://cdn.sspai.com/2018/10/18/d6e24e143daf6151ee78e4c347744e9d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1 \"请输入图片标题\") 当然，以上技巧仅供娱乐，还请大家好好学习，堇业上工，莫要因小失大。","slug":"e6-9c-89-e4-ba-86-e8-bf-99-e4-bb-bd-e4-b8-8a-e7-8f-ad-e6-91-b8-e9-b1-bc-e6-8c-87-e5-8d-97-ef-bc-8c-e4-b8-8d-e7-94-a8-e5-86-8d-e6-80-95-e5-b7-a5-e4-bd-9c-e3-80-8c-e5-88-92-e6-b0-b4-e3-80-8d-e8-a2-ab","published":1,"updated":"2019-09-10T07:46:08.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269bx0029c8gs2qsv1hf5","content":"<p>古语云：授人以鱼，不如授人以渔。又有言曰，凡有劳者，必好摸焉。今天是愚人节，相信你一定也在无聊地刷着网上的各种有趣的假新闻无心工作。针对被 996 和被无休止加班折磨的你，我又特地整理了这份上班摸鱼指南，收录各种「带薪休假」技巧，请各位领导看到本文自觉关闭页面。</p>\n<h2 id=\"上网的正确姿势\"><a href=\"#上网的正确姿势\" class=\"headerlink\" title=\"上网的正确姿势\"></a>上网的正确姿势</h2><h3 id=\"无图才有真相\"><a href=\"#无图才有真相\" class=\"headerlink\" title=\"无图才有真相\"></a>无图才有真相</h3><p>整日面对枯燥的报表，难免会产生倦怠情绪。心理专家建议，此时，应该打开几个常去的网站，休憩身心，方能提高工作效率。如果你担心太明目张胆，不妨以无图模式浏览网页，增大可视面积的同时预防 <a href=\"https://baike.baidu.com/item/NSFW/5576169?fr=aladdin\" title=\"NSFW\">NSFW</a> 内容出现。 <img src=\"https://cdn.sspai.com/2019/03/06/b91dd3c0c5dfeba521c93829359cc8bb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 若要开启 Chrome 的无图模式，只需访问 <code>chrome://settings/content/images</code>，关闭开关即可。你也可以点击地址栏左侧小锁，进入网站设置，从而针对特定站点屏蔽图片。在 Firefox 等浏览器中，也有类似设置。 <img src=\"https://cdn.sspai.com/2018/10/18/7027d9a1388889c2e9bd0f3abccc1056.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 当然，这种方式依然略显繁琐，因此，我更推荐通过扩展过滤图片。以少数派多次推荐的 <a href=\"https://sspai.com/search/article?q=%E7%AE%80%E6%82%A6\" title=\"简悦\">简悦</a> 为例，你可以在其 <a href=\"https://simpread.ksria.cn/plugins/details/0vnL8VbCgs\" title=\"插件中心\">插件中心</a> 下载安装「无图版」插件，从而在阅读模式中屏蔽图片，更加便捷。 <img src=\"https://cdn.sspai.com/2018/10/18/b33b8bf4f3f73fa8ba11ef8205652333.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"命令行也可以看新闻\"><a href=\"#命令行也可以看新闻\" class=\"headerlink\" title=\"命令行也可以看新闻\"></a>命令行也可以看新闻</h3><p>如果你是一位苦逼程序员，上班时间开着浏览器可就不那么自然了。好在已有无数先辈们意识到了这个问题，并在敲键盘之余造出了各种轮子。举例来说，<a href=\"https://github.com/donnemartin/haxor-news\" title=\"haxor-news\">haxor-news</a> 将 <a href=\"https://news.ycombinator.com/\" title=\"Hacker News\">Hacker News</a> 搬到了命令行；而 <a href=\"https://github.com/billcccheng/instagram-terminal-news-feed\" title=\"Instagram Terminal Feed\">Instagram Terminal Feed</a> 则允许你在命令行浏览 Instagram 信息流，甚至包含了字符串拼就的图片预览，着实令人钦佩。 <img src=\"https://cdn.sspai.com/2018/10/18/10d2fbf4df4c96587f62150304f236e2.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 如果你对以上两个网站不感兴趣，不妨试试 <a href=\"https://newsboat.org/\" title=\"Newsboat\">Newsboat</a>，它可以让你在终端阅读任意 RSS 订阅内容，称得上是海纳百川了。 <img src=\"https://cdn.sspai.com/2018/10/18/a627da3c969dbd5b2c7ed3ed3078ed8e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 若你还是欲求不满，可以利用上班时间给自己写一个命令行划水小程序，既可以缓解工作疲劳，又可以收获众人 Star，为日后跳槽加分。</p>\n<h3 id=\"沙雕网友，在线吹水\"><a href=\"#沙雕网友，在线吹水\" class=\"headerlink\" title=\"沙雕网友，在线吹水\"></a>沙雕网友，在线吹水</h3><p>好不容易交上设计稿，甲方却说要全部推倒重来——如此不平之事，不在群里吐槽几句怎么能忍。然而，许多公司早已屏蔽了 QQ、微信等常用社交网站域名，偷偷掏出手机又风险过大。幸好，我们还能找到一些开箱即用的在线聊天网站，例如 <a href=\"https://web.telegram.org/\" title=\"Telegram Web\">Telegram Web</a>、<a href=\"https://www.v2ex.com/\" title=\"V2EX\">V2EX</a>、<a href=\"https://bbs.nga.cn/\" title=\"NGA\">NGA</a>、<a href=\"https://bbs.saraba1st.com/2b/forum.php\" title=\"Stage1st\">Stage1st</a> 和 <a href=\"http://adnmb1.com/Forum\" title=\"A岛匿名版\">A岛匿名版</a> 等。与人斗智，其乐无穷。 <img src=\"https://cdn.sspai.com/2018/10/18/e2e42b2c0b43f9782c1f147ef5584373.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h2 id=\"划水也要充实自己\"><a href=\"#划水也要充实自己\" class=\"headerlink\" title=\"划水也要充实自己\"></a>划水也要充实自己</h2><h3 id=\"老板你看我在码字\"><a href=\"#老板你看我在码字\" class=\"headerlink\" title=\"老板你看我在码字\"></a>老板你看我在码字</h3><p>如果你是一名文字工作者，电脑上开着几个 Word 窗口再正常不过了，而这，也成为了我们摸鱼时的突破点。只需要下载好想读的小说，用 Word 或其它文本编辑器打开，就可以名正言顺地提高姿势水平了。 <img src=\"https://cdn.sspai.com/2019/03/06/05abb4d1c61d403331f462e3a4cdb4f2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 什么，你嫌找离线资源太麻烦？不用担心，<a href=\"https://yuedu.163.com/\" title=\"网易云阅读\">网易云阅读</a> 贴心地为你准备了 Word 主题模式，只需轻点上方按钮，就能一键切换。当然，这种方式的局限性也显而易见，那就是只能模拟 Windows 7 和 Office 2010 界面，非常容易露馅。 <img src=\"https://cdn.sspai.com/2018/10/18/b82a2332bd62cf50d97d6c6e32ee1936.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"代码与书籍齐飞\"><a href=\"#代码与书籍齐飞\" class=\"headerlink\" title=\"代码与书籍齐飞\"></a>代码与书籍齐飞</h3><p>作为一名程序员，整天对着 Word 显然容易引火烧身。不过，我们可以换种思路，利用大多数代码编辑器自带的左右分栏功能，在敲代码的同时瞄几眼小说，锻炼多线程思维能力，保佑编译一次通过。如果你更硬核一点，还可以试试在日志里看小说等奇巧淫技，充分发挥主观能动性。 <img src=\"https://cdn.sspai.com/2019/03/06/e378bb66983ac55e4f03685e5d48e14a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"身在工位，耳听八方\"><a href=\"#身在工位，耳听八方\" class=\"headerlink\" title=\"身在工位，耳听八方\"></a>身在工位，耳听八方</h3><p>尽管严格限制了种种摸鱼行为，但不少公司都允许你在上班时间听音乐，以舒缓身心，提高工作效率。除了轻音乐之外，其实，你还可以将播客、有声小说等内容下载至手机，汲取本职工作以外的精神食粮。 <img src=\"https://cdn.sspai.com/2019/03/06/6b44452dca256205b7f23e7a34409756.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h2 id=\"加班当然玩游戏\"><a href=\"#加班当然玩游戏\" class=\"headerlink\" title=\"加班当然玩游戏\"></a>加班当然玩游戏</h2><h3 id=\"控制台也能玩出花\"><a href=\"#控制台也能玩出花\" class=\"headerlink\" title=\"控制台也能玩出花\"></a>控制台也能玩出花</h3><p>如果你不幸国庆也要加班，心中难免愤懑不堪，亲切问候领导亲属。这时，不妨吸几口「电子海洛因」，排忧解难。当然，一般的电子游戏都过于明目张胆，但还有一批自 DOS 时代潜伏至今的「控制台游戏」，虽然画面简陋，但胜在隐蔽性强。如魔塔、俄罗斯方块、贪吃蛇、2048 等著名游戏都有相应版本实现，直接搜索就能找到。 <img src=\"https://cdn.sspai.com/2018/10/18/ec0b8d83c862f94a5c8d47b21b6e1121.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 此外，还有玩家收集整理了 1800 余款精品 DOS 游戏，囊括了《仙剑奇侠传》、《模拟城市》、《主题医院》、《三国志》和《大航海时代》等陪伴了一代人的经典，你可以直接通过浏览器访问 <a href=\"https://dos.zczc.cz/\" title=\"该网页\">该网页</a> 回味。 <img src=\"https://cdn.sspai.com/2018/10/18/ba33a1ce4d3ef883d570ec2abf402722.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"大灾变：劫后余生\"><a href=\"#大灾变：劫后余生\" class=\"headerlink\" title=\"大灾变：劫后余生\"></a>大灾变：劫后余生</h3><p>如果你是真正的硬核玩家，不妨试试<a href=\"http://cn.cataclysmdda.com/pages/13/display\" title=\"《大灾变：劫后余生》\">《大灾变：劫后余生》</a>这款开放世界 Roguelike 游戏，在末日后的世界克服重重险阻，努力活下去。 尽管《大灾变：劫后余生》的全部画面均由字符串拼就、没有背景音乐，游戏的键位也反人类地类似 vim，整体像是从上世纪 70 年代穿越而来。但凭借出彩的剧情、丰富的机制和极强的代入感，这款游戏仍吸引了一大批忠实拥趸，希望你也喜欢。 <img src=\"https://cdn.sspai.com/2018/10/18/9e8b97a63a56b17601fcbb1a8cdc46a4.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"YORG-io\"><a href=\"#YORG-io\" class=\"headerlink\" title=\"YORG.io\"></a>YORG.io</h3><p>YORG.io 是另一款有趣的网页游戏，它融合了 CLG、塔防、生存、僵尸等多种要素。你需要利用白天时间开采资源，并在夜间使用防御塔保护你的建筑。你可以改变游戏中的时间流速，并在白天暂停游戏。期间，你可以建造、卖出和升级建筑，但不会有任何资源收入。 <img src=\"https://cdn.sspai.com/2019/03/06/e39aedae7217108caacb6f5276435594.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"用好-Touch-Bar\"><a href=\"#用好-Touch-Bar\" class=\"headerlink\" title=\"用好 Touch Bar\"></a>用好 Touch Bar</h3><p>在 2016 款及其后的 MacBook Pro 中，苹果使用触控栏（即 Multi-Touch Bar）取代了键盘上方的 Fn 功能区。如果你正在使用该系列机型办公，便已经拥有了一块得天独厚的娱乐宝地。 举例来说，<a href=\"https://github.com/yuhuili/TouchBarDino\" title=\"TouchBarDino\">TouchBarDino</a> 将 Chrome 断网时的小恐龙游戏搬到触控栏上，<a href=\"https://github.com/henryefranks/pac-bar\" title=\"Pac-Bar\">Pac-Bar</a> 让你在上面玩吃豆人，你也可以选择借助 <a href=\"https://github.com/insidegui/TouchBarSpaceFight\" title=\"Touch Bar Space Fight\">Touch Bar Space Fight</a> 打一场太空战争。当然，不要让上司发现你始终低着头哦。 <img src=\"https://cdn.sspai.com/2018/10/18/9755868e8799222a67d6b7b112d43e81.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 如果你想了解更多触控栏的有趣用法，可以阅读少数派之前的 <a href=\"https://sspai.com/post/44435\" title=\"这篇文章\">这篇文章</a>。</p>\n<h2 id=\"科学破解领导突袭\"><a href=\"#科学破解领导突袭\" class=\"headerlink\" title=\"科学破解领导突袭\"></a>科学破解领导突袭</h2><h3 id=\"一键切换标签页\"><a href=\"#一键切换标签页\" class=\"headerlink\" title=\"一键切换标签页\"></a>一键切换标签页</h3><p>上司已经逼近，浏览器却开着七八个摸鱼网页，值此危急存亡之际，偏偏又点不中标签上的小叉号……为了避免这一风险，我们需要想办法快速关闭当前标签页组，同时打开预设的工作网页。 在这里，我要推荐的是 Chrome 扩展 <a href=\"https://chrome.google.com/webstore/detail/toby-for-chrome/hddnkoipeenegfoeaoibdmnaalmgkpip\" title=\"Toby\">Toby</a>，只需要点击图标，选择「Save Session」，就可以快速关闭并保存当前窗口内所有标签页，不留一丝痕迹。 <img src=\"https://cdn.sspai.com/2019/03/06/22e7ab1d0d89884bab609ad7394b1f99.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 随后，你可以在 Toby 的扩展页面浏览刚才关闭的标签页组，并一键打开。你也可以利用这一技巧提前设置几组工作窗口，实现快速切换的目的。 关联阅读：<a href=\"https://sspai.com/post/44105\" title=\"如何更好地管理「标签页」，我选择 Toby\">如何更好地管理「标签页」，我选择 Toby</a> <img src=\"https://cdn.sspai.com/2019/03/06/a4d591aedc59a04f2567019e4f05c485.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"虚拟桌面保平安\"><a href=\"#虚拟桌面保平安\" class=\"headerlink\" title=\"虚拟桌面保平安\"></a>虚拟桌面保平安</h3><p>纵使远离了标签页困境，一直开着浏览器也不怎么像样。好在 Windows 10 和 macOS 均原生支持虚拟桌面，你可以将当前运行程序拆为工作和娱乐两块，并通过快捷键、鼠标或触控板手势等切换桌面，隐蔽性 Max。 在 Windows 10 中，你可以通过按下 <code>Ctrl-Win-D</code> 创建一个新的虚拟桌面；使用 <code>Ctrl-Win-←/→</code>切换至前一个或后一个虚拟桌面；或使用 <code>Ctrl-Win-F4</code> 关闭当前虚拟桌面。当然，你也可以直接按下任务栏上的「任务视图」按钮，用更直观的方式管理虚拟桌面。 <img src=\"https://cdn.sspai.com/2019/03/06/fa4d79e919f7b4886b3919e750340d2a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 虚拟桌面特性很早以前就来到了 macOS，你也可以使用 <code>⌃Control-←/→</code> 在多个桌面间切换。不过，我想长期使用 MacBook 的诸位更习惯的方式，是在触控板上四指左右轻扫切换，更加自然流畅。这同样是微软官方推荐手势，但由于 Windows 阵营过于繁杂，我不保证适用于所有笔记本。 <img src=\"https://cdn.sspai.com/2019/03/06/eb7629c7a91a68f3a4e7b04b67292d1e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 在少数派的 <a href=\"https://sspai.com/post/45594\" title=\"这篇文章\">这篇文章</a> 中，还介绍了如何通过鼠标宏等方式切换 Windows 虚拟桌面，欢迎继续阅读。</p>\n<h3 id=\"TACTICAL-BOSS-INCOMING\"><a href=\"#TACTICAL-BOSS-INCOMING\" class=\"headerlink\" title=\"TACTICAL BOSS INCOMING\"></a>TACTICAL BOSS INCOMING</h3><p>与其临阵磨枪，不如时刻备战。这一真理也被程序员们熟稔，并研发了 <a href=\"https://github.com/Hironsan/BossSensor\" title=\"BossSensor\">BossSensor</a> 这款神器。只需将若干领导照片放置在工作目录，通过机器学习训练识别模型，就能在摄像头捕捉目标后一键切换至预设的工作环境，用科技让生活更美好。 <img src=\"https://cdn.sspai.com/2018/10/18/d6e24e143daf6151ee78e4c347744e9d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 当然，以上技巧仅供娱乐，还请大家好好学习，堇业上工，莫要因小失大。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>古语云：授人以鱼，不如授人以渔。又有言曰，凡有劳者，必好摸焉。今天是愚人节，相信你一定也在无聊地刷着网上的各种有趣的假新闻无心工作。针对被 996 和被无休止加班折磨的你，我又特地整理了这份上班摸鱼指南，收录各种「带薪休假」技巧，请各位领导看到本文自觉关闭页面。</p>\n<h2 id=\"上网的正确姿势\"><a href=\"#上网的正确姿势\" class=\"headerlink\" title=\"上网的正确姿势\"></a>上网的正确姿势</h2><h3 id=\"无图才有真相\"><a href=\"#无图才有真相\" class=\"headerlink\" title=\"无图才有真相\"></a>无图才有真相</h3><p>整日面对枯燥的报表，难免会产生倦怠情绪。心理专家建议，此时，应该打开几个常去的网站，休憩身心，方能提高工作效率。如果你担心太明目张胆，不妨以无图模式浏览网页，增大可视面积的同时预防 <a href=\"https://baike.baidu.com/item/NSFW/5576169?fr=aladdin\" title=\"NSFW\">NSFW</a> 内容出现。 <img src=\"https://cdn.sspai.com/2019/03/06/b91dd3c0c5dfeba521c93829359cc8bb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 若要开启 Chrome 的无图模式，只需访问 <code>chrome://settings/content/images</code>，关闭开关即可。你也可以点击地址栏左侧小锁，进入网站设置，从而针对特定站点屏蔽图片。在 Firefox 等浏览器中，也有类似设置。 <img src=\"https://cdn.sspai.com/2018/10/18/7027d9a1388889c2e9bd0f3abccc1056.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 当然，这种方式依然略显繁琐，因此，我更推荐通过扩展过滤图片。以少数派多次推荐的 <a href=\"https://sspai.com/search/article?q=%E7%AE%80%E6%82%A6\" title=\"简悦\">简悦</a> 为例，你可以在其 <a href=\"https://simpread.ksria.cn/plugins/details/0vnL8VbCgs\" title=\"插件中心\">插件中心</a> 下载安装「无图版」插件，从而在阅读模式中屏蔽图片，更加便捷。 <img src=\"https://cdn.sspai.com/2018/10/18/b33b8bf4f3f73fa8ba11ef8205652333.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"命令行也可以看新闻\"><a href=\"#命令行也可以看新闻\" class=\"headerlink\" title=\"命令行也可以看新闻\"></a>命令行也可以看新闻</h3><p>如果你是一位苦逼程序员，上班时间开着浏览器可就不那么自然了。好在已有无数先辈们意识到了这个问题，并在敲键盘之余造出了各种轮子。举例来说，<a href=\"https://github.com/donnemartin/haxor-news\" title=\"haxor-news\">haxor-news</a> 将 <a href=\"https://news.ycombinator.com/\" title=\"Hacker News\">Hacker News</a> 搬到了命令行；而 <a href=\"https://github.com/billcccheng/instagram-terminal-news-feed\" title=\"Instagram Terminal Feed\">Instagram Terminal Feed</a> 则允许你在命令行浏览 Instagram 信息流，甚至包含了字符串拼就的图片预览，着实令人钦佩。 <img src=\"https://cdn.sspai.com/2018/10/18/10d2fbf4df4c96587f62150304f236e2.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 如果你对以上两个网站不感兴趣，不妨试试 <a href=\"https://newsboat.org/\" title=\"Newsboat\">Newsboat</a>，它可以让你在终端阅读任意 RSS 订阅内容，称得上是海纳百川了。 <img src=\"https://cdn.sspai.com/2018/10/18/a627da3c969dbd5b2c7ed3ed3078ed8e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 若你还是欲求不满，可以利用上班时间给自己写一个命令行划水小程序，既可以缓解工作疲劳，又可以收获众人 Star，为日后跳槽加分。</p>\n<h3 id=\"沙雕网友，在线吹水\"><a href=\"#沙雕网友，在线吹水\" class=\"headerlink\" title=\"沙雕网友，在线吹水\"></a>沙雕网友，在线吹水</h3><p>好不容易交上设计稿，甲方却说要全部推倒重来——如此不平之事，不在群里吐槽几句怎么能忍。然而，许多公司早已屏蔽了 QQ、微信等常用社交网站域名，偷偷掏出手机又风险过大。幸好，我们还能找到一些开箱即用的在线聊天网站，例如 <a href=\"https://web.telegram.org/\" title=\"Telegram Web\">Telegram Web</a>、<a href=\"https://www.v2ex.com/\" title=\"V2EX\">V2EX</a>、<a href=\"https://bbs.nga.cn/\" title=\"NGA\">NGA</a>、<a href=\"https://bbs.saraba1st.com/2b/forum.php\" title=\"Stage1st\">Stage1st</a> 和 <a href=\"http://adnmb1.com/Forum\" title=\"A岛匿名版\">A岛匿名版</a> 等。与人斗智，其乐无穷。 <img src=\"https://cdn.sspai.com/2018/10/18/e2e42b2c0b43f9782c1f147ef5584373.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h2 id=\"划水也要充实自己\"><a href=\"#划水也要充实自己\" class=\"headerlink\" title=\"划水也要充实自己\"></a>划水也要充实自己</h2><h3 id=\"老板你看我在码字\"><a href=\"#老板你看我在码字\" class=\"headerlink\" title=\"老板你看我在码字\"></a>老板你看我在码字</h3><p>如果你是一名文字工作者，电脑上开着几个 Word 窗口再正常不过了，而这，也成为了我们摸鱼时的突破点。只需要下载好想读的小说，用 Word 或其它文本编辑器打开，就可以名正言顺地提高姿势水平了。 <img src=\"https://cdn.sspai.com/2019/03/06/05abb4d1c61d403331f462e3a4cdb4f2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 什么，你嫌找离线资源太麻烦？不用担心，<a href=\"https://yuedu.163.com/\" title=\"网易云阅读\">网易云阅读</a> 贴心地为你准备了 Word 主题模式，只需轻点上方按钮，就能一键切换。当然，这种方式的局限性也显而易见，那就是只能模拟 Windows 7 和 Office 2010 界面，非常容易露馅。 <img src=\"https://cdn.sspai.com/2018/10/18/b82a2332bd62cf50d97d6c6e32ee1936.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"代码与书籍齐飞\"><a href=\"#代码与书籍齐飞\" class=\"headerlink\" title=\"代码与书籍齐飞\"></a>代码与书籍齐飞</h3><p>作为一名程序员，整天对着 Word 显然容易引火烧身。不过，我们可以换种思路，利用大多数代码编辑器自带的左右分栏功能，在敲代码的同时瞄几眼小说，锻炼多线程思维能力，保佑编译一次通过。如果你更硬核一点，还可以试试在日志里看小说等奇巧淫技，充分发挥主观能动性。 <img src=\"https://cdn.sspai.com/2019/03/06/e378bb66983ac55e4f03685e5d48e14a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"身在工位，耳听八方\"><a href=\"#身在工位，耳听八方\" class=\"headerlink\" title=\"身在工位，耳听八方\"></a>身在工位，耳听八方</h3><p>尽管严格限制了种种摸鱼行为，但不少公司都允许你在上班时间听音乐，以舒缓身心，提高工作效率。除了轻音乐之外，其实，你还可以将播客、有声小说等内容下载至手机，汲取本职工作以外的精神食粮。 <img src=\"https://cdn.sspai.com/2019/03/06/6b44452dca256205b7f23e7a34409756.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h2 id=\"加班当然玩游戏\"><a href=\"#加班当然玩游戏\" class=\"headerlink\" title=\"加班当然玩游戏\"></a>加班当然玩游戏</h2><h3 id=\"控制台也能玩出花\"><a href=\"#控制台也能玩出花\" class=\"headerlink\" title=\"控制台也能玩出花\"></a>控制台也能玩出花</h3><p>如果你不幸国庆也要加班，心中难免愤懑不堪，亲切问候领导亲属。这时，不妨吸几口「电子海洛因」，排忧解难。当然，一般的电子游戏都过于明目张胆，但还有一批自 DOS 时代潜伏至今的「控制台游戏」，虽然画面简陋，但胜在隐蔽性强。如魔塔、俄罗斯方块、贪吃蛇、2048 等著名游戏都有相应版本实现，直接搜索就能找到。 <img src=\"https://cdn.sspai.com/2018/10/18/ec0b8d83c862f94a5c8d47b21b6e1121.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 此外，还有玩家收集整理了 1800 余款精品 DOS 游戏，囊括了《仙剑奇侠传》、《模拟城市》、《主题医院》、《三国志》和《大航海时代》等陪伴了一代人的经典，你可以直接通过浏览器访问 <a href=\"https://dos.zczc.cz/\" title=\"该网页\">该网页</a> 回味。 <img src=\"https://cdn.sspai.com/2018/10/18/ba33a1ce4d3ef883d570ec2abf402722.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"大灾变：劫后余生\"><a href=\"#大灾变：劫后余生\" class=\"headerlink\" title=\"大灾变：劫后余生\"></a>大灾变：劫后余生</h3><p>如果你是真正的硬核玩家，不妨试试<a href=\"http://cn.cataclysmdda.com/pages/13/display\" title=\"《大灾变：劫后余生》\">《大灾变：劫后余生》</a>这款开放世界 Roguelike 游戏，在末日后的世界克服重重险阻，努力活下去。 尽管《大灾变：劫后余生》的全部画面均由字符串拼就、没有背景音乐，游戏的键位也反人类地类似 vim，整体像是从上世纪 70 年代穿越而来。但凭借出彩的剧情、丰富的机制和极强的代入感，这款游戏仍吸引了一大批忠实拥趸，希望你也喜欢。 <img src=\"https://cdn.sspai.com/2018/10/18/9e8b97a63a56b17601fcbb1a8cdc46a4.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"YORG-io\"><a href=\"#YORG-io\" class=\"headerlink\" title=\"YORG.io\"></a>YORG.io</h3><p>YORG.io 是另一款有趣的网页游戏，它融合了 CLG、塔防、生存、僵尸等多种要素。你需要利用白天时间开采资源，并在夜间使用防御塔保护你的建筑。你可以改变游戏中的时间流速，并在白天暂停游戏。期间，你可以建造、卖出和升级建筑，但不会有任何资源收入。 <img src=\"https://cdn.sspai.com/2019/03/06/e39aedae7217108caacb6f5276435594.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"用好-Touch-Bar\"><a href=\"#用好-Touch-Bar\" class=\"headerlink\" title=\"用好 Touch Bar\"></a>用好 Touch Bar</h3><p>在 2016 款及其后的 MacBook Pro 中，苹果使用触控栏（即 Multi-Touch Bar）取代了键盘上方的 Fn 功能区。如果你正在使用该系列机型办公，便已经拥有了一块得天独厚的娱乐宝地。 举例来说，<a href=\"https://github.com/yuhuili/TouchBarDino\" title=\"TouchBarDino\">TouchBarDino</a> 将 Chrome 断网时的小恐龙游戏搬到触控栏上，<a href=\"https://github.com/henryefranks/pac-bar\" title=\"Pac-Bar\">Pac-Bar</a> 让你在上面玩吃豆人，你也可以选择借助 <a href=\"https://github.com/insidegui/TouchBarSpaceFight\" title=\"Touch Bar Space Fight\">Touch Bar Space Fight</a> 打一场太空战争。当然，不要让上司发现你始终低着头哦。 <img src=\"https://cdn.sspai.com/2018/10/18/9755868e8799222a67d6b7b112d43e81.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 如果你想了解更多触控栏的有趣用法，可以阅读少数派之前的 <a href=\"https://sspai.com/post/44435\" title=\"这篇文章\">这篇文章</a>。</p>\n<h2 id=\"科学破解领导突袭\"><a href=\"#科学破解领导突袭\" class=\"headerlink\" title=\"科学破解领导突袭\"></a>科学破解领导突袭</h2><h3 id=\"一键切换标签页\"><a href=\"#一键切换标签页\" class=\"headerlink\" title=\"一键切换标签页\"></a>一键切换标签页</h3><p>上司已经逼近，浏览器却开着七八个摸鱼网页，值此危急存亡之际，偏偏又点不中标签上的小叉号……为了避免这一风险，我们需要想办法快速关闭当前标签页组，同时打开预设的工作网页。 在这里，我要推荐的是 Chrome 扩展 <a href=\"https://chrome.google.com/webstore/detail/toby-for-chrome/hddnkoipeenegfoeaoibdmnaalmgkpip\" title=\"Toby\">Toby</a>，只需要点击图标，选择「Save Session」，就可以快速关闭并保存当前窗口内所有标签页，不留一丝痕迹。 <img src=\"https://cdn.sspai.com/2019/03/06/22e7ab1d0d89884bab609ad7394b1f99.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 随后，你可以在 Toby 的扩展页面浏览刚才关闭的标签页组，并一键打开。你也可以利用这一技巧提前设置几组工作窗口，实现快速切换的目的。 关联阅读：<a href=\"https://sspai.com/post/44105\" title=\"如何更好地管理「标签页」，我选择 Toby\">如何更好地管理「标签页」，我选择 Toby</a> <img src=\"https://cdn.sspai.com/2019/03/06/a4d591aedc59a04f2567019e4f05c485.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"></p>\n<h3 id=\"虚拟桌面保平安\"><a href=\"#虚拟桌面保平安\" class=\"headerlink\" title=\"虚拟桌面保平安\"></a>虚拟桌面保平安</h3><p>纵使远离了标签页困境，一直开着浏览器也不怎么像样。好在 Windows 10 和 macOS 均原生支持虚拟桌面，你可以将当前运行程序拆为工作和娱乐两块，并通过快捷键、鼠标或触控板手势等切换桌面，隐蔽性 Max。 在 Windows 10 中，你可以通过按下 <code>Ctrl-Win-D</code> 创建一个新的虚拟桌面；使用 <code>Ctrl-Win-←/→</code>切换至前一个或后一个虚拟桌面；或使用 <code>Ctrl-Win-F4</code> 关闭当前虚拟桌面。当然，你也可以直接按下任务栏上的「任务视图」按钮，用更直观的方式管理虚拟桌面。 <img src=\"https://cdn.sspai.com/2019/03/06/fa4d79e919f7b4886b3919e750340d2a.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 虚拟桌面特性很早以前就来到了 macOS，你也可以使用 <code>⌃Control-←/→</code> 在多个桌面间切换。不过，我想长期使用 MacBook 的诸位更习惯的方式，是在触控板上四指左右轻扫切换，更加自然流畅。这同样是微软官方推荐手势，但由于 Windows 阵营过于繁杂，我不保证适用于所有笔记本。 <img src=\"https://cdn.sspai.com/2019/03/06/eb7629c7a91a68f3a4e7b04b67292d1e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 在少数派的 <a href=\"https://sspai.com/post/45594\" title=\"这篇文章\">这篇文章</a> 中，还介绍了如何通过鼠标宏等方式切换 Windows 虚拟桌面，欢迎继续阅读。</p>\n<h3 id=\"TACTICAL-BOSS-INCOMING\"><a href=\"#TACTICAL-BOSS-INCOMING\" class=\"headerlink\" title=\"TACTICAL BOSS INCOMING\"></a>TACTICAL BOSS INCOMING</h3><p>与其临阵磨枪，不如时刻备战。这一真理也被程序员们熟稔，并研发了 <a href=\"https://github.com/Hironsan/BossSensor\" title=\"BossSensor\">BossSensor</a> 这款神器。只需将若干领导照片放置在工作目录，通过机器学习训练识别模型，就能在摄像头捕捉目标后一键切换至预设的工作环境，用科技让生活更美好。 <img src=\"https://cdn.sspai.com/2018/10/18/d6e24e143daf6151ee78e4c347744e9d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\" alt=\"请输入图片标题\" title=\"请输入图片标题\"> 当然，以上技巧仅供娱乐，还请大家好好学习，堇业上工，莫要因小失大。</p>\n"},{"title":"极速版-谷歌访问助手v2.3.0破解版","url":"420.html","id":"420","date":"2019-09-06T10:03:47.000Z","thumbnail":"https://blog.zhangruipeng.me/hexo-theme-icarus/gallery/thumbnails/plant.jpg","toc":true,"_content":"\n# 谷歌访问助手 v2.3.0 破解版\n\n> 谷歌访问助手是一款专门为谷歌浏览器制作的浏览器插件，现在越来越多的朋友都在使用谷歌浏览器，但是要是让小白使用的话，进行搜索会提示无法访问，这是因为谷歌搜索在中国大陆被屏蔽了。\n\n<!-- more -->\n\n普通版本的插件，都是可以免费试用`12小时`，但是过了`12小时`之后就需要锁定主页，但是这款不需要。\n\n谷歌访问助手破解版，破除了`12小时`的限制，下载安装后，就可以直接访问，不需锁定任何主页。\n\n之前分享过关于此类型的工具，细心的朋友可以看到，关于这类工具我全部删除了。\n\n这个插件只能打开`谷歌搜索、谷歌商店，gmail邮箱`\n\n# 使用方法\n\n1、安装好谷歌浏览器，地址栏输入快捷方式：chrome://extensions，进入扩展程序界面；\n\n2、把下载的插件解压出来\n\n3、把右上角的开发者模式打开，点击左上角的加载已解压的程序，选择刚才解压出来的文件即可。\n","source":"_posts/e6-9e-81-e9-80-9f-e7-89-88-e8-b0-b7-e6-ad-8c-e8-ae-bf-e9-97-ae-e5-8a-a9-e6-89-8bv2-3-0-e7-a0-b4-e8-a7-a3-e7-89-88.md","raw":"---\ntitle: 极速版-谷歌访问助手v2.3.0破解版\ntags:\n  - Chrome\n  - 插件\n  - 破解\n  - 资源\nurl: 420.html\nid: 420\ncategories:\n  - 精选资源\ndate: 2019-09-06 18:03:47\nthumbnail: https://blog.zhangruipeng.me/hexo-theme-icarus/gallery/thumbnails/plant.jpg\ntoc: true\n---\n\n# 谷歌访问助手 v2.3.0 破解版\n\n> 谷歌访问助手是一款专门为谷歌浏览器制作的浏览器插件，现在越来越多的朋友都在使用谷歌浏览器，但是要是让小白使用的话，进行搜索会提示无法访问，这是因为谷歌搜索在中国大陆被屏蔽了。\n\n<!-- more -->\n\n普通版本的插件，都是可以免费试用`12小时`，但是过了`12小时`之后就需要锁定主页，但是这款不需要。\n\n谷歌访问助手破解版，破除了`12小时`的限制，下载安装后，就可以直接访问，不需锁定任何主页。\n\n之前分享过关于此类型的工具，细心的朋友可以看到，关于这类工具我全部删除了。\n\n这个插件只能打开`谷歌搜索、谷歌商店，gmail邮箱`\n\n# 使用方法\n\n1、安装好谷歌浏览器，地址栏输入快捷方式：chrome://extensions，进入扩展程序界面；\n\n2、把下载的插件解压出来\n\n3、把右上角的开发者模式打开，点击左上角的加载已解压的程序，选择刚才解压出来的文件即可。\n","slug":"e6-9e-81-e9-80-9f-e7-89-88-e8-b0-b7-e6-ad-8c-e8-ae-bf-e9-97-ae-e5-8a-a9-e6-89-8bv2-3-0-e7-a0-b4-e8-a7-a3-e7-89-88","published":1,"updated":"2019-09-11T08:30:30.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269c0002cc8gs6rrchqqg","content":"<h1 id=\"谷歌访问助手-v2-3-0-破解版\"><a href=\"#谷歌访问助手-v2-3-0-破解版\" class=\"headerlink\" title=\"谷歌访问助手 v2.3.0 破解版\"></a>谷歌访问助手 v2.3.0 破解版</h1><blockquote>\n<p>谷歌访问助手是一款专门为谷歌浏览器制作的浏览器插件，现在越来越多的朋友都在使用谷歌浏览器，但是要是让小白使用的话，进行搜索会提示无法访问，这是因为谷歌搜索在中国大陆被屏蔽了。</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<p>普通版本的插件，都是可以免费试用<code>12小时</code>，但是过了<code>12小时</code>之后就需要锁定主页，但是这款不需要。</p>\n<p>谷歌访问助手破解版，破除了<code>12小时</code>的限制，下载安装后，就可以直接访问，不需锁定任何主页。</p>\n<p>之前分享过关于此类型的工具，细心的朋友可以看到，关于这类工具我全部删除了。</p>\n<p>这个插件只能打开<code>谷歌搜索、谷歌商店，gmail邮箱</code></p>\n<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><p>1、安装好谷歌浏览器，地址栏输入快捷方式：chrome://extensions，进入扩展程序界面；</p>\n<p>2、把下载的插件解压出来</p>\n<p>3、把右上角的开发者模式打开，点击左上角的加载已解压的程序，选择刚才解压出来的文件即可。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<h1 id=\"谷歌访问助手-v2-3-0-破解版\"><a href=\"#谷歌访问助手-v2-3-0-破解版\" class=\"headerlink\" title=\"谷歌访问助手 v2.3.0 破解版\"></a>谷歌访问助手 v2.3.0 破解版</h1><blockquote>\n<p>谷歌访问助手是一款专门为谷歌浏览器制作的浏览器插件，现在越来越多的朋友都在使用谷歌浏览器，但是要是让小白使用的话，进行搜索会提示无法访问，这是因为谷歌搜索在中国大陆被屏蔽了。</p>\n</blockquote>","more":"<p>普通版本的插件，都是可以免费试用<code>12小时</code>，但是过了<code>12小时</code>之后就需要锁定主页，但是这款不需要。</p>\n<p>谷歌访问助手破解版，破除了<code>12小时</code>的限制，下载安装后，就可以直接访问，不需锁定任何主页。</p>\n<p>之前分享过关于此类型的工具，细心的朋友可以看到，关于这类工具我全部删除了。</p>\n<p>这个插件只能打开<code>谷歌搜索、谷歌商店，gmail邮箱</code></p>\n<h1 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h1><p>1、安装好谷歌浏览器，地址栏输入快捷方式：chrome://extensions，进入扩展程序界面；</p>\n<p>2、把下载的插件解压出来</p>\n<p>3、把右上角的开发者模式打开，点击左上角的加载已解压的程序，选择刚才解压出来的文件即可。</p>"},{"title":"标签页管理、隐私保护、划词搜索…… 这 10 款新扩展让你的 Chrome 焕然一新","url":"129.html","id":"129","date":"2019-06-22T08:39:33.000Z","_content":"\n本文我将介绍 10 款近期上架的 Chrome 新扩展，从标签页到网站内容抓取再到隐私保护，它们总有一款能满足你的口味。\n\n## Qlearly\n\nQlearly 是一款有些特殊的 Chrome 新标签页扩展，你可以用它一键保存当前打开的标签页，将自己的收藏夹、喜欢的网站、暂存备用的标签页等分组收纳，并在需要时快速开启。此外，你还可以与他人协作，并分享自己的标签页组，提高自己的工作效率。 ![](https://cdn.sspai.com/editor/u_713147/15574547247438.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Qlearly。\n\n## Spider\n\n工作中，你可能会有批量抓取网站内容的需求：淘宝上的商品介绍、网站上的新闻标题、表格中的行列数据……如果只是单纯的复制粘贴，之后还要费心整理，想要写个爬虫又考验编程水平。这时，不妨试试 Spider，它可以一键抓取网页上的结构化数据，并导出为 JSON 和 CSV 文件，轻松高效。 ![](https://cdn.sspai.com/editor/u_713147/15574547247456.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Spider。\n\n## Repl.it\n\nRepl.it  是一款允许你浏览器上编程的云端 IDE，支持编译并运行包括 C、Python、JavaScript、Ruby 等在内的超过 50 种语言，无需下载，即开即用。而其第三方 Chrome 扩展，则给任意网页中的代码片段增加了一键运行按钮，省去复制到本地编译的流程。 ![](https://cdn.sspai.com/editor/u_713147/15574547247473.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Repl.it。\n\n## Password Checkup\n\n不论你是自己发明了一套密码策略，还是用 1Password 等应用随机生成密码，都无法避免网站后台被拖库造成的安全隐患。为了最大限度地减少这一风险，Google 于近期推出了 Password Checkup 扩展，当检测到你正在使用的用户名和密码存在于 40 亿条泄露数据库内时，自动弹出提醒，保护个人隐私。 ![](https://cdn.sspai.com/editor/u_713147/15574547247491.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Password Checkup。\n\n## Web Activities\n\n时间线是 Windows 10 春季创意者更新带来的最重要变化之一，允许你在一处查看所有历史活动记录，如浏览器访问过的网页、使用过的文件等。而微软近期推出的 Web Activities 扩展将这一特性带到了 Chrome，并支持多设备同步浏览记录，体验近似原生。 ![](https://cdn.sspai.com/editor/u_713147/15574547247514.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Web Activities。\n\n## 划词小窗搜索\n\n划词翻译扩展我们见得多了，例如我此前推荐过的   沙拉查词   和   达达划词翻译   都可以在选中单词后通过悬浮小窗查询释义。而划词小窗搜索的泛用性更广一些，可以调用 Google、百度或 Bing 通过小窗搜索选中的文本，无需离开当前页面。 ![](https://cdn.sspai.com/editor/u_713147/15574547247530.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   和  GitHub  免费获取划词小窗搜索。\n\n## Simplify Gmail\n\n为了完成 KPI，Google 大刀部把广受欢迎的 Inbox 砍掉了，如果你曾是 Inbox 忠实用户，可能会对陈旧的 Gmail 界面感到不适应。为了拯救你的收件箱，前 Inbox 设计师 Michael Leggett 开发了 Simplify Gmail 扩展，重新设计了按钮和元素的摆放位置，隐藏了侧边栏，让界面更加清爽干净。 ![](https://cdn.sspai.com/editor/u_713147/15574547247547.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Simplify Gmail。\n\n## Google Results Previewer\n\n使用 Google 搜索时，你可能需要同时浏览对比多个结果。这时，按首页排序一路点下去就未免过于低效。而 Google Results Previewer 就可以在当前页面小窗加载鼠标悬停的链接，并支持进一步交互，提高信息检索效率。 ![](https://cdn.sspai.com/editor/u_713147/15574547247566.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 需要注意的是，由于 Google Results Previewer 无法运行 JavaScript，部分网站可能会出现加载异常或失败等情况，仍待改进。 你可以在  Chrome 网上应用店   免费获取 Google Results Previewer。\n\n## NoScript\n\nNoScript 是 Firefox 上知名的隐私保护扩展，近期移植到了 Chrome 上，作用是禁止加载 JavaScript、Flash、Silverlight 等可能收集你个人信息的脚本，让你的浏览更加安全。不过，由于 JavaScript 已然成为了网页标配，禁用后会导致大多数网站无法正常访问，需要一段时间的白名单调教后才能正常使用。 ![](https://cdn.sspai.com/editor/u_713147/15574547247585.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 NoScript。\n\n## 简易扩展\n\n简易扩展的名字相当实诚，但功能性却毫不逊色。它可以帮助你快速切换用户代理、管理多个 Cookies、监听网络请求、改写静态和动态网址等，可谓前端开发者必备。 ![](https://cdn.sspai.com/editor/u_713147/15574547247604.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取简易扩展。\n","source":"_posts/e6-a0-87-e7-ad-be-e9-a1-b5-e7-ae-a1-e7-90-86-e3-80-81-e9-9a-90-e7-a7-81-e4-bf-9d-e6-8a-a4-e3-80-81-e5-88-92-e8-af-8d-e6-90-9c-e7-b4-a2-e8-bf-99-10-e6-ac-be-e6-96-b0-e6-89-a9.md","raw":"---\ntitle: 标签页管理、隐私保护、划词搜索…… 这 10 款新扩展让你的 Chrome 焕然一新\nurl: 129.html\nid: 129\ncategories:\n  - 杂谈\ndate: 2019-06-22 16:39:33\ntags:\n---\n\n本文我将介绍 10 款近期上架的 Chrome 新扩展，从标签页到网站内容抓取再到隐私保护，它们总有一款能满足你的口味。\n\n## Qlearly\n\nQlearly 是一款有些特殊的 Chrome 新标签页扩展，你可以用它一键保存当前打开的标签页，将自己的收藏夹、喜欢的网站、暂存备用的标签页等分组收纳，并在需要时快速开启。此外，你还可以与他人协作，并分享自己的标签页组，提高自己的工作效率。 ![](https://cdn.sspai.com/editor/u_713147/15574547247438.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Qlearly。\n\n## Spider\n\n工作中，你可能会有批量抓取网站内容的需求：淘宝上的商品介绍、网站上的新闻标题、表格中的行列数据……如果只是单纯的复制粘贴，之后还要费心整理，想要写个爬虫又考验编程水平。这时，不妨试试 Spider，它可以一键抓取网页上的结构化数据，并导出为 JSON 和 CSV 文件，轻松高效。 ![](https://cdn.sspai.com/editor/u_713147/15574547247456.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Spider。\n\n## Repl.it\n\nRepl.it  是一款允许你浏览器上编程的云端 IDE，支持编译并运行包括 C、Python、JavaScript、Ruby 等在内的超过 50 种语言，无需下载，即开即用。而其第三方 Chrome 扩展，则给任意网页中的代码片段增加了一键运行按钮，省去复制到本地编译的流程。 ![](https://cdn.sspai.com/editor/u_713147/15574547247473.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Repl.it。\n\n## Password Checkup\n\n不论你是自己发明了一套密码策略，还是用 1Password 等应用随机生成密码，都无法避免网站后台被拖库造成的安全隐患。为了最大限度地减少这一风险，Google 于近期推出了 Password Checkup 扩展，当检测到你正在使用的用户名和密码存在于 40 亿条泄露数据库内时，自动弹出提醒，保护个人隐私。 ![](https://cdn.sspai.com/editor/u_713147/15574547247491.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Password Checkup。\n\n## Web Activities\n\n时间线是 Windows 10 春季创意者更新带来的最重要变化之一，允许你在一处查看所有历史活动记录，如浏览器访问过的网页、使用过的文件等。而微软近期推出的 Web Activities 扩展将这一特性带到了 Chrome，并支持多设备同步浏览记录，体验近似原生。 ![](https://cdn.sspai.com/editor/u_713147/15574547247514.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Web Activities。\n\n## 划词小窗搜索\n\n划词翻译扩展我们见得多了，例如我此前推荐过的   沙拉查词   和   达达划词翻译   都可以在选中单词后通过悬浮小窗查询释义。而划词小窗搜索的泛用性更广一些，可以调用 Google、百度或 Bing 通过小窗搜索选中的文本，无需离开当前页面。 ![](https://cdn.sspai.com/editor/u_713147/15574547247530.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   和  GitHub  免费获取划词小窗搜索。\n\n## Simplify Gmail\n\n为了完成 KPI，Google 大刀部把广受欢迎的 Inbox 砍掉了，如果你曾是 Inbox 忠实用户，可能会对陈旧的 Gmail 界面感到不适应。为了拯救你的收件箱，前 Inbox 设计师 Michael Leggett 开发了 Simplify Gmail 扩展，重新设计了按钮和元素的摆放位置，隐藏了侧边栏，让界面更加清爽干净。 ![](https://cdn.sspai.com/editor/u_713147/15574547247547.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 Simplify Gmail。\n\n## Google Results Previewer\n\n使用 Google 搜索时，你可能需要同时浏览对比多个结果。这时，按首页排序一路点下去就未免过于低效。而 Google Results Previewer 就可以在当前页面小窗加载鼠标悬停的链接，并支持进一步交互，提高信息检索效率。 ![](https://cdn.sspai.com/editor/u_713147/15574547247566.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 需要注意的是，由于 Google Results Previewer 无法运行 JavaScript，部分网站可能会出现加载异常或失败等情况，仍待改进。 你可以在  Chrome 网上应用店   免费获取 Google Results Previewer。\n\n## NoScript\n\nNoScript 是 Firefox 上知名的隐私保护扩展，近期移植到了 Chrome 上，作用是禁止加载 JavaScript、Flash、Silverlight 等可能收集你个人信息的脚本，让你的浏览更加安全。不过，由于 JavaScript 已然成为了网页标配，禁用后会导致大多数网站无法正常访问，需要一段时间的白名单调教后才能正常使用。 ![](https://cdn.sspai.com/editor/u_713147/15574547247585.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取 NoScript。\n\n## 简易扩展\n\n简易扩展的名字相当实诚，但功能性却毫不逊色。它可以帮助你快速切换用户代理、管理多个 Cookies、监听网络请求、改写静态和动态网址等，可谓前端开发者必备。 ![](https://cdn.sspai.com/editor/u_713147/15574547247604.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在  Chrome 网上应用店   免费获取简易扩展。\n","slug":"e6-a0-87-e7-ad-be-e9-a1-b5-e7-ae-a1-e7-90-86-e3-80-81-e9-9a-90-e7-a7-81-e4-bf-9d-e6-8a-a4-e3-80-81-e5-88-92-e8-af-8d-e6-90-9c-e7-b4-a2-e8-bf-99-10-e6-ac-be-e6-96-b0-e6-89-a9","published":1,"updated":"2019-09-11T03:07:50.066Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269cb002fc8gs43th8y6h","content":"<p>本文我将介绍 10 款近期上架的 Chrome 新扩展，从标签页到网站内容抓取再到隐私保护，它们总有一款能满足你的口味。</p>\n<h2 id=\"Qlearly\"><a href=\"#Qlearly\" class=\"headerlink\" title=\"Qlearly\"></a>Qlearly</h2><p>Qlearly 是一款有些特殊的 Chrome 新标签页扩展，你可以用它一键保存当前打开的标签页，将自己的收藏夹、喜欢的网站、暂存备用的标签页等分组收纳，并在需要时快速开启。此外，你还可以与他人协作，并分享自己的标签页组，提高自己的工作效率。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247438.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Qlearly。</p>\n<h2 id=\"Spider\"><a href=\"#Spider\" class=\"headerlink\" title=\"Spider\"></a>Spider</h2><p>工作中，你可能会有批量抓取网站内容的需求：淘宝上的商品介绍、网站上的新闻标题、表格中的行列数据……如果只是单纯的复制粘贴，之后还要费心整理，想要写个爬虫又考验编程水平。这时，不妨试试 Spider，它可以一键抓取网页上的结构化数据，并导出为 JSON 和 CSV 文件，轻松高效。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247456.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Spider。</p>\n<h2 id=\"Repl-it\"><a href=\"#Repl-it\" class=\"headerlink\" title=\"Repl.it\"></a>Repl.it</h2><p>Repl.it  是一款允许你浏览器上编程的云端 IDE，支持编译并运行包括 C、Python、JavaScript、Ruby 等在内的超过 50 种语言，无需下载，即开即用。而其第三方 Chrome 扩展，则给任意网页中的代码片段增加了一键运行按钮，省去复制到本地编译的流程。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247473.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Repl.it。</p>\n<h2 id=\"Password-Checkup\"><a href=\"#Password-Checkup\" class=\"headerlink\" title=\"Password Checkup\"></a>Password Checkup</h2><p>不论你是自己发明了一套密码策略，还是用 1Password 等应用随机生成密码，都无法避免网站后台被拖库造成的安全隐患。为了最大限度地减少这一风险，Google 于近期推出了 Password Checkup 扩展，当检测到你正在使用的用户名和密码存在于 40 亿条泄露数据库内时，自动弹出提醒，保护个人隐私。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247491.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Password Checkup。</p>\n<h2 id=\"Web-Activities\"><a href=\"#Web-Activities\" class=\"headerlink\" title=\"Web Activities\"></a>Web Activities</h2><p>时间线是 Windows 10 春季创意者更新带来的最重要变化之一，允许你在一处查看所有历史活动记录，如浏览器访问过的网页、使用过的文件等。而微软近期推出的 Web Activities 扩展将这一特性带到了 Chrome，并支持多设备同步浏览记录，体验近似原生。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247514.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Web Activities。</p>\n<h2 id=\"划词小窗搜索\"><a href=\"#划词小窗搜索\" class=\"headerlink\" title=\"划词小窗搜索\"></a>划词小窗搜索</h2><p>划词翻译扩展我们见得多了，例如我此前推荐过的   沙拉查词   和   达达划词翻译   都可以在选中单词后通过悬浮小窗查询释义。而划词小窗搜索的泛用性更广一些，可以调用 Google、百度或 Bing 通过小窗搜索选中的文本，无需离开当前页面。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247530.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   和  GitHub  免费获取划词小窗搜索。</p>\n<h2 id=\"Simplify-Gmail\"><a href=\"#Simplify-Gmail\" class=\"headerlink\" title=\"Simplify Gmail\"></a>Simplify Gmail</h2><p>为了完成 KPI，Google 大刀部把广受欢迎的 Inbox 砍掉了，如果你曾是 Inbox 忠实用户，可能会对陈旧的 Gmail 界面感到不适应。为了拯救你的收件箱，前 Inbox 设计师 Michael Leggett 开发了 Simplify Gmail 扩展，重新设计了按钮和元素的摆放位置，隐藏了侧边栏，让界面更加清爽干净。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247547.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Simplify Gmail。</p>\n<h2 id=\"Google-Results-Previewer\"><a href=\"#Google-Results-Previewer\" class=\"headerlink\" title=\"Google Results Previewer\"></a>Google Results Previewer</h2><p>使用 Google 搜索时，你可能需要同时浏览对比多个结果。这时，按首页排序一路点下去就未免过于低效。而 Google Results Previewer 就可以在当前页面小窗加载鼠标悬停的链接，并支持进一步交互，提高信息检索效率。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247566.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 需要注意的是，由于 Google Results Previewer 无法运行 JavaScript，部分网站可能会出现加载异常或失败等情况，仍待改进。 你可以在  Chrome 网上应用店   免费获取 Google Results Previewer。</p>\n<h2 id=\"NoScript\"><a href=\"#NoScript\" class=\"headerlink\" title=\"NoScript\"></a>NoScript</h2><p>NoScript 是 Firefox 上知名的隐私保护扩展，近期移植到了 Chrome 上，作用是禁止加载 JavaScript、Flash、Silverlight 等可能收集你个人信息的脚本，让你的浏览更加安全。不过，由于 JavaScript 已然成为了网页标配，禁用后会导致大多数网站无法正常访问，需要一段时间的白名单调教后才能正常使用。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247585.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 NoScript。</p>\n<h2 id=\"简易扩展\"><a href=\"#简易扩展\" class=\"headerlink\" title=\"简易扩展\"></a>简易扩展</h2><p>简易扩展的名字相当实诚，但功能性却毫不逊色。它可以帮助你快速切换用户代理、管理多个 Cookies、监听网络请求、改写静态和动态网址等，可谓前端开发者必备。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247604.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取简易扩展。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>本文我将介绍 10 款近期上架的 Chrome 新扩展，从标签页到网站内容抓取再到隐私保护，它们总有一款能满足你的口味。</p>\n<h2 id=\"Qlearly\"><a href=\"#Qlearly\" class=\"headerlink\" title=\"Qlearly\"></a>Qlearly</h2><p>Qlearly 是一款有些特殊的 Chrome 新标签页扩展，你可以用它一键保存当前打开的标签页，将自己的收藏夹、喜欢的网站、暂存备用的标签页等分组收纳，并在需要时快速开启。此外，你还可以与他人协作，并分享自己的标签页组，提高自己的工作效率。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247438.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Qlearly。</p>\n<h2 id=\"Spider\"><a href=\"#Spider\" class=\"headerlink\" title=\"Spider\"></a>Spider</h2><p>工作中，你可能会有批量抓取网站内容的需求：淘宝上的商品介绍、网站上的新闻标题、表格中的行列数据……如果只是单纯的复制粘贴，之后还要费心整理，想要写个爬虫又考验编程水平。这时，不妨试试 Spider，它可以一键抓取网页上的结构化数据，并导出为 JSON 和 CSV 文件，轻松高效。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247456.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Spider。</p>\n<h2 id=\"Repl-it\"><a href=\"#Repl-it\" class=\"headerlink\" title=\"Repl.it\"></a>Repl.it</h2><p>Repl.it  是一款允许你浏览器上编程的云端 IDE，支持编译并运行包括 C、Python、JavaScript、Ruby 等在内的超过 50 种语言，无需下载，即开即用。而其第三方 Chrome 扩展，则给任意网页中的代码片段增加了一键运行按钮，省去复制到本地编译的流程。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247473.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Repl.it。</p>\n<h2 id=\"Password-Checkup\"><a href=\"#Password-Checkup\" class=\"headerlink\" title=\"Password Checkup\"></a>Password Checkup</h2><p>不论你是自己发明了一套密码策略，还是用 1Password 等应用随机生成密码，都无法避免网站后台被拖库造成的安全隐患。为了最大限度地减少这一风险，Google 于近期推出了 Password Checkup 扩展，当检测到你正在使用的用户名和密码存在于 40 亿条泄露数据库内时，自动弹出提醒，保护个人隐私。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247491.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Password Checkup。</p>\n<h2 id=\"Web-Activities\"><a href=\"#Web-Activities\" class=\"headerlink\" title=\"Web Activities\"></a>Web Activities</h2><p>时间线是 Windows 10 春季创意者更新带来的最重要变化之一，允许你在一处查看所有历史活动记录，如浏览器访问过的网页、使用过的文件等。而微软近期推出的 Web Activities 扩展将这一特性带到了 Chrome，并支持多设备同步浏览记录，体验近似原生。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247514.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Web Activities。</p>\n<h2 id=\"划词小窗搜索\"><a href=\"#划词小窗搜索\" class=\"headerlink\" title=\"划词小窗搜索\"></a>划词小窗搜索</h2><p>划词翻译扩展我们见得多了，例如我此前推荐过的   沙拉查词   和   达达划词翻译   都可以在选中单词后通过悬浮小窗查询释义。而划词小窗搜索的泛用性更广一些，可以调用 Google、百度或 Bing 通过小窗搜索选中的文本，无需离开当前页面。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247530.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   和  GitHub  免费获取划词小窗搜索。</p>\n<h2 id=\"Simplify-Gmail\"><a href=\"#Simplify-Gmail\" class=\"headerlink\" title=\"Simplify Gmail\"></a>Simplify Gmail</h2><p>为了完成 KPI，Google 大刀部把广受欢迎的 Inbox 砍掉了，如果你曾是 Inbox 忠实用户，可能会对陈旧的 Gmail 界面感到不适应。为了拯救你的收件箱，前 Inbox 设计师 Michael Leggett 开发了 Simplify Gmail 扩展，重新设计了按钮和元素的摆放位置，隐藏了侧边栏，让界面更加清爽干净。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247547.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 Simplify Gmail。</p>\n<h2 id=\"Google-Results-Previewer\"><a href=\"#Google-Results-Previewer\" class=\"headerlink\" title=\"Google Results Previewer\"></a>Google Results Previewer</h2><p>使用 Google 搜索时，你可能需要同时浏览对比多个结果。这时，按首页排序一路点下去就未免过于低效。而 Google Results Previewer 就可以在当前页面小窗加载鼠标悬停的链接，并支持进一步交互，提高信息检索效率。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247566.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 需要注意的是，由于 Google Results Previewer 无法运行 JavaScript，部分网站可能会出现加载异常或失败等情况，仍待改进。 你可以在  Chrome 网上应用店   免费获取 Google Results Previewer。</p>\n<h2 id=\"NoScript\"><a href=\"#NoScript\" class=\"headerlink\" title=\"NoScript\"></a>NoScript</h2><p>NoScript 是 Firefox 上知名的隐私保护扩展，近期移植到了 Chrome 上，作用是禁止加载 JavaScript、Flash、Silverlight 等可能收集你个人信息的脚本，让你的浏览更加安全。不过，由于 JavaScript 已然成为了网页标配，禁用后会导致大多数网站无法正常访问，需要一段时间的白名单调教后才能正常使用。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247585.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取 NoScript。</p>\n<h2 id=\"简易扩展\"><a href=\"#简易扩展\" class=\"headerlink\" title=\"简易扩展\"></a>简易扩展</h2><p>简易扩展的名字相当实诚，但功能性却毫不逊色。它可以帮助你快速切换用户代理、管理多个 Cookies、监听网络请求、改写静态和动态网址等，可谓前端开发者必备。 <img src=\"https://cdn.sspai.com/editor/u_713147/15574547247604.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在  Chrome 网上应用店   免费获取简易扩展。</p>\n"},{"title":"苏醒Grace8.0去授权破解版-WordPress主题","url":"223.html","id":"223","date":"2019-07-09T03:32:13.000Z","_content":"\n# ![](https://www.v5ant.com/wp-content/uploads/2019/07/2018082914441786-1024x597.jpg)\n\n# 主题介绍\n\nGrace 天生属于自媒体、极客用户，是一款友好更好用且功能丰富的 WordPress 博客主题。 它天生属于自媒体、极客用户。它提供多样化的文章分类样式，大图、小图、多图、推广文章样式，更好的展示网站逼格好看文章配图。内置了许多个性化的功能，能够满足您的各种需求。 Grace 主题满足多终端浏览，足够逼格的响应式可触摸滑动的幻灯片等优点，无论您使用电脑、平板还是智能手机，Grace 主题都能为您呈现完美的界面及极好的体验。另外注意的是，为了更好的支持多终端浏览，Grace 主题使用了 WordPress 官方响应式函数来判断每个终端设备，因此，如果使用 cdn 加速等，可能会照成 PC、手机端浏览错乱。建议关闭这类 CDN 加速的优化。 Grace 内置强大的后台自定义设置中心，满足您在后台自定义功能，调整布局，管理小工具，优化搜索引擎，优化用户浏览体验的更多可能。 启动 Grace ，3、5 分钟即可完成操作，打造属于您的极客空间。\n","source":"_posts/e8-8b-8f-e9-86-92grace8-0-e5-8e-bb-e6-8e-88-e6-9d-83-e7-a0-b4-e8-a7-a3-e7-89-88-wordpress-e4-b8-bb-e9-a2-98.md","raw":"---\ntitle: 苏醒Grace8.0去授权破解版-WordPress主题\nurl: 223.html\nid: 223\ncategories:\n  - 精选资源\ndate: 2019-07-09 11:32:13\ntags:\n---\n\n# ![](https://www.v5ant.com/wp-content/uploads/2019/07/2018082914441786-1024x597.jpg)\n\n# 主题介绍\n\nGrace 天生属于自媒体、极客用户，是一款友好更好用且功能丰富的 WordPress 博客主题。 它天生属于自媒体、极客用户。它提供多样化的文章分类样式，大图、小图、多图、推广文章样式，更好的展示网站逼格好看文章配图。内置了许多个性化的功能，能够满足您的各种需求。 Grace 主题满足多终端浏览，足够逼格的响应式可触摸滑动的幻灯片等优点，无论您使用电脑、平板还是智能手机，Grace 主题都能为您呈现完美的界面及极好的体验。另外注意的是，为了更好的支持多终端浏览，Grace 主题使用了 WordPress 官方响应式函数来判断每个终端设备，因此，如果使用 cdn 加速等，可能会照成 PC、手机端浏览错乱。建议关闭这类 CDN 加速的优化。 Grace 内置强大的后台自定义设置中心，满足您在后台自定义功能，调整布局，管理小工具，优化搜索引擎，优化用户浏览体验的更多可能。 启动 Grace ，3、5 分钟即可完成操作，打造属于您的极客空间。\n","slug":"e8-8b-8f-e9-86-92grace8-0-e5-8e-bb-e6-8e-88-e6-9d-83-e7-a0-b4-e8-a7-a3-e7-89-88-wordpress-e4-b8-bb-e9-a2-98","published":1,"updated":"2019-09-11T03:08:05.117Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269cf002ic8gsa0qh9xxh","content":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://www.v5ant.com/wp-content/uploads/2019/07/2018082914441786-1024x597.jpg\"></h1><h1 id=\"主题介绍\"><a href=\"#主题介绍\" class=\"headerlink\" title=\"主题介绍\"></a>主题介绍</h1><p>Grace 天生属于自媒体、极客用户，是一款友好更好用且功能丰富的 WordPress 博客主题。 它天生属于自媒体、极客用户。它提供多样化的文章分类样式，大图、小图、多图、推广文章样式，更好的展示网站逼格好看文章配图。内置了许多个性化的功能，能够满足您的各种需求。 Grace 主题满足多终端浏览，足够逼格的响应式可触摸滑动的幻灯片等优点，无论您使用电脑、平板还是智能手机，Grace 主题都能为您呈现完美的界面及极好的体验。另外注意的是，为了更好的支持多终端浏览，Grace 主题使用了 WordPress 官方响应式函数来判断每个终端设备，因此，如果使用 cdn 加速等，可能会照成 PC、手机端浏览错乱。建议关闭这类 CDN 加速的优化。 Grace 内置强大的后台自定义设置中心，满足您在后台自定义功能，调整布局，管理小工具，优化搜索引擎，优化用户浏览体验的更多可能。 启动 Grace ，3、5 分钟即可完成操作，打造属于您的极客空间。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://www.v5ant.com/wp-content/uploads/2019/07/2018082914441786-1024x597.jpg\"></h1><h1 id=\"主题介绍\"><a href=\"#主题介绍\" class=\"headerlink\" title=\"主题介绍\"></a>主题介绍</h1><p>Grace 天生属于自媒体、极客用户，是一款友好更好用且功能丰富的 WordPress 博客主题。 它天生属于自媒体、极客用户。它提供多样化的文章分类样式，大图、小图、多图、推广文章样式，更好的展示网站逼格好看文章配图。内置了许多个性化的功能，能够满足您的各种需求。 Grace 主题满足多终端浏览，足够逼格的响应式可触摸滑动的幻灯片等优点，无论您使用电脑、平板还是智能手机，Grace 主题都能为您呈现完美的界面及极好的体验。另外注意的是，为了更好的支持多终端浏览，Grace 主题使用了 WordPress 官方响应式函数来判断每个终端设备，因此，如果使用 cdn 加速等，可能会照成 PC、手机端浏览错乱。建议关闭这类 CDN 加速的优化。 Grace 内置强大的后台自定义设置中心，满足您在后台自定义功能，调整布局，管理小工具，优化搜索引擎，优化用户浏览体验的更多可能。 启动 Grace ，3、5 分钟即可完成操作，打造属于您的极客空间。</p>\n"},{"title":"苹果公布 2019 年度设计大奖，这 9 款 App 是今年的赢家","url":"29.html","id":"29","date":"2019-06-20T15:32:11.000Z","_content":"\n除了开幕演讲外，每年的  WWDC  最受人瞩目的还有   [Apple Design Awards](https://developer.apple.com/design/awards)（苹果设计奖）。苹果每年都会为在设计、技术和创新方面有突出表现的开发者颁发此奖。今年共有以下  9  款应用和游戏获得这份奖项。\n\n## 花园之间：控制时间来解谜\n\n[花园之间](https://sspai.com/post/51367)  曾获  2018  年度  Mac  游戏的奖项，并于今年  5  月移植到了  iOS  平台。在游戏中，玩家将与一对朋友共同经历从相识、相知到离别的过程。\n\n![](https://cdn.sspai.com/2019/06/05/3e0bc828c1521191e678acbd37bf0b67.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n花园之间最吸引人的自然是它绝美的画面。无论是在  Mac  还是  iOS  设备上，它都能给玩家带来惊艳的视觉效果。不同于常规游戏的是，在游戏中，你不能操纵主角的行走，但你可以通过操控时间来为其铺设道路。\n\n精美的画面只是吸引玩家的第一步，这款游戏真正击中玩家内心的是它的叙事。游戏对时间、友情的讨论，让玩过本作的玩家无一不沉浸其中。\n\n你可以在   [App Store](https://itunes.apple.com/cn/app/%E8%8A%B1%E5%9B%AD%E4%B9%8B%E9%97%B4/id1371965583?mt=8&ign-mpt=uo%3D4)  购买花园之间，售价 ¥30。\n\n## Ordia：画风优美的跳跃游戏\n\nOrdia 是一款平台动作游戏，玩家需要操控主角在诡谲的星球上跳跃、探索。游戏在动画效果方面极为出色，无论是主角与跳跃点的融合，还是外星生物的突然袭击，弹性效果都十分流畅、自然。\n\n![](https://cdn.sspai.com/2019/06/04/d3cfc66ab2c0b50c5c6af2b769d56258.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\nOrdia 共有  30  个关卡，每个关卡都拥有挑战模式供玩家选择。在游戏过程中，玩家也可以解锁成就和隐藏关卡。出色的动画效果、丰富的关卡设计再加上一只手指就能游玩的操作设计，为 Ordia 赢得了苹果设计奖。\n\n你可以在   [App Store](https://itunes.apple.com/us/app/ordia/id1309000429)  购买 Ordia，售价  \\$3.99，国区暂未上架。\n\n## Flow：高颜值绘本笔记\n\n在笔记界，Moleskine  凭借颜值吸引了不少拥趸，Moleskine  的应用给人的感觉也都是精致、优雅。Flow  作为一款主打绘图的笔记应用，内置了高度可自定义的笔刷工具，你可以根据自己的喜好组合出一套专属笔刷。\n\n![](https://cdn.sspai.com/2019/06/04/cffb07cee4cee0b5e1631ab4fa93c947.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\nFlow  支持无限宽度的绘图区域，你可以通过双指横向滑动来无限延长你的画作，让你的灵感在纸上尽情挥洒。除了拥有可无限延长的纸张外，你还可以对纸张样式进行修改。\n\nFlow  将「滑动」这一元素完美地融入到应用中。无论是更换笔刷、选择纸张样式，或是调整颜色、打开菜单，你都可以通过滑动来完成。滑动时的动画效果也正如应用名字  Flow  一样，具有流动感。\n\n你可以在   [App Store](https://itunes.apple.com/cn/app/flow-by-moleskine/id1271361459)  免费下载  Flow。\n\n#### Flow 由 Moleskine 呈现\n\n## [相关文章狂野飙车  9：传奇：令人震撼的视觉盛宴](https://sspai.com/app/Flow%E7%94%B1Moleskine%E5%91%88%E7%8E%B0)\n\n《狂野飙车》系列一直是移动平台最受欢迎的赛车游戏之一，狂野飙车  9：传奇（下简称狂野飙车  9），更是给玩家带来了令人震撼的视觉盛宴。\n\n![](https://cdn.sspai.com/2019/06/04/1b98af249884a76914767b2d9f95b7c6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n狂野飙车  9 拥有极其真实的赛车建模和环境效果，在泥泞的道路上行驶，你的车身也会沾上泥土。在高速行驶时，周围景物的动态模糊效果极大地加强了「速度感」。游戏内置的回放系统，也让玩家可以保存自己在赛场上驰骋的精彩瞬间。\n\n一款优秀的赛车游戏应该能让所有玩家体验游戏乐趣，同时也能让硬核玩家不断突破操作的极限。狂野飙车  9 加入了点按操作，游戏会自动帮你驾驶，而你要做的只是在岔路口点按选择方向。\n\n在  WWDC  的开幕演讲上，苹果也以狂野飙车  9 作为例子展示了  Project Catalyst。在不久的将来，我们也能在  Mac  上体验竞速的快感。\n\n你可以在   [App Store](https://itunes.apple.com/us/app/asphalt-9-legends/id805603214?mt=8)  免费下载狂野飙车  9：传奇，国区暂未上架。\n\n## Pixelmator Photo：让  AI  帮你修图\n\n[Pixelmator Photo](https://sspai.com/post/54012)  使用了超过  2000  万张照片进行  AI  训练，即使你对图片后期一无所知，也可以利用  Pixelmator Photo  修出好看的照片。\n\n![](https://cdn.sspai.com/2019/06/04/9c1182d3729c4ee9364e9f372ba5af84.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\nPixelmator Photo  兼顾了入门用户和专业用户的需求。对于入门用户而言，你可以直接点击自动调整，随后进行简单的裁切即可。专业用户则可以呼出工具栏，对各项参数进行细致的调整。得力于  iPad  的高素质屏幕，你可以对照片色彩实现更精准的把控。Pixelmator Photo  还支持导入  RAW  格式的照片，让随拍随修成为现实。\n\n你可以在   [App Store](https://itunes.apple.com/cn/app/pixelmator-photo/id1444636541?mt=8)  购买  Pixelmator Photo，售价  30  元。\n\n## ELOH：弹射游戏与打击乐的美妙结合\n\n[ELOH](https://sspai.com/post/47467)  作为一款解谜游戏，不但没有让玩家因为谜题的困难而感到焦虑，反而让玩家在动听的打击乐中放松下来。ELOH 设计团队的前作  [回忆之旅](https://sspai.com/post/39581)  也曾获得  2017  年苹果设计奖。\n\n![](https://cdn.sspai.com/2019/06/04/900e63476c9f5e35fbd3b1228e03210c.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\nELOH 最大的乐趣就在于它恰到好处的音乐。玩家需要移动图腾来让子弹弹射到接收器中，子弹在发射和反弹时会发出「咚」和「叮」的声音，两种声音此起彼伏，演奏出不同的旋律。游戏的关卡设计极为巧妙，无论玩家怎么摆放图腾，都能演奏出和谐动听的旋律。\n\nELOH 手绘风格的精致画面和恰到好处的音乐，让玩家可以在不经意间放松下来。游戏没有任何的文字描述，但任何人都能快速上手并演奏出动听的旋律，让人有种「欲罢不能」的感觉。\n\n你可以在   [App Store](https://itunes.apple.com/cn/app/eloh/id1406382064?mt=8&uo=4&at=11l6hc&app=itunes&ct=fnd)  购买 ELOH，售价  18  元。\n\nThumper: Pocket Edition：备受赞誉的视觉跑酷游戏\n\n---\n\nThumper: Pocket Edition（下简称  Thumper）是一款太空科幻风格的视觉跑酷游戏，在各平台备受赞誉。游戏的配乐采用了重金属电子乐，时刻刺激着玩家的肾上腺素。\n\n![](https://cdn.sspai.com/2019/06/04/0a44590870a4361b5aefc9b77a7b217e.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\nThumper  的操作根据移动端进行了优化，玩家只需进行简单的点按、滑动即可完成所有游戏操作。80  年代霓虹灯的画风和极具速度感的游戏画面相结合，给玩家带来了强烈的视觉刺激，让人大呼过瘾。\n\n你可以在   [App Store](https://itunes.apple.com/cn/app/id1287138671)  购买  Thumper: Pocket Editon，售价 30 元。\n\n## HomeCourt：AI  篮球教练\n\n在  iPhone Xs  的发布会上，苹果第一次向我们展示了  HomeCourt  这款智能篮球教练应用。通过机器学习和  AR  跟踪，它可以记录你每一次的投球，并为你提供专业建议。\n\n![](https://cdn.sspai.com/2019/06/04/064f6881044077fdfd43168b81bcb950.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n你可以利用  HomeCourt  在家进行篮球训练，也可以通过它的社交功能与健身房、教练互动，获取更专业的建议。HomeCourt  最大的亮点便是采用了机器学习对人物进行跟踪，得益于  A12  仿生处理器的强大性能，你可以实时获得精准的投球数据。\n\n你可以在   [App Store](https://itunes.apple.com/us/app/homecourt-the-basketball-app/id1258520424?mt=8)  免费下载  HomeCourt。\n\n## Butterfly iQ：随时随地进行超声波检查\n\nButterfly iQ  是一款支持全身超声波检查的应用，需要搭配专门的仪器来使用。应用经过  CE  认证，FDA  批准，在安全性上有足够的保障。\n\n![](https://cdn.sspai.com/2019/06/05/cd38768a153bb1f8f832cbc7483e9898.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n图片来自官网\n\nButterfly iQ  对单手操作进行了优化，你可以一个人进行自我检查。你不需要拥有专业的医疗知识，应用会通过  AR  和机器学习来帮助你进行超声波检查。Butterfly iQ  所拍摄的超声波图像可以上传到云端，与医生、家人共享。\n\n你可以在   [App Store](https://itunes.apple.com/us/app/butterfly-iq-ultrasound/id1183035589?mt=8)  免费下载  Butterfly iQ，国区暂未上架。\n","source":"_posts/e8-8b-b9-e6-9e-9c-e5-85-ac-e5-b8-83-2019-e5-b9-b4-e5-ba-a6-e8-ae-be-e8-ae-a1-e5-a4-a7-e5-a5-96-ef-bc-8c-e8-bf-99-9-e6-ac-be-app-e6-98-af-e4-bb-8a-e5-b9-b4-e7-9a-84-e8-b5-a2-e5-ae-b6.md","raw":"---\ntitle: 苹果公布 2019 年度设计大奖，这 9 款 App 是今年的赢家\nurl: 29.html\nid: 29\ncategories:\n  - 杂谈\ndate: 2019-06-20 23:32:11\ntags:\n---\n\n除了开幕演讲外，每年的  WWDC  最受人瞩目的还有   [Apple Design Awards](https://developer.apple.com/design/awards)（苹果设计奖）。苹果每年都会为在设计、技术和创新方面有突出表现的开发者颁发此奖。今年共有以下  9  款应用和游戏获得这份奖项。\n\n## 花园之间：控制时间来解谜\n\n[花园之间](https://sspai.com/post/51367)  曾获  2018  年度  Mac  游戏的奖项，并于今年  5  月移植到了  iOS  平台。在游戏中，玩家将与一对朋友共同经历从相识、相知到离别的过程。\n\n![](https://cdn.sspai.com/2019/06/05/3e0bc828c1521191e678acbd37bf0b67.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n花园之间最吸引人的自然是它绝美的画面。无论是在  Mac  还是  iOS  设备上，它都能给玩家带来惊艳的视觉效果。不同于常规游戏的是，在游戏中，你不能操纵主角的行走，但你可以通过操控时间来为其铺设道路。\n\n精美的画面只是吸引玩家的第一步，这款游戏真正击中玩家内心的是它的叙事。游戏对时间、友情的讨论，让玩过本作的玩家无一不沉浸其中。\n\n你可以在   [App Store](https://itunes.apple.com/cn/app/%E8%8A%B1%E5%9B%AD%E4%B9%8B%E9%97%B4/id1371965583?mt=8&ign-mpt=uo%3D4)  购买花园之间，售价 ¥30。\n\n## Ordia：画风优美的跳跃游戏\n\nOrdia 是一款平台动作游戏，玩家需要操控主角在诡谲的星球上跳跃、探索。游戏在动画效果方面极为出色，无论是主角与跳跃点的融合，还是外星生物的突然袭击，弹性效果都十分流畅、自然。\n\n![](https://cdn.sspai.com/2019/06/04/d3cfc66ab2c0b50c5c6af2b769d56258.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\nOrdia 共有  30  个关卡，每个关卡都拥有挑战模式供玩家选择。在游戏过程中，玩家也可以解锁成就和隐藏关卡。出色的动画效果、丰富的关卡设计再加上一只手指就能游玩的操作设计，为 Ordia 赢得了苹果设计奖。\n\n你可以在   [App Store](https://itunes.apple.com/us/app/ordia/id1309000429)  购买 Ordia，售价  \\$3.99，国区暂未上架。\n\n## Flow：高颜值绘本笔记\n\n在笔记界，Moleskine  凭借颜值吸引了不少拥趸，Moleskine  的应用给人的感觉也都是精致、优雅。Flow  作为一款主打绘图的笔记应用，内置了高度可自定义的笔刷工具，你可以根据自己的喜好组合出一套专属笔刷。\n\n![](https://cdn.sspai.com/2019/06/04/cffb07cee4cee0b5e1631ab4fa93c947.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\nFlow  支持无限宽度的绘图区域，你可以通过双指横向滑动来无限延长你的画作，让你的灵感在纸上尽情挥洒。除了拥有可无限延长的纸张外，你还可以对纸张样式进行修改。\n\nFlow  将「滑动」这一元素完美地融入到应用中。无论是更换笔刷、选择纸张样式，或是调整颜色、打开菜单，你都可以通过滑动来完成。滑动时的动画效果也正如应用名字  Flow  一样，具有流动感。\n\n你可以在   [App Store](https://itunes.apple.com/cn/app/flow-by-moleskine/id1271361459)  免费下载  Flow。\n\n#### Flow 由 Moleskine 呈现\n\n## [相关文章狂野飙车  9：传奇：令人震撼的视觉盛宴](https://sspai.com/app/Flow%E7%94%B1Moleskine%E5%91%88%E7%8E%B0)\n\n《狂野飙车》系列一直是移动平台最受欢迎的赛车游戏之一，狂野飙车  9：传奇（下简称狂野飙车  9），更是给玩家带来了令人震撼的视觉盛宴。\n\n![](https://cdn.sspai.com/2019/06/04/1b98af249884a76914767b2d9f95b7c6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n狂野飙车  9 拥有极其真实的赛车建模和环境效果，在泥泞的道路上行驶，你的车身也会沾上泥土。在高速行驶时，周围景物的动态模糊效果极大地加强了「速度感」。游戏内置的回放系统，也让玩家可以保存自己在赛场上驰骋的精彩瞬间。\n\n一款优秀的赛车游戏应该能让所有玩家体验游戏乐趣，同时也能让硬核玩家不断突破操作的极限。狂野飙车  9 加入了点按操作，游戏会自动帮你驾驶，而你要做的只是在岔路口点按选择方向。\n\n在  WWDC  的开幕演讲上，苹果也以狂野飙车  9 作为例子展示了  Project Catalyst。在不久的将来，我们也能在  Mac  上体验竞速的快感。\n\n你可以在   [App Store](https://itunes.apple.com/us/app/asphalt-9-legends/id805603214?mt=8)  免费下载狂野飙车  9：传奇，国区暂未上架。\n\n## Pixelmator Photo：让  AI  帮你修图\n\n[Pixelmator Photo](https://sspai.com/post/54012)  使用了超过  2000  万张照片进行  AI  训练，即使你对图片后期一无所知，也可以利用  Pixelmator Photo  修出好看的照片。\n\n![](https://cdn.sspai.com/2019/06/04/9c1182d3729c4ee9364e9f372ba5af84.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\nPixelmator Photo  兼顾了入门用户和专业用户的需求。对于入门用户而言，你可以直接点击自动调整，随后进行简单的裁切即可。专业用户则可以呼出工具栏，对各项参数进行细致的调整。得力于  iPad  的高素质屏幕，你可以对照片色彩实现更精准的把控。Pixelmator Photo  还支持导入  RAW  格式的照片，让随拍随修成为现实。\n\n你可以在   [App Store](https://itunes.apple.com/cn/app/pixelmator-photo/id1444636541?mt=8)  购买  Pixelmator Photo，售价  30  元。\n\n## ELOH：弹射游戏与打击乐的美妙结合\n\n[ELOH](https://sspai.com/post/47467)  作为一款解谜游戏，不但没有让玩家因为谜题的困难而感到焦虑，反而让玩家在动听的打击乐中放松下来。ELOH 设计团队的前作  [回忆之旅](https://sspai.com/post/39581)  也曾获得  2017  年苹果设计奖。\n\n![](https://cdn.sspai.com/2019/06/04/900e63476c9f5e35fbd3b1228e03210c.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\nELOH 最大的乐趣就在于它恰到好处的音乐。玩家需要移动图腾来让子弹弹射到接收器中，子弹在发射和反弹时会发出「咚」和「叮」的声音，两种声音此起彼伏，演奏出不同的旋律。游戏的关卡设计极为巧妙，无论玩家怎么摆放图腾，都能演奏出和谐动听的旋律。\n\nELOH 手绘风格的精致画面和恰到好处的音乐，让玩家可以在不经意间放松下来。游戏没有任何的文字描述，但任何人都能快速上手并演奏出动听的旋律，让人有种「欲罢不能」的感觉。\n\n你可以在   [App Store](https://itunes.apple.com/cn/app/eloh/id1406382064?mt=8&uo=4&at=11l6hc&app=itunes&ct=fnd)  购买 ELOH，售价  18  元。\n\nThumper: Pocket Edition：备受赞誉的视觉跑酷游戏\n\n---\n\nThumper: Pocket Edition（下简称  Thumper）是一款太空科幻风格的视觉跑酷游戏，在各平台备受赞誉。游戏的配乐采用了重金属电子乐，时刻刺激着玩家的肾上腺素。\n\n![](https://cdn.sspai.com/2019/06/04/0a44590870a4361b5aefc9b77a7b217e.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\nThumper  的操作根据移动端进行了优化，玩家只需进行简单的点按、滑动即可完成所有游戏操作。80  年代霓虹灯的画风和极具速度感的游戏画面相结合，给玩家带来了强烈的视觉刺激，让人大呼过瘾。\n\n你可以在   [App Store](https://itunes.apple.com/cn/app/id1287138671)  购买  Thumper: Pocket Editon，售价 30 元。\n\n## HomeCourt：AI  篮球教练\n\n在  iPhone Xs  的发布会上，苹果第一次向我们展示了  HomeCourt  这款智能篮球教练应用。通过机器学习和  AR  跟踪，它可以记录你每一次的投球，并为你提供专业建议。\n\n![](https://cdn.sspai.com/2019/06/04/064f6881044077fdfd43168b81bcb950.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n你可以利用  HomeCourt  在家进行篮球训练，也可以通过它的社交功能与健身房、教练互动，获取更专业的建议。HomeCourt  最大的亮点便是采用了机器学习对人物进行跟踪，得益于  A12  仿生处理器的强大性能，你可以实时获得精准的投球数据。\n\n你可以在   [App Store](https://itunes.apple.com/us/app/homecourt-the-basketball-app/id1258520424?mt=8)  免费下载  HomeCourt。\n\n## Butterfly iQ：随时随地进行超声波检查\n\nButterfly iQ  是一款支持全身超声波检查的应用，需要搭配专门的仪器来使用。应用经过  CE  认证，FDA  批准，在安全性上有足够的保障。\n\n![](https://cdn.sspai.com/2019/06/05/cd38768a153bb1f8f832cbc7483e9898.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n图片来自官网\n\nButterfly iQ  对单手操作进行了优化，你可以一个人进行自我检查。你不需要拥有专业的医疗知识，应用会通过  AR  和机器学习来帮助你进行超声波检查。Butterfly iQ  所拍摄的超声波图像可以上传到云端，与医生、家人共享。\n\n你可以在   [App Store](https://itunes.apple.com/us/app/butterfly-iq-ultrasound/id1183035589?mt=8)  免费下载  Butterfly iQ，国区暂未上架。\n","slug":"e8-8b-b9-e6-9e-9c-e5-85-ac-e5-b8-83-2019-e5-b9-b4-e5-ba-a6-e8-ae-be-e8-ae-a1-e5-a4-a7-e5-a5-96-ef-bc-8c-e8-bf-99-9-e6-ac-be-app-e6-98-af-e4-bb-8a-e5-b9-b4-e7-9a-84-e8-b5-a2-e5-ae-b6","published":1,"updated":"2019-09-11T03:08:11.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269cq002lc8gse06welvf","content":"<p>除了开幕演讲外，每年的  WWDC  最受人瞩目的还有   <a href=\"https://developer.apple.com/design/awards\">Apple Design Awards</a>（苹果设计奖）。苹果每年都会为在设计、技术和创新方面有突出表现的开发者颁发此奖。今年共有以下  9  款应用和游戏获得这份奖项。</p>\n<h2 id=\"花园之间：控制时间来解谜\"><a href=\"#花园之间：控制时间来解谜\" class=\"headerlink\" title=\"花园之间：控制时间来解谜\"></a>花园之间：控制时间来解谜</h2><p><a href=\"https://sspai.com/post/51367\">花园之间</a>  曾获  2018  年度  Mac  游戏的奖项，并于今年  5  月移植到了  iOS  平台。在游戏中，玩家将与一对朋友共同经历从相识、相知到离别的过程。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/3e0bc828c1521191e678acbd37bf0b67.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>花园之间最吸引人的自然是它绝美的画面。无论是在  Mac  还是  iOS  设备上，它都能给玩家带来惊艳的视觉效果。不同于常规游戏的是，在游戏中，你不能操纵主角的行走，但你可以通过操控时间来为其铺设道路。</p>\n<p>精美的画面只是吸引玩家的第一步，这款游戏真正击中玩家内心的是它的叙事。游戏对时间、友情的讨论，让玩过本作的玩家无一不沉浸其中。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/cn/app/%E8%8A%B1%E5%9B%AD%E4%B9%8B%E9%97%B4/id1371965583?mt=8&ign-mpt=uo=4\">App Store</a>  购买花园之间，售价 ¥30。</p>\n<h2 id=\"Ordia：画风优美的跳跃游戏\"><a href=\"#Ordia：画风优美的跳跃游戏\" class=\"headerlink\" title=\"Ordia：画风优美的跳跃游戏\"></a>Ordia：画风优美的跳跃游戏</h2><p>Ordia 是一款平台动作游戏，玩家需要操控主角在诡谲的星球上跳跃、探索。游戏在动画效果方面极为出色，无论是主角与跳跃点的融合，还是外星生物的突然袭击，弹性效果都十分流畅、自然。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/d3cfc66ab2c0b50c5c6af2b769d56258.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>Ordia 共有  30  个关卡，每个关卡都拥有挑战模式供玩家选择。在游戏过程中，玩家也可以解锁成就和隐藏关卡。出色的动画效果、丰富的关卡设计再加上一只手指就能游玩的操作设计，为 Ordia 赢得了苹果设计奖。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/us/app/ordia/id1309000429\">App Store</a>  购买 Ordia，售价  $3.99，国区暂未上架。</p>\n<h2 id=\"Flow：高颜值绘本笔记\"><a href=\"#Flow：高颜值绘本笔记\" class=\"headerlink\" title=\"Flow：高颜值绘本笔记\"></a>Flow：高颜值绘本笔记</h2><p>在笔记界，Moleskine  凭借颜值吸引了不少拥趸，Moleskine  的应用给人的感觉也都是精致、优雅。Flow  作为一款主打绘图的笔记应用，内置了高度可自定义的笔刷工具，你可以根据自己的喜好组合出一套专属笔刷。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/cffb07cee4cee0b5e1631ab4fa93c947.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>Flow  支持无限宽度的绘图区域，你可以通过双指横向滑动来无限延长你的画作，让你的灵感在纸上尽情挥洒。除了拥有可无限延长的纸张外，你还可以对纸张样式进行修改。</p>\n<p>Flow  将「滑动」这一元素完美地融入到应用中。无论是更换笔刷、选择纸张样式，或是调整颜色、打开菜单，你都可以通过滑动来完成。滑动时的动画效果也正如应用名字  Flow  一样，具有流动感。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/cn/app/flow-by-moleskine/id1271361459\">App Store</a>  免费下载  Flow。</p>\n<h4 id=\"Flow-由-Moleskine-呈现\"><a href=\"#Flow-由-Moleskine-呈现\" class=\"headerlink\" title=\"Flow 由 Moleskine 呈现\"></a>Flow 由 Moleskine 呈现</h4><h2 id=\"相关文章狂野飙车-9：传奇：令人震撼的视觉盛宴\"><a href=\"#相关文章狂野飙车-9：传奇：令人震撼的视觉盛宴\" class=\"headerlink\" title=\"相关文章狂野飙车  9：传奇：令人震撼的视觉盛宴\"></a><a href=\"https://sspai.com/app/Flow%E7%94%B1Moleskine%E5%91%88%E7%8E%B0\">相关文章狂野飙车  9：传奇：令人震撼的视觉盛宴</a></h2><p>《狂野飙车》系列一直是移动平台最受欢迎的赛车游戏之一，狂野飙车  9：传奇（下简称狂野飙车  9），更是给玩家带来了令人震撼的视觉盛宴。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/1b98af249884a76914767b2d9f95b7c6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>狂野飙车  9 拥有极其真实的赛车建模和环境效果，在泥泞的道路上行驶，你的车身也会沾上泥土。在高速行驶时，周围景物的动态模糊效果极大地加强了「速度感」。游戏内置的回放系统，也让玩家可以保存自己在赛场上驰骋的精彩瞬间。</p>\n<p>一款优秀的赛车游戏应该能让所有玩家体验游戏乐趣，同时也能让硬核玩家不断突破操作的极限。狂野飙车  9 加入了点按操作，游戏会自动帮你驾驶，而你要做的只是在岔路口点按选择方向。</p>\n<p>在  WWDC  的开幕演讲上，苹果也以狂野飙车  9 作为例子展示了  Project Catalyst。在不久的将来，我们也能在  Mac  上体验竞速的快感。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/us/app/asphalt-9-legends/id805603214?mt=8\">App Store</a>  免费下载狂野飙车  9：传奇，国区暂未上架。</p>\n<h2 id=\"Pixelmator-Photo：让-AI-帮你修图\"><a href=\"#Pixelmator-Photo：让-AI-帮你修图\" class=\"headerlink\" title=\"Pixelmator Photo：让  AI  帮你修图\"></a>Pixelmator Photo：让  AI  帮你修图</h2><p><a href=\"https://sspai.com/post/54012\">Pixelmator Photo</a>  使用了超过  2000  万张照片进行  AI  训练，即使你对图片后期一无所知，也可以利用  Pixelmator Photo  修出好看的照片。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/9c1182d3729c4ee9364e9f372ba5af84.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>Pixelmator Photo  兼顾了入门用户和专业用户的需求。对于入门用户而言，你可以直接点击自动调整，随后进行简单的裁切即可。专业用户则可以呼出工具栏，对各项参数进行细致的调整。得力于  iPad  的高素质屏幕，你可以对照片色彩实现更精准的把控。Pixelmator Photo  还支持导入  RAW  格式的照片，让随拍随修成为现实。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/cn/app/pixelmator-photo/id1444636541?mt=8\">App Store</a>  购买  Pixelmator Photo，售价  30  元。</p>\n<h2 id=\"ELOH：弹射游戏与打击乐的美妙结合\"><a href=\"#ELOH：弹射游戏与打击乐的美妙结合\" class=\"headerlink\" title=\"ELOH：弹射游戏与打击乐的美妙结合\"></a>ELOH：弹射游戏与打击乐的美妙结合</h2><p><a href=\"https://sspai.com/post/47467\">ELOH</a>  作为一款解谜游戏，不但没有让玩家因为谜题的困难而感到焦虑，反而让玩家在动听的打击乐中放松下来。ELOH 设计团队的前作  <a href=\"https://sspai.com/post/39581\">回忆之旅</a>  也曾获得  2017  年苹果设计奖。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/900e63476c9f5e35fbd3b1228e03210c.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>ELOH 最大的乐趣就在于它恰到好处的音乐。玩家需要移动图腾来让子弹弹射到接收器中，子弹在发射和反弹时会发出「咚」和「叮」的声音，两种声音此起彼伏，演奏出不同的旋律。游戏的关卡设计极为巧妙，无论玩家怎么摆放图腾，都能演奏出和谐动听的旋律。</p>\n<p>ELOH 手绘风格的精致画面和恰到好处的音乐，让玩家可以在不经意间放松下来。游戏没有任何的文字描述，但任何人都能快速上手并演奏出动听的旋律，让人有种「欲罢不能」的感觉。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/cn/app/eloh/id1406382064?mt=8&uo=4&at=11l6hc&app=itunes&ct=fnd\">App Store</a>  购买 ELOH，售价  18  元。</p>\n<p>Thumper: Pocket Edition：备受赞誉的视觉跑酷游戏</p>\n<hr>\n<p>Thumper: Pocket Edition（下简称  Thumper）是一款太空科幻风格的视觉跑酷游戏，在各平台备受赞誉。游戏的配乐采用了重金属电子乐，时刻刺激着玩家的肾上腺素。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/0a44590870a4361b5aefc9b77a7b217e.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>Thumper  的操作根据移动端进行了优化，玩家只需进行简单的点按、滑动即可完成所有游戏操作。80  年代霓虹灯的画风和极具速度感的游戏画面相结合，给玩家带来了强烈的视觉刺激，让人大呼过瘾。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/cn/app/id1287138671\">App Store</a>  购买  Thumper: Pocket Editon，售价 30 元。</p>\n<h2 id=\"HomeCourt：AI-篮球教练\"><a href=\"#HomeCourt：AI-篮球教练\" class=\"headerlink\" title=\"HomeCourt：AI  篮球教练\"></a>HomeCourt：AI  篮球教练</h2><p>在  iPhone Xs  的发布会上，苹果第一次向我们展示了  HomeCourt  这款智能篮球教练应用。通过机器学习和  AR  跟踪，它可以记录你每一次的投球，并为你提供专业建议。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/064f6881044077fdfd43168b81bcb950.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>你可以利用  HomeCourt  在家进行篮球训练，也可以通过它的社交功能与健身房、教练互动，获取更专业的建议。HomeCourt  最大的亮点便是采用了机器学习对人物进行跟踪，得益于  A12  仿生处理器的强大性能，你可以实时获得精准的投球数据。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/us/app/homecourt-the-basketball-app/id1258520424?mt=8\">App Store</a>  免费下载  HomeCourt。</p>\n<h2 id=\"Butterfly-iQ：随时随地进行超声波检查\"><a href=\"#Butterfly-iQ：随时随地进行超声波检查\" class=\"headerlink\" title=\"Butterfly iQ：随时随地进行超声波检查\"></a>Butterfly iQ：随时随地进行超声波检查</h2><p>Butterfly iQ  是一款支持全身超声波检查的应用，需要搭配专门的仪器来使用。应用经过  CE  认证，FDA  批准，在安全性上有足够的保障。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/cd38768a153bb1f8f832cbc7483e9898.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>图片来自官网</p>\n<p>Butterfly iQ  对单手操作进行了优化，你可以一个人进行自我检查。你不需要拥有专业的医疗知识，应用会通过  AR  和机器学习来帮助你进行超声波检查。Butterfly iQ  所拍摄的超声波图像可以上传到云端，与医生、家人共享。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/us/app/butterfly-iq-ultrasound/id1183035589?mt=8\">App Store</a>  免费下载  Butterfly iQ，国区暂未上架。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>除了开幕演讲外，每年的  WWDC  最受人瞩目的还有   <a href=\"https://developer.apple.com/design/awards\">Apple Design Awards</a>（苹果设计奖）。苹果每年都会为在设计、技术和创新方面有突出表现的开发者颁发此奖。今年共有以下  9  款应用和游戏获得这份奖项。</p>\n<h2 id=\"花园之间：控制时间来解谜\"><a href=\"#花园之间：控制时间来解谜\" class=\"headerlink\" title=\"花园之间：控制时间来解谜\"></a>花园之间：控制时间来解谜</h2><p><a href=\"https://sspai.com/post/51367\">花园之间</a>  曾获  2018  年度  Mac  游戏的奖项，并于今年  5  月移植到了  iOS  平台。在游戏中，玩家将与一对朋友共同经历从相识、相知到离别的过程。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/3e0bc828c1521191e678acbd37bf0b67.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>花园之间最吸引人的自然是它绝美的画面。无论是在  Mac  还是  iOS  设备上，它都能给玩家带来惊艳的视觉效果。不同于常规游戏的是，在游戏中，你不能操纵主角的行走，但你可以通过操控时间来为其铺设道路。</p>\n<p>精美的画面只是吸引玩家的第一步，这款游戏真正击中玩家内心的是它的叙事。游戏对时间、友情的讨论，让玩过本作的玩家无一不沉浸其中。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/cn/app/%E8%8A%B1%E5%9B%AD%E4%B9%8B%E9%97%B4/id1371965583?mt=8&ign-mpt=uo=4\">App Store</a>  购买花园之间，售价 ¥30。</p>\n<h2 id=\"Ordia：画风优美的跳跃游戏\"><a href=\"#Ordia：画风优美的跳跃游戏\" class=\"headerlink\" title=\"Ordia：画风优美的跳跃游戏\"></a>Ordia：画风优美的跳跃游戏</h2><p>Ordia 是一款平台动作游戏，玩家需要操控主角在诡谲的星球上跳跃、探索。游戏在动画效果方面极为出色，无论是主角与跳跃点的融合，还是外星生物的突然袭击，弹性效果都十分流畅、自然。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/d3cfc66ab2c0b50c5c6af2b769d56258.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>Ordia 共有  30  个关卡，每个关卡都拥有挑战模式供玩家选择。在游戏过程中，玩家也可以解锁成就和隐藏关卡。出色的动画效果、丰富的关卡设计再加上一只手指就能游玩的操作设计，为 Ordia 赢得了苹果设计奖。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/us/app/ordia/id1309000429\">App Store</a>  购买 Ordia，售价  $3.99，国区暂未上架。</p>\n<h2 id=\"Flow：高颜值绘本笔记\"><a href=\"#Flow：高颜值绘本笔记\" class=\"headerlink\" title=\"Flow：高颜值绘本笔记\"></a>Flow：高颜值绘本笔记</h2><p>在笔记界，Moleskine  凭借颜值吸引了不少拥趸，Moleskine  的应用给人的感觉也都是精致、优雅。Flow  作为一款主打绘图的笔记应用，内置了高度可自定义的笔刷工具，你可以根据自己的喜好组合出一套专属笔刷。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/cffb07cee4cee0b5e1631ab4fa93c947.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>Flow  支持无限宽度的绘图区域，你可以通过双指横向滑动来无限延长你的画作，让你的灵感在纸上尽情挥洒。除了拥有可无限延长的纸张外，你还可以对纸张样式进行修改。</p>\n<p>Flow  将「滑动」这一元素完美地融入到应用中。无论是更换笔刷、选择纸张样式，或是调整颜色、打开菜单，你都可以通过滑动来完成。滑动时的动画效果也正如应用名字  Flow  一样，具有流动感。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/cn/app/flow-by-moleskine/id1271361459\">App Store</a>  免费下载  Flow。</p>\n<h4 id=\"Flow-由-Moleskine-呈现\"><a href=\"#Flow-由-Moleskine-呈现\" class=\"headerlink\" title=\"Flow 由 Moleskine 呈现\"></a>Flow 由 Moleskine 呈现</h4><h2 id=\"相关文章狂野飙车-9：传奇：令人震撼的视觉盛宴\"><a href=\"#相关文章狂野飙车-9：传奇：令人震撼的视觉盛宴\" class=\"headerlink\" title=\"相关文章狂野飙车  9：传奇：令人震撼的视觉盛宴\"></a><a href=\"https://sspai.com/app/Flow%E7%94%B1Moleskine%E5%91%88%E7%8E%B0\">相关文章狂野飙车  9：传奇：令人震撼的视觉盛宴</a></h2><p>《狂野飙车》系列一直是移动平台最受欢迎的赛车游戏之一，狂野飙车  9：传奇（下简称狂野飙车  9），更是给玩家带来了令人震撼的视觉盛宴。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/1b98af249884a76914767b2d9f95b7c6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>狂野飙车  9 拥有极其真实的赛车建模和环境效果，在泥泞的道路上行驶，你的车身也会沾上泥土。在高速行驶时，周围景物的动态模糊效果极大地加强了「速度感」。游戏内置的回放系统，也让玩家可以保存自己在赛场上驰骋的精彩瞬间。</p>\n<p>一款优秀的赛车游戏应该能让所有玩家体验游戏乐趣，同时也能让硬核玩家不断突破操作的极限。狂野飙车  9 加入了点按操作，游戏会自动帮你驾驶，而你要做的只是在岔路口点按选择方向。</p>\n<p>在  WWDC  的开幕演讲上，苹果也以狂野飙车  9 作为例子展示了  Project Catalyst。在不久的将来，我们也能在  Mac  上体验竞速的快感。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/us/app/asphalt-9-legends/id805603214?mt=8\">App Store</a>  免费下载狂野飙车  9：传奇，国区暂未上架。</p>\n<h2 id=\"Pixelmator-Photo：让-AI-帮你修图\"><a href=\"#Pixelmator-Photo：让-AI-帮你修图\" class=\"headerlink\" title=\"Pixelmator Photo：让  AI  帮你修图\"></a>Pixelmator Photo：让  AI  帮你修图</h2><p><a href=\"https://sspai.com/post/54012\">Pixelmator Photo</a>  使用了超过  2000  万张照片进行  AI  训练，即使你对图片后期一无所知，也可以利用  Pixelmator Photo  修出好看的照片。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/9c1182d3729c4ee9364e9f372ba5af84.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>Pixelmator Photo  兼顾了入门用户和专业用户的需求。对于入门用户而言，你可以直接点击自动调整，随后进行简单的裁切即可。专业用户则可以呼出工具栏，对各项参数进行细致的调整。得力于  iPad  的高素质屏幕，你可以对照片色彩实现更精准的把控。Pixelmator Photo  还支持导入  RAW  格式的照片，让随拍随修成为现实。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/cn/app/pixelmator-photo/id1444636541?mt=8\">App Store</a>  购买  Pixelmator Photo，售价  30  元。</p>\n<h2 id=\"ELOH：弹射游戏与打击乐的美妙结合\"><a href=\"#ELOH：弹射游戏与打击乐的美妙结合\" class=\"headerlink\" title=\"ELOH：弹射游戏与打击乐的美妙结合\"></a>ELOH：弹射游戏与打击乐的美妙结合</h2><p><a href=\"https://sspai.com/post/47467\">ELOH</a>  作为一款解谜游戏，不但没有让玩家因为谜题的困难而感到焦虑，反而让玩家在动听的打击乐中放松下来。ELOH 设计团队的前作  <a href=\"https://sspai.com/post/39581\">回忆之旅</a>  也曾获得  2017  年苹果设计奖。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/900e63476c9f5e35fbd3b1228e03210c.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>ELOH 最大的乐趣就在于它恰到好处的音乐。玩家需要移动图腾来让子弹弹射到接收器中，子弹在发射和反弹时会发出「咚」和「叮」的声音，两种声音此起彼伏，演奏出不同的旋律。游戏的关卡设计极为巧妙，无论玩家怎么摆放图腾，都能演奏出和谐动听的旋律。</p>\n<p>ELOH 手绘风格的精致画面和恰到好处的音乐，让玩家可以在不经意间放松下来。游戏没有任何的文字描述，但任何人都能快速上手并演奏出动听的旋律，让人有种「欲罢不能」的感觉。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/cn/app/eloh/id1406382064?mt=8&uo=4&at=11l6hc&app=itunes&ct=fnd\">App Store</a>  购买 ELOH，售价  18  元。</p>\n<p>Thumper: Pocket Edition：备受赞誉的视觉跑酷游戏</p>\n<hr>\n<p>Thumper: Pocket Edition（下简称  Thumper）是一款太空科幻风格的视觉跑酷游戏，在各平台备受赞誉。游戏的配乐采用了重金属电子乐，时刻刺激着玩家的肾上腺素。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/0a44590870a4361b5aefc9b77a7b217e.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>Thumper  的操作根据移动端进行了优化，玩家只需进行简单的点按、滑动即可完成所有游戏操作。80  年代霓虹灯的画风和极具速度感的游戏画面相结合，给玩家带来了强烈的视觉刺激，让人大呼过瘾。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/cn/app/id1287138671\">App Store</a>  购买  Thumper: Pocket Editon，售价 30 元。</p>\n<h2 id=\"HomeCourt：AI-篮球教练\"><a href=\"#HomeCourt：AI-篮球教练\" class=\"headerlink\" title=\"HomeCourt：AI  篮球教练\"></a>HomeCourt：AI  篮球教练</h2><p>在  iPhone Xs  的发布会上，苹果第一次向我们展示了  HomeCourt  这款智能篮球教练应用。通过机器学习和  AR  跟踪，它可以记录你每一次的投球，并为你提供专业建议。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/04/064f6881044077fdfd43168b81bcb950.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>你可以利用  HomeCourt  在家进行篮球训练，也可以通过它的社交功能与健身房、教练互动，获取更专业的建议。HomeCourt  最大的亮点便是采用了机器学习对人物进行跟踪，得益于  A12  仿生处理器的强大性能，你可以实时获得精准的投球数据。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/us/app/homecourt-the-basketball-app/id1258520424?mt=8\">App Store</a>  免费下载  HomeCourt。</p>\n<h2 id=\"Butterfly-iQ：随时随地进行超声波检查\"><a href=\"#Butterfly-iQ：随时随地进行超声波检查\" class=\"headerlink\" title=\"Butterfly iQ：随时随地进行超声波检查\"></a>Butterfly iQ：随时随地进行超声波检查</h2><p>Butterfly iQ  是一款支持全身超声波检查的应用，需要搭配专门的仪器来使用。应用经过  CE  认证，FDA  批准，在安全性上有足够的保障。</p>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/cd38768a153bb1f8f832cbc7483e9898.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<p>图片来自官网</p>\n<p>Butterfly iQ  对单手操作进行了优化，你可以一个人进行自我检查。你不需要拥有专业的医疗知识，应用会通过  AR  和机器学习来帮助你进行超声波检查。Butterfly iQ  所拍摄的超声波图像可以上传到云端，与医生、家人共享。</p>\n<p>你可以在   <a href=\"https://itunes.apple.com/us/app/butterfly-iq-ultrasound/id1183035589?mt=8\">App Store</a>  免费下载  Butterfly iQ，国区暂未上架。</p>\n"},{"title":"苹果cms程序最新源码获取及视频解析接口分享","url":"397.html","id":"397","date":"2019-09-02T11:25:36.000Z","_content":"\n# 介绍\n\n> 苹果 CMS 程序是一套采用 PHP+MYSQL 环境下运行的完善而强大的快速建站系统。经过近多年的开发经验和技术积累，苹果 CMS 程序已逐步走向成熟，在易用性和功能上已经成为同行中的佼佼者。程序体积小->优化程序代码，运行速度快->高效的缓存处理，只要普通的虚拟主机就可以完美搭建起来，建站成本非常低。仿 MVC 模板分离，内置标签，自定义函数标签接口，强大的自定义采集功能，只要你会 HTML 就可以轻松做出个性化的网站。 程序易用性和功能上一直以来都积极采纳广大站长提出的各种好的建议，迅速响应各种紧急问题，我们的服务理念贯穿其中，保证每一位站长每一个环节都可以从容应对。v10 采用 tp5.x 内核进行开发，扩展了模板处理引擎，将后台程序与 html 模板简单的分离出来，让设计人员与程序人员最大限度的发挥自己的优势而互不干扰，大大加快了项目有序、快速的完成。即使您是第一次接触，也会在最短的时间内熟练掌握它的使用方法。后台管理模块，一目了然，操作简单，绝对不会让您眼花缭乱。\n\n## 注：本页分享的源码均为苹果 cms 官方源码\n\n<!-- more -->\n\n苹果 cms 最新官方源码（及时更新） 8 月 22 号更新（版本：2019.1000.1008） 苹果 cms8\n\n未更新\n\n苹果 cms10\n\n完整版：[https://pan.baidu.com/s/1ZHB3TFx1xcK0HkvHq7-lZA](https://pan.baidu.com/s/1ZHB3TFx1xcK0HkvHq7-lZA) 提取码: c95x 升级包：[https://pan.baidu.com/s/1sNV-wCn9I0ITKUi0AQSitQ](https://pan.baidu.com/s/1sNV-wCn9I0ITKUi0AQSitQ) 提取码: auf1 更新日志\n\n1，新增微信 QQ 防红防封跳转提示和 public/browser.html 提示模板。 2，修复分集剧情入库默认值的问题。 3，新增标签\\$maccms.http_url 获取当前网址。 4，其他细节。 【教程】苹果 cms 防红防封设置：[https://mebi.me/821](https://mebi.me/821)\n\n8 月 18 号更新（版本：2019.1000.1007）\n\n### 苹果 cms8\n\n地址：[https://pan.baidu.com/s/1tIhUnCY_qgXHdYxWQnBWhQ](https://pan.baidu.com/s/1tIhUnCY_qgXHdYxWQnBWhQ) 提取码：f6d7\n\n### 苹果 cms10\n\n地址：[https://pan.baidu.com/s/1r-S7aNtnQ0l3hm5aJpP8hg](https://pan.baidu.com/s/1r-S7aNtnQ0l3hm5aJpP8hg) 提取码：ffbf 更新日志\n\n1，视频管理加入独立分集剧情部分、模板和标签项目。 2，采集配置二次更新规则加入分集剧情。 3，火车头模块加入分集剧情部分。 4，其他细节。\n\n### 苹果 cms 升级方法\n\n1、苹果 cms 后台会有升级提示，按照提示升级即可。\n\n2、如果苹果 cms 版本太旧，后台无法升级，可以下载更新包（update），然后将更新包上传到服务器并允许覆盖旧文件。覆盖前请记得备份。\n\n#### 资源下载\n\n使用教程 [https://www.lanzous.com/b256378](https://www.lanzous.com/b256378)\n\n#### 苹果 cms 模版下载（V10）\n\n[https://www.lanzous.com/b355667](https://www.lanzous.com/b355667)\n\n#### 苹果 cms 插件下载（V10）\n\n[https://www.lanzous.com/b355668](https://www.lanzous.com/b355668)\n\n### 解析接口\n\n解析接口失效速度快，是否可用请自测。大多数接口有广告，一般出现在手机端\n\n最新无广告快速接口 [http://jx.v5ant.com/?v](http://jx.v5ant.com/?v)=\n\n付费解析接口 [https://www.ckmov.com](https://www.ckmov.com)\n\n8 月 19 日更新 [http://jx.du2.cc/?url](http://jx.du2.cc/?url)=\n\n[http://jx.drgxj.com/?url](http://jx.drgxj.com/?url)=\n\n[http://jx.618ge.com/?url](http://jx.618ge.com/?url)=\n\n[http://vip.jlsprh.com/?url](http://vip.jlsprh.com/?url)=\n\n[http://jx.598110.com/?url](http://jx.598110.com/?url)=\n\n[https://vip.rkesb.cn/vip/?url](https://vip.rkesb.cn/vip/?url)=\n\n[http://api.baiyug.vip/index.php?url](http://api.baiyug.vip/index.php?url)=\n\n[http://tv.beipy.com/jx/?url](http://tv.beipy.com/jx/?url)=\n\n[https://660e.com/?url](https://660e.com/?url)=\n\n[http://api.nepian.com/ckparse/?url](http://api.nepian.com/ckparse/?url)=\n\n[http://jx.618g.com/?url](http://jx.618g.com/?url)=\n\n[https://jiexi.071811.cc/jx2.php?url](https://jiexi.071811.cc/jx2.php?url)=\n\n[http://jiexi.071811.cc/jx2.php?url](http://jiexi.071811.cc/jx2.php?url)=\n\n[http://jqaaa.com/jq3/?url](http://jqaaa.com/jq3/?url)=\n","source":"_posts/e8-8b-b9-e6-9e-9ccms-e7-a8-8b-e5-ba-8f-e6-9c-80-e6-96-b0-e6-ba-90-e7-a0-81-e8-8e-b7-e5-8f-96-e5-8f-8a-e8-a7-86-e9-a2-91-e8-a7-a3-e6-9e-90-e6-8e-a5-e5-8f-a3-e5-88-86-e4-ba-ab.md","raw":"---\ntitle: 苹果cms程序最新源码获取及视频解析接口分享\ntags:\n  - Maccms\n  - V10\n  - 解析接口\nurl: 397.html\nid: 397\ncategories:\n  - 精选资源\ndate: 2019-09-02 19:25:36\n---\n\n# 介绍\n\n> 苹果 CMS 程序是一套采用 PHP+MYSQL 环境下运行的完善而强大的快速建站系统。经过近多年的开发经验和技术积累，苹果 CMS 程序已逐步走向成熟，在易用性和功能上已经成为同行中的佼佼者。程序体积小->优化程序代码，运行速度快->高效的缓存处理，只要普通的虚拟主机就可以完美搭建起来，建站成本非常低。仿 MVC 模板分离，内置标签，自定义函数标签接口，强大的自定义采集功能，只要你会 HTML 就可以轻松做出个性化的网站。 程序易用性和功能上一直以来都积极采纳广大站长提出的各种好的建议，迅速响应各种紧急问题，我们的服务理念贯穿其中，保证每一位站长每一个环节都可以从容应对。v10 采用 tp5.x 内核进行开发，扩展了模板处理引擎，将后台程序与 html 模板简单的分离出来，让设计人员与程序人员最大限度的发挥自己的优势而互不干扰，大大加快了项目有序、快速的完成。即使您是第一次接触，也会在最短的时间内熟练掌握它的使用方法。后台管理模块，一目了然，操作简单，绝对不会让您眼花缭乱。\n\n## 注：本页分享的源码均为苹果 cms 官方源码\n\n<!-- more -->\n\n苹果 cms 最新官方源码（及时更新） 8 月 22 号更新（版本：2019.1000.1008） 苹果 cms8\n\n未更新\n\n苹果 cms10\n\n完整版：[https://pan.baidu.com/s/1ZHB3TFx1xcK0HkvHq7-lZA](https://pan.baidu.com/s/1ZHB3TFx1xcK0HkvHq7-lZA) 提取码: c95x 升级包：[https://pan.baidu.com/s/1sNV-wCn9I0ITKUi0AQSitQ](https://pan.baidu.com/s/1sNV-wCn9I0ITKUi0AQSitQ) 提取码: auf1 更新日志\n\n1，新增微信 QQ 防红防封跳转提示和 public/browser.html 提示模板。 2，修复分集剧情入库默认值的问题。 3，新增标签\\$maccms.http_url 获取当前网址。 4，其他细节。 【教程】苹果 cms 防红防封设置：[https://mebi.me/821](https://mebi.me/821)\n\n8 月 18 号更新（版本：2019.1000.1007）\n\n### 苹果 cms8\n\n地址：[https://pan.baidu.com/s/1tIhUnCY_qgXHdYxWQnBWhQ](https://pan.baidu.com/s/1tIhUnCY_qgXHdYxWQnBWhQ) 提取码：f6d7\n\n### 苹果 cms10\n\n地址：[https://pan.baidu.com/s/1r-S7aNtnQ0l3hm5aJpP8hg](https://pan.baidu.com/s/1r-S7aNtnQ0l3hm5aJpP8hg) 提取码：ffbf 更新日志\n\n1，视频管理加入独立分集剧情部分、模板和标签项目。 2，采集配置二次更新规则加入分集剧情。 3，火车头模块加入分集剧情部分。 4，其他细节。\n\n### 苹果 cms 升级方法\n\n1、苹果 cms 后台会有升级提示，按照提示升级即可。\n\n2、如果苹果 cms 版本太旧，后台无法升级，可以下载更新包（update），然后将更新包上传到服务器并允许覆盖旧文件。覆盖前请记得备份。\n\n#### 资源下载\n\n使用教程 [https://www.lanzous.com/b256378](https://www.lanzous.com/b256378)\n\n#### 苹果 cms 模版下载（V10）\n\n[https://www.lanzous.com/b355667](https://www.lanzous.com/b355667)\n\n#### 苹果 cms 插件下载（V10）\n\n[https://www.lanzous.com/b355668](https://www.lanzous.com/b355668)\n\n### 解析接口\n\n解析接口失效速度快，是否可用请自测。大多数接口有广告，一般出现在手机端\n\n最新无广告快速接口 [http://jx.v5ant.com/?v](http://jx.v5ant.com/?v)=\n\n付费解析接口 [https://www.ckmov.com](https://www.ckmov.com)\n\n8 月 19 日更新 [http://jx.du2.cc/?url](http://jx.du2.cc/?url)=\n\n[http://jx.drgxj.com/?url](http://jx.drgxj.com/?url)=\n\n[http://jx.618ge.com/?url](http://jx.618ge.com/?url)=\n\n[http://vip.jlsprh.com/?url](http://vip.jlsprh.com/?url)=\n\n[http://jx.598110.com/?url](http://jx.598110.com/?url)=\n\n[https://vip.rkesb.cn/vip/?url](https://vip.rkesb.cn/vip/?url)=\n\n[http://api.baiyug.vip/index.php?url](http://api.baiyug.vip/index.php?url)=\n\n[http://tv.beipy.com/jx/?url](http://tv.beipy.com/jx/?url)=\n\n[https://660e.com/?url](https://660e.com/?url)=\n\n[http://api.nepian.com/ckparse/?url](http://api.nepian.com/ckparse/?url)=\n\n[http://jx.618g.com/?url](http://jx.618g.com/?url)=\n\n[https://jiexi.071811.cc/jx2.php?url](https://jiexi.071811.cc/jx2.php?url)=\n\n[http://jiexi.071811.cc/jx2.php?url](http://jiexi.071811.cc/jx2.php?url)=\n\n[http://jqaaa.com/jq3/?url](http://jqaaa.com/jq3/?url)=\n","slug":"e8-8b-b9-e6-9e-9ccms-e7-a8-8b-e5-ba-8f-e6-9c-80-e6-96-b0-e6-ba-90-e7-a0-81-e8-8e-b7-e5-8f-96-e5-8f-8a-e8-a7-86-e9-a2-91-e8-a7-a3-e6-9e-90-e6-8e-a5-e5-8f-a3-e5-88-86-e4-ba-ab","published":1,"updated":"2019-09-11T08:45:49.769Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269cs002oc8gsdgf288t8","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><blockquote>\n<p>苹果 CMS 程序是一套采用 PHP+MYSQL 环境下运行的完善而强大的快速建站系统。经过近多年的开发经验和技术积累，苹果 CMS 程序已逐步走向成熟，在易用性和功能上已经成为同行中的佼佼者。程序体积小-&gt;优化程序代码，运行速度快-&gt;高效的缓存处理，只要普通的虚拟主机就可以完美搭建起来，建站成本非常低。仿 MVC 模板分离，内置标签，自定义函数标签接口，强大的自定义采集功能，只要你会 HTML 就可以轻松做出个性化的网站。 程序易用性和功能上一直以来都积极采纳广大站长提出的各种好的建议，迅速响应各种紧急问题，我们的服务理念贯穿其中，保证每一位站长每一个环节都可以从容应对。v10 采用 tp5.x 内核进行开发，扩展了模板处理引擎，将后台程序与 html 模板简单的分离出来，让设计人员与程序人员最大限度的发挥自己的优势而互不干扰，大大加快了项目有序、快速的完成。即使您是第一次接触，也会在最短的时间内熟练掌握它的使用方法。后台管理模块，一目了然，操作简单，绝对不会让您眼花缭乱。</p>\n</blockquote>\n<h2 id=\"注：本页分享的源码均为苹果-cms-官方源码\"><a href=\"#注：本页分享的源码均为苹果-cms-官方源码\" class=\"headerlink\" title=\"注：本页分享的源码均为苹果 cms 官方源码\"></a>注：本页分享的源码均为苹果 cms 官方源码</h2><span id=\"more\"></span>\n\n<p>苹果 cms 最新官方源码（及时更新） 8 月 22 号更新（版本：2019.1000.1008） 苹果 cms8</p>\n<p>未更新</p>\n<p>苹果 cms10</p>\n<p>完整版：<a href=\"https://pan.baidu.com/s/1ZHB3TFx1xcK0HkvHq7-lZA\">https://pan.baidu.com/s/1ZHB3TFx1xcK0HkvHq7-lZA</a> 提取码: c95x 升级包：<a href=\"https://pan.baidu.com/s/1sNV-wCn9I0ITKUi0AQSitQ\">https://pan.baidu.com/s/1sNV-wCn9I0ITKUi0AQSitQ</a> 提取码: auf1 更新日志</p>\n<p>1，新增微信 QQ 防红防封跳转提示和 public/browser.html 提示模板。 2，修复分集剧情入库默认值的问题。 3，新增标签$maccms.http_url 获取当前网址。 4，其他细节。 【教程】苹果 cms 防红防封设置：<a href=\"https://mebi.me/821\">https://mebi.me/821</a></p>\n<p>8 月 18 号更新（版本：2019.1000.1007）</p>\n<h3 id=\"苹果-cms8\"><a href=\"#苹果-cms8\" class=\"headerlink\" title=\"苹果 cms8\"></a>苹果 cms8</h3><p>地址：<a href=\"https://pan.baidu.com/s/1tIhUnCY_qgXHdYxWQnBWhQ\">https://pan.baidu.com/s/1tIhUnCY_qgXHdYxWQnBWhQ</a> 提取码：f6d7</p>\n<h3 id=\"苹果-cms10\"><a href=\"#苹果-cms10\" class=\"headerlink\" title=\"苹果 cms10\"></a>苹果 cms10</h3><p>地址：<a href=\"https://pan.baidu.com/s/1r-S7aNtnQ0l3hm5aJpP8hg\">https://pan.baidu.com/s/1r-S7aNtnQ0l3hm5aJpP8hg</a> 提取码：ffbf 更新日志</p>\n<p>1，视频管理加入独立分集剧情部分、模板和标签项目。 2，采集配置二次更新规则加入分集剧情。 3，火车头模块加入分集剧情部分。 4，其他细节。</p>\n<h3 id=\"苹果-cms-升级方法\"><a href=\"#苹果-cms-升级方法\" class=\"headerlink\" title=\"苹果 cms 升级方法\"></a>苹果 cms 升级方法</h3><p>1、苹果 cms 后台会有升级提示，按照提示升级即可。</p>\n<p>2、如果苹果 cms 版本太旧，后台无法升级，可以下载更新包（update），然后将更新包上传到服务器并允许覆盖旧文件。覆盖前请记得备份。</p>\n<h4 id=\"资源下载\"><a href=\"#资源下载\" class=\"headerlink\" title=\"资源下载\"></a>资源下载</h4><p>使用教程 <a href=\"https://www.lanzous.com/b256378\">https://www.lanzous.com/b256378</a></p>\n<h4 id=\"苹果-cms-模版下载（V10）\"><a href=\"#苹果-cms-模版下载（V10）\" class=\"headerlink\" title=\"苹果 cms 模版下载（V10）\"></a>苹果 cms 模版下载（V10）</h4><p><a href=\"https://www.lanzous.com/b355667\">https://www.lanzous.com/b355667</a></p>\n<h4 id=\"苹果-cms-插件下载（V10）\"><a href=\"#苹果-cms-插件下载（V10）\" class=\"headerlink\" title=\"苹果 cms 插件下载（V10）\"></a>苹果 cms 插件下载（V10）</h4><p><a href=\"https://www.lanzous.com/b355668\">https://www.lanzous.com/b355668</a></p>\n<h3 id=\"解析接口\"><a href=\"#解析接口\" class=\"headerlink\" title=\"解析接口\"></a>解析接口</h3><p>解析接口失效速度快，是否可用请自测。大多数接口有广告，一般出现在手机端</p>\n<p>最新无广告快速接口 <a href=\"http://jx.v5ant.com/?v\">http://jx.v5ant.com/?v</a>=</p>\n<p>付费解析接口 <a href=\"https://www.ckmov.com/\">https://www.ckmov.com</a></p>\n<p>8 月 19 日更新 <a href=\"http://jx.du2.cc/?url\">http://jx.du2.cc/?url</a>=</p>\n<p><a href=\"http://jx.drgxj.com/?url\">http://jx.drgxj.com/?url</a>=</p>\n<p><a href=\"http://jx.618ge.com/?url\">http://jx.618ge.com/?url</a>=</p>\n<p><a href=\"http://vip.jlsprh.com/?url\">http://vip.jlsprh.com/?url</a>=</p>\n<p><a href=\"http://jx.598110.com/?url\">http://jx.598110.com/?url</a>=</p>\n<p><a href=\"https://vip.rkesb.cn/vip/?url\">https://vip.rkesb.cn/vip/?url</a>=</p>\n<p><a href=\"http://api.baiyug.vip/index.php?url\">http://api.baiyug.vip/index.php?url</a>=</p>\n<p><a href=\"http://tv.beipy.com/jx/?url\">http://tv.beipy.com/jx/?url</a>=</p>\n<p><a href=\"https://660e.com/?url\">https://660e.com/?url</a>=</p>\n<p><a href=\"http://api.nepian.com/ckparse/?url\">http://api.nepian.com/ckparse/?url</a>=</p>\n<p><a href=\"http://jx.618g.com/?url\">http://jx.618g.com/?url</a>=</p>\n<p><a href=\"https://jiexi.071811.cc/jx2.php?url\">https://jiexi.071811.cc/jx2.php?url</a>=</p>\n<p><a href=\"http://jiexi.071811.cc/jx2.php?url\">http://jiexi.071811.cc/jx2.php?url</a>=</p>\n<p><a href=\"http://jqaaa.com/jq3/?url\">http://jqaaa.com/jq3/?url</a>=</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><blockquote>\n<p>苹果 CMS 程序是一套采用 PHP+MYSQL 环境下运行的完善而强大的快速建站系统。经过近多年的开发经验和技术积累，苹果 CMS 程序已逐步走向成熟，在易用性和功能上已经成为同行中的佼佼者。程序体积小-&gt;优化程序代码，运行速度快-&gt;高效的缓存处理，只要普通的虚拟主机就可以完美搭建起来，建站成本非常低。仿 MVC 模板分离，内置标签，自定义函数标签接口，强大的自定义采集功能，只要你会 HTML 就可以轻松做出个性化的网站。 程序易用性和功能上一直以来都积极采纳广大站长提出的各种好的建议，迅速响应各种紧急问题，我们的服务理念贯穿其中，保证每一位站长每一个环节都可以从容应对。v10 采用 tp5.x 内核进行开发，扩展了模板处理引擎，将后台程序与 html 模板简单的分离出来，让设计人员与程序人员最大限度的发挥自己的优势而互不干扰，大大加快了项目有序、快速的完成。即使您是第一次接触，也会在最短的时间内熟练掌握它的使用方法。后台管理模块，一目了然，操作简单，绝对不会让您眼花缭乱。</p>\n</blockquote>\n<h2 id=\"注：本页分享的源码均为苹果-cms-官方源码\"><a href=\"#注：本页分享的源码均为苹果-cms-官方源码\" class=\"headerlink\" title=\"注：本页分享的源码均为苹果 cms 官方源码\"></a>注：本页分享的源码均为苹果 cms 官方源码</h2>","more":"<p>苹果 cms 最新官方源码（及时更新） 8 月 22 号更新（版本：2019.1000.1008） 苹果 cms8</p>\n<p>未更新</p>\n<p>苹果 cms10</p>\n<p>完整版：<a href=\"https://pan.baidu.com/s/1ZHB3TFx1xcK0HkvHq7-lZA\">https://pan.baidu.com/s/1ZHB3TFx1xcK0HkvHq7-lZA</a> 提取码: c95x 升级包：<a href=\"https://pan.baidu.com/s/1sNV-wCn9I0ITKUi0AQSitQ\">https://pan.baidu.com/s/1sNV-wCn9I0ITKUi0AQSitQ</a> 提取码: auf1 更新日志</p>\n<p>1，新增微信 QQ 防红防封跳转提示和 public/browser.html 提示模板。 2，修复分集剧情入库默认值的问题。 3，新增标签$maccms.http_url 获取当前网址。 4，其他细节。 【教程】苹果 cms 防红防封设置：<a href=\"https://mebi.me/821\">https://mebi.me/821</a></p>\n<p>8 月 18 号更新（版本：2019.1000.1007）</p>\n<h3 id=\"苹果-cms8\"><a href=\"#苹果-cms8\" class=\"headerlink\" title=\"苹果 cms8\"></a>苹果 cms8</h3><p>地址：<a href=\"https://pan.baidu.com/s/1tIhUnCY_qgXHdYxWQnBWhQ\">https://pan.baidu.com/s/1tIhUnCY_qgXHdYxWQnBWhQ</a> 提取码：f6d7</p>\n<h3 id=\"苹果-cms10\"><a href=\"#苹果-cms10\" class=\"headerlink\" title=\"苹果 cms10\"></a>苹果 cms10</h3><p>地址：<a href=\"https://pan.baidu.com/s/1r-S7aNtnQ0l3hm5aJpP8hg\">https://pan.baidu.com/s/1r-S7aNtnQ0l3hm5aJpP8hg</a> 提取码：ffbf 更新日志</p>\n<p>1，视频管理加入独立分集剧情部分、模板和标签项目。 2，采集配置二次更新规则加入分集剧情。 3，火车头模块加入分集剧情部分。 4，其他细节。</p>\n<h3 id=\"苹果-cms-升级方法\"><a href=\"#苹果-cms-升级方法\" class=\"headerlink\" title=\"苹果 cms 升级方法\"></a>苹果 cms 升级方法</h3><p>1、苹果 cms 后台会有升级提示，按照提示升级即可。</p>\n<p>2、如果苹果 cms 版本太旧，后台无法升级，可以下载更新包（update），然后将更新包上传到服务器并允许覆盖旧文件。覆盖前请记得备份。</p>\n<h4 id=\"资源下载\"><a href=\"#资源下载\" class=\"headerlink\" title=\"资源下载\"></a>资源下载</h4><p>使用教程 <a href=\"https://www.lanzous.com/b256378\">https://www.lanzous.com/b256378</a></p>\n<h4 id=\"苹果-cms-模版下载（V10）\"><a href=\"#苹果-cms-模版下载（V10）\" class=\"headerlink\" title=\"苹果 cms 模版下载（V10）\"></a>苹果 cms 模版下载（V10）</h4><p><a href=\"https://www.lanzous.com/b355667\">https://www.lanzous.com/b355667</a></p>\n<h4 id=\"苹果-cms-插件下载（V10）\"><a href=\"#苹果-cms-插件下载（V10）\" class=\"headerlink\" title=\"苹果 cms 插件下载（V10）\"></a>苹果 cms 插件下载（V10）</h4><p><a href=\"https://www.lanzous.com/b355668\">https://www.lanzous.com/b355668</a></p>\n<h3 id=\"解析接口\"><a href=\"#解析接口\" class=\"headerlink\" title=\"解析接口\"></a>解析接口</h3><p>解析接口失效速度快，是否可用请自测。大多数接口有广告，一般出现在手机端</p>\n<p>最新无广告快速接口 <a href=\"http://jx.v5ant.com/?v\">http://jx.v5ant.com/?v</a>=</p>\n<p>付费解析接口 <a href=\"https://www.ckmov.com/\">https://www.ckmov.com</a></p>\n<p>8 月 19 日更新 <a href=\"http://jx.du2.cc/?url\">http://jx.du2.cc/?url</a>=</p>\n<p><a href=\"http://jx.drgxj.com/?url\">http://jx.drgxj.com/?url</a>=</p>\n<p><a href=\"http://jx.618ge.com/?url\">http://jx.618ge.com/?url</a>=</p>\n<p><a href=\"http://vip.jlsprh.com/?url\">http://vip.jlsprh.com/?url</a>=</p>\n<p><a href=\"http://jx.598110.com/?url\">http://jx.598110.com/?url</a>=</p>\n<p><a href=\"https://vip.rkesb.cn/vip/?url\">https://vip.rkesb.cn/vip/?url</a>=</p>\n<p><a href=\"http://api.baiyug.vip/index.php?url\">http://api.baiyug.vip/index.php?url</a>=</p>\n<p><a href=\"http://tv.beipy.com/jx/?url\">http://tv.beipy.com/jx/?url</a>=</p>\n<p><a href=\"https://660e.com/?url\">https://660e.com/?url</a>=</p>\n<p><a href=\"http://api.nepian.com/ckparse/?url\">http://api.nepian.com/ckparse/?url</a>=</p>\n<p><a href=\"http://jx.618g.com/?url\">http://jx.618g.com/?url</a>=</p>\n<p><a href=\"https://jiexi.071811.cc/jx2.php?url\">https://jiexi.071811.cc/jx2.php?url</a>=</p>\n<p><a href=\"http://jiexi.071811.cc/jx2.php?url\">http://jiexi.071811.cc/jx2.php?url</a>=</p>\n<p><a href=\"http://jqaaa.com/jq3/?url\">http://jqaaa.com/jq3/?url</a>=</p>"},{"title":"苹果cmsV10幕乔酷黑模板免授权破解版","url":"135.html","id":"135","date":"2019-06-22T08:55:07.000Z","_content":"\n![](https://www.v5ant.com/ueditor/themes/default/images/spacer.gif \"正在上传...\") ![005WTxucgy1g0ndeayyd2j31hc0u0n3r.jpg](http://cdn.v5ant.com/ueditor/images/1125978293342965760.jpg)","source":"_posts/e8-8b-b9-e6-9e-9ccmsv10-e5-b9-95-e4-b9-94-e9-85-b7-e9-bb-91-e6-a8-a1-e6-9d-bf-e5-85-8d-e6-8e-88-e6-9d-83-e7-a0-b4-e8-a7-a3-e7-89-88.md","raw":"---\ntitle: 苹果cmsV10幕乔酷黑模板免授权破解版\nurl: 135.html\nid: 135\ncategories:\n  - 精选资源\ndate: 2019-06-22 16:55:07\ntags:\n---\n\n![](https://www.v5ant.com/ueditor/themes/default/images/spacer.gif \"正在上传...\") ![005WTxucgy1g0ndeayyd2j31hc0u0n3r.jpg](http://cdn.v5ant.com/ueditor/images/1125978293342965760.jpg)","slug":"e8-8b-b9-e6-9e-9ccmsv10-e5-b9-95-e4-b9-94-e9-85-b7-e9-bb-91-e6-a8-a1-e6-9d-bf-e5-85-8d-e6-8e-88-e6-9d-83-e7-a0-b4-e8-a7-a3-e7-89-88","published":1,"updated":"2019-09-10T07:46:08.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269cw002rc8gs5gqub2vw","content":"<p><img src=\"https://www.v5ant.com/ueditor/themes/default/images/spacer.gif\" title=\"正在上传...\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1125978293342965760.jpg\" alt=\"005WTxucgy1g0ndeayyd2j31hc0u0n3r.jpg\"></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><img src=\"https://www.v5ant.com/ueditor/themes/default/images/spacer.gif\" title=\"正在上传...\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1125978293342965760.jpg\" alt=\"005WTxucgy1g0ndeayyd2j31hc0u0n3r.jpg\"></p>\n"},{"title":"解决Vue单页面应用在微信等APP里面无法设置title问题","url":"271.html","id":"271","date":"2019-07-26T03:32:47.000Z","_content":"\n### 作用\n\nVuejs 单页应用在 iOS 系统下部分 APP 的 webview 中 标题不能通过 document.title = xxx 的方式修改 该插件只为解决该问题而生(兼容安卓)\n\n### 安装\n\n> Vuejs 2.x\n\n    npm install vue-titles --save\n    \n\n##### ES6\n\n> main.js\n\n    Vue.use(require('vue-titles'));\n    \n\n使用场景 1 ：单页面应用切换路由跳转更新 title\n---------------------------\n\n> 路由定义(只截取一部分)\n\n    // ...\n    const routes = [\n      {\n        name: 'Home',\n        path: '/home',\n        meta: {\n          title: '首页'\n        },\n        component: require('../views/Home.vue')\n      },\n      {\n        name: 'UCenter',\n        path: '/ucenter',\n        meta: {\n          title: '用户中心'\n        },\n        component: require('../views/UCenter.vue')\n      }\n    ];\n    // ...\n    \n\n> App.vue **建议全局只使用一次该指令 标题可用 vuex 或者 router 中定义 不要多处使用!!**\n\n    <!-- 任意元素中加 v-title 指令 建议将标题放在 route 对应meta对象的定义中 -->\n    <div v-title=\"$route.meta.title\"></div>\n    <!--or-->\n    <router-view v-title=\"$route.meta.title\"></router-view>\n    \n\n使用场景 2：同一个路由不同状态需要手动设置 title\n----------------------------\n\n    // 需要的地方直接调用\n    this.$setTitle('厉害了我的哥！');","source":"_posts/e8-a7-a3-e5-86-b3vue-e5-8d-95-e9-a1-b5-e9-9d-a2-e5-ba-94-e7-94-a8-e5-9c-a8-e5-be-ae-e4-bf-a1-e7-ad-89app-e9-87-8c-e9-9d-a2-e6-97-a0-e6-b3-95-e8-ae-be-e7-bd-aetitle-e9-97-ae-e9-a2-98.md","raw":"---\ntitle: 解决Vue单页面应用在微信等APP里面无法设置title问题\ntags:\n  - Vue\n  - vue-titles\n  - 开源\nurl: 271.html\nid: 271\ncategories:\n  - 大前端\ndate: 2019-07-26 11:32:47\n---\n\n### 作用\n\nVuejs 单页应用在 iOS 系统下部分 APP 的 webview 中 标题不能通过 document.title = xxx 的方式修改 该插件只为解决该问题而生(兼容安卓)\n\n### 安装\n\n> Vuejs 2.x\n\n    npm install vue-titles --save\n    \n\n##### ES6\n\n> main.js\n\n    Vue.use(require('vue-titles'));\n    \n\n使用场景 1 ：单页面应用切换路由跳转更新 title\n---------------------------\n\n> 路由定义(只截取一部分)\n\n    // ...\n    const routes = [\n      {\n        name: 'Home',\n        path: '/home',\n        meta: {\n          title: '首页'\n        },\n        component: require('../views/Home.vue')\n      },\n      {\n        name: 'UCenter',\n        path: '/ucenter',\n        meta: {\n          title: '用户中心'\n        },\n        component: require('../views/UCenter.vue')\n      }\n    ];\n    // ...\n    \n\n> App.vue **建议全局只使用一次该指令 标题可用 vuex 或者 router 中定义 不要多处使用!!**\n\n    <!-- 任意元素中加 v-title 指令 建议将标题放在 route 对应meta对象的定义中 -->\n    <div v-title=\"$route.meta.title\"></div>\n    <!--or-->\n    <router-view v-title=\"$route.meta.title\"></router-view>\n    \n\n使用场景 2：同一个路由不同状态需要手动设置 title\n----------------------------\n\n    // 需要的地方直接调用\n    this.$setTitle('厉害了我的哥！');","slug":"e8-a7-a3-e5-86-b3vue-e5-8d-95-e9-a1-b5-e9-9d-a2-e5-ba-94-e7-94-a8-e5-9c-a8-e5-be-ae-e4-bf-a1-e7-ad-89app-e9-87-8c-e9-9d-a2-e6-97-a0-e6-b3-95-e8-ae-be-e7-bd-aetitle-e9-97-ae-e9-a2-98","published":1,"updated":"2019-09-10T07:46:08.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269cy002uc8gs4d94evyn","content":"<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>Vuejs 单页应用在 iOS 系统下部分 APP 的 webview 中 标题不能通过 document.title = xxx 的方式修改 该插件只为解决该问题而生(兼容安卓)</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><blockquote>\n<p>Vuejs 2.x</p>\n</blockquote>\n<pre><code>npm install vue-titles --save\n</code></pre>\n<h5 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h5><blockquote>\n<p>main.js</p>\n</blockquote>\n<pre><code>Vue.use(require(&#39;vue-titles&#39;));\n</code></pre>\n<h2 id=\"使用场景-1-：单页面应用切换路由跳转更新-title\"><a href=\"#使用场景-1-：单页面应用切换路由跳转更新-title\" class=\"headerlink\" title=\"使用场景 1 ：单页面应用切换路由跳转更新 title\"></a>使用场景 1 ：单页面应用切换路由跳转更新 title</h2><blockquote>\n<p>路由定义(只截取一部分)</p>\n</blockquote>\n<pre><code>// ...\nconst routes = [\n  &#123;\n    name: &#39;Home&#39;,\n    path: &#39;/home&#39;,\n    meta: &#123;\n      title: &#39;首页&#39;\n    &#125;,\n    component: require(&#39;../views/Home.vue&#39;)\n  &#125;,\n  &#123;\n    name: &#39;UCenter&#39;,\n    path: &#39;/ucenter&#39;,\n    meta: &#123;\n      title: &#39;用户中心&#39;\n    &#125;,\n    component: require(&#39;../views/UCenter.vue&#39;)\n  &#125;\n];\n// ...\n</code></pre>\n<blockquote>\n<p>App.vue <strong>建议全局只使用一次该指令 标题可用 vuex 或者 router 中定义 不要多处使用!!</strong></p>\n</blockquote>\n<pre><code>&lt;!-- 任意元素中加 v-title 指令 建议将标题放在 route 对应meta对象的定义中 --&gt;\n&lt;div v-title=&quot;$route.meta.title&quot;&gt;&lt;/div&gt;\n&lt;!--or--&gt;\n&lt;router-view v-title=&quot;$route.meta.title&quot;&gt;&lt;/router-view&gt;\n</code></pre>\n<h2 id=\"使用场景-2：同一个路由不同状态需要手动设置-title\"><a href=\"#使用场景-2：同一个路由不同状态需要手动设置-title\" class=\"headerlink\" title=\"使用场景 2：同一个路由不同状态需要手动设置 title\"></a>使用场景 2：同一个路由不同状态需要手动设置 title</h2><pre><code>// 需要的地方直接调用\nthis.$setTitle(&#39;厉害了我的哥！&#39;);\n</code></pre>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h3 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h3><p>Vuejs 单页应用在 iOS 系统下部分 APP 的 webview 中 标题不能通过 document.title = xxx 的方式修改 该插件只为解决该问题而生(兼容安卓)</p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><blockquote>\n<p>Vuejs 2.x</p>\n</blockquote>\n<pre><code>npm install vue-titles --save\n</code></pre>\n<h5 id=\"ES6\"><a href=\"#ES6\" class=\"headerlink\" title=\"ES6\"></a>ES6</h5><blockquote>\n<p>main.js</p>\n</blockquote>\n<pre><code>Vue.use(require(&#39;vue-titles&#39;));\n</code></pre>\n<h2 id=\"使用场景-1-：单页面应用切换路由跳转更新-title\"><a href=\"#使用场景-1-：单页面应用切换路由跳转更新-title\" class=\"headerlink\" title=\"使用场景 1 ：单页面应用切换路由跳转更新 title\"></a>使用场景 1 ：单页面应用切换路由跳转更新 title</h2><blockquote>\n<p>路由定义(只截取一部分)</p>\n</blockquote>\n<pre><code>// ...\nconst routes = [\n  &#123;\n    name: &#39;Home&#39;,\n    path: &#39;/home&#39;,\n    meta: &#123;\n      title: &#39;首页&#39;\n    &#125;,\n    component: require(&#39;../views/Home.vue&#39;)\n  &#125;,\n  &#123;\n    name: &#39;UCenter&#39;,\n    path: &#39;/ucenter&#39;,\n    meta: &#123;\n      title: &#39;用户中心&#39;\n    &#125;,\n    component: require(&#39;../views/UCenter.vue&#39;)\n  &#125;\n];\n// ...\n</code></pre>\n<blockquote>\n<p>App.vue <strong>建议全局只使用一次该指令 标题可用 vuex 或者 router 中定义 不要多处使用!!</strong></p>\n</blockquote>\n<pre><code>&lt;!-- 任意元素中加 v-title 指令 建议将标题放在 route 对应meta对象的定义中 --&gt;\n&lt;div v-title=&quot;$route.meta.title&quot;&gt;&lt;/div&gt;\n&lt;!--or--&gt;\n&lt;router-view v-title=&quot;$route.meta.title&quot;&gt;&lt;/router-view&gt;\n</code></pre>\n<h2 id=\"使用场景-2：同一个路由不同状态需要手动设置-title\"><a href=\"#使用场景-2：同一个路由不同状态需要手动设置-title\" class=\"headerlink\" title=\"使用场景 2：同一个路由不同状态需要手动设置 title\"></a>使用场景 2：同一个路由不同状态需要手动设置 title</h2><pre><code>// 需要的地方直接调用\nthis.$setTitle(&#39;厉害了我的哥！&#39;);\n</code></pre>\n"},{"title":"说说到底什么是 BT 种子","url":"199.html","id":"199","date":"2019-07-05T06:47:45.000Z","_content":"\n> BT 种子和磁力链接是如何工作的？ 如何构建一个无法被审查和封禁的去中心化网络？\n\n![](https://cdn.sspai.com/article/0b5e11d6-3b9b-0068-0b02-4ba572cd8eee.jpg?imageMogr2/quality/95/thumbnail/!1440x480r/gravity/Center/crop/1440x480)**以下为视频逐字稿：** 如果你想要下载一集不存在的回形针视频，你会怎么做？ 最简单的方法当然是找一个有资源的哥们——每羊，让他把这期视频发给你。早期互联网，大家就是这么共享文件的，但是这样也有很多问题。 比如下载的人一多，每个人分配到的带宽就变小了，下载速度会变慢。更危险的是，这期视频是敏感资源，你的哥们本来就不应该分享给你，如果每羊被抓了，大家也都别下载了。 针对这些问题，美国工程师 Bram Cohen 在 2001 年发布了 BitTorrent 协议，资源不再由一个人或一个中心服务器提供，而是所有人提供给所有人，下载的人越多，速度越快。这种模式也叫 peer-to-peer（用户群对用户群），也就是我们常说的 P2P 下载。 BitTorrent 的核心思想是把文件分成很多个小块，让下载者互相连接。 以这支 117.3 MB 的视频为例，被分成了 895 个 128kB 的文件块后，下载了第 306 块的用户 A 就可以和下载了第 11 块的用户 B 交换彼此下载好的部分。参与的人越多，互相交换的就越密集，下载的越快。 为了做到这一点，BitTorrent 协议需要资源共享者生成一个包含下载信息的种子文件，后缀是 .torrent，这就是我们常说的 BT 种子。 种子文件包含文件的名字、大小，分块后每块文件的大小、哈希值，以及 Tracker 服务器的地址。 Tracker 很重要，通过 Tracker 我们才能找到其他下载者的联系方式。 当你用下载软件打开种子，就会开始联系种子文件里内置的 Tracker 服务器，告诉 Tracker 我要下载这个文件，服务器会记录下你的 IP，并把其他正在下载或下载完成的人的 IP 返回给你，这样你们就可以愉快的组队下载了。 当然，如果没有找到正在下载的人，资源发布者也不在线，你就只能以 0kb/s 的速度等着了。 不难发现，Tracker 服务器是 P2P 网络的弱点，如果 Tracker 被关闭或封禁，你就无法找到同伴，也难以完成下载。 为了摆脱对 Tracker 服务器的依赖，今天最流行的下载方式是磁力链接（Magnet URI scheme），通常是一串这样的神秘代码： `magnet:?xt=urn:btih:1a427c8498f72b9a27fde87662dbeb6fc043fc47` 前面都是标准格式，最重要的是这 40 个 16 进制的数字。任何文件丢进哈希算法都能得到一串这样字符，40 位、16 进制、只属于这个文件。你可以把它当成一个文件 ID，它能帮我们找到我们要下载的东西。 磁力链接的本质是把所有人都变成一个小型 Tracker，每个人都拿着一份动态更新的地址和文件信息。我找与我连接的 10 个人，他们再各自找 10 个人，一传十十传百、千、万，最后是我找到小明小明找老王老王找郭冬临郭冬临找到每羊，我和每羊就连上线了。 但这种所有人找所有人的方案其实不太行，不仅占用了大量的资源，效率也非常低，还有可能重复传播，造成广播灾难。 这时，就需要补充一个关键信息——距离。 注意，这里的距离，不是空间上的距离，而是逻辑上的距离。 重点来了！接下来，我会详细解释磁力链接使用的 DHT 网络的构建过程，有一点点难，但是真的非常有意思。让我们开始吧。 刚刚说了，每个磁力链接都有一串唯一的文件 ID，可以产生 2 的 (4*40) 即 2 的 160 次方种组合，用只有 0 和 1 的二进制表示就是 160 个 0 和 1。 而每个节点也有一串 160 位的 0 和 1，作为节点 ID。根据这 160 位数，我们可以计算节点和节点之间，节点和资源之间的距离。 假设每羊发布了一个文件，就能计算他所知道的节点 ID 与这个文件 ID 的距离，让算出来最距离最短的节点再计算它知道的节点和文件 ID 的距离，重复这个过程，就能找到与文件 ID 的距离最短的一批节点 ID，把每羊提供的下载信息存在这里。 这样，下载者也只要找到和文件 ID 距离接近的节点 ID，就能建立连接，开始下载。 但这个距离到底是怎么算出来的呢？ 这就是有趣的地方了，用异或算法来计算节点之间的逻辑距离，相同就是 0，不同就是 1。 为了方便你理解，我们简化一下模型，把 160 位缩减到 4 位。假设你的节点 ID 是 0100，目标节点 ID 是 1111，那么你们之间的二进制距离就是 1011，换算成十进制就是 11。 有了距离，我们就可以在一个这样的二叉树里快速查找目标了。 所有可能的节点 ID 都在这棵二叉树上。 4 位数需要分叉 4 次，生成 2 的 4 次方即 16 条路径，每条路径的终点，就是一个节点 ID。 接下来，你作为 0100，就可以拆分这颗二叉树了，从第一次分叉开始，把不包含你的那棵子树拆分，然后在剩下的子树的第二次分叉处再次拆分，直到只剩下你自己。 这样，就拆分出了 4 个子树。 我们在每个子树里选 2 个点，就得到了 4 个 K 桶，呃，不是这个，是这个，K-bucket。 暂停下来想想你就会发现，用异或算法计算 0 号 K 桶和你的距离是 0001，换算成十进制就是1，1 号 K 桶里 2 个点和你的距离是 2-3，以此类推，2 号 K 桶的距离区间是 4-7，3 号 K桶的距离区间是 8-15。 我们刚刚算过，你的节点 ID 0110 和目标 ID 1111 之间的二进制距离是 1011，换算成十进制是 11，也就是说，离 1111 最近的，肯定是 3 号 K 桶里的 2 个节点。 接下来，我们就可以联系这两个节点，让他们帮我们找 1111。 以 1110 为例。1110 也能拆分出 4 棵子树，得到 4 个 K 桶，计算 1110 和 1111 之间的距离，结果是 0001，换算成十进制是 1，也就是在 0 号 K 桶，1111 就在这里。 这种网络结构被称为 DHT，分布式哈希表（Distributed Hash Table），一个高宽容度的去中心化网络。只需要一串文件 ID和存储在本地的 K 桶数据，你就可以高效的找到要下载的文件。 而资源的发布者和传播者也只需要分享 40 个数字就好，足够简单，方便和隐私。 在真实的 DHT 网络，每个 K 桶至少记录了 8 个节点，任何一个节点下线，都不会影响整个网络的运行。 作为文件和节点 ID ，2 的 160 次方也足够大，大到全地球 70 亿人每秒下载 10000 个种子，也足够下载百万亿年直到宇宙终结。 这些天才们的设计，让我们拥有了一个无法被审查和追踪的去中心化网络。这催生了庞大的盗版产业，但也让很多内容有机会避开审查。 因为网站可以被隔离、被拔线、被禁止访问，但种子不会。只要种子不死，那些不存在的音乐图书和视频就还活在互联网上，没有任何人可以毁掉。","source":"_posts/e8-af-b4-e8-af-b4-e5-88-b0-e5-ba-95-e4-bb-80-e4-b9-88-e6-98-af-bt-e7-a7-8d-e5-ad-90.md","raw":"---\ntitle: 说说到底什么是 BT 种子\ntags:\n  - BT\n  - 种子\nurl: 199.html\nid: 199\ncategories:\n  - 杂谈\ndate: 2019-07-05 14:47:45\n---\n\n> BT 种子和磁力链接是如何工作的？ 如何构建一个无法被审查和封禁的去中心化网络？\n\n![](https://cdn.sspai.com/article/0b5e11d6-3b9b-0068-0b02-4ba572cd8eee.jpg?imageMogr2/quality/95/thumbnail/!1440x480r/gravity/Center/crop/1440x480)**以下为视频逐字稿：** 如果你想要下载一集不存在的回形针视频，你会怎么做？ 最简单的方法当然是找一个有资源的哥们——每羊，让他把这期视频发给你。早期互联网，大家就是这么共享文件的，但是这样也有很多问题。 比如下载的人一多，每个人分配到的带宽就变小了，下载速度会变慢。更危险的是，这期视频是敏感资源，你的哥们本来就不应该分享给你，如果每羊被抓了，大家也都别下载了。 针对这些问题，美国工程师 Bram Cohen 在 2001 年发布了 BitTorrent 协议，资源不再由一个人或一个中心服务器提供，而是所有人提供给所有人，下载的人越多，速度越快。这种模式也叫 peer-to-peer（用户群对用户群），也就是我们常说的 P2P 下载。 BitTorrent 的核心思想是把文件分成很多个小块，让下载者互相连接。 以这支 117.3 MB 的视频为例，被分成了 895 个 128kB 的文件块后，下载了第 306 块的用户 A 就可以和下载了第 11 块的用户 B 交换彼此下载好的部分。参与的人越多，互相交换的就越密集，下载的越快。 为了做到这一点，BitTorrent 协议需要资源共享者生成一个包含下载信息的种子文件，后缀是 .torrent，这就是我们常说的 BT 种子。 种子文件包含文件的名字、大小，分块后每块文件的大小、哈希值，以及 Tracker 服务器的地址。 Tracker 很重要，通过 Tracker 我们才能找到其他下载者的联系方式。 当你用下载软件打开种子，就会开始联系种子文件里内置的 Tracker 服务器，告诉 Tracker 我要下载这个文件，服务器会记录下你的 IP，并把其他正在下载或下载完成的人的 IP 返回给你，这样你们就可以愉快的组队下载了。 当然，如果没有找到正在下载的人，资源发布者也不在线，你就只能以 0kb/s 的速度等着了。 不难发现，Tracker 服务器是 P2P 网络的弱点，如果 Tracker 被关闭或封禁，你就无法找到同伴，也难以完成下载。 为了摆脱对 Tracker 服务器的依赖，今天最流行的下载方式是磁力链接（Magnet URI scheme），通常是一串这样的神秘代码： `magnet:?xt=urn:btih:1a427c8498f72b9a27fde87662dbeb6fc043fc47` 前面都是标准格式，最重要的是这 40 个 16 进制的数字。任何文件丢进哈希算法都能得到一串这样字符，40 位、16 进制、只属于这个文件。你可以把它当成一个文件 ID，它能帮我们找到我们要下载的东西。 磁力链接的本质是把所有人都变成一个小型 Tracker，每个人都拿着一份动态更新的地址和文件信息。我找与我连接的 10 个人，他们再各自找 10 个人，一传十十传百、千、万，最后是我找到小明小明找老王老王找郭冬临郭冬临找到每羊，我和每羊就连上线了。 但这种所有人找所有人的方案其实不太行，不仅占用了大量的资源，效率也非常低，还有可能重复传播，造成广播灾难。 这时，就需要补充一个关键信息——距离。 注意，这里的距离，不是空间上的距离，而是逻辑上的距离。 重点来了！接下来，我会详细解释磁力链接使用的 DHT 网络的构建过程，有一点点难，但是真的非常有意思。让我们开始吧。 刚刚说了，每个磁力链接都有一串唯一的文件 ID，可以产生 2 的 (4*40) 即 2 的 160 次方种组合，用只有 0 和 1 的二进制表示就是 160 个 0 和 1。 而每个节点也有一串 160 位的 0 和 1，作为节点 ID。根据这 160 位数，我们可以计算节点和节点之间，节点和资源之间的距离。 假设每羊发布了一个文件，就能计算他所知道的节点 ID 与这个文件 ID 的距离，让算出来最距离最短的节点再计算它知道的节点和文件 ID 的距离，重复这个过程，就能找到与文件 ID 的距离最短的一批节点 ID，把每羊提供的下载信息存在这里。 这样，下载者也只要找到和文件 ID 距离接近的节点 ID，就能建立连接，开始下载。 但这个距离到底是怎么算出来的呢？ 这就是有趣的地方了，用异或算法来计算节点之间的逻辑距离，相同就是 0，不同就是 1。 为了方便你理解，我们简化一下模型，把 160 位缩减到 4 位。假设你的节点 ID 是 0100，目标节点 ID 是 1111，那么你们之间的二进制距离就是 1011，换算成十进制就是 11。 有了距离，我们就可以在一个这样的二叉树里快速查找目标了。 所有可能的节点 ID 都在这棵二叉树上。 4 位数需要分叉 4 次，生成 2 的 4 次方即 16 条路径，每条路径的终点，就是一个节点 ID。 接下来，你作为 0100，就可以拆分这颗二叉树了，从第一次分叉开始，把不包含你的那棵子树拆分，然后在剩下的子树的第二次分叉处再次拆分，直到只剩下你自己。 这样，就拆分出了 4 个子树。 我们在每个子树里选 2 个点，就得到了 4 个 K 桶，呃，不是这个，是这个，K-bucket。 暂停下来想想你就会发现，用异或算法计算 0 号 K 桶和你的距离是 0001，换算成十进制就是1，1 号 K 桶里 2 个点和你的距离是 2-3，以此类推，2 号 K 桶的距离区间是 4-7，3 号 K桶的距离区间是 8-15。 我们刚刚算过，你的节点 ID 0110 和目标 ID 1111 之间的二进制距离是 1011，换算成十进制是 11，也就是说，离 1111 最近的，肯定是 3 号 K 桶里的 2 个节点。 接下来，我们就可以联系这两个节点，让他们帮我们找 1111。 以 1110 为例。1110 也能拆分出 4 棵子树，得到 4 个 K 桶，计算 1110 和 1111 之间的距离，结果是 0001，换算成十进制是 1，也就是在 0 号 K 桶，1111 就在这里。 这种网络结构被称为 DHT，分布式哈希表（Distributed Hash Table），一个高宽容度的去中心化网络。只需要一串文件 ID和存储在本地的 K 桶数据，你就可以高效的找到要下载的文件。 而资源的发布者和传播者也只需要分享 40 个数字就好，足够简单，方便和隐私。 在真实的 DHT 网络，每个 K 桶至少记录了 8 个节点，任何一个节点下线，都不会影响整个网络的运行。 作为文件和节点 ID ，2 的 160 次方也足够大，大到全地球 70 亿人每秒下载 10000 个种子，也足够下载百万亿年直到宇宙终结。 这些天才们的设计，让我们拥有了一个无法被审查和追踪的去中心化网络。这催生了庞大的盗版产业，但也让很多内容有机会避开审查。 因为网站可以被隔离、被拔线、被禁止访问，但种子不会。只要种子不死，那些不存在的音乐图书和视频就还活在互联网上，没有任何人可以毁掉。","slug":"e8-af-b4-e8-af-b4-e5-88-b0-e5-ba-95-e4-bb-80-e4-b9-88-e6-98-af-bt-e7-a7-8d-e5-ad-90","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269cz002xc8gsfqr8gocn","content":"<blockquote>\n<p>BT 种子和磁力链接是如何工作的？ 如何构建一个无法被审查和封禁的去中心化网络？</p>\n</blockquote>\n<p><img src=\"https://cdn.sspai.com/article/0b5e11d6-3b9b-0068-0b02-4ba572cd8eee.jpg?imageMogr2/quality/95/thumbnail/!1440x480r/gravity/Center/crop/1440x480\"><strong>以下为视频逐字稿：</strong> 如果你想要下载一集不存在的回形针视频，你会怎么做？ 最简单的方法当然是找一个有资源的哥们——每羊，让他把这期视频发给你。早期互联网，大家就是这么共享文件的，但是这样也有很多问题。 比如下载的人一多，每个人分配到的带宽就变小了，下载速度会变慢。更危险的是，这期视频是敏感资源，你的哥们本来就不应该分享给你，如果每羊被抓了，大家也都别下载了。 针对这些问题，美国工程师 Bram Cohen 在 2001 年发布了 BitTorrent 协议，资源不再由一个人或一个中心服务器提供，而是所有人提供给所有人，下载的人越多，速度越快。这种模式也叫 peer-to-peer（用户群对用户群），也就是我们常说的 P2P 下载。 BitTorrent 的核心思想是把文件分成很多个小块，让下载者互相连接。 以这支 117.3 MB 的视频为例，被分成了 895 个 128kB 的文件块后，下载了第 306 块的用户 A 就可以和下载了第 11 块的用户 B 交换彼此下载好的部分。参与的人越多，互相交换的就越密集，下载的越快。 为了做到这一点，BitTorrent 协议需要资源共享者生成一个包含下载信息的种子文件，后缀是 .torrent，这就是我们常说的 BT 种子。 种子文件包含文件的名字、大小，分块后每块文件的大小、哈希值，以及 Tracker 服务器的地址。 Tracker 很重要，通过 Tracker 我们才能找到其他下载者的联系方式。 当你用下载软件打开种子，就会开始联系种子文件里内置的 Tracker 服务器，告诉 Tracker 我要下载这个文件，服务器会记录下你的 IP，并把其他正在下载或下载完成的人的 IP 返回给你，这样你们就可以愉快的组队下载了。 当然，如果没有找到正在下载的人，资源发布者也不在线，你就只能以 0kb/s 的速度等着了。 不难发现，Tracker 服务器是 P2P 网络的弱点，如果 Tracker 被关闭或封禁，你就无法找到同伴，也难以完成下载。 为了摆脱对 Tracker 服务器的依赖，今天最流行的下载方式是磁力链接（Magnet URI scheme），通常是一串这样的神秘代码： <code>magnet:?xt=urn:btih:1a427c8498f72b9a27fde87662dbeb6fc043fc47</code> 前面都是标准格式，最重要的是这 40 个 16 进制的数字。任何文件丢进哈希算法都能得到一串这样字符，40 位、16 进制、只属于这个文件。你可以把它当成一个文件 ID，它能帮我们找到我们要下载的东西。 磁力链接的本质是把所有人都变成一个小型 Tracker，每个人都拿着一份动态更新的地址和文件信息。我找与我连接的 10 个人，他们再各自找 10 个人，一传十十传百、千、万，最后是我找到小明小明找老王老王找郭冬临郭冬临找到每羊，我和每羊就连上线了。 但这种所有人找所有人的方案其实不太行，不仅占用了大量的资源，效率也非常低，还有可能重复传播，造成广播灾难。 这时，就需要补充一个关键信息——距离。 注意，这里的距离，不是空间上的距离，而是逻辑上的距离。 重点来了！接下来，我会详细解释磁力链接使用的 DHT 网络的构建过程，有一点点难，但是真的非常有意思。让我们开始吧。 刚刚说了，每个磁力链接都有一串唯一的文件 ID，可以产生 2 的 (4*40) 即 2 的 160 次方种组合，用只有 0 和 1 的二进制表示就是 160 个 0 和 1。 而每个节点也有一串 160 位的 0 和 1，作为节点 ID。根据这 160 位数，我们可以计算节点和节点之间，节点和资源之间的距离。 假设每羊发布了一个文件，就能计算他所知道的节点 ID 与这个文件 ID 的距离，让算出来最距离最短的节点再计算它知道的节点和文件 ID 的距离，重复这个过程，就能找到与文件 ID 的距离最短的一批节点 ID，把每羊提供的下载信息存在这里。 这样，下载者也只要找到和文件 ID 距离接近的节点 ID，就能建立连接，开始下载。 但这个距离到底是怎么算出来的呢？ 这就是有趣的地方了，用异或算法来计算节点之间的逻辑距离，相同就是 0，不同就是 1。 为了方便你理解，我们简化一下模型，把 160 位缩减到 4 位。假设你的节点 ID 是 0100，目标节点 ID 是 1111，那么你们之间的二进制距离就是 1011，换算成十进制就是 11。 有了距离，我们就可以在一个这样的二叉树里快速查找目标了。 所有可能的节点 ID 都在这棵二叉树上。 4 位数需要分叉 4 次，生成 2 的 4 次方即 16 条路径，每条路径的终点，就是一个节点 ID。 接下来，你作为 0100，就可以拆分这颗二叉树了，从第一次分叉开始，把不包含你的那棵子树拆分，然后在剩下的子树的第二次分叉处再次拆分，直到只剩下你自己。 这样，就拆分出了 4 个子树。 我们在每个子树里选 2 个点，就得到了 4 个 K 桶，呃，不是这个，是这个，K-bucket。 暂停下来想想你就会发现，用异或算法计算 0 号 K 桶和你的距离是 0001，换算成十进制就是1，1 号 K 桶里 2 个点和你的距离是 2-3，以此类推，2 号 K 桶的距离区间是 4-7，3 号 K桶的距离区间是 8-15。 我们刚刚算过，你的节点 ID 0110 和目标 ID 1111 之间的二进制距离是 1011，换算成十进制是 11，也就是说，离 1111 最近的，肯定是 3 号 K 桶里的 2 个节点。 接下来，我们就可以联系这两个节点，让他们帮我们找 1111。 以 1110 为例。1110 也能拆分出 4 棵子树，得到 4 个 K 桶，计算 1110 和 1111 之间的距离，结果是 0001，换算成十进制是 1，也就是在 0 号 K 桶，1111 就在这里。 这种网络结构被称为 DHT，分布式哈希表（Distributed Hash Table），一个高宽容度的去中心化网络。只需要一串文件 ID和存储在本地的 K 桶数据，你就可以高效的找到要下载的文件。 而资源的发布者和传播者也只需要分享 40 个数字就好，足够简单，方便和隐私。 在真实的 DHT 网络，每个 K 桶至少记录了 8 个节点，任何一个节点下线，都不会影响整个网络的运行。 作为文件和节点 ID ，2 的 160 次方也足够大，大到全地球 70 亿人每秒下载 10000 个种子，也足够下载百万亿年直到宇宙终结。 这些天才们的设计，让我们拥有了一个无法被审查和追踪的去中心化网络。这催生了庞大的盗版产业，但也让很多内容有机会避开审查。 因为网站可以被隔离、被拔线、被禁止访问，但种子不会。只要种子不死，那些不存在的音乐图书和视频就还活在互联网上，没有任何人可以毁掉。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<blockquote>\n<p>BT 种子和磁力链接是如何工作的？ 如何构建一个无法被审查和封禁的去中心化网络？</p>\n</blockquote>\n<p><img src=\"https://cdn.sspai.com/article/0b5e11d6-3b9b-0068-0b02-4ba572cd8eee.jpg?imageMogr2/quality/95/thumbnail/!1440x480r/gravity/Center/crop/1440x480\"><strong>以下为视频逐字稿：</strong> 如果你想要下载一集不存在的回形针视频，你会怎么做？ 最简单的方法当然是找一个有资源的哥们——每羊，让他把这期视频发给你。早期互联网，大家就是这么共享文件的，但是这样也有很多问题。 比如下载的人一多，每个人分配到的带宽就变小了，下载速度会变慢。更危险的是，这期视频是敏感资源，你的哥们本来就不应该分享给你，如果每羊被抓了，大家也都别下载了。 针对这些问题，美国工程师 Bram Cohen 在 2001 年发布了 BitTorrent 协议，资源不再由一个人或一个中心服务器提供，而是所有人提供给所有人，下载的人越多，速度越快。这种模式也叫 peer-to-peer（用户群对用户群），也就是我们常说的 P2P 下载。 BitTorrent 的核心思想是把文件分成很多个小块，让下载者互相连接。 以这支 117.3 MB 的视频为例，被分成了 895 个 128kB 的文件块后，下载了第 306 块的用户 A 就可以和下载了第 11 块的用户 B 交换彼此下载好的部分。参与的人越多，互相交换的就越密集，下载的越快。 为了做到这一点，BitTorrent 协议需要资源共享者生成一个包含下载信息的种子文件，后缀是 .torrent，这就是我们常说的 BT 种子。 种子文件包含文件的名字、大小，分块后每块文件的大小、哈希值，以及 Tracker 服务器的地址。 Tracker 很重要，通过 Tracker 我们才能找到其他下载者的联系方式。 当你用下载软件打开种子，就会开始联系种子文件里内置的 Tracker 服务器，告诉 Tracker 我要下载这个文件，服务器会记录下你的 IP，并把其他正在下载或下载完成的人的 IP 返回给你，这样你们就可以愉快的组队下载了。 当然，如果没有找到正在下载的人，资源发布者也不在线，你就只能以 0kb/s 的速度等着了。 不难发现，Tracker 服务器是 P2P 网络的弱点，如果 Tracker 被关闭或封禁，你就无法找到同伴，也难以完成下载。 为了摆脱对 Tracker 服务器的依赖，今天最流行的下载方式是磁力链接（Magnet URI scheme），通常是一串这样的神秘代码： <code>magnet:?xt=urn:btih:1a427c8498f72b9a27fde87662dbeb6fc043fc47</code> 前面都是标准格式，最重要的是这 40 个 16 进制的数字。任何文件丢进哈希算法都能得到一串这样字符，40 位、16 进制、只属于这个文件。你可以把它当成一个文件 ID，它能帮我们找到我们要下载的东西。 磁力链接的本质是把所有人都变成一个小型 Tracker，每个人都拿着一份动态更新的地址和文件信息。我找与我连接的 10 个人，他们再各自找 10 个人，一传十十传百、千、万，最后是我找到小明小明找老王老王找郭冬临郭冬临找到每羊，我和每羊就连上线了。 但这种所有人找所有人的方案其实不太行，不仅占用了大量的资源，效率也非常低，还有可能重复传播，造成广播灾难。 这时，就需要补充一个关键信息——距离。 注意，这里的距离，不是空间上的距离，而是逻辑上的距离。 重点来了！接下来，我会详细解释磁力链接使用的 DHT 网络的构建过程，有一点点难，但是真的非常有意思。让我们开始吧。 刚刚说了，每个磁力链接都有一串唯一的文件 ID，可以产生 2 的 (4*40) 即 2 的 160 次方种组合，用只有 0 和 1 的二进制表示就是 160 个 0 和 1。 而每个节点也有一串 160 位的 0 和 1，作为节点 ID。根据这 160 位数，我们可以计算节点和节点之间，节点和资源之间的距离。 假设每羊发布了一个文件，就能计算他所知道的节点 ID 与这个文件 ID 的距离，让算出来最距离最短的节点再计算它知道的节点和文件 ID 的距离，重复这个过程，就能找到与文件 ID 的距离最短的一批节点 ID，把每羊提供的下载信息存在这里。 这样，下载者也只要找到和文件 ID 距离接近的节点 ID，就能建立连接，开始下载。 但这个距离到底是怎么算出来的呢？ 这就是有趣的地方了，用异或算法来计算节点之间的逻辑距离，相同就是 0，不同就是 1。 为了方便你理解，我们简化一下模型，把 160 位缩减到 4 位。假设你的节点 ID 是 0100，目标节点 ID 是 1111，那么你们之间的二进制距离就是 1011，换算成十进制就是 11。 有了距离，我们就可以在一个这样的二叉树里快速查找目标了。 所有可能的节点 ID 都在这棵二叉树上。 4 位数需要分叉 4 次，生成 2 的 4 次方即 16 条路径，每条路径的终点，就是一个节点 ID。 接下来，你作为 0100，就可以拆分这颗二叉树了，从第一次分叉开始，把不包含你的那棵子树拆分，然后在剩下的子树的第二次分叉处再次拆分，直到只剩下你自己。 这样，就拆分出了 4 个子树。 我们在每个子树里选 2 个点，就得到了 4 个 K 桶，呃，不是这个，是这个，K-bucket。 暂停下来想想你就会发现，用异或算法计算 0 号 K 桶和你的距离是 0001，换算成十进制就是1，1 号 K 桶里 2 个点和你的距离是 2-3，以此类推，2 号 K 桶的距离区间是 4-7，3 号 K桶的距离区间是 8-15。 我们刚刚算过，你的节点 ID 0110 和目标 ID 1111 之间的二进制距离是 1011，换算成十进制是 11，也就是说，离 1111 最近的，肯定是 3 号 K 桶里的 2 个节点。 接下来，我们就可以联系这两个节点，让他们帮我们找 1111。 以 1110 为例。1110 也能拆分出 4 棵子树，得到 4 个 K 桶，计算 1110 和 1111 之间的距离，结果是 0001，换算成十进制是 1，也就是在 0 号 K 桶，1111 就在这里。 这种网络结构被称为 DHT，分布式哈希表（Distributed Hash Table），一个高宽容度的去中心化网络。只需要一串文件 ID和存储在本地的 K 桶数据，你就可以高效的找到要下载的文件。 而资源的发布者和传播者也只需要分享 40 个数字就好，足够简单，方便和隐私。 在真实的 DHT 网络，每个 K 桶至少记录了 8 个节点，任何一个节点下线，都不会影响整个网络的运行。 作为文件和节点 ID ，2 的 160 次方也足够大，大到全地球 70 亿人每秒下载 10000 个种子，也足够下载百万亿年直到宇宙终结。 这些天才们的设计，让我们拥有了一个无法被审查和追踪的去中心化网络。这催生了庞大的盗版产业，但也让很多内容有机会避开审查。 因为网站可以被隔离、被拔线、被禁止访问，但种子不会。只要种子不死，那些不存在的音乐图书和视频就还活在互联网上，没有任何人可以毁掉。</p>\n"},{"title":"首涂简约SEO模板，去首页广告脚本","url":"294.html","id":"294","date":"2019-08-21T07:52:23.000Z","_content":"\n首涂简洁 SEO 模板，响应式支持手机版，模板简单加载速度很快。 来源网络，已经去掉首页广告脚本分享给需要的人。 ![](https://www.v5ant.com/wp-content/uploads/2019/08/WX20190821-160002@2x.png) ![](https://www.v5ant.com/wp-content/uploads/2019/08/WX20190821-160026@2x.png)\n","source":"_posts/e9-a6-96-e6-b6-82-e7-ae-80-e7-ba-a6seo-e6-a8-a1-e6-9d-bf-ef-bc-8c-e5-8e-bb-e9-a6-96-e9-a1-b5-e5-b9-bf-e5-91-8a-e8-84-9a-e6-9c-ac.md","raw":"---\ntitle: 首涂简约SEO模板，去首页广告脚本\ntags:\n  - maccms10\n  - 模板\nurl: 294.html\nid: 294\ncategories:\n  - 精选资源\ndate: 2019-08-21 15:52:23\n---\n\n首涂简洁 SEO 模板，响应式支持手机版，模板简单加载速度很快。 来源网络，已经去掉首页广告脚本分享给需要的人。 ![](https://www.v5ant.com/wp-content/uploads/2019/08/WX20190821-160002@2x.png) ![](https://www.v5ant.com/wp-content/uploads/2019/08/WX20190821-160026@2x.png)\n","slug":"e9-a6-96-e6-b6-82-e7-ae-80-e7-ba-a6seo-e6-a8-a1-e6-9d-bf-ef-bc-8c-e5-8e-bb-e9-a6-96-e9-a1-b5-e5-b9-bf-e5-91-8a-e8-84-9a-e6-9c-ac","published":1,"updated":"2019-09-11T03:08:30.666Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269dc0030c8gs417p1plq","content":"<p>首涂简洁 SEO 模板，响应式支持手机版，模板简单加载速度很快。 来源网络，已经去掉首页广告脚本分享给需要的人。 <img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/WX20190821-160002@2x.png\"> <img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/WX20190821-160026@2x.png\"></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>首涂简洁 SEO 模板，响应式支持手机版，模板简单加载速度很快。 来源网络，已经去掉首页广告脚本分享给需要的人。 <img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/WX20190821-160002@2x.png\"> <img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/WX20190821-160026@2x.png\"></p>\n"},{"title":"eslint配置参考中文解释","url":"187.html","id":"187","date":"2019-06-26T02:39:11.000Z","_content":"\n**package.json文件中eslint的配置（以下是vue-cli的默认配置）**\n\n    \"eslintConfig\": {\n         \"root\": true,////此项是用来告诉eslint找当前配置文件不能往父级查找\n         \"env\": {\n           \"node\": true//此项指定环境的全局变量，下面的配置指定为node环境\n         },\n         \"extends\": [// 此项是用来配置vue.js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错\n           \"plugin:vue/essential\",\n           \"@vue/standard\"\n         ],\n         \"rules\": {//规则配置写在这里\n           \"indent\": [1, 4]\n         },\n         \"parserOptions\": {\n           \"parser\": \"babel-eslint\"//此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析\n         }\n       },\n\n    rules: {\n        \"规则名\": [规则值, 规则配置]\n    }\n\n`\"off\"或者0 //关闭规则关闭 \"warn\"或者1 //在打开的规则作为警告（不影响退出代码） \"error\"或者2 //把规则作为一个错误（退出代码触发时为1）` **eslint 规则配置参数**\n\n    \"no-alert\": 0,//禁止使用alert confirm prompt\n    \"no-array-constructor\": 2,//禁止使用数组构造器\n    \"no-bitwise\": 0,//禁止使用按位运算符\n    \"no-caller\": 1,//禁止使用arguments.caller或arguments.callee\n    \"no-catch-shadow\": 2,//禁止catch子句参数与外部作用域变量同名\n    \"no-class-assign\": 2,//禁止给类赋值\n    \"no-cond-assign\": 2,//禁止在条件表达式中使用赋值语句\n    \"no-console\": 2,//禁止使用console\n    \"no-const-assign\": 2,//禁止修改const声明的变量\n    \"no-constant-condition\": 2,//禁止在条件中使用常量表达式 if(true) if(1)\n    \"no-continue\": 0,//禁止使用continue\n    \"no-control-regex\": 2,//禁止在正则表达式中使用控制字符\n    \"no-debugger\": 2,//禁止使用debugger\n    \"no-delete-var\": 2,//不能对var声明的变量使用delete操作符\n    \"no-div-regex\": 1,//不能使用看起来像除法的正则表达式/=foo/\n    \"no-dupe-keys\": 2,//在创建对象字面量时不允许键重复 {a:1,a:1}\n    \"no-dupe-args\": 2,//函数参数不能重复\n    \"no-duplicate-case\": 2,//switch中的case标签不能重复\n    \"no-else-return\": 2,//如果if语句里面有return,后面不能跟else语句\n    \"no-empty\": 2,//块语句中的内容不能为空\n    \"no-empty-character-class\": 2,//正则表达式中的[]内容不能为空\n    \"no-empty-label\": 2,//禁止使用空label\n    \"no-eq-null\": 2,//禁止对null使用==或!=运算符\n    \"no-eval\": 1,//禁止使用eval\n    \"no-ex-assign\": 2,//禁止给catch语句中的异常参数赋值\n    \"no-extend-native\": 2,//禁止扩展native对象\n    \"no-extra-bind\": 2,//禁止不必要的函数绑定\n    \"no-extra-boolean-cast\": 2,//禁止不必要的bool转换\n    \"no-extra-parens\": 2,//禁止非必要的括号\n    \"no-extra-semi\": 2,//禁止多余的冒号\n    \"no-fallthrough\": 1,//禁止switch穿透\n    \"no-floating-decimal\": 2,//禁止省略浮点数中的0 .5 3.\n    \"no-func-assign\": 2,//禁止重复的函数声明\n    \"no-implicit-coercion\": 1,//禁止隐式转换\n    \"no-implied-eval\": 2,//禁止使用隐式eval\n    \"no-inline-comments\": 0,//禁止行内备注\n    \"no-inner-declarations\": [2, \"functions\"],//禁止在块语句中使用声明（变量或函数）\n    \"no-invalid-regexp\": 2,//禁止无效的正则表达式\n    \"no-invalid-this\": 2,//禁止无效的this，只能用在构造器，类，对象字面量\n    \"no-irregular-whitespace\": 2,//不能有不规则的空格\n    \"no-iterator\": 2,//禁止使用__iterator__ 属性\n    \"no-label-var\": 2,//label名不能与var声明的变量名相同\n    \"no-labels\": 2,//禁止标签声明\n    \"no-lone-blocks\": 2,//禁止不必要的嵌套块\n    \"no-lonely-if\": 2,//禁止else语句内只有if语句\n    \"no-loop-func\": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）\n    \"no-mixed-requires\": [0, false],//声明时不能混用声明类型\n    \"no-mixed-spaces-and-tabs\": [2, false],//禁止混用tab和空格\n    \"linebreak-style\": [0, \"windows\"],//换行风格\n    \"no-multi-spaces\": 1,//不能用多余的空格\n    \"no-multi-str\": 2,//字符串不能用\\换行\n    \"no-multiple-empty-lines\": [1, {\"max\": 2}],//空行最多不能超过2行\n    \"no-native-reassign\": 2,//不能重写native对象\n    \"no-negated-in-lhs\": 2,//in 操作符的左边不能有!\n    \"no-nested-ternary\": 0,//禁止使用嵌套的三目运算\n    \"no-new\": 1,//禁止在使用new构造一个实例后不赋值\n    \"no-new-func\": 1,//禁止使用new Function\n    \"no-new-object\": 2,//禁止使用new Object()\n    \"no-new-require\": 2,//禁止使用new require\n    \"no-new-wrappers\": 2,//禁止使用new创建包装实例，new String new Boolean new Number\n    \"no-obj-calls\": 2,//不能调用内置的全局对象，比如Math() JSON()\n    \"no-octal\": 2,//禁止使用八进制数字\n    \"no-octal-escape\": 2,//禁止使用八进制转义序列\n    \"no-param-reassign\": 2,//禁止给参数重新赋值\n    \"no-path-concat\": 0,//node中不能使用__dirname或__filename做路径拼接\n    \"no-plusplus\": 0,//禁止使用++，--\n    \"no-process-env\": 0,//禁止使用process.env\n    \"no-process-exit\": 0,//禁止使用process.exit()\n    \"no-proto\": 2,//禁止使用__proto__属性\n    \"no-redeclare\": 2,//禁止重复声明变量\n    \"no-regex-spaces\": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/\n    \"no-restricted-modules\": 0,//如果禁用了指定模块，使用就会报错\n    \"no-return-assign\": 1,//return 语句中不能有赋值表达式\n    \"no-script-url\": 0,//禁止使用javascript:void(0)\n    \"no-self-compare\": 2,//不能比较自身\n    \"no-sequences\": 0,//禁止使用逗号运算符\n    \"no-shadow\": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名\n    \"no-shadow-restricted-names\": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用\n    \"no-spaced-func\": 2,//函数调用时 函数名与()之间不能有空格\n    \"no-sparse-arrays\": 2,//禁止稀疏数组， [1,,2]\n    \"no-sync\": 0,//nodejs 禁止同步方法\n    \"no-ternary\": 0,//禁止使用三目运算符\n    \"no-trailing-spaces\": 1,//一行结束后面不要有空格\n    \"no-this-before-super\": 0,//在调用super()之前不能使用this或super\n    \"no-throw-literal\": 2,//禁止抛出字面量错误 throw \"error\";\n    \"no-undef\": 1,//不能有未定义的变量\n    \"no-undef-init\": 2,//变量初始化时不能直接给它赋值为undefined\n    \"no-undefined\": 2,//不能使用undefined\n    \"no-unexpected-multiline\": 2,//避免多行表达式\n    \"no-underscore-dangle\": 1,//标识符不能以_开头或结尾\n    \"no-unneeded-ternary\": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;\n    \"no-unreachable\": 2,//不能有无法执行的代码\n    \"no-unused-expressions\": 2,//禁止无用的表达式\n    \"no-unused-vars\": [2, {\"vars\": \"all\", \"args\": \"after-used\"}],//不能有声明后未被使用的变量或参数\n    \"no-use-before-define\": 2,//未定义前不能使用\n    \"no-useless-call\": 2,//禁止不必要的call和apply\n    \"no-void\": 2,//禁用void操作符\n    \"no-var\": 0,//禁用var，用let和const代替\n    \"no-warning-comments\": [1, { \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" }],//不能有警告备注\n    \"no-with\": 2,//禁用with\n    \n    \"array-bracket-spacing\": [2, \"never\"],//是否允许非空数组里面有多余的空格\n    \"arrow-parens\": 0,//箭头函数用小括号括起来\n    \"arrow-spacing\": 0,//=>的前/后括号\n    \"accessor-pairs\": 0,//在对象中使用getter/setter\n    \"block-scoped-var\": 0,//块语句中使用var\n    \"brace-style\": [1, \"1tbs\"],//大括号风格\n    \"callback-return\": 1,//避免多次调用回调什么的\n    \"camelcase\": 2,//强制驼峰法命名\n    \"comma-dangle\": [2, \"never\"],//对象字面量项尾不能有逗号\n    \"comma-spacing\": 0,//逗号前后的空格\n    \"comma-style\": [2, \"last\"],//逗号风格，换行时在行首还是行尾\n    \"complexity\": [0, 11],//循环复杂度\n    \"computed-property-spacing\": [0, \"never\"],//是否允许计算后的键名什么的\n    \"consistent-return\": 0,//return 后面是否允许省略\n    \"consistent-this\": [2, \"that\"],//this别名\n    \"constructor-super\": 0,//非派生类不能调用super，派生类必须调用super\n    \"curly\": [2, \"all\"],//必须使用 if(){} 中的{}\n    \"default-case\": 2,//switch语句最后必须有default\n    \"dot-location\": 0,//对象访问符的位置，换行的时候在行首还是行尾\n    \"dot-notation\": [0, { \"allowKeywords\": true }],//避免不必要的方括号\n    \"eol-last\": 0,//文件以单一的换行符结束\n    \"eqeqeq\": 2,//必须使用全等\n    \"func-names\": 0,//函数表达式必须有名字\n    \"func-style\": [0, \"declaration\"],//函数风格，规定只能使用函数声明/函数表达式\n    \"generator-star-spacing\": 0,//生成器函数*的前后空格\n    \"guard-for-in\": 0,//for in循环要用if语句过滤\n    \"handle-callback-err\": 0,//nodejs 处理错误\n    \"id-length\": 0,//变量名长度\n    \"indent\": [2, 4],//缩进风格\n    \"init-declarations\": 0,//声明时必须赋初值\n    \"key-spacing\": [0, { \"beforeColon\": false, \"afterColon\": true }],//对象字面量中冒号的前后空格\n    \"lines-around-comment\": 0,//行前/行后备注\n    \"max-depth\": [0, 4],//嵌套块深度\n    \"max-len\": [0, 80, 4],//字符串最大长度\n    \"max-nested-callbacks\": [0, 2],//回调嵌套深度\n    \"max-params\": [0, 3],//函数最多只能有3个参数\n    \"max-statements\": [0, 10],//函数内最多有几个声明\n    \"new-cap\": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用\n    \"new-parens\": 2,//new时必须加小括号\n    \"newline-after-var\": 2,//变量声明后是否需要空一行\n    \"object-curly-spacing\": [0, \"never\"],//大括号内是否允许不必要的空格\n    \"object-shorthand\": 0,//强制对象字面量缩写语法\n    \"one-var\": 1,//连续声明\n    \"operator-assignment\": [0, \"always\"],//赋值运算符 += -=什么的\n    \"operator-linebreak\": [2, \"after\"],//换行时运算符在行尾还是行首\n    \"padded-blocks\": 0,//块语句内行首行尾是否要空行\n    \"prefer-const\": 0,//首选const\n    \"prefer-spread\": 0,//首选展开运算\n    \"prefer-reflect\": 0,//首选Reflect的方法\n    \"quotes\": [1, \"single\"],//引号类型 `` \"\" ''\n    \"quote-props\":[2, \"always\"],//对象字面量中的属性名是否强制双引号\n    \"radix\": 2,//parseInt必须指定第二个参数\n    \"id-match\": 0,//命名检测\n    \"require-yield\": 0,//生成器函数必须有yield\n    \"semi\": [2, \"always\"],//语句强制分号结尾\n    \"semi-spacing\": [0, {\"before\": false, \"after\": true}],//分号前后空格\n    \"sort-vars\": 0,//变量声明时排序\n    \"space-after-keywords\": [0, \"always\"],//关键字后面是否要空一格\n    \"space-before-blocks\": [0, \"always\"],//不以新行开始的块{前面要不要有空格\n    \"space-before-function-paren\": [0, \"always\"],//函数定义时括号前面要不要有空格\n    \"space-in-parens\": [0, \"never\"],//小括号里面要不要有空格\n    \"space-infix-ops\": 0,//中缀操作符周围要不要有空格\n    \"space-return-throw-case\": 2,//return throw case后面要不要加空格\n    \"space-unary-ops\": [0, { \"words\": true, \"nonwords\": false }],//一元运算符的前/后要不要加空格\n    \"spaced-comment\": 0,//注释风格要不要有空格什么的\n    \"strict\": 2,//使用严格模式\n    \"use-isnan\": 2,//禁止比较时使用NaN，只能用isNaN()\n    \"valid-jsdoc\": 0,//jsdoc规则\n    \"valid-typeof\": 2,//必须使用合法的typeof的值\n    \"vars-on-top\": 2,//var必须放在作用域顶部\n    \"wrap-iife\": [2, \"inside\"],//立即执行函数表达式的小括号风格\n    \"wrap-regex\": 0,//正则表达式字面量用小括号包起来\n    \"yoda\": [2, \"never\"]//禁止尤达条件","source":"_posts/eslint-e9-85-8d-e7-bd-ae-e5-8f-82-e8-80-83-e4-b8-ad-e6-96-87-e8-a7-a3-e9-87-8a.md","raw":"---\ntitle: eslint配置参考中文解释\ntags:\n  - eslint\n  - JavaScrip\n  - vue-cli\nurl: 187.html\nid: 187\ncategories:\n  - 大前端\ndate: 2019-06-26 10:39:11\n---\n\n**package.json文件中eslint的配置（以下是vue-cli的默认配置）**\n\n    \"eslintConfig\": {\n         \"root\": true,////此项是用来告诉eslint找当前配置文件不能往父级查找\n         \"env\": {\n           \"node\": true//此项指定环境的全局变量，下面的配置指定为node环境\n         },\n         \"extends\": [// 此项是用来配置vue.js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错\n           \"plugin:vue/essential\",\n           \"@vue/standard\"\n         ],\n         \"rules\": {//规则配置写在这里\n           \"indent\": [1, 4]\n         },\n         \"parserOptions\": {\n           \"parser\": \"babel-eslint\"//此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析\n         }\n       },\n\n    rules: {\n        \"规则名\": [规则值, 规则配置]\n    }\n\n`\"off\"或者0 //关闭规则关闭 \"warn\"或者1 //在打开的规则作为警告（不影响退出代码） \"error\"或者2 //把规则作为一个错误（退出代码触发时为1）` **eslint 规则配置参数**\n\n    \"no-alert\": 0,//禁止使用alert confirm prompt\n    \"no-array-constructor\": 2,//禁止使用数组构造器\n    \"no-bitwise\": 0,//禁止使用按位运算符\n    \"no-caller\": 1,//禁止使用arguments.caller或arguments.callee\n    \"no-catch-shadow\": 2,//禁止catch子句参数与外部作用域变量同名\n    \"no-class-assign\": 2,//禁止给类赋值\n    \"no-cond-assign\": 2,//禁止在条件表达式中使用赋值语句\n    \"no-console\": 2,//禁止使用console\n    \"no-const-assign\": 2,//禁止修改const声明的变量\n    \"no-constant-condition\": 2,//禁止在条件中使用常量表达式 if(true) if(1)\n    \"no-continue\": 0,//禁止使用continue\n    \"no-control-regex\": 2,//禁止在正则表达式中使用控制字符\n    \"no-debugger\": 2,//禁止使用debugger\n    \"no-delete-var\": 2,//不能对var声明的变量使用delete操作符\n    \"no-div-regex\": 1,//不能使用看起来像除法的正则表达式/=foo/\n    \"no-dupe-keys\": 2,//在创建对象字面量时不允许键重复 {a:1,a:1}\n    \"no-dupe-args\": 2,//函数参数不能重复\n    \"no-duplicate-case\": 2,//switch中的case标签不能重复\n    \"no-else-return\": 2,//如果if语句里面有return,后面不能跟else语句\n    \"no-empty\": 2,//块语句中的内容不能为空\n    \"no-empty-character-class\": 2,//正则表达式中的[]内容不能为空\n    \"no-empty-label\": 2,//禁止使用空label\n    \"no-eq-null\": 2,//禁止对null使用==或!=运算符\n    \"no-eval\": 1,//禁止使用eval\n    \"no-ex-assign\": 2,//禁止给catch语句中的异常参数赋值\n    \"no-extend-native\": 2,//禁止扩展native对象\n    \"no-extra-bind\": 2,//禁止不必要的函数绑定\n    \"no-extra-boolean-cast\": 2,//禁止不必要的bool转换\n    \"no-extra-parens\": 2,//禁止非必要的括号\n    \"no-extra-semi\": 2,//禁止多余的冒号\n    \"no-fallthrough\": 1,//禁止switch穿透\n    \"no-floating-decimal\": 2,//禁止省略浮点数中的0 .5 3.\n    \"no-func-assign\": 2,//禁止重复的函数声明\n    \"no-implicit-coercion\": 1,//禁止隐式转换\n    \"no-implied-eval\": 2,//禁止使用隐式eval\n    \"no-inline-comments\": 0,//禁止行内备注\n    \"no-inner-declarations\": [2, \"functions\"],//禁止在块语句中使用声明（变量或函数）\n    \"no-invalid-regexp\": 2,//禁止无效的正则表达式\n    \"no-invalid-this\": 2,//禁止无效的this，只能用在构造器，类，对象字面量\n    \"no-irregular-whitespace\": 2,//不能有不规则的空格\n    \"no-iterator\": 2,//禁止使用__iterator__ 属性\n    \"no-label-var\": 2,//label名不能与var声明的变量名相同\n    \"no-labels\": 2,//禁止标签声明\n    \"no-lone-blocks\": 2,//禁止不必要的嵌套块\n    \"no-lonely-if\": 2,//禁止else语句内只有if语句\n    \"no-loop-func\": 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）\n    \"no-mixed-requires\": [0, false],//声明时不能混用声明类型\n    \"no-mixed-spaces-and-tabs\": [2, false],//禁止混用tab和空格\n    \"linebreak-style\": [0, \"windows\"],//换行风格\n    \"no-multi-spaces\": 1,//不能用多余的空格\n    \"no-multi-str\": 2,//字符串不能用\\换行\n    \"no-multiple-empty-lines\": [1, {\"max\": 2}],//空行最多不能超过2行\n    \"no-native-reassign\": 2,//不能重写native对象\n    \"no-negated-in-lhs\": 2,//in 操作符的左边不能有!\n    \"no-nested-ternary\": 0,//禁止使用嵌套的三目运算\n    \"no-new\": 1,//禁止在使用new构造一个实例后不赋值\n    \"no-new-func\": 1,//禁止使用new Function\n    \"no-new-object\": 2,//禁止使用new Object()\n    \"no-new-require\": 2,//禁止使用new require\n    \"no-new-wrappers\": 2,//禁止使用new创建包装实例，new String new Boolean new Number\n    \"no-obj-calls\": 2,//不能调用内置的全局对象，比如Math() JSON()\n    \"no-octal\": 2,//禁止使用八进制数字\n    \"no-octal-escape\": 2,//禁止使用八进制转义序列\n    \"no-param-reassign\": 2,//禁止给参数重新赋值\n    \"no-path-concat\": 0,//node中不能使用__dirname或__filename做路径拼接\n    \"no-plusplus\": 0,//禁止使用++，--\n    \"no-process-env\": 0,//禁止使用process.env\n    \"no-process-exit\": 0,//禁止使用process.exit()\n    \"no-proto\": 2,//禁止使用__proto__属性\n    \"no-redeclare\": 2,//禁止重复声明变量\n    \"no-regex-spaces\": 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/\n    \"no-restricted-modules\": 0,//如果禁用了指定模块，使用就会报错\n    \"no-return-assign\": 1,//return 语句中不能有赋值表达式\n    \"no-script-url\": 0,//禁止使用javascript:void(0)\n    \"no-self-compare\": 2,//不能比较自身\n    \"no-sequences\": 0,//禁止使用逗号运算符\n    \"no-shadow\": 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名\n    \"no-shadow-restricted-names\": 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用\n    \"no-spaced-func\": 2,//函数调用时 函数名与()之间不能有空格\n    \"no-sparse-arrays\": 2,//禁止稀疏数组， [1,,2]\n    \"no-sync\": 0,//nodejs 禁止同步方法\n    \"no-ternary\": 0,//禁止使用三目运算符\n    \"no-trailing-spaces\": 1,//一行结束后面不要有空格\n    \"no-this-before-super\": 0,//在调用super()之前不能使用this或super\n    \"no-throw-literal\": 2,//禁止抛出字面量错误 throw \"error\";\n    \"no-undef\": 1,//不能有未定义的变量\n    \"no-undef-init\": 2,//变量初始化时不能直接给它赋值为undefined\n    \"no-undefined\": 2,//不能使用undefined\n    \"no-unexpected-multiline\": 2,//避免多行表达式\n    \"no-underscore-dangle\": 1,//标识符不能以_开头或结尾\n    \"no-unneeded-ternary\": 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;\n    \"no-unreachable\": 2,//不能有无法执行的代码\n    \"no-unused-expressions\": 2,//禁止无用的表达式\n    \"no-unused-vars\": [2, {\"vars\": \"all\", \"args\": \"after-used\"}],//不能有声明后未被使用的变量或参数\n    \"no-use-before-define\": 2,//未定义前不能使用\n    \"no-useless-call\": 2,//禁止不必要的call和apply\n    \"no-void\": 2,//禁用void操作符\n    \"no-var\": 0,//禁用var，用let和const代替\n    \"no-warning-comments\": [1, { \"terms\": [\"todo\", \"fixme\", \"xxx\"], \"location\": \"start\" }],//不能有警告备注\n    \"no-with\": 2,//禁用with\n    \n    \"array-bracket-spacing\": [2, \"never\"],//是否允许非空数组里面有多余的空格\n    \"arrow-parens\": 0,//箭头函数用小括号括起来\n    \"arrow-spacing\": 0,//=>的前/后括号\n    \"accessor-pairs\": 0,//在对象中使用getter/setter\n    \"block-scoped-var\": 0,//块语句中使用var\n    \"brace-style\": [1, \"1tbs\"],//大括号风格\n    \"callback-return\": 1,//避免多次调用回调什么的\n    \"camelcase\": 2,//强制驼峰法命名\n    \"comma-dangle\": [2, \"never\"],//对象字面量项尾不能有逗号\n    \"comma-spacing\": 0,//逗号前后的空格\n    \"comma-style\": [2, \"last\"],//逗号风格，换行时在行首还是行尾\n    \"complexity\": [0, 11],//循环复杂度\n    \"computed-property-spacing\": [0, \"never\"],//是否允许计算后的键名什么的\n    \"consistent-return\": 0,//return 后面是否允许省略\n    \"consistent-this\": [2, \"that\"],//this别名\n    \"constructor-super\": 0,//非派生类不能调用super，派生类必须调用super\n    \"curly\": [2, \"all\"],//必须使用 if(){} 中的{}\n    \"default-case\": 2,//switch语句最后必须有default\n    \"dot-location\": 0,//对象访问符的位置，换行的时候在行首还是行尾\n    \"dot-notation\": [0, { \"allowKeywords\": true }],//避免不必要的方括号\n    \"eol-last\": 0,//文件以单一的换行符结束\n    \"eqeqeq\": 2,//必须使用全等\n    \"func-names\": 0,//函数表达式必须有名字\n    \"func-style\": [0, \"declaration\"],//函数风格，规定只能使用函数声明/函数表达式\n    \"generator-star-spacing\": 0,//生成器函数*的前后空格\n    \"guard-for-in\": 0,//for in循环要用if语句过滤\n    \"handle-callback-err\": 0,//nodejs 处理错误\n    \"id-length\": 0,//变量名长度\n    \"indent\": [2, 4],//缩进风格\n    \"init-declarations\": 0,//声明时必须赋初值\n    \"key-spacing\": [0, { \"beforeColon\": false, \"afterColon\": true }],//对象字面量中冒号的前后空格\n    \"lines-around-comment\": 0,//行前/行后备注\n    \"max-depth\": [0, 4],//嵌套块深度\n    \"max-len\": [0, 80, 4],//字符串最大长度\n    \"max-nested-callbacks\": [0, 2],//回调嵌套深度\n    \"max-params\": [0, 3],//函数最多只能有3个参数\n    \"max-statements\": [0, 10],//函数内最多有几个声明\n    \"new-cap\": 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用\n    \"new-parens\": 2,//new时必须加小括号\n    \"newline-after-var\": 2,//变量声明后是否需要空一行\n    \"object-curly-spacing\": [0, \"never\"],//大括号内是否允许不必要的空格\n    \"object-shorthand\": 0,//强制对象字面量缩写语法\n    \"one-var\": 1,//连续声明\n    \"operator-assignment\": [0, \"always\"],//赋值运算符 += -=什么的\n    \"operator-linebreak\": [2, \"after\"],//换行时运算符在行尾还是行首\n    \"padded-blocks\": 0,//块语句内行首行尾是否要空行\n    \"prefer-const\": 0,//首选const\n    \"prefer-spread\": 0,//首选展开运算\n    \"prefer-reflect\": 0,//首选Reflect的方法\n    \"quotes\": [1, \"single\"],//引号类型 `` \"\" ''\n    \"quote-props\":[2, \"always\"],//对象字面量中的属性名是否强制双引号\n    \"radix\": 2,//parseInt必须指定第二个参数\n    \"id-match\": 0,//命名检测\n    \"require-yield\": 0,//生成器函数必须有yield\n    \"semi\": [2, \"always\"],//语句强制分号结尾\n    \"semi-spacing\": [0, {\"before\": false, \"after\": true}],//分号前后空格\n    \"sort-vars\": 0,//变量声明时排序\n    \"space-after-keywords\": [0, \"always\"],//关键字后面是否要空一格\n    \"space-before-blocks\": [0, \"always\"],//不以新行开始的块{前面要不要有空格\n    \"space-before-function-paren\": [0, \"always\"],//函数定义时括号前面要不要有空格\n    \"space-in-parens\": [0, \"never\"],//小括号里面要不要有空格\n    \"space-infix-ops\": 0,//中缀操作符周围要不要有空格\n    \"space-return-throw-case\": 2,//return throw case后面要不要加空格\n    \"space-unary-ops\": [0, { \"words\": true, \"nonwords\": false }],//一元运算符的前/后要不要加空格\n    \"spaced-comment\": 0,//注释风格要不要有空格什么的\n    \"strict\": 2,//使用严格模式\n    \"use-isnan\": 2,//禁止比较时使用NaN，只能用isNaN()\n    \"valid-jsdoc\": 0,//jsdoc规则\n    \"valid-typeof\": 2,//必须使用合法的typeof的值\n    \"vars-on-top\": 2,//var必须放在作用域顶部\n    \"wrap-iife\": [2, \"inside\"],//立即执行函数表达式的小括号风格\n    \"wrap-regex\": 0,//正则表达式字面量用小括号包起来\n    \"yoda\": [2, \"never\"]//禁止尤达条件","slug":"eslint-e9-85-8d-e7-bd-ae-e5-8f-82-e8-80-83-e4-b8-ad-e6-96-87-e8-a7-a3-e9-87-8a","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269de0033c8gs7cwse9kt","content":"<p><strong>package.json文件中eslint的配置（以下是vue-cli的默认配置）</strong></p>\n<pre><code>&quot;eslintConfig&quot;: &#123;\n     &quot;root&quot;: true,////此项是用来告诉eslint找当前配置文件不能往父级查找\n     &quot;env&quot;: &#123;\n       &quot;node&quot;: true//此项指定环境的全局变量，下面的配置指定为node环境\n     &#125;,\n     &quot;extends&quot;: [// 此项是用来配置vue.js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错\n       &quot;plugin:vue/essential&quot;,\n       &quot;@vue/standard&quot;\n     ],\n     &quot;rules&quot;: &#123;//规则配置写在这里\n       &quot;indent&quot;: [1, 4]\n     &#125;,\n     &quot;parserOptions&quot;: &#123;\n       &quot;parser&quot;: &quot;babel-eslint&quot;//此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析\n     &#125;\n   &#125;,\n\nrules: &#123;\n    &quot;规则名&quot;: [规则值, 规则配置]\n&#125;\n</code></pre>\n<p><code>&quot;off&quot;或者0 //关闭规则关闭 &quot;warn&quot;或者1 //在打开的规则作为警告（不影响退出代码） &quot;error&quot;或者2 //把规则作为一个错误（退出代码触发时为1）</code> <strong>eslint 规则配置参数</strong></p>\n<pre><code>&quot;no-alert&quot;: 0,//禁止使用alert confirm prompt\n&quot;no-array-constructor&quot;: 2,//禁止使用数组构造器\n&quot;no-bitwise&quot;: 0,//禁止使用按位运算符\n&quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee\n&quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名\n&quot;no-class-assign&quot;: 2,//禁止给类赋值\n&quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句\n&quot;no-console&quot;: 2,//禁止使用console\n&quot;no-const-assign&quot;: 2,//禁止修改const声明的变量\n&quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1)\n&quot;no-continue&quot;: 0,//禁止使用continue\n&quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符\n&quot;no-debugger&quot;: 2,//禁止使用debugger\n&quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符\n&quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/\n&quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;\n&quot;no-dupe-args&quot;: 2,//函数参数不能重复\n&quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复\n&quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句\n&quot;no-empty&quot;: 2,//块语句中的内容不能为空\n&quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空\n&quot;no-empty-label&quot;: 2,//禁止使用空label\n&quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符\n&quot;no-eval&quot;: 1,//禁止使用eval\n&quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值\n&quot;no-extend-native&quot;: 2,//禁止扩展native对象\n&quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定\n&quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换\n&quot;no-extra-parens&quot;: 2,//禁止非必要的括号\n&quot;no-extra-semi&quot;: 2,//禁止多余的冒号\n&quot;no-fallthrough&quot;: 1,//禁止switch穿透\n&quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3.\n&quot;no-func-assign&quot;: 2,//禁止重复的函数声明\n&quot;no-implicit-coercion&quot;: 1,//禁止隐式转换\n&quot;no-implied-eval&quot;: 2,//禁止使用隐式eval\n&quot;no-inline-comments&quot;: 0,//禁止行内备注\n&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数）\n&quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式\n&quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量\n&quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格\n&quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性\n&quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同\n&quot;no-labels&quot;: 2,//禁止标签声明\n&quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块\n&quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句\n&quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）\n&quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型\n&quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格\n&quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格\n&quot;no-multi-spaces&quot;: 1,//不能用多余的空格\n&quot;no-multi-str&quot;: 2,//字符串不能用\\换行\n&quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行\n&quot;no-native-reassign&quot;: 2,//不能重写native对象\n&quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有!\n&quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算\n&quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值\n&quot;no-new-func&quot;: 1,//禁止使用new Function\n&quot;no-new-object&quot;: 2,//禁止使用new Object()\n&quot;no-new-require&quot;: 2,//禁止使用new require\n&quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number\n&quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON()\n&quot;no-octal&quot;: 2,//禁止使用八进制数字\n&quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列\n&quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值\n&quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接\n&quot;no-plusplus&quot;: 0,//禁止使用++，--\n&quot;no-process-env&quot;: 0,//禁止使用process.env\n&quot;no-process-exit&quot;: 0,//禁止使用process.exit()\n&quot;no-proto&quot;: 2,//禁止使用__proto__属性\n&quot;no-redeclare&quot;: 2,//禁止重复声明变量\n&quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/\n&quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错\n&quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式\n&quot;no-script-url&quot;: 0,//禁止使用javascript:void(0)\n&quot;no-self-compare&quot;: 2,//不能比较自身\n&quot;no-sequences&quot;: 0,//禁止使用逗号运算符\n&quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名\n&quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用\n&quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格\n&quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]\n&quot;no-sync&quot;: 0,//nodejs 禁止同步方法\n&quot;no-ternary&quot;: 0,//禁止使用三目运算符\n&quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格\n&quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super\n&quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;;\n&quot;no-undef&quot;: 1,//不能有未定义的变量\n&quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined\n&quot;no-undefined&quot;: 2,//不能使用undefined\n&quot;no-unexpected-multiline&quot;: 2,//避免多行表达式\n&quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾\n&quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;\n&quot;no-unreachable&quot;: 2,//不能有无法执行的代码\n&quot;no-unused-expressions&quot;: 2,//禁止无用的表达式\n&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数\n&quot;no-use-before-define&quot;: 2,//未定义前不能使用\n&quot;no-useless-call&quot;: 2,//禁止不必要的call和apply\n&quot;no-void&quot;: 2,//禁用void操作符\n&quot;no-var&quot;: 0,//禁用var，用let和const代替\n&quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注\n&quot;no-with&quot;: 2,//禁用with\n\n&quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格\n&quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来\n&quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号\n&quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter\n&quot;block-scoped-var&quot;: 0,//块语句中使用var\n&quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格\n&quot;callback-return&quot;: 1,//避免多次调用回调什么的\n&quot;camelcase&quot;: 2,//强制驼峰法命名\n&quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号\n&quot;comma-spacing&quot;: 0,//逗号前后的空格\n&quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾\n&quot;complexity&quot;: [0, 11],//循环复杂度\n&quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的\n&quot;consistent-return&quot;: 0,//return 后面是否允许省略\n&quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名\n&quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super\n&quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125;\n&quot;default-case&quot;: 2,//switch语句最后必须有default\n&quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾\n&quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号\n&quot;eol-last&quot;: 0,//文件以单一的换行符结束\n&quot;eqeqeq&quot;: 2,//必须使用全等\n&quot;func-names&quot;: 0,//函数表达式必须有名字\n&quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式\n&quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格\n&quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤\n&quot;handle-callback-err&quot;: 0,//nodejs 处理错误\n&quot;id-length&quot;: 0,//变量名长度\n&quot;indent&quot;: [2, 4],//缩进风格\n&quot;init-declarations&quot;: 0,//声明时必须赋初值\n&quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格\n&quot;lines-around-comment&quot;: 0,//行前/行后备注\n&quot;max-depth&quot;: [0, 4],//嵌套块深度\n&quot;max-len&quot;: [0, 80, 4],//字符串最大长度\n&quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度\n&quot;max-params&quot;: [0, 3],//函数最多只能有3个参数\n&quot;max-statements&quot;: [0, 10],//函数内最多有几个声明\n&quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用\n&quot;new-parens&quot;: 2,//new时必须加小括号\n&quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行\n&quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格\n&quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法\n&quot;one-var&quot;: 1,//连续声明\n&quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的\n&quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首\n&quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行\n&quot;prefer-const&quot;: 0,//首选const\n&quot;prefer-spread&quot;: 0,//首选展开运算\n&quot;prefer-reflect&quot;: 0,//首选Reflect的方法\n&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#39;&#39;\n&quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号\n&quot;radix&quot;: 2,//parseInt必须指定第二个参数\n&quot;id-match&quot;: 0,//命名检测\n&quot;require-yield&quot;: 0,//生成器函数必须有yield\n&quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾\n&quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格\n&quot;sort-vars&quot;: 0,//变量声明时排序\n&quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格\n&quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格\n&quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格\n&quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格\n&quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格\n&quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格\n&quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格\n&quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的\n&quot;strict&quot;: 2,//使用严格模式\n&quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN()\n&quot;valid-jsdoc&quot;: 0,//jsdoc规则\n&quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值\n&quot;vars-on-top&quot;: 2,//var必须放在作用域顶部\n&quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格\n&quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来\n&quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件\n</code></pre>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><strong>package.json文件中eslint的配置（以下是vue-cli的默认配置）</strong></p>\n<pre><code>&quot;eslintConfig&quot;: &#123;\n     &quot;root&quot;: true,////此项是用来告诉eslint找当前配置文件不能往父级查找\n     &quot;env&quot;: &#123;\n       &quot;node&quot;: true//此项指定环境的全局变量，下面的配置指定为node环境\n     &#125;,\n     &quot;extends&quot;: [// 此项是用来配置vue.js风格，就是说写代码的时候要规范的写，如果你使用vs-code我觉得应该可以避免出错\n       &quot;plugin:vue/essential&quot;,\n       &quot;@vue/standard&quot;\n     ],\n     &quot;rules&quot;: &#123;//规则配置写在这里\n       &quot;indent&quot;: [1, 4]\n     &#125;,\n     &quot;parserOptions&quot;: &#123;\n       &quot;parser&quot;: &quot;babel-eslint&quot;//此项是用来指定eslint解析器的，解析器必须符合规则，babel-eslint解析器是对babel解析器的包装使其与ESLint解析\n     &#125;\n   &#125;,\n\nrules: &#123;\n    &quot;规则名&quot;: [规则值, 规则配置]\n&#125;\n</code></pre>\n<p><code>&quot;off&quot;或者0 //关闭规则关闭 &quot;warn&quot;或者1 //在打开的规则作为警告（不影响退出代码） &quot;error&quot;或者2 //把规则作为一个错误（退出代码触发时为1）</code> <strong>eslint 规则配置参数</strong></p>\n<pre><code>&quot;no-alert&quot;: 0,//禁止使用alert confirm prompt\n&quot;no-array-constructor&quot;: 2,//禁止使用数组构造器\n&quot;no-bitwise&quot;: 0,//禁止使用按位运算符\n&quot;no-caller&quot;: 1,//禁止使用arguments.caller或arguments.callee\n&quot;no-catch-shadow&quot;: 2,//禁止catch子句参数与外部作用域变量同名\n&quot;no-class-assign&quot;: 2,//禁止给类赋值\n&quot;no-cond-assign&quot;: 2,//禁止在条件表达式中使用赋值语句\n&quot;no-console&quot;: 2,//禁止使用console\n&quot;no-const-assign&quot;: 2,//禁止修改const声明的变量\n&quot;no-constant-condition&quot;: 2,//禁止在条件中使用常量表达式 if(true) if(1)\n&quot;no-continue&quot;: 0,//禁止使用continue\n&quot;no-control-regex&quot;: 2,//禁止在正则表达式中使用控制字符\n&quot;no-debugger&quot;: 2,//禁止使用debugger\n&quot;no-delete-var&quot;: 2,//不能对var声明的变量使用delete操作符\n&quot;no-div-regex&quot;: 1,//不能使用看起来像除法的正则表达式/=foo/\n&quot;no-dupe-keys&quot;: 2,//在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;\n&quot;no-dupe-args&quot;: 2,//函数参数不能重复\n&quot;no-duplicate-case&quot;: 2,//switch中的case标签不能重复\n&quot;no-else-return&quot;: 2,//如果if语句里面有return,后面不能跟else语句\n&quot;no-empty&quot;: 2,//块语句中的内容不能为空\n&quot;no-empty-character-class&quot;: 2,//正则表达式中的[]内容不能为空\n&quot;no-empty-label&quot;: 2,//禁止使用空label\n&quot;no-eq-null&quot;: 2,//禁止对null使用==或!=运算符\n&quot;no-eval&quot;: 1,//禁止使用eval\n&quot;no-ex-assign&quot;: 2,//禁止给catch语句中的异常参数赋值\n&quot;no-extend-native&quot;: 2,//禁止扩展native对象\n&quot;no-extra-bind&quot;: 2,//禁止不必要的函数绑定\n&quot;no-extra-boolean-cast&quot;: 2,//禁止不必要的bool转换\n&quot;no-extra-parens&quot;: 2,//禁止非必要的括号\n&quot;no-extra-semi&quot;: 2,//禁止多余的冒号\n&quot;no-fallthrough&quot;: 1,//禁止switch穿透\n&quot;no-floating-decimal&quot;: 2,//禁止省略浮点数中的0 .5 3.\n&quot;no-func-assign&quot;: 2,//禁止重复的函数声明\n&quot;no-implicit-coercion&quot;: 1,//禁止隐式转换\n&quot;no-implied-eval&quot;: 2,//禁止使用隐式eval\n&quot;no-inline-comments&quot;: 0,//禁止行内备注\n&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],//禁止在块语句中使用声明（变量或函数）\n&quot;no-invalid-regexp&quot;: 2,//禁止无效的正则表达式\n&quot;no-invalid-this&quot;: 2,//禁止无效的this，只能用在构造器，类，对象字面量\n&quot;no-irregular-whitespace&quot;: 2,//不能有不规则的空格\n&quot;no-iterator&quot;: 2,//禁止使用__iterator__ 属性\n&quot;no-label-var&quot;: 2,//label名不能与var声明的变量名相同\n&quot;no-labels&quot;: 2,//禁止标签声明\n&quot;no-lone-blocks&quot;: 2,//禁止不必要的嵌套块\n&quot;no-lonely-if&quot;: 2,//禁止else语句内只有if语句\n&quot;no-loop-func&quot;: 1,//禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）\n&quot;no-mixed-requires&quot;: [0, false],//声明时不能混用声明类型\n&quot;no-mixed-spaces-and-tabs&quot;: [2, false],//禁止混用tab和空格\n&quot;linebreak-style&quot;: [0, &quot;windows&quot;],//换行风格\n&quot;no-multi-spaces&quot;: 1,//不能用多余的空格\n&quot;no-multi-str&quot;: 2,//字符串不能用\\换行\n&quot;no-multiple-empty-lines&quot;: [1, &#123;&quot;max&quot;: 2&#125;],//空行最多不能超过2行\n&quot;no-native-reassign&quot;: 2,//不能重写native对象\n&quot;no-negated-in-lhs&quot;: 2,//in 操作符的左边不能有!\n&quot;no-nested-ternary&quot;: 0,//禁止使用嵌套的三目运算\n&quot;no-new&quot;: 1,//禁止在使用new构造一个实例后不赋值\n&quot;no-new-func&quot;: 1,//禁止使用new Function\n&quot;no-new-object&quot;: 2,//禁止使用new Object()\n&quot;no-new-require&quot;: 2,//禁止使用new require\n&quot;no-new-wrappers&quot;: 2,//禁止使用new创建包装实例，new String new Boolean new Number\n&quot;no-obj-calls&quot;: 2,//不能调用内置的全局对象，比如Math() JSON()\n&quot;no-octal&quot;: 2,//禁止使用八进制数字\n&quot;no-octal-escape&quot;: 2,//禁止使用八进制转义序列\n&quot;no-param-reassign&quot;: 2,//禁止给参数重新赋值\n&quot;no-path-concat&quot;: 0,//node中不能使用__dirname或__filename做路径拼接\n&quot;no-plusplus&quot;: 0,//禁止使用++，--\n&quot;no-process-env&quot;: 0,//禁止使用process.env\n&quot;no-process-exit&quot;: 0,//禁止使用process.exit()\n&quot;no-proto&quot;: 2,//禁止使用__proto__属性\n&quot;no-redeclare&quot;: 2,//禁止重复声明变量\n&quot;no-regex-spaces&quot;: 2,//禁止在正则表达式字面量中使用多个空格 /foo bar/\n&quot;no-restricted-modules&quot;: 0,//如果禁用了指定模块，使用就会报错\n&quot;no-return-assign&quot;: 1,//return 语句中不能有赋值表达式\n&quot;no-script-url&quot;: 0,//禁止使用javascript:void(0)\n&quot;no-self-compare&quot;: 2,//不能比较自身\n&quot;no-sequences&quot;: 0,//禁止使用逗号运算符\n&quot;no-shadow&quot;: 2,//外部作用域中的变量不能与它所包含的作用域中的变量或参数同名\n&quot;no-shadow-restricted-names&quot;: 2,//严格模式中规定的限制标识符不能作为声明时的变量名使用\n&quot;no-spaced-func&quot;: 2,//函数调用时 函数名与()之间不能有空格\n&quot;no-sparse-arrays&quot;: 2,//禁止稀疏数组， [1,,2]\n&quot;no-sync&quot;: 0,//nodejs 禁止同步方法\n&quot;no-ternary&quot;: 0,//禁止使用三目运算符\n&quot;no-trailing-spaces&quot;: 1,//一行结束后面不要有空格\n&quot;no-this-before-super&quot;: 0,//在调用super()之前不能使用this或super\n&quot;no-throw-literal&quot;: 2,//禁止抛出字面量错误 throw &quot;error&quot;;\n&quot;no-undef&quot;: 1,//不能有未定义的变量\n&quot;no-undef-init&quot;: 2,//变量初始化时不能直接给它赋值为undefined\n&quot;no-undefined&quot;: 2,//不能使用undefined\n&quot;no-unexpected-multiline&quot;: 2,//避免多行表达式\n&quot;no-underscore-dangle&quot;: 1,//标识符不能以_开头或结尾\n&quot;no-unneeded-ternary&quot;: 2,//禁止不必要的嵌套 var isYes = answer === 1 ? true : false;\n&quot;no-unreachable&quot;: 2,//不能有无法执行的代码\n&quot;no-unused-expressions&quot;: 2,//禁止无用的表达式\n&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;after-used&quot;&#125;],//不能有声明后未被使用的变量或参数\n&quot;no-use-before-define&quot;: 2,//未定义前不能使用\n&quot;no-useless-call&quot;: 2,//禁止不必要的call和apply\n&quot;no-void&quot;: 2,//禁用void操作符\n&quot;no-var&quot;: 0,//禁用var，用let和const代替\n&quot;no-warning-comments&quot;: [1, &#123; &quot;terms&quot;: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], &quot;location&quot;: &quot;start&quot; &#125;],//不能有警告备注\n&quot;no-with&quot;: 2,//禁用with\n\n&quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],//是否允许非空数组里面有多余的空格\n&quot;arrow-parens&quot;: 0,//箭头函数用小括号括起来\n&quot;arrow-spacing&quot;: 0,//=&gt;的前/后括号\n&quot;accessor-pairs&quot;: 0,//在对象中使用getter/setter\n&quot;block-scoped-var&quot;: 0,//块语句中使用var\n&quot;brace-style&quot;: [1, &quot;1tbs&quot;],//大括号风格\n&quot;callback-return&quot;: 1,//避免多次调用回调什么的\n&quot;camelcase&quot;: 2,//强制驼峰法命名\n&quot;comma-dangle&quot;: [2, &quot;never&quot;],//对象字面量项尾不能有逗号\n&quot;comma-spacing&quot;: 0,//逗号前后的空格\n&quot;comma-style&quot;: [2, &quot;last&quot;],//逗号风格，换行时在行首还是行尾\n&quot;complexity&quot;: [0, 11],//循环复杂度\n&quot;computed-property-spacing&quot;: [0, &quot;never&quot;],//是否允许计算后的键名什么的\n&quot;consistent-return&quot;: 0,//return 后面是否允许省略\n&quot;consistent-this&quot;: [2, &quot;that&quot;],//this别名\n&quot;constructor-super&quot;: 0,//非派生类不能调用super，派生类必须调用super\n&quot;curly&quot;: [2, &quot;all&quot;],//必须使用 if()&#123;&#125; 中的&#123;&#125;\n&quot;default-case&quot;: 2,//switch语句最后必须有default\n&quot;dot-location&quot;: 0,//对象访问符的位置，换行的时候在行首还是行尾\n&quot;dot-notation&quot;: [0, &#123; &quot;allowKeywords&quot;: true &#125;],//避免不必要的方括号\n&quot;eol-last&quot;: 0,//文件以单一的换行符结束\n&quot;eqeqeq&quot;: 2,//必须使用全等\n&quot;func-names&quot;: 0,//函数表达式必须有名字\n&quot;func-style&quot;: [0, &quot;declaration&quot;],//函数风格，规定只能使用函数声明/函数表达式\n&quot;generator-star-spacing&quot;: 0,//生成器函数*的前后空格\n&quot;guard-for-in&quot;: 0,//for in循环要用if语句过滤\n&quot;handle-callback-err&quot;: 0,//nodejs 处理错误\n&quot;id-length&quot;: 0,//变量名长度\n&quot;indent&quot;: [2, 4],//缩进风格\n&quot;init-declarations&quot;: 0,//声明时必须赋初值\n&quot;key-spacing&quot;: [0, &#123; &quot;beforeColon&quot;: false, &quot;afterColon&quot;: true &#125;],//对象字面量中冒号的前后空格\n&quot;lines-around-comment&quot;: 0,//行前/行后备注\n&quot;max-depth&quot;: [0, 4],//嵌套块深度\n&quot;max-len&quot;: [0, 80, 4],//字符串最大长度\n&quot;max-nested-callbacks&quot;: [0, 2],//回调嵌套深度\n&quot;max-params&quot;: [0, 3],//函数最多只能有3个参数\n&quot;max-statements&quot;: [0, 10],//函数内最多有几个声明\n&quot;new-cap&quot;: 2,//函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用\n&quot;new-parens&quot;: 2,//new时必须加小括号\n&quot;newline-after-var&quot;: 2,//变量声明后是否需要空一行\n&quot;object-curly-spacing&quot;: [0, &quot;never&quot;],//大括号内是否允许不必要的空格\n&quot;object-shorthand&quot;: 0,//强制对象字面量缩写语法\n&quot;one-var&quot;: 1,//连续声明\n&quot;operator-assignment&quot;: [0, &quot;always&quot;],//赋值运算符 += -=什么的\n&quot;operator-linebreak&quot;: [2, &quot;after&quot;],//换行时运算符在行尾还是行首\n&quot;padded-blocks&quot;: 0,//块语句内行首行尾是否要空行\n&quot;prefer-const&quot;: 0,//首选const\n&quot;prefer-spread&quot;: 0,//首选展开运算\n&quot;prefer-reflect&quot;: 0,//首选Reflect的方法\n&quot;quotes&quot;: [1, &quot;single&quot;],//引号类型 `` &quot;&quot; &#39;&#39;\n&quot;quote-props&quot;:[2, &quot;always&quot;],//对象字面量中的属性名是否强制双引号\n&quot;radix&quot;: 2,//parseInt必须指定第二个参数\n&quot;id-match&quot;: 0,//命名检测\n&quot;require-yield&quot;: 0,//生成器函数必须有yield\n&quot;semi&quot;: [2, &quot;always&quot;],//语句强制分号结尾\n&quot;semi-spacing&quot;: [0, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],//分号前后空格\n&quot;sort-vars&quot;: 0,//变量声明时排序\n&quot;space-after-keywords&quot;: [0, &quot;always&quot;],//关键字后面是否要空一格\n&quot;space-before-blocks&quot;: [0, &quot;always&quot;],//不以新行开始的块&#123;前面要不要有空格\n&quot;space-before-function-paren&quot;: [0, &quot;always&quot;],//函数定义时括号前面要不要有空格\n&quot;space-in-parens&quot;: [0, &quot;never&quot;],//小括号里面要不要有空格\n&quot;space-infix-ops&quot;: 0,//中缀操作符周围要不要有空格\n&quot;space-return-throw-case&quot;: 2,//return throw case后面要不要加空格\n&quot;space-unary-ops&quot;: [0, &#123; &quot;words&quot;: true, &quot;nonwords&quot;: false &#125;],//一元运算符的前/后要不要加空格\n&quot;spaced-comment&quot;: 0,//注释风格要不要有空格什么的\n&quot;strict&quot;: 2,//使用严格模式\n&quot;use-isnan&quot;: 2,//禁止比较时使用NaN，只能用isNaN()\n&quot;valid-jsdoc&quot;: 0,//jsdoc规则\n&quot;valid-typeof&quot;: 2,//必须使用合法的typeof的值\n&quot;vars-on-top&quot;: 2,//var必须放在作用域顶部\n&quot;wrap-iife&quot;: [2, &quot;inside&quot;],//立即执行函数表达式的小括号风格\n&quot;wrap-regex&quot;: 0,//正则表达式字面量用小括号包起来\n&quot;yoda&quot;: [2, &quot;never&quot;]//禁止尤达条件\n</code></pre>\n"},{"title":"Git学习再入门-命令清单","url":"219.html","id":"219","date":"2019-07-05T10:19:12.000Z","_content":"\n我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png) 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\n\n> *   Workspace：工作区\n> *   Index / Stage：暂存区\n> *   Repository：仓库区（或本地仓库）\n> *   Remote：远程仓库\n\n一、新建代码库\n-------\n\n>     \n>     # 在当前目录新建一个Git代码库\n>     $ git init\n>     \n>     # 新建一个目录，将其初始化为Git代码库\n>     $ git init [project-name]\n>     \n>     # 下载一个项目和它的整个代码历史\n>     $ git clone [url]\n>     \n\n二、配置\n----\n\nGit的设置文件为`.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n>     \n>     # 显示当前的Git配置\n>     $ git config --list\n>     \n>     # 编辑Git配置文件\n>     $ git config -e [--global]\n>     \n>     # 设置提交代码时的用户信息\n>     $ git config [--global] user.name \"[name]\"\n>     $ git config [--global] user.email \"[email address]\"\n>     \n\n三、增加/删除文件\n---------\n\n>     \n>     # 添加指定文件到暂存区\n>     $ git add [file1] [file2] ...\n>     \n>     # 添加指定目录到暂存区，包括子目录\n>     $ git add [dir]\n>     \n>     # 添加当前目录的所有文件到暂存区\n>     $ git add .\n>     \n>     # 添加每个变化前，都会要求确认\n>     # 对于同一个文件的多处变化，可以实现分次提交\n>     $ git add -p\n>     \n>     # 删除工作区文件，并且将这次删除放入暂存区\n>     $ git rm [file1] [file2] ...\n>     \n>     # 停止追踪指定文件，但该文件会保留在工作区\n>     $ git rm --cached [file]\n>     \n>     # 改名文件，并且将这个改名放入暂存区\n>     $ git mv [file-original] [file-renamed]\n>     \n\n四、代码提交\n------\n\n>     \n>     # 提交暂存区到仓库区\n>     $ git commit -m [message]\n>     \n>     # 提交暂存区的指定文件到仓库区\n>     $ git commit [file1] [file2] ... -m [message]\n>     \n>     # 提交工作区自上次commit之后的变化，直接到仓库区\n>     $ git commit -a\n>     \n>     # 提交时显示所有diff信息\n>     $ git commit -v\n>     \n>     # 使用一次新的commit，替代上一次提交\n>     # 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n>     $ git commit --amend -m [message]\n>     \n>     # 重做上一次commit，并包括指定文件的新变化\n>     $ git commit --amend [file1] [file2] ...\n>     \n\n五、分支\n----\n\n>     \n>     # 列出所有本地分支\n>     $ git branch\n>     \n>     # 列出所有远程分支\n>     $ git branch -r\n>     \n>     # 列出所有本地分支和远程分支\n>     $ git branch -a\n>     \n>     # 新建一个分支，但依然停留在当前分支\n>     $ git branch [branch-name]\n>     \n>     # 新建一个分支，并切换到该分支\n>     $ git checkout -b [branch]\n>     \n>     # 新建一个分支，指向指定commit\n>     $ git branch [branch] [commit]\n>     \n>     # 新建一个分支，与指定的远程分支建立追踪关系\n>     $ git branch --track [branch] [remote-branch]\n>     \n>     # 切换到指定分支，并更新工作区\n>     $ git checkout [branch-name]\n>     \n>     # 切换到上一个分支\n>     $ git checkout -\n>     \n>     # 建立追踪关系，在现有分支与指定的远程分支之间\n>     $ git branch --set-upstream [branch] [remote-branch]\n>     \n>     # 合并指定分支到当前分支\n>     $ git merge [branch]\n>     \n>     # 选择一个commit，合并进当前分支\n>     $ git cherry-pick [commit]\n>     \n>     # 删除分支\n>     $ git branch -d [branch-name]\n>     \n>     # 删除远程分支\n>     $ git push origin --delete [branch-name]\n>     $ git branch -dr [remote/branch]\n>     \n\n六、标签\n----\n\n>     \n>     # 列出所有tag\n>     $ git tag\n>     \n>     # 新建一个tag在当前commit\n>     $ git tag [tag]\n>     \n>     # 新建一个tag在指定commit\n>     $ git tag [tag] [commit]\n>     \n>     # 删除本地tag\n>     $ git tag -d [tag]\n>     \n>     # 删除远程tag\n>     $ git push origin :refs/tags/[tagName]\n>     \n>     # 查看tag信息\n>     $ git show [tag]\n>     \n>     # 提交指定tag\n>     $ git push [remote] [tag]\n>     \n>     # 提交所有tag\n>     $ git push [remote] --tags\n>     \n>     # 新建一个分支，指向某个tag\n>     $ git checkout -b [branch] [tag]\n>     \n\n七、查看信息\n------\n\n>     \n>     # 显示有变更的文件\n>     $ git status\n>     \n>     # 显示当前分支的版本历史\n>     $ git log\n>     \n>     # 显示commit历史，以及每次commit发生变更的文件\n>     $ git log --stat\n>     \n>     # 搜索提交历史，根据关键词\n>     $ git log -S [keyword]\n>     \n>     # 显示某个commit之后的所有变动，每个commit占据一行\n>     $ git log [tag] HEAD --pretty=format:%s\n>     \n>     # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n>     $ git log [tag] HEAD --grep feature\n>     \n>     # 显示某个文件的版本历史，包括文件改名\n>     $ git log --follow [file]\n>     $ git whatchanged [file]\n>     \n>     # 显示指定文件相关的每一次diff\n>     $ git log -p [file]\n>     \n>     # 显示过去5次提交\n>     $ git log -5 --pretty --oneline\n>     \n>     # 显示所有提交过的用户，按提交次数排序\n>     $ git shortlog -sn\n>     \n>     # 显示指定文件是什么人在什么时间修改过\n>     $ git blame [file]\n>     \n>     # 显示暂存区和工作区的差异\n>     $ git diff\n>     \n>     # 显示暂存区和上一个commit的差异\n>     $ git diff --cached [file]\n>     \n>     # 显示工作区与当前分支最新commit之间的差异\n>     $ git diff HEAD\n>     \n>     # 显示两次提交之间的差异\n>     $ git diff [first-branch]...[second-branch]\n>     \n>     # 显示今天你写了多少行代码\n>     $ git diff --shortstat \"@{0 day ago}\"\n>     \n>     # 显示某次提交的元数据和内容变化\n>     $ git show [commit]\n>     \n>     # 显示某次提交发生变化的文件\n>     $ git show --name-only [commit]\n>     \n>     # 显示某次提交时，某个文件的内容\n>     $ git show [commit]:[filename]\n>     \n>     # 显示当前分支的最近几次提交\n>     $ git reflog\n>     \n\n八、远程同步\n------\n\n>     \n>     # 下载远程仓库的所有变动\n>     $ git fetch [remote]\n>     \n>     # 显示所有远程仓库\n>     $ git remote -v\n>     \n>     # 显示某个远程仓库的信息\n>     $ git remote show [remote]\n>     \n>     # 增加一个新的远程仓库，并命名\n>     $ git remote add [shortname] [url]\n>     \n>     # 取回远程仓库的变化，并与本地分支合并\n>     $ git pull [remote] [branch]\n>     \n>     # 上传本地指定分支到远程仓库\n>     $ git push [remote] [branch]\n>     \n>     # 强行推送当前分支到远程仓库，即使有冲突\n>     $ git push [remote] --force\n>     \n>     # 推送所有分支到远程仓库\n>     $ git push [remote] --all\n>     \n\n九、撤销\n----\n\n>     \n>     # 恢复暂存区的指定文件到工作区\n>     $ git checkout [file]\n>     \n>     # 恢复某个commit的指定文件到暂存区和工作区\n>     $ git checkout [commit] [file]\n>     \n>     # 恢复暂存区的所有文件到工作区\n>     $ git checkout .\n>     \n>     # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n>     $ git reset [file]\n>     \n>     # 重置暂存区与工作区，与上一次commit保持一致\n>     $ git reset --hard\n>     \n>     # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n>     $ git reset [commit]\n>     \n>     # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n>     $ git reset --hard [commit]\n>     \n>     # 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n>     $ git reset --keep [commit]\n>     \n>     # 新建一个commit，用来撤销指定commit\n>     # 后者的所有变化都将被前者抵消，并且应用到当前分支\n>     $ git revert [commit]\n>     \n>     # 暂时将未提交的变化移除，稍后再移入\n>     $ git stash\n>     $ git stash pop\n>     \n\n十、其他\n----\n\n>     \n>     # 生成一个可供发布的压缩包\n>     $ git archive\n>     \n\n本文转载之阮一峰老师的文章。特此声明。","source":"_posts/git-e5-ad-a6-e4-b9-a0-e5-86-8d-e5-85-a5-e9-97-a8-e5-91-bd-e4-bb-a4-e6-b8-85-e5-8d-95.md","raw":"---\ntitle: Git学习再入门-命令清单\ntags:\n  - Git\nurl: 219.html\nid: 219\ncategories:\n  - 大前端\ndate: 2019-07-05 18:19:12\n---\n\n我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 ![](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png) 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。\n\n> *   Workspace：工作区\n> *   Index / Stage：暂存区\n> *   Repository：仓库区（或本地仓库）\n> *   Remote：远程仓库\n\n一、新建代码库\n-------\n\n>     \n>     # 在当前目录新建一个Git代码库\n>     $ git init\n>     \n>     # 新建一个目录，将其初始化为Git代码库\n>     $ git init [project-name]\n>     \n>     # 下载一个项目和它的整个代码历史\n>     $ git clone [url]\n>     \n\n二、配置\n----\n\nGit的设置文件为`.gitconfig`，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n>     \n>     # 显示当前的Git配置\n>     $ git config --list\n>     \n>     # 编辑Git配置文件\n>     $ git config -e [--global]\n>     \n>     # 设置提交代码时的用户信息\n>     $ git config [--global] user.name \"[name]\"\n>     $ git config [--global] user.email \"[email address]\"\n>     \n\n三、增加/删除文件\n---------\n\n>     \n>     # 添加指定文件到暂存区\n>     $ git add [file1] [file2] ...\n>     \n>     # 添加指定目录到暂存区，包括子目录\n>     $ git add [dir]\n>     \n>     # 添加当前目录的所有文件到暂存区\n>     $ git add .\n>     \n>     # 添加每个变化前，都会要求确认\n>     # 对于同一个文件的多处变化，可以实现分次提交\n>     $ git add -p\n>     \n>     # 删除工作区文件，并且将这次删除放入暂存区\n>     $ git rm [file1] [file2] ...\n>     \n>     # 停止追踪指定文件，但该文件会保留在工作区\n>     $ git rm --cached [file]\n>     \n>     # 改名文件，并且将这个改名放入暂存区\n>     $ git mv [file-original] [file-renamed]\n>     \n\n四、代码提交\n------\n\n>     \n>     # 提交暂存区到仓库区\n>     $ git commit -m [message]\n>     \n>     # 提交暂存区的指定文件到仓库区\n>     $ git commit [file1] [file2] ... -m [message]\n>     \n>     # 提交工作区自上次commit之后的变化，直接到仓库区\n>     $ git commit -a\n>     \n>     # 提交时显示所有diff信息\n>     $ git commit -v\n>     \n>     # 使用一次新的commit，替代上一次提交\n>     # 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n>     $ git commit --amend -m [message]\n>     \n>     # 重做上一次commit，并包括指定文件的新变化\n>     $ git commit --amend [file1] [file2] ...\n>     \n\n五、分支\n----\n\n>     \n>     # 列出所有本地分支\n>     $ git branch\n>     \n>     # 列出所有远程分支\n>     $ git branch -r\n>     \n>     # 列出所有本地分支和远程分支\n>     $ git branch -a\n>     \n>     # 新建一个分支，但依然停留在当前分支\n>     $ git branch [branch-name]\n>     \n>     # 新建一个分支，并切换到该分支\n>     $ git checkout -b [branch]\n>     \n>     # 新建一个分支，指向指定commit\n>     $ git branch [branch] [commit]\n>     \n>     # 新建一个分支，与指定的远程分支建立追踪关系\n>     $ git branch --track [branch] [remote-branch]\n>     \n>     # 切换到指定分支，并更新工作区\n>     $ git checkout [branch-name]\n>     \n>     # 切换到上一个分支\n>     $ git checkout -\n>     \n>     # 建立追踪关系，在现有分支与指定的远程分支之间\n>     $ git branch --set-upstream [branch] [remote-branch]\n>     \n>     # 合并指定分支到当前分支\n>     $ git merge [branch]\n>     \n>     # 选择一个commit，合并进当前分支\n>     $ git cherry-pick [commit]\n>     \n>     # 删除分支\n>     $ git branch -d [branch-name]\n>     \n>     # 删除远程分支\n>     $ git push origin --delete [branch-name]\n>     $ git branch -dr [remote/branch]\n>     \n\n六、标签\n----\n\n>     \n>     # 列出所有tag\n>     $ git tag\n>     \n>     # 新建一个tag在当前commit\n>     $ git tag [tag]\n>     \n>     # 新建一个tag在指定commit\n>     $ git tag [tag] [commit]\n>     \n>     # 删除本地tag\n>     $ git tag -d [tag]\n>     \n>     # 删除远程tag\n>     $ git push origin :refs/tags/[tagName]\n>     \n>     # 查看tag信息\n>     $ git show [tag]\n>     \n>     # 提交指定tag\n>     $ git push [remote] [tag]\n>     \n>     # 提交所有tag\n>     $ git push [remote] --tags\n>     \n>     # 新建一个分支，指向某个tag\n>     $ git checkout -b [branch] [tag]\n>     \n\n七、查看信息\n------\n\n>     \n>     # 显示有变更的文件\n>     $ git status\n>     \n>     # 显示当前分支的版本历史\n>     $ git log\n>     \n>     # 显示commit历史，以及每次commit发生变更的文件\n>     $ git log --stat\n>     \n>     # 搜索提交历史，根据关键词\n>     $ git log -S [keyword]\n>     \n>     # 显示某个commit之后的所有变动，每个commit占据一行\n>     $ git log [tag] HEAD --pretty=format:%s\n>     \n>     # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件\n>     $ git log [tag] HEAD --grep feature\n>     \n>     # 显示某个文件的版本历史，包括文件改名\n>     $ git log --follow [file]\n>     $ git whatchanged [file]\n>     \n>     # 显示指定文件相关的每一次diff\n>     $ git log -p [file]\n>     \n>     # 显示过去5次提交\n>     $ git log -5 --pretty --oneline\n>     \n>     # 显示所有提交过的用户，按提交次数排序\n>     $ git shortlog -sn\n>     \n>     # 显示指定文件是什么人在什么时间修改过\n>     $ git blame [file]\n>     \n>     # 显示暂存区和工作区的差异\n>     $ git diff\n>     \n>     # 显示暂存区和上一个commit的差异\n>     $ git diff --cached [file]\n>     \n>     # 显示工作区与当前分支最新commit之间的差异\n>     $ git diff HEAD\n>     \n>     # 显示两次提交之间的差异\n>     $ git diff [first-branch]...[second-branch]\n>     \n>     # 显示今天你写了多少行代码\n>     $ git diff --shortstat \"@{0 day ago}\"\n>     \n>     # 显示某次提交的元数据和内容变化\n>     $ git show [commit]\n>     \n>     # 显示某次提交发生变化的文件\n>     $ git show --name-only [commit]\n>     \n>     # 显示某次提交时，某个文件的内容\n>     $ git show [commit]:[filename]\n>     \n>     # 显示当前分支的最近几次提交\n>     $ git reflog\n>     \n\n八、远程同步\n------\n\n>     \n>     # 下载远程仓库的所有变动\n>     $ git fetch [remote]\n>     \n>     # 显示所有远程仓库\n>     $ git remote -v\n>     \n>     # 显示某个远程仓库的信息\n>     $ git remote show [remote]\n>     \n>     # 增加一个新的远程仓库，并命名\n>     $ git remote add [shortname] [url]\n>     \n>     # 取回远程仓库的变化，并与本地分支合并\n>     $ git pull [remote] [branch]\n>     \n>     # 上传本地指定分支到远程仓库\n>     $ git push [remote] [branch]\n>     \n>     # 强行推送当前分支到远程仓库，即使有冲突\n>     $ git push [remote] --force\n>     \n>     # 推送所有分支到远程仓库\n>     $ git push [remote] --all\n>     \n\n九、撤销\n----\n\n>     \n>     # 恢复暂存区的指定文件到工作区\n>     $ git checkout [file]\n>     \n>     # 恢复某个commit的指定文件到暂存区和工作区\n>     $ git checkout [commit] [file]\n>     \n>     # 恢复暂存区的所有文件到工作区\n>     $ git checkout .\n>     \n>     # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n>     $ git reset [file]\n>     \n>     # 重置暂存区与工作区，与上一次commit保持一致\n>     $ git reset --hard\n>     \n>     # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n>     $ git reset [commit]\n>     \n>     # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n>     $ git reset --hard [commit]\n>     \n>     # 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n>     $ git reset --keep [commit]\n>     \n>     # 新建一个commit，用来撤销指定commit\n>     # 后者的所有变化都将被前者抵消，并且应用到当前分支\n>     $ git revert [commit]\n>     \n>     # 暂时将未提交的变化移除，稍后再移入\n>     $ git stash\n>     $ git stash pop\n>     \n\n十、其他\n----\n\n>     \n>     # 生成一个可供发布的压缩包\n>     $ git archive\n>     \n\n本文转载之阮一峰老师的文章。特此声明。","slug":"git-e5-ad-a6-e4-b9-a0-e5-86-8d-e5-85-a5-e9-97-a8-e5-91-bd-e4-bb-a4-e6-b8-85-e5-8d-95","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269dg0036c8gs4lk5d0mu","content":"<p>我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 <img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png\"> 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>\n<blockquote>\n<ul>\n<li>  Workspace：工作区</li>\n<li>  Index / Stage：暂存区</li>\n<li>  Repository：仓库区（或本地仓库）</li>\n<li>  Remote：远程仓库</li>\n</ul>\n</blockquote>\n<h2 id=\"一、新建代码库\"><a href=\"#一、新建代码库\" class=\"headerlink\" title=\"一、新建代码库\"></a>一、新建代码库</h2><blockquote>\n<pre><code># 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n</code></pre>\n</blockquote>\n<h2 id=\"二、配置\"><a href=\"#二、配置\" class=\"headerlink\" title=\"二、配置\"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<blockquote>\n<pre><code># 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name &quot;[name]&quot;\n$ git config [--global] user.email &quot;[email address]&quot;\n</code></pre>\n</blockquote>\n<h2 id=\"三、增加-删除文件\"><a href=\"#三、增加-删除文件\" class=\"headerlink\" title=\"三、增加/删除文件\"></a>三、增加/删除文件</h2><blockquote>\n<pre><code># 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n</code></pre>\n</blockquote>\n<h2 id=\"四、代码提交\"><a href=\"#四、代码提交\" class=\"headerlink\" title=\"四、代码提交\"></a>四、代码提交</h2><blockquote>\n<pre><code># 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n</code></pre>\n</blockquote>\n<h2 id=\"五、分支\"><a href=\"#五、分支\" class=\"headerlink\" title=\"五、分支\"></a>五、分支</h2><blockquote>\n<pre><code># 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n</code></pre>\n</blockquote>\n<h2 id=\"六、标签\"><a href=\"#六、标签\" class=\"headerlink\" title=\"六、标签\"></a>六、标签</h2><blockquote>\n<pre><code># 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n</code></pre>\n</blockquote>\n<h2 id=\"七、查看信息\"><a href=\"#七、查看信息\" class=\"headerlink\" title=\"七、查看信息\"></a>七、查看信息</h2><blockquote>\n<pre><code># 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n</code></pre>\n</blockquote>\n<h2 id=\"八、远程同步\"><a href=\"#八、远程同步\" class=\"headerlink\" title=\"八、远程同步\"></a>八、远程同步</h2><blockquote>\n<pre><code># 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n</code></pre>\n</blockquote>\n<h2 id=\"九、撤销\"><a href=\"#九、撤销\" class=\"headerlink\" title=\"九、撤销\"></a>九、撤销</h2><blockquote>\n<pre><code># 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n</code></pre>\n</blockquote>\n<h2 id=\"十、其他\"><a href=\"#十、其他\" class=\"headerlink\" title=\"十、其他\"></a>十、其他</h2><blockquote>\n<pre><code># 生成一个可供发布的压缩包\n$ git archive\n</code></pre>\n</blockquote>\n<p>本文转载之阮一峰老师的文章。特此声明。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>我每天使用 Git ，但是很多命令记不住。 一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。 <img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png\"> 下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。</p>\n<blockquote>\n<ul>\n<li>  Workspace：工作区</li>\n<li>  Index / Stage：暂存区</li>\n<li>  Repository：仓库区（或本地仓库）</li>\n<li>  Remote：远程仓库</li>\n</ul>\n</blockquote>\n<h2 id=\"一、新建代码库\"><a href=\"#一、新建代码库\" class=\"headerlink\" title=\"一、新建代码库\"></a>一、新建代码库</h2><blockquote>\n<pre><code># 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n</code></pre>\n</blockquote>\n<h2 id=\"二、配置\"><a href=\"#二、配置\" class=\"headerlink\" title=\"二、配置\"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<blockquote>\n<pre><code># 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name &quot;[name]&quot;\n$ git config [--global] user.email &quot;[email address]&quot;\n</code></pre>\n</blockquote>\n<h2 id=\"三、增加-删除文件\"><a href=\"#三、增加-删除文件\" class=\"headerlink\" title=\"三、增加/删除文件\"></a>三、增加/删除文件</h2><blockquote>\n<pre><code># 添加指定文件到暂存区\n$ git add [file1] [file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n$ git add .\n\n# 添加每个变化前，都会要求确认\n# 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n</code></pre>\n</blockquote>\n<h2 id=\"四、代码提交\"><a href=\"#四、代码提交\" class=\"headerlink\" title=\"四、代码提交\"></a>四、代码提交</h2><blockquote>\n<pre><code># 提交暂存区到仓库区\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n\n# 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n\n# 提交时显示所有diff信息\n$ git commit -v\n\n# 使用一次新的commit，替代上一次提交\n# 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n\n# 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n</code></pre>\n</blockquote>\n<h2 id=\"五、分支\"><a href=\"#五、分支\" class=\"headerlink\" title=\"五、分支\"></a>五、分支</h2><blockquote>\n<pre><code># 列出所有本地分支\n$ git branch\n\n# 列出所有远程分支\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n\n# 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n\n# 合并指定分支到当前分支\n$ git merge [branch]\n\n# 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n\n# 删除分支\n$ git branch -d [branch-name]\n\n# 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n</code></pre>\n</blockquote>\n<h2 id=\"六、标签\"><a href=\"#六、标签\" class=\"headerlink\" title=\"六、标签\"></a>六、标签</h2><blockquote>\n<pre><code># 列出所有tag\n$ git tag\n\n# 新建一个tag在当前commit\n$ git tag [tag]\n\n# 新建一个tag在指定commit\n$ git tag [tag] [commit]\n\n# 删除本地tag\n$ git tag -d [tag]\n\n# 删除远程tag\n$ git push origin :refs/tags/[tagName]\n\n# 查看tag信息\n$ git show [tag]\n\n# 提交指定tag\n$ git push [remote] [tag]\n\n# 提交所有tag\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n</code></pre>\n</blockquote>\n<h2 id=\"七、查看信息\"><a href=\"#七、查看信息\" class=\"headerlink\" title=\"七、查看信息\"></a>七、查看信息</h2><blockquote>\n<pre><code># 显示有变更的文件\n$ git status\n\n# 显示当前分支的版本历史\n$ git log\n\n# 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n$ git log -S [keyword]\n\n# 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次diff\n$ git log -p [file]\n\n# 显示过去5次提交\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n$ git diff\n\n# 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;\n\n# 显示某次提交的元数据和内容变化\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n$ git reflog\n</code></pre>\n</blockquote>\n<h2 id=\"八、远程同步\"><a href=\"#八、远程同步\" class=\"headerlink\" title=\"八、远程同步\"></a>八、远程同步</h2><blockquote>\n<pre><code># 下载远程仓库的所有变动\n$ git fetch [remote]\n\n# 显示所有远程仓库\n$ git remote -v\n\n# 显示某个远程仓库的信息\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n\n# 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n\n# 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n$ git push [remote] --all\n</code></pre>\n</blockquote>\n<h2 id=\"九、撤销\"><a href=\"#九、撤销\" class=\"headerlink\" title=\"九、撤销\"></a>九、撤销</h2><blockquote>\n<pre><code># 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n\n# 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n\n# 恢复暂存区的所有文件到工作区\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n\n# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n\n# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n\n# 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n\n# 新建一个commit，用来撤销指定commit\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n</code></pre>\n</blockquote>\n<h2 id=\"十、其他\"><a href=\"#十、其他\" class=\"headerlink\" title=\"十、其他\"></a>十、其他</h2><blockquote>\n<pre><code># 生成一个可供发布的压缩包\n$ git archive\n</code></pre>\n</blockquote>\n<p>本文转载之阮一峰老师的文章。特此声明。</p>\n"},{"title":"Git学习再入门-基础篇","url":"214.html","id":"214","date":"2019-07-05T10:14:06.000Z","_content":"\n> Git和GitHub有啥关系？\n\n答：Git是版本控制工具，GitHub是基于Git工具流的一个项目托管平台 ![](https://upload-images.jianshu.io/upload_images/226662-6e184a8462131352.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp) 顺便提一下这里只温习一下Git的相关知识，关于SVN（集中式管理系统）这里不做对比也不去做详细的描述。具体了解两者的区别可以去这里：[https://www.shiyanlou.com/questions/2999/  ](https://www.shiyanlou.com/questions/2999/)\n\n常用配置\n----\n\n--system #系统级别 \n--global #用户全局 \n--local #单独一个项目 \ngit config --global user.name \"xxxx\" #用户名 \ngit config --global user.email \"xxxx@xxx.com\" #邮箱 \ngit config --global core.editor vim #编辑器 \ngit config --global alias.st status #按这种方法，配置别名 \ngit config -l #列举所有配置\n\n文件直接比较差异Diff\n------------\n\ngit diff git diff <file> #比较工作区与暂存区文件的差异\ngit diff --cached   \\# 比较暂存区和版本库差异\n\ngit diff <$id1> <$id2>   \\# 比较两次提交之间的差异\ngit diff <branch1>..<branch2> \\# 在两个分支之间比较分支\ngit branch -r #查看远程分支\ngit branch new\\_branch\\_name #新建一个分支\ngit branch --merged #查看已经被合并到当前分支的分支\ngit branch --no-merged #查看未被合并到当前分支的分支\n\ngit checkout branch_name #切换分支\ngit checkout -b branch_name #创建分支并切换\n\ngit branch -d branch_name #删除分支\ngit branch -D branch_name #强制删除分支\ngit push origin :branch-name #删除远程分支（先在本地删除该分支），原理是把一个空分支push到server上，相当于删除该分支。\n\n#从远程clone一个项目，虽然远程上该项目是有分支的，但clone下来后发现只有master分支，解决：\ngit checkout -b not\\_master\\_branch  origin/not\\_master\\_branch #本地创建一个分支，指向对应的远程分支\ngit pull origin not\\_master\\_branch #将远程的not\\_master\\_branch分支pull下来\ngit push origin not\\_master\\_branch #将修改后的not\\_master\\_branch分支push到远程的not\\_master\\_branch \n\nGit中3种状态的一些操作\n-------------\n\n#将工作区的修改提交到暂存区\ngit add <file>\ngit add . \n#------------------------------------------\n\n#将暂存区的内容提交到版本库\ngit commit <file>\ngit commit .\ngit commit -a #包括git add/ git rm /git commint 这三个操作，所有一般在操作工作区的时候，直接删除了文件，而不是使用git rm的，最后提交是可以用这个，如下\n              #git commit -am \"提交信息\"\ngit commit -amend #修改最后一次提交的信息\n\n#------------------------------------------\n\n\\# 抛弃工作区修改(使用当前暂存区的内容状态去覆盖工作区，从而达到抛弃工作区修改的作用)\ngit checkout <file>  \ngit checkout .  \n\n#------------------------------------------\n#改变暂存区的修改（其实是重置HEAD，将指定版本库的内容状态去覆盖暂存区，从而达到暂存区的改变）\ngit reset <file>  #从暂存区恢复到工作区（不指定版本id，则默认为最后一次提交的版本id）\ngit reset .  #从暂存区恢复到工作区\ngit reset $id \\# 恢复到指定的提交版本，该$id之后的版本提交都恢复到工作区\ngit reset --hard $id #恢复到指定的提交版本，该$id之后的版本提交全部会被抛弃，将不出现在工作区\n\n#注：如果不小心使用了错误的HEAD重置，会发现HEAD指向了重置的版本id，该版本之后的版本提交都不见了，使用git log也无法找到，那么怎么恢复呢？使用下面两个命令\ngit reflog show master | head #会显示所有的版本记录\ngit reset --hard $id #重新重置，至于--hard，请根据你时候将改变的内容放到工作区还是直接抛弃进行选择\n\n#------------------------------------------\n#恢复某次提交（其实是某提提交的回滚操作，不影响其他的提交，所产生的效果创建一个新版本提交去回滚将指定的提交删除，包括产生的差异文件不会出现在工作区，而是直接被抛弃）\ngit revert <$id>\ngit revert HEAD\n#这里有一个很好的讲解revert与reset的差异：git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。\n\n#------------------------------------------\n#删除文件的几种方法（貌似Git2.0后有了变化）\n#第一种直接在工作区删除\nrm your_file #直接在工作区删除文件\ngit add -u . #将有改动的都提交到暂存区（包括修改的，删除的等操作），貌似git2.0 不加 -u 参数也可以\ngit commint -m \"message\" #提交版本库\n\n#第二种方法直接在工作区删除\nrm your_file #直接在工作区删除文件\ngit commit -am \"message\" #这个在前面提过，直接可以提交版本库，-a会包括包括git add/ git rm /git commint 这三个操作\n\n#第三种方法使用git rm\ngit rm <file> #不仅在工作区将文件删除，同时将该删除操作提交到暂存区\ngit commint -m \"message\" #提交版本库\n\n#关于git rm的其他补充\ngit rm --cached <file> #从暂存区中除去该文件，git将不再跟踪该文件的变更，但仍然在工作区内，在需要.gitignore时经常用到\n\nTag\n---\n\ngit tag v1.0.0 \\[SHA\\] \n#打一个轻量级的tag，只是一个commit的指向引用,\\[SHA\\]是可选择值（某个commit的SHA），指定为哪个commit打tag，如果没写则直接为最后一个commit打tag\n\ngit tag -a v1.0.0 -m \"你的附注信息\" \\[SHA\\]\n#一个带附注信息的tag，不是一个简单的引用，而是单独的一个对象，\\[SHA\\]是可选择值（某个commit的SHA），指定为哪个commit打tag，如果没写则直接为最后一个commit打tag\n\ngit tag #列出所有的tag\ngit show v1.0.0  #打印指定tag的信息\ngit tag -d v1.0.0 #删除本地指定tag\ngit push origin :refs/tags/v1.0.0 #删除远程tag\n\n远程\n--\n\ngit remote -v                    \\# 查看远程服务器地址和仓库名称\ngit remote show origin           \\# 查看远程服务器仓库状态\ngit remote add origin git@github:robbin/robbin_site.git         \\# 添加远程仓库地址\ngit remote set-url origin git@github.com:robbin/robbin #修改远程地址\ngit remote rm #删除远程创库地址\n\n从远程拉取内容,提交内容到远程\n---------------\n\ngit pull #=git fetch + git merge\ngit fetch #拉取\ngit merge #合并\n\ngit push                         \\# push所有分支\ngit push origin master           \\# 将本地主分支推到远程主分支\ngit push -u origin master        \\# 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)\ngit push origin <local_branch>   \\# 创建远程分支， origin是远程仓库名\ngit push origin <local\\_branch>:<remote\\_branch>  \\# 创建远程分支\ngit push origin :<remote_branch>  #先删除本地分支(git br -d <branch>)，然后再push删除远程分支\n\n暂存管理\n----\n\ngit stash #将工作区做的修改暂存到一个git栈中\ngit stash list #查看栈中所有暂存\ngit stash apply <暂存编号> #回复对应编号暂存到工作区，如果不指定编号为栈顶的，注意：这些暂存还在栈中\ngit stash pop #将栈顶的暂存，恢复到工作区，并从栈中弹出\ngit stash clear #清空暂存栈\n\n创建远程库\n-----\n\ngit clone --bare git\\_url\\_path #clone的时候，将其创建成远程创库\ngit --bare init #初始化项目的时候，创建成远程创库","source":"_posts/git-e5-ad-a6-e4-b9-a0-e5-86-8d-e5-85-a5-e9-97-a8-e5-9f-ba-e7-a1-80-e7-af-87.md","raw":"---\ntitle: Git学习再入门-基础篇\ntags:\n  - Git\nurl: 214.html\nid: 214\ncategories:\n  - 大前端\ndate: 2019-07-05 18:14:06\n---\n\n> Git和GitHub有啥关系？\n\n答：Git是版本控制工具，GitHub是基于Git工具流的一个项目托管平台 ![](https://upload-images.jianshu.io/upload_images/226662-6e184a8462131352.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp) 顺便提一下这里只温习一下Git的相关知识，关于SVN（集中式管理系统）这里不做对比也不去做详细的描述。具体了解两者的区别可以去这里：[https://www.shiyanlou.com/questions/2999/  ](https://www.shiyanlou.com/questions/2999/)\n\n常用配置\n----\n\n--system #系统级别 \n--global #用户全局 \n--local #单独一个项目 \ngit config --global user.name \"xxxx\" #用户名 \ngit config --global user.email \"xxxx@xxx.com\" #邮箱 \ngit config --global core.editor vim #编辑器 \ngit config --global alias.st status #按这种方法，配置别名 \ngit config -l #列举所有配置\n\n文件直接比较差异Diff\n------------\n\ngit diff git diff <file> #比较工作区与暂存区文件的差异\ngit diff --cached   \\# 比较暂存区和版本库差异\n\ngit diff <$id1> <$id2>   \\# 比较两次提交之间的差异\ngit diff <branch1>..<branch2> \\# 在两个分支之间比较分支\ngit branch -r #查看远程分支\ngit branch new\\_branch\\_name #新建一个分支\ngit branch --merged #查看已经被合并到当前分支的分支\ngit branch --no-merged #查看未被合并到当前分支的分支\n\ngit checkout branch_name #切换分支\ngit checkout -b branch_name #创建分支并切换\n\ngit branch -d branch_name #删除分支\ngit branch -D branch_name #强制删除分支\ngit push origin :branch-name #删除远程分支（先在本地删除该分支），原理是把一个空分支push到server上，相当于删除该分支。\n\n#从远程clone一个项目，虽然远程上该项目是有分支的，但clone下来后发现只有master分支，解决：\ngit checkout -b not\\_master\\_branch  origin/not\\_master\\_branch #本地创建一个分支，指向对应的远程分支\ngit pull origin not\\_master\\_branch #将远程的not\\_master\\_branch分支pull下来\ngit push origin not\\_master\\_branch #将修改后的not\\_master\\_branch分支push到远程的not\\_master\\_branch \n\nGit中3种状态的一些操作\n-------------\n\n#将工作区的修改提交到暂存区\ngit add <file>\ngit add . \n#------------------------------------------\n\n#将暂存区的内容提交到版本库\ngit commit <file>\ngit commit .\ngit commit -a #包括git add/ git rm /git commint 这三个操作，所有一般在操作工作区的时候，直接删除了文件，而不是使用git rm的，最后提交是可以用这个，如下\n              #git commit -am \"提交信息\"\ngit commit -amend #修改最后一次提交的信息\n\n#------------------------------------------\n\n\\# 抛弃工作区修改(使用当前暂存区的内容状态去覆盖工作区，从而达到抛弃工作区修改的作用)\ngit checkout <file>  \ngit checkout .  \n\n#------------------------------------------\n#改变暂存区的修改（其实是重置HEAD，将指定版本库的内容状态去覆盖暂存区，从而达到暂存区的改变）\ngit reset <file>  #从暂存区恢复到工作区（不指定版本id，则默认为最后一次提交的版本id）\ngit reset .  #从暂存区恢复到工作区\ngit reset $id \\# 恢复到指定的提交版本，该$id之后的版本提交都恢复到工作区\ngit reset --hard $id #恢复到指定的提交版本，该$id之后的版本提交全部会被抛弃，将不出现在工作区\n\n#注：如果不小心使用了错误的HEAD重置，会发现HEAD指向了重置的版本id，该版本之后的版本提交都不见了，使用git log也无法找到，那么怎么恢复呢？使用下面两个命令\ngit reflog show master | head #会显示所有的版本记录\ngit reset --hard $id #重新重置，至于--hard，请根据你时候将改变的内容放到工作区还是直接抛弃进行选择\n\n#------------------------------------------\n#恢复某次提交（其实是某提提交的回滚操作，不影响其他的提交，所产生的效果创建一个新版本提交去回滚将指定的提交删除，包括产生的差异文件不会出现在工作区，而是直接被抛弃）\ngit revert <$id>\ngit revert HEAD\n#这里有一个很好的讲解revert与reset的差异：git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。\n\n#------------------------------------------\n#删除文件的几种方法（貌似Git2.0后有了变化）\n#第一种直接在工作区删除\nrm your_file #直接在工作区删除文件\ngit add -u . #将有改动的都提交到暂存区（包括修改的，删除的等操作），貌似git2.0 不加 -u 参数也可以\ngit commint -m \"message\" #提交版本库\n\n#第二种方法直接在工作区删除\nrm your_file #直接在工作区删除文件\ngit commit -am \"message\" #这个在前面提过，直接可以提交版本库，-a会包括包括git add/ git rm /git commint 这三个操作\n\n#第三种方法使用git rm\ngit rm <file> #不仅在工作区将文件删除，同时将该删除操作提交到暂存区\ngit commint -m \"message\" #提交版本库\n\n#关于git rm的其他补充\ngit rm --cached <file> #从暂存区中除去该文件，git将不再跟踪该文件的变更，但仍然在工作区内，在需要.gitignore时经常用到\n\nTag\n---\n\ngit tag v1.0.0 \\[SHA\\] \n#打一个轻量级的tag，只是一个commit的指向引用,\\[SHA\\]是可选择值（某个commit的SHA），指定为哪个commit打tag，如果没写则直接为最后一个commit打tag\n\ngit tag -a v1.0.0 -m \"你的附注信息\" \\[SHA\\]\n#一个带附注信息的tag，不是一个简单的引用，而是单独的一个对象，\\[SHA\\]是可选择值（某个commit的SHA），指定为哪个commit打tag，如果没写则直接为最后一个commit打tag\n\ngit tag #列出所有的tag\ngit show v1.0.0  #打印指定tag的信息\ngit tag -d v1.0.0 #删除本地指定tag\ngit push origin :refs/tags/v1.0.0 #删除远程tag\n\n远程\n--\n\ngit remote -v                    \\# 查看远程服务器地址和仓库名称\ngit remote show origin           \\# 查看远程服务器仓库状态\ngit remote add origin git@github:robbin/robbin_site.git         \\# 添加远程仓库地址\ngit remote set-url origin git@github.com:robbin/robbin #修改远程地址\ngit remote rm #删除远程创库地址\n\n从远程拉取内容,提交内容到远程\n---------------\n\ngit pull #=git fetch + git merge\ngit fetch #拉取\ngit merge #合并\n\ngit push                         \\# push所有分支\ngit push origin master           \\# 将本地主分支推到远程主分支\ngit push -u origin master        \\# 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)\ngit push origin <local_branch>   \\# 创建远程分支， origin是远程仓库名\ngit push origin <local\\_branch>:<remote\\_branch>  \\# 创建远程分支\ngit push origin :<remote_branch>  #先删除本地分支(git br -d <branch>)，然后再push删除远程分支\n\n暂存管理\n----\n\ngit stash #将工作区做的修改暂存到一个git栈中\ngit stash list #查看栈中所有暂存\ngit stash apply <暂存编号> #回复对应编号暂存到工作区，如果不指定编号为栈顶的，注意：这些暂存还在栈中\ngit stash pop #将栈顶的暂存，恢复到工作区，并从栈中弹出\ngit stash clear #清空暂存栈\n\n创建远程库\n-----\n\ngit clone --bare git\\_url\\_path #clone的时候，将其创建成远程创库\ngit --bare init #初始化项目的时候，创建成远程创库","slug":"git-e5-ad-a6-e4-b9-a0-e5-86-8d-e5-85-a5-e9-97-a8-e5-9f-ba-e7-a1-80-e7-af-87","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269dr0039c8gsatblhyir","content":"<blockquote>\n<p>Git和GitHub有啥关系？</p>\n</blockquote>\n<p>答：Git是版本控制工具，GitHub是基于Git工具流的一个项目托管平台 <img src=\"https://upload-images.jianshu.io/upload_images/226662-6e184a8462131352.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp\"> 顺便提一下这里只温习一下Git的相关知识，关于SVN（集中式管理系统）这里不做对比也不去做详细的描述。具体了解两者的区别可以去这里：<a href=\"https://www.shiyanlou.com/questions/2999/\">https://www.shiyanlou.com/questions/2999/  </a></p>\n<h2 id=\"常用配置\"><a href=\"#常用配置\" class=\"headerlink\" title=\"常用配置\"></a>常用配置</h2><p>–system #系统级别<br>–global #用户全局<br>–local #单独一个项目<br>git config –global user.name “xxxx” #用户名<br>git config –global user.email “<a href=\"mailto:&#x78;&#120;&#x78;&#x78;&#64;&#120;&#x78;&#x78;&#46;&#x63;&#111;&#109;\">&#x78;&#120;&#x78;&#x78;&#64;&#120;&#x78;&#x78;&#46;&#x63;&#111;&#109;</a>“ #邮箱<br>git config –global core.editor vim #编辑器<br>git config –global alias.st status #按这种方法，配置别名<br>git config -l #列举所有配置</p>\n<h2 id=\"文件直接比较差异Diff\"><a href=\"#文件直接比较差异Diff\" class=\"headerlink\" title=\"文件直接比较差异Diff\"></a>文件直接比较差异Diff</h2><p>git diff git diff <file> #比较工作区与暂存区文件的差异<br>git diff –cached   # 比较暂存区和版本库差异</p>\n<p>git diff &lt;$id1&gt; &lt;$id2&gt;   # 比较两次提交之间的差异<br>git diff <branch1>..<branch2> # 在两个分支之间比较分支<br>git branch -r #查看远程分支<br>git branch new_branch_name #新建一个分支<br>git branch –merged #查看已经被合并到当前分支的分支<br>git branch –no-merged #查看未被合并到当前分支的分支</p>\n<p>git checkout branch_name #切换分支<br>git checkout -b branch_name #创建分支并切换</p>\n<p>git branch -d branch_name #删除分支<br>git branch -D branch_name #强制删除分支<br>git push origin :branch-name #删除远程分支（先在本地删除该分支），原理是把一个空分支push到server上，相当于删除该分支。</p>\n<p>#从远程clone一个项目，虽然远程上该项目是有分支的，但clone下来后发现只有master分支，解决：<br>git checkout -b not_master_branch  origin/not_master_branch #本地创建一个分支，指向对应的远程分支<br>git pull origin not_master_branch #将远程的not_master_branch分支pull下来<br>git push origin not_master_branch #将修改后的not_master_branch分支push到远程的not_master_branch </p>\n<h2 id=\"Git中3种状态的一些操作\"><a href=\"#Git中3种状态的一些操作\" class=\"headerlink\" title=\"Git中3种状态的一些操作\"></a>Git中3种状态的一些操作</h2><p>#将工作区的修改提交到暂存区<br>git add <file><br>git add .<br>#——————————————</p>\n<p>#将暂存区的内容提交到版本库<br>git commit <file><br>git commit .<br>git commit -a #包括git add/ git rm /git commint 这三个操作，所有一般在操作工作区的时候，直接删除了文件，而不是使用git rm的，最后提交是可以用这个，如下<br>              #git commit -am “提交信息”<br>git commit -amend #修改最后一次提交的信息</p>\n<p>#——————————————</p>\n<p># 抛弃工作区修改(使用当前暂存区的内容状态去覆盖工作区，从而达到抛弃工作区修改的作用)<br>git checkout <file><br>git checkout .  </p>\n<p>#——————————————<br>#改变暂存区的修改（其实是重置HEAD，将指定版本库的内容状态去覆盖暂存区，从而达到暂存区的改变）<br>git reset <file>  #从暂存区恢复到工作区（不指定版本id，则默认为最后一次提交的版本id）<br>git reset .  #从暂存区恢复到工作区<br>git reset $id # 恢复到指定的提交版本，该$id之后的版本提交都恢复到工作区<br>git reset –hard $id #恢复到指定的提交版本，该$id之后的版本提交全部会被抛弃，将不出现在工作区</p>\n<p>#注：如果不小心使用了错误的HEAD重置，会发现HEAD指向了重置的版本id，该版本之后的版本提交都不见了，使用git log也无法找到，那么怎么恢复呢？使用下面两个命令<br>git reflog show master | head #会显示所有的版本记录<br>git reset –hard $id #重新重置，至于–hard，请根据你时候将改变的内容放到工作区还是直接抛弃进行选择</p>\n<p>#——————————————<br>#恢复某次提交（其实是某提提交的回滚操作，不影响其他的提交，所产生的效果创建一个新版本提交去回滚将指定的提交删除，包括产生的差异文件不会出现在工作区，而是直接被抛弃）<br>git revert &lt;$id&gt;<br>git revert HEAD<br>#这里有一个很好的讲解revert与reset的差异：git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</p>\n<p>#——————————————<br>#删除文件的几种方法（貌似Git2.0后有了变化）<br>#第一种直接在工作区删除<br>rm your_file #直接在工作区删除文件<br>git add -u . #将有改动的都提交到暂存区（包括修改的，删除的等操作），貌似git2.0 不加 -u 参数也可以<br>git commint -m “message” #提交版本库</p>\n<p>#第二种方法直接在工作区删除<br>rm your_file #直接在工作区删除文件<br>git commit -am “message” #这个在前面提过，直接可以提交版本库，-a会包括包括git add/ git rm /git commint 这三个操作</p>\n<p>#第三种方法使用git rm<br>git rm <file> #不仅在工作区将文件删除，同时将该删除操作提交到暂存区<br>git commint -m “message” #提交版本库</p>\n<p>#关于git rm的其他补充<br>git rm –cached <file> #从暂存区中除去该文件，git将不再跟踪该文件的变更，但仍然在工作区内，在需要.gitignore时经常用到</p>\n<h2 id=\"Tag\"><a href=\"#Tag\" class=\"headerlink\" title=\"Tag\"></a>Tag</h2><p>git tag v1.0.0 [SHA]<br>#打一个轻量级的tag，只是一个commit的指向引用,[SHA]是可选择值（某个commit的SHA），指定为哪个commit打tag，如果没写则直接为最后一个commit打tag</p>\n<p>git tag -a v1.0.0 -m “你的附注信息” [SHA]<br>#一个带附注信息的tag，不是一个简单的引用，而是单独的一个对象，[SHA]是可选择值（某个commit的SHA），指定为哪个commit打tag，如果没写则直接为最后一个commit打tag</p>\n<p>git tag #列出所有的tag<br>git show v1.0.0  #打印指定tag的信息<br>git tag -d v1.0.0 #删除本地指定tag<br>git push origin :refs/tags/v1.0.0 #删除远程tag</p>\n<h2 id=\"远程\"><a href=\"#远程\" class=\"headerlink\" title=\"远程\"></a>远程</h2><p>git remote -v                    # 查看远程服务器地址和仓库名称<br>git remote show origin           # 查看远程服务器仓库状态<br>git remote add origin git@github:robbin/robbin_site.git         # 添加远程仓库地址<br>git remote set-url origin <a href=\"mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;\">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;</a>:robbin/robbin #修改远程地址<br>git remote rm #删除远程创库地址</p>\n<h2 id=\"从远程拉取内容-提交内容到远程\"><a href=\"#从远程拉取内容-提交内容到远程\" class=\"headerlink\" title=\"从远程拉取内容,提交内容到远程\"></a>从远程拉取内容,提交内容到远程</h2><p>git pull #=git fetch + git merge<br>git fetch #拉取<br>git merge #合并</p>\n<p>git push                         # push所有分支<br>git push origin master           # 将本地主分支推到远程主分支<br>git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)<br>git push origin <local_branch>   # 创建远程分支， origin是远程仓库名<br>git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  # 创建远程分支<br>git push origin :<remote_branch>  #先删除本地分支(git br -d <branch>)，然后再push删除远程分支</p>\n<h2 id=\"暂存管理\"><a href=\"#暂存管理\" class=\"headerlink\" title=\"暂存管理\"></a>暂存管理</h2><p>git stash #将工作区做的修改暂存到一个git栈中<br>git stash list #查看栈中所有暂存<br>git stash apply &lt;暂存编号&gt; #回复对应编号暂存到工作区，如果不指定编号为栈顶的，注意：这些暂存还在栈中<br>git stash pop #将栈顶的暂存，恢复到工作区，并从栈中弹出<br>git stash clear #清空暂存栈</p>\n<h2 id=\"创建远程库\"><a href=\"#创建远程库\" class=\"headerlink\" title=\"创建远程库\"></a>创建远程库</h2><p>git clone –bare git_url_path #clone的时候，将其创建成远程创库<br>git –bare init #初始化项目的时候，创建成远程创库</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<blockquote>\n<p>Git和GitHub有啥关系？</p>\n</blockquote>\n<p>答：Git是版本控制工具，GitHub是基于Git工具流的一个项目托管平台 <img src=\"https://upload-images.jianshu.io/upload_images/226662-6e184a8462131352.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/583/format/webp\"> 顺便提一下这里只温习一下Git的相关知识，关于SVN（集中式管理系统）这里不做对比也不去做详细的描述。具体了解两者的区别可以去这里：<a href=\"https://www.shiyanlou.com/questions/2999/\">https://www.shiyanlou.com/questions/2999/  </a></p>\n<h2 id=\"常用配置\"><a href=\"#常用配置\" class=\"headerlink\" title=\"常用配置\"></a>常用配置</h2><p>–system #系统级别<br>–global #用户全局<br>–local #单独一个项目<br>git config –global user.name “xxxx” #用户名<br>git config –global user.email “<a href=\"mailto:&#x78;&#120;&#x78;&#x78;&#64;&#120;&#x78;&#x78;&#46;&#x63;&#111;&#109;\">&#x78;&#120;&#x78;&#x78;&#64;&#120;&#x78;&#x78;&#46;&#x63;&#111;&#109;</a>“ #邮箱<br>git config –global core.editor vim #编辑器<br>git config –global alias.st status #按这种方法，配置别名<br>git config -l #列举所有配置</p>\n<h2 id=\"文件直接比较差异Diff\"><a href=\"#文件直接比较差异Diff\" class=\"headerlink\" title=\"文件直接比较差异Diff\"></a>文件直接比较差异Diff</h2><p>git diff git diff <file> #比较工作区与暂存区文件的差异<br>git diff –cached   # 比较暂存区和版本库差异</p>\n<p>git diff &lt;$id1&gt; &lt;$id2&gt;   # 比较两次提交之间的差异<br>git diff <branch1>..<branch2> # 在两个分支之间比较分支<br>git branch -r #查看远程分支<br>git branch new_branch_name #新建一个分支<br>git branch –merged #查看已经被合并到当前分支的分支<br>git branch –no-merged #查看未被合并到当前分支的分支</p>\n<p>git checkout branch_name #切换分支<br>git checkout -b branch_name #创建分支并切换</p>\n<p>git branch -d branch_name #删除分支<br>git branch -D branch_name #强制删除分支<br>git push origin :branch-name #删除远程分支（先在本地删除该分支），原理是把一个空分支push到server上，相当于删除该分支。</p>\n<p>#从远程clone一个项目，虽然远程上该项目是有分支的，但clone下来后发现只有master分支，解决：<br>git checkout -b not_master_branch  origin/not_master_branch #本地创建一个分支，指向对应的远程分支<br>git pull origin not_master_branch #将远程的not_master_branch分支pull下来<br>git push origin not_master_branch #将修改后的not_master_branch分支push到远程的not_master_branch </p>\n<h2 id=\"Git中3种状态的一些操作\"><a href=\"#Git中3种状态的一些操作\" class=\"headerlink\" title=\"Git中3种状态的一些操作\"></a>Git中3种状态的一些操作</h2><p>#将工作区的修改提交到暂存区<br>git add <file><br>git add .<br>#——————————————</p>\n<p>#将暂存区的内容提交到版本库<br>git commit <file><br>git commit .<br>git commit -a #包括git add/ git rm /git commint 这三个操作，所有一般在操作工作区的时候，直接删除了文件，而不是使用git rm的，最后提交是可以用这个，如下<br>              #git commit -am “提交信息”<br>git commit -amend #修改最后一次提交的信息</p>\n<p>#——————————————</p>\n<p># 抛弃工作区修改(使用当前暂存区的内容状态去覆盖工作区，从而达到抛弃工作区修改的作用)<br>git checkout <file><br>git checkout .  </p>\n<p>#——————————————<br>#改变暂存区的修改（其实是重置HEAD，将指定版本库的内容状态去覆盖暂存区，从而达到暂存区的改变）<br>git reset <file>  #从暂存区恢复到工作区（不指定版本id，则默认为最后一次提交的版本id）<br>git reset .  #从暂存区恢复到工作区<br>git reset $id # 恢复到指定的提交版本，该$id之后的版本提交都恢复到工作区<br>git reset –hard $id #恢复到指定的提交版本，该$id之后的版本提交全部会被抛弃，将不出现在工作区</p>\n<p>#注：如果不小心使用了错误的HEAD重置，会发现HEAD指向了重置的版本id，该版本之后的版本提交都不见了，使用git log也无法找到，那么怎么恢复呢？使用下面两个命令<br>git reflog show master | head #会显示所有的版本记录<br>git reset –hard $id #重新重置，至于–hard，请根据你时候将改变的内容放到工作区还是直接抛弃进行选择</p>\n<p>#——————————————<br>#恢复某次提交（其实是某提提交的回滚操作，不影响其他的提交，所产生的效果创建一个新版本提交去回滚将指定的提交删除，包括产生的差异文件不会出现在工作区，而是直接被抛弃）<br>git revert &lt;$id&gt;<br>git revert HEAD<br>#这里有一个很好的讲解revert与reset的差异：git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。</p>\n<p>#——————————————<br>#删除文件的几种方法（貌似Git2.0后有了变化）<br>#第一种直接在工作区删除<br>rm your_file #直接在工作区删除文件<br>git add -u . #将有改动的都提交到暂存区（包括修改的，删除的等操作），貌似git2.0 不加 -u 参数也可以<br>git commint -m “message” #提交版本库</p>\n<p>#第二种方法直接在工作区删除<br>rm your_file #直接在工作区删除文件<br>git commit -am “message” #这个在前面提过，直接可以提交版本库，-a会包括包括git add/ git rm /git commint 这三个操作</p>\n<p>#第三种方法使用git rm<br>git rm <file> #不仅在工作区将文件删除，同时将该删除操作提交到暂存区<br>git commint -m “message” #提交版本库</p>\n<p>#关于git rm的其他补充<br>git rm –cached <file> #从暂存区中除去该文件，git将不再跟踪该文件的变更，但仍然在工作区内，在需要.gitignore时经常用到</p>\n<h2 id=\"Tag\"><a href=\"#Tag\" class=\"headerlink\" title=\"Tag\"></a>Tag</h2><p>git tag v1.0.0 [SHA]<br>#打一个轻量级的tag，只是一个commit的指向引用,[SHA]是可选择值（某个commit的SHA），指定为哪个commit打tag，如果没写则直接为最后一个commit打tag</p>\n<p>git tag -a v1.0.0 -m “你的附注信息” [SHA]<br>#一个带附注信息的tag，不是一个简单的引用，而是单独的一个对象，[SHA]是可选择值（某个commit的SHA），指定为哪个commit打tag，如果没写则直接为最后一个commit打tag</p>\n<p>git tag #列出所有的tag<br>git show v1.0.0  #打印指定tag的信息<br>git tag -d v1.0.0 #删除本地指定tag<br>git push origin :refs/tags/v1.0.0 #删除远程tag</p>\n<h2 id=\"远程\"><a href=\"#远程\" class=\"headerlink\" title=\"远程\"></a>远程</h2><p>git remote -v                    # 查看远程服务器地址和仓库名称<br>git remote show origin           # 查看远程服务器仓库状态<br>git remote add origin git@github:robbin/robbin_site.git         # 添加远程仓库地址<br>git remote set-url origin <a href=\"mailto:&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;\">&#x67;&#x69;&#x74;&#x40;&#103;&#105;&#x74;&#104;&#x75;&#98;&#x2e;&#99;&#x6f;&#109;</a>:robbin/robbin #修改远程地址<br>git remote rm #删除远程创库地址</p>\n<h2 id=\"从远程拉取内容-提交内容到远程\"><a href=\"#从远程拉取内容-提交内容到远程\" class=\"headerlink\" title=\"从远程拉取内容,提交内容到远程\"></a>从远程拉取内容,提交内容到远程</h2><p>git pull #=git fetch + git merge<br>git fetch #拉取<br>git merge #合并</p>\n<p>git push                         # push所有分支<br>git push origin master           # 将本地主分支推到远程主分支<br>git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)<br>git push origin <local_branch>   # 创建远程分支， origin是远程仓库名<br>git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  # 创建远程分支<br>git push origin :<remote_branch>  #先删除本地分支(git br -d <branch>)，然后再push删除远程分支</p>\n<h2 id=\"暂存管理\"><a href=\"#暂存管理\" class=\"headerlink\" title=\"暂存管理\"></a>暂存管理</h2><p>git stash #将工作区做的修改暂存到一个git栈中<br>git stash list #查看栈中所有暂存<br>git stash apply &lt;暂存编号&gt; #回复对应编号暂存到工作区，如果不指定编号为栈顶的，注意：这些暂存还在栈中<br>git stash pop #将栈顶的暂存，恢复到工作区，并从栈中弹出<br>git stash clear #清空暂存栈</p>\n<h2 id=\"创建远程库\"><a href=\"#创建远程库\" class=\"headerlink\" title=\"创建远程库\"></a>创建远程库</h2><p>git clone –bare git_url_path #clone的时候，将其创建成远程创库<br>git –bare init #初始化项目的时候，创建成远程创库</p>\n"},{"title":"git日常操作","comments":1,"toc":true,"thumbnail":"http://pic2.zhimg.com/v2-d37c3ddfbf67ac4e568adc623d923b73_1200x500.gif","date":"2020-01-13T03:24:51.000Z","updated":"2020-01-13T03:24:51.000Z","_content":"\n目前在我工作中用到的版本控制工具有 `SVN` 和 `Git`,代码开发主要以 Git 为主，Git 的命令有很多不过只是常规操作也就那么 6 个，但是要熟练使用那就需要记住很多命令了\n\n<!-- more -->\n\n![常用命令清单](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png)\nGit 操作流中的专业术语，简单解释一下\n\n> - Workspace：工作区\n> - Index / Stage：暂存区 （add 操作后放置的地方）\n> - Repository：仓库区（或本地仓库执行 commit 操作后保存到的地方）\n> - Remote：远程仓库（线上仓库）\n\n以下我们就从头开始收集一下常用的开发命令\n\n# 创建新仓库\n\n```bash\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n# 配置\n\nGit 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```bash\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n# 增加/删除文件\n\n```bash\n# 添加指定文件到暂存区\n\n$ git add [file1][file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n\n$ git add .\n\n# 添加每个变化前，都会要求确认\n\n# 对于同一个文件的多处变化，可以实现分次提交\n\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n\n$ git rm [file1][file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n\n$ git mv [file-original][file-renamed]\n```\n\n# 代码提交\n\n```bash\n# 提交暂存区到仓库区\n\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n\n$ git commit [file1][file2] ... -m [message]\n\n# 提交工作区自上次 commit 之后的变化，直接到仓库区\n\n$ git commit -a\n\n# 提交时显示所有 diff 信息\n\n$ git commit -v\n\n# 使用一次新的 commit，替代上一次提交\n\n# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息\n\n$ git commit --amend -m [message]\n\n# 重做上一次 commit，并包括指定文件的新变化\n\n$ git commit --amend [file1][file2] ...\n```\n\n# 分支\n\n```bash\n# 列出所有本地分支\n\n$ git branch\n\n# 列出所有远程分支\n\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定 commit\n\n$ git branch [branch][commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n\n$ git branch --track [branch][remote-branch]\n\n# 切换到指定分支，并更新工作区\n\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n\n$ git branch --set-upstream [branch][remote-branch]\n\n# 合并指定分支到当前分支\n\n$ git merge [branch]\n\n# 选择一个 commit，合并进当前分支\n\n$ git cherry-pick [commit]\n\n# 删除分支\n\n$ git branch -d [branch-name]\n\n# 删除远程分支\n\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n\n# 标签\n\n```bash\n# 列出所有 tag\n\n$ git tag\n\n# 新建一个 tag 在当前 commit\n\n$ git tag [tag]\n\n# 新建一个 tag 在指定 commit\n\n$ git tag [tag][commit]\n\n# 删除本地 tag\n\n$ git tag -d [tag]\n\n# 删除远程 tag\n\n$ git push origin :refs/tags/[tagName]\n\n# 查看 tag 信息\n\n$ git show [tag]\n\n# 提交指定 tag\n\n$ git push [remote][tag]\n\n# 提交所有 tag\n\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个 tag\n\n$ git checkout -b [branch][tag]\n```\n\n# 查看信息\n\n```bash\n# 显示有变更的文件\n\n$ git status\n\n# 显示当前分支的版本历史\n\n$ git log\n\n# 显示 commit 历史，以及每次 commit 发生变更的文件\n\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n\n$ git log -S [keyword]\n\n# 显示某个 commit 之后的所有变动，每个 commit 占据一行\n\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个 commit 之后的所有变动，其\"提交说明\"必须符合搜索条件\n\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次 diff\n\n$ git log -p [file]\n\n# 显示过去 5 次提交\n\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n\n$ git diff\n\n# 显示暂存区和上一个 commit 的差异\n\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新 commit 之间的差异\n\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n\n$ git reflog\n```\n\n# 远程同步\n\n```bash\n# 下载远程仓库的所有变动\n\n$ git fetch [remote]\n\n# 显示所有远程仓库\n\n$ git remote -v\n\n# 显示某个远程仓库的信息\n\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n\n$ git remote add [shortname][url]\n\n# 取回远程仓库的变化，并与本地分支合并\n\n$ git pull [remote][branch]\n\n# 上传本地指定分支到远程仓库\n\n$ git push [remote][branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n\n$ git push [remote] --all\n```\n\n# 撤销\n\n```bash\n# 恢复暂存区的指定文件到工作区\n\n$ git checkout [file]\n\n# 恢复某个 commit 的指定文件到暂存区和工作区\n\n$ git checkout [commit][file]\n\n# 恢复暂存区的所有文件到工作区\n\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\n\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次 commit 保持一致\n\n$ git reset --hard\n\n# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变\n\n$ git reset [commit]\n\n# 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致\n\n$ git reset --hard [commit]\n\n# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变\n\n$ git reset --keep [commit]\n\n# 新建一个 commit，用来撤销指定 commit\n\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n\n$ git stash\n$ git stash pop\n```\n\n# 其他\n\n```bash\n# 生成一个可供发布的压缩包\n\n$ git archive\n```\n\n参考资料： [常用 Git 命令清单](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n","source":"_posts/git日常操作.md","raw":"---\ntitle: git日常操作\ncomments: true\ntoc: true\ncategories:\n  - 大前端\nthumbnail: 'http://pic2.zhimg.com/v2-d37c3ddfbf67ac4e568adc623d923b73_1200x500.gif'\ndate: 2020-01-13 11:24:51\nupdated: 2020-01-13 11:24:51\ntags:\n---\n\n目前在我工作中用到的版本控制工具有 `SVN` 和 `Git`,代码开发主要以 Git 为主，Git 的命令有很多不过只是常规操作也就那么 6 个，但是要熟练使用那就需要记住很多命令了\n\n<!-- more -->\n\n![常用命令清单](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png)\nGit 操作流中的专业术语，简单解释一下\n\n> - Workspace：工作区\n> - Index / Stage：暂存区 （add 操作后放置的地方）\n> - Repository：仓库区（或本地仓库执行 commit 操作后保存到的地方）\n> - Remote：远程仓库（线上仓库）\n\n以下我们就从头开始收集一下常用的开发命令\n\n# 创建新仓库\n\n```bash\n# 在当前目录新建一个Git代码库\n$ git init\n\n# 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n\n# 下载一个项目和它的整个代码历史\n$ git clone [url]\n```\n\n# 配置\n\nGit 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n\n```bash\n# 显示当前的Git配置\n$ git config --list\n\n# 编辑Git配置文件\n$ git config -e [--global]\n\n# 设置提交代码时的用户信息\n$ git config [--global] user.name \"[name]\"\n$ git config [--global] user.email \"[email address]\"\n```\n\n# 增加/删除文件\n\n```bash\n# 添加指定文件到暂存区\n\n$ git add [file1][file2] ...\n\n# 添加指定目录到暂存区，包括子目录\n\n$ git add [dir]\n\n# 添加当前目录的所有文件到暂存区\n\n$ git add .\n\n# 添加每个变化前，都会要求确认\n\n# 对于同一个文件的多处变化，可以实现分次提交\n\n$ git add -p\n\n# 删除工作区文件，并且将这次删除放入暂存区\n\n$ git rm [file1][file2] ...\n\n# 停止追踪指定文件，但该文件会保留在工作区\n\n$ git rm --cached [file]\n\n# 改名文件，并且将这个改名放入暂存区\n\n$ git mv [file-original][file-renamed]\n```\n\n# 代码提交\n\n```bash\n# 提交暂存区到仓库区\n\n$ git commit -m [message]\n\n# 提交暂存区的指定文件到仓库区\n\n$ git commit [file1][file2] ... -m [message]\n\n# 提交工作区自上次 commit 之后的变化，直接到仓库区\n\n$ git commit -a\n\n# 提交时显示所有 diff 信息\n\n$ git commit -v\n\n# 使用一次新的 commit，替代上一次提交\n\n# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息\n\n$ git commit --amend -m [message]\n\n# 重做上一次 commit，并包括指定文件的新变化\n\n$ git commit --amend [file1][file2] ...\n```\n\n# 分支\n\n```bash\n# 列出所有本地分支\n\n$ git branch\n\n# 列出所有远程分支\n\n$ git branch -r\n\n# 列出所有本地分支和远程分支\n\n$ git branch -a\n\n# 新建一个分支，但依然停留在当前分支\n\n$ git branch [branch-name]\n\n# 新建一个分支，并切换到该分支\n\n$ git checkout -b [branch]\n\n# 新建一个分支，指向指定 commit\n\n$ git branch [branch][commit]\n\n# 新建一个分支，与指定的远程分支建立追踪关系\n\n$ git branch --track [branch][remote-branch]\n\n# 切换到指定分支，并更新工作区\n\n$ git checkout [branch-name]\n\n# 切换到上一个分支\n\n$ git checkout -\n\n# 建立追踪关系，在现有分支与指定的远程分支之间\n\n$ git branch --set-upstream [branch][remote-branch]\n\n# 合并指定分支到当前分支\n\n$ git merge [branch]\n\n# 选择一个 commit，合并进当前分支\n\n$ git cherry-pick [commit]\n\n# 删除分支\n\n$ git branch -d [branch-name]\n\n# 删除远程分支\n\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n```\n\n# 标签\n\n```bash\n# 列出所有 tag\n\n$ git tag\n\n# 新建一个 tag 在当前 commit\n\n$ git tag [tag]\n\n# 新建一个 tag 在指定 commit\n\n$ git tag [tag][commit]\n\n# 删除本地 tag\n\n$ git tag -d [tag]\n\n# 删除远程 tag\n\n$ git push origin :refs/tags/[tagName]\n\n# 查看 tag 信息\n\n$ git show [tag]\n\n# 提交指定 tag\n\n$ git push [remote][tag]\n\n# 提交所有 tag\n\n$ git push [remote] --tags\n\n# 新建一个分支，指向某个 tag\n\n$ git checkout -b [branch][tag]\n```\n\n# 查看信息\n\n```bash\n# 显示有变更的文件\n\n$ git status\n\n# 显示当前分支的版本历史\n\n$ git log\n\n# 显示 commit 历史，以及每次 commit 发生变更的文件\n\n$ git log --stat\n\n# 搜索提交历史，根据关键词\n\n$ git log -S [keyword]\n\n# 显示某个 commit 之后的所有变动，每个 commit 占据一行\n\n$ git log [tag] HEAD --pretty=format:%s\n\n# 显示某个 commit 之后的所有变动，其\"提交说明\"必须符合搜索条件\n\n$ git log [tag] HEAD --grep feature\n\n# 显示某个文件的版本历史，包括文件改名\n\n$ git log --follow [file]\n$ git whatchanged [file]\n\n# 显示指定文件相关的每一次 diff\n\n$ git log -p [file]\n\n# 显示过去 5 次提交\n\n$ git log -5 --pretty --oneline\n\n# 显示所有提交过的用户，按提交次数排序\n\n$ git shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\n\n$ git blame [file]\n\n# 显示暂存区和工作区的差异\n\n$ git diff\n\n# 显示暂存区和上一个 commit 的差异\n\n$ git diff --cached [file]\n\n# 显示工作区与当前分支最新 commit 之间的差异\n\n$ git diff HEAD\n\n# 显示两次提交之间的差异\n\n$ git diff [first-branch]...[second-branch]\n\n# 显示今天你写了多少行代码\n\n$ git diff --shortstat \"@{0 day ago}\"\n\n# 显示某次提交的元数据和内容变化\n\n$ git show [commit]\n\n# 显示某次提交发生变化的文件\n\n$ git show --name-only [commit]\n\n# 显示某次提交时，某个文件的内容\n\n$ git show [commit]:[filename]\n\n# 显示当前分支的最近几次提交\n\n$ git reflog\n```\n\n# 远程同步\n\n```bash\n# 下载远程仓库的所有变动\n\n$ git fetch [remote]\n\n# 显示所有远程仓库\n\n$ git remote -v\n\n# 显示某个远程仓库的信息\n\n$ git remote show [remote]\n\n# 增加一个新的远程仓库，并命名\n\n$ git remote add [shortname][url]\n\n# 取回远程仓库的变化，并与本地分支合并\n\n$ git pull [remote][branch]\n\n# 上传本地指定分支到远程仓库\n\n$ git push [remote][branch]\n\n# 强行推送当前分支到远程仓库，即使有冲突\n\n$ git push [remote] --force\n\n# 推送所有分支到远程仓库\n\n$ git push [remote] --all\n```\n\n# 撤销\n\n```bash\n# 恢复暂存区的指定文件到工作区\n\n$ git checkout [file]\n\n# 恢复某个 commit 的指定文件到暂存区和工作区\n\n$ git checkout [commit][file]\n\n# 恢复暂存区的所有文件到工作区\n\n$ git checkout .\n\n# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变\n\n$ git reset [file]\n\n# 重置暂存区与工作区，与上一次 commit 保持一致\n\n$ git reset --hard\n\n# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变\n\n$ git reset [commit]\n\n# 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致\n\n$ git reset --hard [commit]\n\n# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变\n\n$ git reset --keep [commit]\n\n# 新建一个 commit，用来撤销指定 commit\n\n# 后者的所有变化都将被前者抵消，并且应用到当前分支\n\n$ git revert [commit]\n\n# 暂时将未提交的变化移除，稍后再移入\n\n$ git stash\n$ git stash pop\n```\n\n# 其他\n\n```bash\n# 生成一个可供发布的压缩包\n\n$ git archive\n```\n\n参考资料： [常用 Git 命令清单](http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html)\n","slug":"git日常操作","published":1,"layout":"post","photos":[],"link":"","_id":"ckmp269dt003cc8gs82csgpgv","content":"<p>目前在我工作中用到的版本控制工具有 <code>SVN</code> 和 <code>Git</code>,代码开发主要以 Git 为主，Git 的命令有很多不过只是常规操作也就那么 6 个，但是要熟练使用那就需要记住很多命令了</p>\n<span id=\"more\"></span>\n\n<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png\" alt=\"常用命令清单\"><br>Git 操作流中的专业术语，简单解释一下</p>\n<blockquote>\n<ul>\n<li>Workspace：工作区</li>\n<li>Index / Stage：暂存区 （add 操作后放置的地方）</li>\n<li>Repository：仓库区（或本地仓库执行 commit 操作后保存到的地方）</li>\n<li>Remote：远程仓库（线上仓库）</li>\n</ul>\n</blockquote>\n<p>以下我们就从头开始收集一下常用的开发命令</p>\n<h1 id=\"创建新仓库\"><a href=\"#创建新仓库\" class=\"headerlink\" title=\"创建新仓库\"></a>创建新仓库</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 在当前目录新建一个Git代码库</span><br>$ git init<br><br><span class=\"hljs-comment\"># 新建一个目录，将其初始化为Git代码库</span><br>$ git init [project-name]<br><br><span class=\"hljs-comment\"># 下载一个项目和它的整个代码历史</span><br>$ git <span class=\"hljs-built_in\">clone</span> [url]<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 显示当前的Git配置</span><br>$ git config --list<br><br><span class=\"hljs-comment\"># 编辑Git配置文件</span><br>$ git config -e [--global]<br><br><span class=\"hljs-comment\"># 设置提交代码时的用户信息</span><br>$ git config [--global] user.name <span class=\"hljs-string\">&quot;[name]&quot;</span><br>$ git config [--global] user.email <span class=\"hljs-string\">&quot;[email address]&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"增加-删除文件\"><a href=\"#增加-删除文件\" class=\"headerlink\" title=\"增加/删除文件\"></a>增加/删除文件</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 添加指定文件到暂存区</span><br><br>$ git add [file1][file2] ...<br><br><span class=\"hljs-comment\"># 添加指定目录到暂存区，包括子目录</span><br><br>$ git add [dir]<br><br><span class=\"hljs-comment\"># 添加当前目录的所有文件到暂存区</span><br><br>$ git add .<br><br><span class=\"hljs-comment\"># 添加每个变化前，都会要求确认</span><br><br><span class=\"hljs-comment\"># 对于同一个文件的多处变化，可以实现分次提交</span><br><br>$ git add -p<br><br><span class=\"hljs-comment\"># 删除工作区文件，并且将这次删除放入暂存区</span><br><br>$ git rm [file1][file2] ...<br><br><span class=\"hljs-comment\"># 停止追踪指定文件，但该文件会保留在工作区</span><br><br>$ git rm --cached [file]<br><br><span class=\"hljs-comment\"># 改名文件，并且将这个改名放入暂存区</span><br><br>$ git mv [file-original][file-renamed]<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"代码提交\"><a href=\"#代码提交\" class=\"headerlink\" title=\"代码提交\"></a>代码提交</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 提交暂存区到仓库区</span><br><br>$ git commit -m [message]<br><br><span class=\"hljs-comment\"># 提交暂存区的指定文件到仓库区</span><br><br>$ git commit [file1][file2] ... -m [message]<br><br><span class=\"hljs-comment\"># 提交工作区自上次 commit 之后的变化，直接到仓库区</span><br><br>$ git commit -a<br><br><span class=\"hljs-comment\"># 提交时显示所有 diff 信息</span><br><br>$ git commit -v<br><br><span class=\"hljs-comment\"># 使用一次新的 commit，替代上一次提交</span><br><br><span class=\"hljs-comment\"># 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息</span><br><br>$ git commit --amend -m [message]<br><br><span class=\"hljs-comment\"># 重做上一次 commit，并包括指定文件的新变化</span><br><br>$ git commit --amend [file1][file2] ...<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 列出所有本地分支</span><br><br>$ git branch<br><br><span class=\"hljs-comment\"># 列出所有远程分支</span><br><br>$ git branch -r<br><br><span class=\"hljs-comment\"># 列出所有本地分支和远程分支</span><br><br>$ git branch -a<br><br><span class=\"hljs-comment\"># 新建一个分支，但依然停留在当前分支</span><br><br>$ git branch [branch-name]<br><br><span class=\"hljs-comment\"># 新建一个分支，并切换到该分支</span><br><br>$ git checkout -b [branch]<br><br><span class=\"hljs-comment\"># 新建一个分支，指向指定 commit</span><br><br>$ git branch [branch][commit]<br><br><span class=\"hljs-comment\"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><br>$ git branch --track [branch][remote-branch]<br><br><span class=\"hljs-comment\"># 切换到指定分支，并更新工作区</span><br><br>$ git checkout [branch-name]<br><br><span class=\"hljs-comment\"># 切换到上一个分支</span><br><br>$ git checkout -<br><br><span class=\"hljs-comment\"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><br>$ git branch --set-upstream [branch][remote-branch]<br><br><span class=\"hljs-comment\"># 合并指定分支到当前分支</span><br><br>$ git merge [branch]<br><br><span class=\"hljs-comment\"># 选择一个 commit，合并进当前分支</span><br><br>$ git cherry-pick [commit]<br><br><span class=\"hljs-comment\"># 删除分支</span><br><br>$ git branch -d [branch-name]<br><br><span class=\"hljs-comment\"># 删除远程分支</span><br><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 列出所有 tag</span><br><br>$ git tag<br><br><span class=\"hljs-comment\"># 新建一个 tag 在当前 commit</span><br><br>$ git tag [tag]<br><br><span class=\"hljs-comment\"># 新建一个 tag 在指定 commit</span><br><br>$ git tag [tag][commit]<br><br><span class=\"hljs-comment\"># 删除本地 tag</span><br><br>$ git tag -d [tag]<br><br><span class=\"hljs-comment\"># 删除远程 tag</span><br><br>$ git push origin :refs/tags/[tagName]<br><br><span class=\"hljs-comment\"># 查看 tag 信息</span><br><br>$ git show [tag]<br><br><span class=\"hljs-comment\"># 提交指定 tag</span><br><br>$ git push [remote][tag]<br><br><span class=\"hljs-comment\"># 提交所有 tag</span><br><br>$ git push [remote] --tags<br><br><span class=\"hljs-comment\"># 新建一个分支，指向某个 tag</span><br><br>$ git checkout -b [branch][tag]<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 显示有变更的文件</span><br><br>$ git status<br><br><span class=\"hljs-comment\"># 显示当前分支的版本历史</span><br><br>$ git <span class=\"hljs-built_in\">log</span><br><br><span class=\"hljs-comment\"># 显示 commit 历史，以及每次 commit 发生变更的文件</span><br><br>$ git <span class=\"hljs-built_in\">log</span> --<span class=\"hljs-built_in\">stat</span><br><br><span class=\"hljs-comment\"># 搜索提交历史，根据关键词</span><br><br>$ git <span class=\"hljs-built_in\">log</span> -S [keyword]<br><br><span class=\"hljs-comment\"># 显示某个 commit 之后的所有变动，每个 commit 占据一行</span><br><br>$ git <span class=\"hljs-built_in\">log</span> [tag] HEAD --pretty=format:%s<br><br><span class=\"hljs-comment\"># 显示某个 commit 之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><br>$ git <span class=\"hljs-built_in\">log</span> [tag] HEAD --grep feature<br><br><span class=\"hljs-comment\"># 显示某个文件的版本历史，包括文件改名</span><br><br>$ git <span class=\"hljs-built_in\">log</span> --follow [file]<br>$ git whatchanged [file]<br><br><span class=\"hljs-comment\"># 显示指定文件相关的每一次 diff</span><br><br>$ git <span class=\"hljs-built_in\">log</span> -p [file]<br><br><span class=\"hljs-comment\"># 显示过去 5 次提交</span><br><br>$ git <span class=\"hljs-built_in\">log</span> -5 --pretty --oneline<br><br><span class=\"hljs-comment\"># 显示所有提交过的用户，按提交次数排序</span><br><br>$ git shortlog -sn<br><br><span class=\"hljs-comment\"># 显示指定文件是什么人在什么时间修改过</span><br><br>$ git blame [file]<br><br><span class=\"hljs-comment\"># 显示暂存区和工作区的差异</span><br><br>$ git diff<br><br><span class=\"hljs-comment\"># 显示暂存区和上一个 commit 的差异</span><br><br>$ git diff --cached [file]<br><br><span class=\"hljs-comment\"># 显示工作区与当前分支最新 commit 之间的差异</span><br><br>$ git diff HEAD<br><br><span class=\"hljs-comment\"># 显示两次提交之间的差异</span><br><br>$ git diff [first-branch]...[second-branch]<br><br><span class=\"hljs-comment\"># 显示今天你写了多少行代码</span><br><br>$ git diff --shortstat <span class=\"hljs-string\">&quot;@&#123;0 day ago&#125;&quot;</span><br><br><span class=\"hljs-comment\"># 显示某次提交的元数据和内容变化</span><br><br>$ git show [commit]<br><br><span class=\"hljs-comment\"># 显示某次提交发生变化的文件</span><br><br>$ git show --name-only [commit]<br><br><span class=\"hljs-comment\"># 显示某次提交时，某个文件的内容</span><br><br>$ git show [commit]:[filename]<br><br><span class=\"hljs-comment\"># 显示当前分支的最近几次提交</span><br><br>$ git reflog<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 下载远程仓库的所有变动</span><br><br>$ git fetch [remote]<br><br><span class=\"hljs-comment\"># 显示所有远程仓库</span><br><br>$ git remote -v<br><br><span class=\"hljs-comment\"># 显示某个远程仓库的信息</span><br><br>$ git remote show [remote]<br><br><span class=\"hljs-comment\"># 增加一个新的远程仓库，并命名</span><br><br>$ git remote add [shortname][url]<br><br><span class=\"hljs-comment\"># 取回远程仓库的变化，并与本地分支合并</span><br><br>$ git pull [remote][branch]<br><br><span class=\"hljs-comment\"># 上传本地指定分支到远程仓库</span><br><br>$ git push [remote][branch]<br><br><span class=\"hljs-comment\"># 强行推送当前分支到远程仓库，即使有冲突</span><br><br>$ git push [remote] --force<br><br><span class=\"hljs-comment\"># 推送所有分支到远程仓库</span><br><br>$ git push [remote] --all<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 恢复暂存区的指定文件到工作区</span><br><br>$ git checkout [file]<br><br><span class=\"hljs-comment\"># 恢复某个 commit 的指定文件到暂存区和工作区</span><br><br>$ git checkout [commit][file]<br><br><span class=\"hljs-comment\"># 恢复暂存区的所有文件到工作区</span><br><br>$ git checkout .<br><br><span class=\"hljs-comment\"># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span><br><br>$ git reset [file]<br><br><span class=\"hljs-comment\"># 重置暂存区与工作区，与上一次 commit 保持一致</span><br><br>$ git reset --hard<br><br><span class=\"hljs-comment\"># 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span><br><br>$ git reset [commit]<br><br><span class=\"hljs-comment\"># 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致</span><br><br>$ git reset --hard [commit]<br><br><span class=\"hljs-comment\"># 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</span><br><br>$ git reset --keep [commit]<br><br><span class=\"hljs-comment\"># 新建一个 commit，用来撤销指定 commit</span><br><br><span class=\"hljs-comment\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><br>$ git revert [commit]<br><br><span class=\"hljs-comment\"># 暂时将未提交的变化移除，稍后再移入</span><br><br>$ git stash<br>$ git stash pop<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 生成一个可供发布的压缩包</span><br><br>$ git archive<br></code></pre></td></tr></table></figure>\n\n<p>参考资料： <a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\">常用 Git 命令清单</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<p>目前在我工作中用到的版本控制工具有 <code>SVN</code> 和 <code>Git</code>,代码开发主要以 Git 为主，Git 的命令有很多不过只是常规操作也就那么 6 个，但是要熟练使用那就需要记住很多命令了</p>","more":"<p><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png\" alt=\"常用命令清单\"><br>Git 操作流中的专业术语，简单解释一下</p>\n<blockquote>\n<ul>\n<li>Workspace：工作区</li>\n<li>Index / Stage：暂存区 （add 操作后放置的地方）</li>\n<li>Repository：仓库区（或本地仓库执行 commit 操作后保存到的地方）</li>\n<li>Remote：远程仓库（线上仓库）</li>\n</ul>\n</blockquote>\n<p>以下我们就从头开始收集一下常用的开发命令</p>\n<h1 id=\"创建新仓库\"><a href=\"#创建新仓库\" class=\"headerlink\" title=\"创建新仓库\"></a>创建新仓库</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 在当前目录新建一个Git代码库</span><br>$ git init<br><br><span class=\"hljs-comment\"># 新建一个目录，将其初始化为Git代码库</span><br>$ git init [project-name]<br><br><span class=\"hljs-comment\"># 下载一个项目和它的整个代码历史</span><br>$ git <span class=\"hljs-built_in\">clone</span> [url]<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h1><p>Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 显示当前的Git配置</span><br>$ git config --list<br><br><span class=\"hljs-comment\"># 编辑Git配置文件</span><br>$ git config -e [--global]<br><br><span class=\"hljs-comment\"># 设置提交代码时的用户信息</span><br>$ git config [--global] user.name <span class=\"hljs-string\">&quot;[name]&quot;</span><br>$ git config [--global] user.email <span class=\"hljs-string\">&quot;[email address]&quot;</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"增加-删除文件\"><a href=\"#增加-删除文件\" class=\"headerlink\" title=\"增加/删除文件\"></a>增加/删除文件</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 添加指定文件到暂存区</span><br><br>$ git add [file1][file2] ...<br><br><span class=\"hljs-comment\"># 添加指定目录到暂存区，包括子目录</span><br><br>$ git add [dir]<br><br><span class=\"hljs-comment\"># 添加当前目录的所有文件到暂存区</span><br><br>$ git add .<br><br><span class=\"hljs-comment\"># 添加每个变化前，都会要求确认</span><br><br><span class=\"hljs-comment\"># 对于同一个文件的多处变化，可以实现分次提交</span><br><br>$ git add -p<br><br><span class=\"hljs-comment\"># 删除工作区文件，并且将这次删除放入暂存区</span><br><br>$ git rm [file1][file2] ...<br><br><span class=\"hljs-comment\"># 停止追踪指定文件，但该文件会保留在工作区</span><br><br>$ git rm --cached [file]<br><br><span class=\"hljs-comment\"># 改名文件，并且将这个改名放入暂存区</span><br><br>$ git mv [file-original][file-renamed]<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"代码提交\"><a href=\"#代码提交\" class=\"headerlink\" title=\"代码提交\"></a>代码提交</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 提交暂存区到仓库区</span><br><br>$ git commit -m [message]<br><br><span class=\"hljs-comment\"># 提交暂存区的指定文件到仓库区</span><br><br>$ git commit [file1][file2] ... -m [message]<br><br><span class=\"hljs-comment\"># 提交工作区自上次 commit 之后的变化，直接到仓库区</span><br><br>$ git commit -a<br><br><span class=\"hljs-comment\"># 提交时显示所有 diff 信息</span><br><br>$ git commit -v<br><br><span class=\"hljs-comment\"># 使用一次新的 commit，替代上一次提交</span><br><br><span class=\"hljs-comment\"># 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息</span><br><br>$ git commit --amend -m [message]<br><br><span class=\"hljs-comment\"># 重做上一次 commit，并包括指定文件的新变化</span><br><br>$ git commit --amend [file1][file2] ...<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 列出所有本地分支</span><br><br>$ git branch<br><br><span class=\"hljs-comment\"># 列出所有远程分支</span><br><br>$ git branch -r<br><br><span class=\"hljs-comment\"># 列出所有本地分支和远程分支</span><br><br>$ git branch -a<br><br><span class=\"hljs-comment\"># 新建一个分支，但依然停留在当前分支</span><br><br>$ git branch [branch-name]<br><br><span class=\"hljs-comment\"># 新建一个分支，并切换到该分支</span><br><br>$ git checkout -b [branch]<br><br><span class=\"hljs-comment\"># 新建一个分支，指向指定 commit</span><br><br>$ git branch [branch][commit]<br><br><span class=\"hljs-comment\"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><br>$ git branch --track [branch][remote-branch]<br><br><span class=\"hljs-comment\"># 切换到指定分支，并更新工作区</span><br><br>$ git checkout [branch-name]<br><br><span class=\"hljs-comment\"># 切换到上一个分支</span><br><br>$ git checkout -<br><br><span class=\"hljs-comment\"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><br>$ git branch --set-upstream [branch][remote-branch]<br><br><span class=\"hljs-comment\"># 合并指定分支到当前分支</span><br><br>$ git merge [branch]<br><br><span class=\"hljs-comment\"># 选择一个 commit，合并进当前分支</span><br><br>$ git cherry-pick [commit]<br><br><span class=\"hljs-comment\"># 删除分支</span><br><br>$ git branch -d [branch-name]<br><br><span class=\"hljs-comment\"># 删除远程分支</span><br><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 列出所有 tag</span><br><br>$ git tag<br><br><span class=\"hljs-comment\"># 新建一个 tag 在当前 commit</span><br><br>$ git tag [tag]<br><br><span class=\"hljs-comment\"># 新建一个 tag 在指定 commit</span><br><br>$ git tag [tag][commit]<br><br><span class=\"hljs-comment\"># 删除本地 tag</span><br><br>$ git tag -d [tag]<br><br><span class=\"hljs-comment\"># 删除远程 tag</span><br><br>$ git push origin :refs/tags/[tagName]<br><br><span class=\"hljs-comment\"># 查看 tag 信息</span><br><br>$ git show [tag]<br><br><span class=\"hljs-comment\"># 提交指定 tag</span><br><br>$ git push [remote][tag]<br><br><span class=\"hljs-comment\"># 提交所有 tag</span><br><br>$ git push [remote] --tags<br><br><span class=\"hljs-comment\"># 新建一个分支，指向某个 tag</span><br><br>$ git checkout -b [branch][tag]<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"查看信息\"><a href=\"#查看信息\" class=\"headerlink\" title=\"查看信息\"></a>查看信息</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 显示有变更的文件</span><br><br>$ git status<br><br><span class=\"hljs-comment\"># 显示当前分支的版本历史</span><br><br>$ git <span class=\"hljs-built_in\">log</span><br><br><span class=\"hljs-comment\"># 显示 commit 历史，以及每次 commit 发生变更的文件</span><br><br>$ git <span class=\"hljs-built_in\">log</span> --<span class=\"hljs-built_in\">stat</span><br><br><span class=\"hljs-comment\"># 搜索提交历史，根据关键词</span><br><br>$ git <span class=\"hljs-built_in\">log</span> -S [keyword]<br><br><span class=\"hljs-comment\"># 显示某个 commit 之后的所有变动，每个 commit 占据一行</span><br><br>$ git <span class=\"hljs-built_in\">log</span> [tag] HEAD --pretty=format:%s<br><br><span class=\"hljs-comment\"># 显示某个 commit 之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><br>$ git <span class=\"hljs-built_in\">log</span> [tag] HEAD --grep feature<br><br><span class=\"hljs-comment\"># 显示某个文件的版本历史，包括文件改名</span><br><br>$ git <span class=\"hljs-built_in\">log</span> --follow [file]<br>$ git whatchanged [file]<br><br><span class=\"hljs-comment\"># 显示指定文件相关的每一次 diff</span><br><br>$ git <span class=\"hljs-built_in\">log</span> -p [file]<br><br><span class=\"hljs-comment\"># 显示过去 5 次提交</span><br><br>$ git <span class=\"hljs-built_in\">log</span> -5 --pretty --oneline<br><br><span class=\"hljs-comment\"># 显示所有提交过的用户，按提交次数排序</span><br><br>$ git shortlog -sn<br><br><span class=\"hljs-comment\"># 显示指定文件是什么人在什么时间修改过</span><br><br>$ git blame [file]<br><br><span class=\"hljs-comment\"># 显示暂存区和工作区的差异</span><br><br>$ git diff<br><br><span class=\"hljs-comment\"># 显示暂存区和上一个 commit 的差异</span><br><br>$ git diff --cached [file]<br><br><span class=\"hljs-comment\"># 显示工作区与当前分支最新 commit 之间的差异</span><br><br>$ git diff HEAD<br><br><span class=\"hljs-comment\"># 显示两次提交之间的差异</span><br><br>$ git diff [first-branch]...[second-branch]<br><br><span class=\"hljs-comment\"># 显示今天你写了多少行代码</span><br><br>$ git diff --shortstat <span class=\"hljs-string\">&quot;@&#123;0 day ago&#125;&quot;</span><br><br><span class=\"hljs-comment\"># 显示某次提交的元数据和内容变化</span><br><br>$ git show [commit]<br><br><span class=\"hljs-comment\"># 显示某次提交发生变化的文件</span><br><br>$ git show --name-only [commit]<br><br><span class=\"hljs-comment\"># 显示某次提交时，某个文件的内容</span><br><br>$ git show [commit]:[filename]<br><br><span class=\"hljs-comment\"># 显示当前分支的最近几次提交</span><br><br>$ git reflog<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"远程同步\"><a href=\"#远程同步\" class=\"headerlink\" title=\"远程同步\"></a>远程同步</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 下载远程仓库的所有变动</span><br><br>$ git fetch [remote]<br><br><span class=\"hljs-comment\"># 显示所有远程仓库</span><br><br>$ git remote -v<br><br><span class=\"hljs-comment\"># 显示某个远程仓库的信息</span><br><br>$ git remote show [remote]<br><br><span class=\"hljs-comment\"># 增加一个新的远程仓库，并命名</span><br><br>$ git remote add [shortname][url]<br><br><span class=\"hljs-comment\"># 取回远程仓库的变化，并与本地分支合并</span><br><br>$ git pull [remote][branch]<br><br><span class=\"hljs-comment\"># 上传本地指定分支到远程仓库</span><br><br>$ git push [remote][branch]<br><br><span class=\"hljs-comment\"># 强行推送当前分支到远程仓库，即使有冲突</span><br><br>$ git push [remote] --force<br><br><span class=\"hljs-comment\"># 推送所有分支到远程仓库</span><br><br>$ git push [remote] --all<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 恢复暂存区的指定文件到工作区</span><br><br>$ git checkout [file]<br><br><span class=\"hljs-comment\"># 恢复某个 commit 的指定文件到暂存区和工作区</span><br><br>$ git checkout [commit][file]<br><br><span class=\"hljs-comment\"># 恢复暂存区的所有文件到工作区</span><br><br>$ git checkout .<br><br><span class=\"hljs-comment\"># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span><br><br>$ git reset [file]<br><br><span class=\"hljs-comment\"># 重置暂存区与工作区，与上一次 commit 保持一致</span><br><br>$ git reset --hard<br><br><span class=\"hljs-comment\"># 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变</span><br><br>$ git reset [commit]<br><br><span class=\"hljs-comment\"># 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致</span><br><br>$ git reset --hard [commit]<br><br><span class=\"hljs-comment\"># 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变</span><br><br>$ git reset --keep [commit]<br><br><span class=\"hljs-comment\"># 新建一个 commit，用来撤销指定 commit</span><br><br><span class=\"hljs-comment\"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><br>$ git revert [commit]<br><br><span class=\"hljs-comment\"># 暂时将未提交的变化移除，稍后再移入</span><br><br>$ git stash<br>$ git stash pop<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\"># 生成一个可供发布的压缩包</span><br><br>$ git archive<br></code></pre></td></tr></table></figure>\n\n<p>参考资料： <a href=\"http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html\">常用 Git 命令清单</a></p>"},{"title":"ios（苹果）钉钉虚拟位置打卡方法","url":"242.html","id":"242","date":"2019-07-11T12:05:48.000Z","_content":"\n**之前发过一篇关于 苹果系统修改钉钉虚拟位置打卡方法，那个限制ios版本。** **今天这个没有任何限制，任何版本的都可以用，亲测百分百可用，不异常。** **需要工具，一台电脑，一根数据线，爱思助手即可。**\n\n### 方法：\n\n**1、电脑端下载爱思助手，安装程序，打开爱思助手，连接手机** **2、右下角 - 更多功能 -  虚拟位置，在地图内输入地址即可。修改定位即可。** **个人说一下，这个功能太带劲了，只要手机不重启，你的位置一直处在你修改的地方。不管有人看你定位还是分享，你都在同一个位置。** **效果图：** [![2.jpg](https://www.dcqzz.cn/content/uploadfile/201907/15601562676762.jpg \"点击查看原图\")](https://www.dcqzz.cn/content/uploadfile/201907/15601562676762.jpg)","source":"_posts/ios-ef-bc-88-e8-8b-b9-e6-9e-9c-ef-bc-89-e9-92-89-e9-92-89-e8-99-9a-e6-8b-9f-e4-bd-8d-e7-bd-ae-e6-89-93-e5-8d-a1-e6-96-b9-e6-b3-95.md","raw":"---\ntitle: ios（苹果）钉钉虚拟位置打卡方法\ntags:\n  - 技巧\nurl: 242.html\nid: 242\ncategories:\n  - 杂谈\ndate: 2019-07-11 20:05:48\n---\n\n**之前发过一篇关于 苹果系统修改钉钉虚拟位置打卡方法，那个限制ios版本。** **今天这个没有任何限制，任何版本的都可以用，亲测百分百可用，不异常。** **需要工具，一台电脑，一根数据线，爱思助手即可。**\n\n### 方法：\n\n**1、电脑端下载爱思助手，安装程序，打开爱思助手，连接手机** **2、右下角 - 更多功能 -  虚拟位置，在地图内输入地址即可。修改定位即可。** **个人说一下，这个功能太带劲了，只要手机不重启，你的位置一直处在你修改的地方。不管有人看你定位还是分享，你都在同一个位置。** **效果图：** [![2.jpg](https://www.dcqzz.cn/content/uploadfile/201907/15601562676762.jpg \"点击查看原图\")](https://www.dcqzz.cn/content/uploadfile/201907/15601562676762.jpg)","slug":"ios-ef-bc-88-e8-8b-b9-e6-9e-9c-ef-bc-89-e9-92-89-e9-92-89-e8-99-9a-e6-8b-9f-e4-bd-8d-e7-bd-ae-e6-89-93-e5-8d-a1-e6-96-b9-e6-b3-95","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269dv003fc8gsd06gb405","content":"<p><strong>之前发过一篇关于 苹果系统修改钉钉虚拟位置打卡方法，那个限制ios版本。</strong> <strong>今天这个没有任何限制，任何版本的都可以用，亲测百分百可用，不异常。</strong> <strong>需要工具，一台电脑，一根数据线，爱思助手即可。</strong></p>\n<h3 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3><p><strong>1、电脑端下载爱思助手，安装程序，打开爱思助手，连接手机</strong> <strong>2、右下角 - 更多功能 -  虚拟位置，在地图内输入地址即可。修改定位即可。</strong> <strong>个人说一下，这个功能太带劲了，只要手机不重启，你的位置一直处在你修改的地方。不管有人看你定位还是分享，你都在同一个位置。</strong> <strong>效果图：</strong> <a href=\"https://www.dcqzz.cn/content/uploadfile/201907/15601562676762.jpg\"><img src=\"https://www.dcqzz.cn/content/uploadfile/201907/15601562676762.jpg\" alt=\"2.jpg\" title=\"点击查看原图\"></a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><strong>之前发过一篇关于 苹果系统修改钉钉虚拟位置打卡方法，那个限制ios版本。</strong> <strong>今天这个没有任何限制，任何版本的都可以用，亲测百分百可用，不异常。</strong> <strong>需要工具，一台电脑，一根数据线，爱思助手即可。</strong></p>\n<h3 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h3><p><strong>1、电脑端下载爱思助手，安装程序，打开爱思助手，连接手机</strong> <strong>2、右下角 - 更多功能 -  虚拟位置，在地图内输入地址即可。修改定位即可。</strong> <strong>个人说一下，这个功能太带劲了，只要手机不重启，你的位置一直处在你修改的地方。不管有人看你定位还是分享，你都在同一个位置。</strong> <strong>效果图：</strong> <a href=\"https://www.dcqzz.cn/content/uploadfile/201907/15601562676762.jpg\"><img src=\"https://www.dcqzz.cn/content/uploadfile/201907/15601562676762.jpg\" alt=\"2.jpg\" title=\"点击查看原图\"></a></p>\n"},{"title":"JavaScript 错误机制处理","url":"261.html","id":"261","date":"2019-07-18T08:00:45.000Z","_content":"\nError 实例对象\n----------\n\nJavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供`Error`构造函数，所有抛出的错误都是这个构造函数的实例。\n\n    var err = new Error('出错了');\n    err.message // \"出错了\"\n    \n\n上面代码中，我们调用`Error`构造函数，生成一个实例对象`err`。`Error`构造函数接受一个参数，表示错误提示，可以从实例的`message`属性读到这个参数。抛出`Error`实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。 JavaScript 语言标准只提到，`Error`实例对象必须有`message`属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对`Error`实例还提供`name`和`stack`属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。\n\n*   **message**：错误提示信息\n*   **name**：错误名称（非标准属性）\n*   **stack**：错误的堆栈（非标准属性）\n\n使用`name`和`message`这两个属性，可以对发生什么错误有一个大概的了解。\n\n    if (error.name) {\n      console.log(error.name + ': ' + error.message);\n    }\n    \n\n`stack`属性用来查看错误发生时的堆栈。\n\n    function throwit() {\n      throw new Error('');\n    }\n    \n    function catchit() {\n      try {\n        throwit();\n      } catch(e) {\n        console.log(e.stack); // print stack trace\n      }\n    }\n    \n    catchit()\n    // Error\n    //    at throwit (~/examples/throwcatch.js:9:11)\n    //    at catchit (~/examples/throwcatch.js:3:9)\n    //    at repl:1:5\n    \n\n上面代码中，错误堆栈的最内层是`throwit`函数，然后是`catchit`函数，最后是函数的运行环境。\n\n原生错误类型\n------\n\n`Error`实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在`Error`的6个派生对象。\n\n### SyntaxError 对象\n\n`SyntaxError`对象是解析代码时发生的语法错误。\n\n    // 变量名错误\n    var 1a;\n    // Uncaught SyntaxError: Invalid or unexpected token\n    \n    // 缺少括号\n    console.log 'hello');\n    // Uncaught SyntaxError: Unexpected string\n    \n\n上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出`SyntaxError`。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。\n\n### ReferenceError 对象\n\n`ReferenceError`对象是引用一个不存在的变量时发生的错误。\n\n    // 使用一个不存在的变量\n    unknownVariable\n    // Uncaught ReferenceError: unknownVariable is not defined\n    \n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者`this`赋值。\n\n    // 等号左侧不是变量\n    console.log() = 1\n    // Uncaught ReferenceError: Invalid left-hand side in assignment\n    \n    // this 对象不能手动赋值\n    this = 1\n    // ReferenceError: Invalid left-hand side in assignment\n    \n\n上面代码对函数`console.log`的运行结果和`this`赋值，结果都引发了`ReferenceError`错误。\n\n### RangeError 对象\n\n`RangeError`对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是`Number`对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n    // 数组长度不得为负数\n    new Array(-1)\n    // Uncaught RangeError: Invalid array length\n    \n\n### TypeError 对象\n\n`TypeError`对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用`new`命令，就会抛出这种错误，因为`new`命令的参数应该是一个构造函数。\n\n    new 123\n    // Uncaught TypeError: number is not a func\n    \n    var obj = {};\n    obj.unknownMethod()\n    // Uncaught TypeError: obj.unknownMethod is not a function\n    \n\n上面代码的第二种情况，调用对象不存在的方法，也会抛出`TypeError`错误，因为`obj.unknownMethod`的值是`undefined`，而不是一个函数。\n\n### URIError 对象\n\n`URIError`对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。\n\n    decodeURI('%2')\n    // URIError: URI malformed\n    \n\n### EvalError 对象\n\n`eval`函数没有被正确执行时，会抛出`EvalError`错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\n\n### 总结\n\n以上这6种派生错误，连同原始的`Error`对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。\n\n    var err1 = new Error('出错了！');\n    var err2 = new RangeError('出错了，变量超出有效范围！');\n    var err3 = new TypeError('出错了，变量类型无效！');\n    \n    err1.message // \"出错了！\"\n    err2.message // \"出错了，变量超出有效范围！\"\n    err3.message // \"出错了，变量类型无效！\"\n    \n\n自定义错误\n-----\n\n除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。\n\n    function UserError(message) {\n      this.message = message || '默认信息';\n      this.name = 'UserError';\n    }\n    \n    UserError.prototype = new Error();\n    UserError.prototype.constructor = UserError;\n    \n\n上面代码自定义一个错误对象`UserError`，让它继承`Error`对象。然后，就可以生成这种自定义类型的错误了。\n\n    new UserError('这是自定义的错误！');\n    \n\nthrow 语句\n--------\n\n`throw`语句的作用是手动中断程序执行，抛出一个错误。\n\n    if (x <= 0) {\n      throw new Error('x 必须为正数');\n    }\n    // Uncaught ReferenceError: x is not defined\n    \n\n上面代码中，如果变量`x`小于等于`0`，就手动抛出一个错误，告诉用户`x`的值不正确，整个程序就会在这里中断执行。可以看到，`throw`抛出的错误就是它的参数，这里是一个`Error`实例。 `throw`也可以抛出自定义错误。\n\n    function UserError(message) {\n      this.message = message || '默认信息';\n      this.name = 'UserError';\n    }\n    \n    throw new UserError('出错了！');\n    // Uncaught UserError {message: \"出错了！\", name: \"UserError\"}\n    \n\n上面代码中，`throw`抛出的是一个`UserError`实例。 实际上，`throw`可以抛出任何类型的值。也就是说，它的参数可以是任何值。\n\n    // 抛出一个字符串\n    throw 'Error！';\n    // Uncaught Error！\n    \n    // 抛出一个数值\n    throw 42;\n    // Uncaught 42\n    \n    // 抛出一个布尔值\n    throw true;\n    // Uncaught true\n    \n    // 抛出一个对象\n    throw {\n      toString: function () {\n        return 'Error!';\n      }\n    };\n    // Uncaught {toString: ƒ}\n    \n\n对于 JavaScript 引擎来说，遇到`throw`语句，程序就中止了。引擎会接收到`throw`抛出的信息，可能是一个错误实例，也可能是其他类型的值。\n\ntry...catch 结构\n--------------\n\n一旦发生错误，程序就中止执行了。JavaScript 提供了`try...catch`结构，允许对错误进行处理，选择是否往下执行。\n\n    try {\n      throw new Error('出错了!');\n    } catch (e) {\n      console.log(e.name + \": \" + e.message);\n      console.log(e.stack);\n    }\n    // Error: 出错了!\n    //   at <anonymous>:3:9\n    //   ...\n    \n\n上面代码中，`try`代码块抛出错误（上例用的是`throw`语句），JavaScript 引擎就立即把代码的执行，转到`catch`代码块，或者说错误被`catch`代码块捕获了。`catch`接受一个参数，表示`try`代码块抛出的值。 如果你不确定某些代码是否会报错，就可以把它们放在`try...catch`代码块之中，便于进一步对错误进行处理。\n\n    try {\n      f();\n    } catch(e) {\n      // 处理错误\n    }\n    \n\n上面代码中，如果函数`f`执行报错，就会进行`catch`代码块，接着对错误进行处理。 `catch`代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。\n\n    try {\n      throw \"出错了\";\n    } catch (e) {\n      console.log(111);\n    }\n    console.log(222);\n    // 111\n    // 222\n    \n\n上面代码中，`try`代码块抛出的错误，被`catch`代码块捕获后，程序会继续向下执行。 `catch`代码块之中，还可以再抛出错误，甚至使用嵌套的`try...catch`结构。\n\n    var n = 100;\n    \n    try {\n      throw n;\n    } catch (e) {\n      if (e <= 50) {\n        // ...\n      } else {\n        throw e;\n      }\n    }\n    // Uncaught 100\n    \n\n上面代码中，`catch`代码之中又抛出了一个错误。 为了捕捉不同类型的错误，`catch`代码块之中可以加入判断语句。\n\n    try {\n      foo.bar();\n    } catch (e) {\n      if (e instanceof EvalError) {\n        console.log(e.name + \": \" + e.message);\n      } else if (e instanceof RangeError) {\n        console.log(e.name + \": \" + e.message);\n      }\n      // ...\n    }\n    \n\n上面代码中，`catch`捕获错误之后，会判断错误类型（`EvalError`还是`RangeError`），进行不同的处理。\n\nfinally 代码块\n-----------\n\n`try...catch`结构允许在最后添加一个`finally`代码块，表示不管是否出现错误，都必需在最后运行的语句。\n\n    function cleansUp() {\n      try {\n        throw new Error('出错了……');\n        console.log('此行不会执行');\n      } finally {\n        console.log('完成清理工作');\n      }\n    }\n    \n    cleansUp()\n    // 完成清理工作\n    // Uncaught Error: 出错了……\n    //    at cleansUp (<anonymous>:3:11)\n    //    at <anonymous>:10:1\n    \n\n上面代码中，由于没有`catch`语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行`finally`代码块，然后再向用户提示报错信息。\n\n    function idle(x) {\n      try {\n        console.log(x);\n        return 'result';\n      } finally {\n        console.log('FINALLY');\n      }\n    }\n    \n    idle('hello')\n    // hello\n    // FINALLY\n    \n\n上面代码中，`try`代码块没有发生错误，而且里面还包括`return`语句，但是`finally`代码块依然会执行。而且，这个函数的返回值还是`result`。 下面的例子说明，`return`语句的执行是排在`finally`代码之前，只是等`finally`代码执行完毕后才返回。\n\n    var count = 0;\n    function countUp() {\n      try {\n        return count;\n      } finally {\n        count++;\n      }\n    }\n    \n    countUp()\n    // 0\n    count\n    // 1\n    \n\n上面代码说明，`return`语句里面的`count`的值，是在`finally`代码块运行之前就获取了。 下面是`finally`代码块用法的典型场景。\n\n    openFile();\n    \n    try {\n      writeFile(Data);\n    } catch(e) {\n      handleError(e);\n    } finally {\n      closeFile();\n    }\n    \n\n上面代码首先打开一个文件，然后在`try`代码块中写入文件，如果没有发生错误，则运行`finally`代码块关闭文件；一旦发生错误，则先使用`catch`代码块处理错误，再使用`finally`代码块关闭文件。 下面的例子充分反映了`try...catch...finally`这三者之间的执行顺序。\n\n    function f() {\n      try {\n        console.log(0);\n        throw 'bug';\n      } catch(e) {\n        console.log(1);\n        return true; // 这句原本会延迟到 finally 代码块结束再执行\n        console.log(2); // 不会运行\n      } finally {\n        console.log(3);\n        return false; // 这句会覆盖掉前面那句 return\n        console.log(4); // 不会运行\n      }\n    \n      console.log(5); // 不会运行\n    }\n    \n    var result = f();\n    // 0\n    // 1\n    // 3\n    \n    result\n    // false\n    \n\n上面代码中，`catch`代码块结束执行之前，会先执行`finally`代码块。 `catch`代码块之中，触发转入`finally`代码快的标志，不仅有`return`语句，还有`throw`语句。\n\n    function f() {\n      try {\n        throw '出错了！';\n      } catch(e) {\n        console.log('捕捉到内部错误');\n        throw e; // 这句原本会等到finally结束再执行\n      } finally {\n        return false; // 直接返回\n      }\n    }\n    \n    try {\n      f();\n    } catch(e) {\n      // 此处不会执行\n      console.log('caught outer \"bogus\"');\n    }\n    \n    //  捕捉到内部错误\n    \n\n上面代码中，进入`catch`代码块之后，一遇到`throw`语句，就会去执行`finally`代码块，其中有`return false`语句，因此就直接返回了，不再会回去执行`catch`代码块剩下的部分了。 `try`代码块内部，还可以再使用`try`代码块。\n\n    try {\n      try {\n        console.log('Hello world!'); // 报错\n      }\n      finally {\n        console.log('Finally');\n      }\n      console.log('Will I run?');\n    } catch(error) {\n      console.error(error.message);\n    }\n    // Finally\n    // consle is not defined\n    \n\n上面代码中，`try`里面还有一个`try`。内层的`try`报错，这时会执行内层的`finally`代码块，然后抛出错误，被外层的`catch`捕获。\n\n参考连接 # \n-------\n\n*   Jani Hartikainen, [JavaScript Errors and How to Fix Them](http://davidwalsh.name/fix-javascript-errors)","source":"_posts/javascript-e9-94-99-e8-af-af-e6-9c-ba-e5-88-b6-e5-a4-84-e7-90-86.md","raw":"---\ntitle: JavaScript 错误机制处理\ntags:\n  - 前端，JavaScript\nurl: 261.html\nid: 261\ncategories:\n  - 大前端\ndate: 2019-07-18 16:00:45\n---\n\nError 实例对象\n----------\n\nJavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供`Error`构造函数，所有抛出的错误都是这个构造函数的实例。\n\n    var err = new Error('出错了');\n    err.message // \"出错了\"\n    \n\n上面代码中，我们调用`Error`构造函数，生成一个实例对象`err`。`Error`构造函数接受一个参数，表示错误提示，可以从实例的`message`属性读到这个参数。抛出`Error`实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。 JavaScript 语言标准只提到，`Error`实例对象必须有`message`属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对`Error`实例还提供`name`和`stack`属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。\n\n*   **message**：错误提示信息\n*   **name**：错误名称（非标准属性）\n*   **stack**：错误的堆栈（非标准属性）\n\n使用`name`和`message`这两个属性，可以对发生什么错误有一个大概的了解。\n\n    if (error.name) {\n      console.log(error.name + ': ' + error.message);\n    }\n    \n\n`stack`属性用来查看错误发生时的堆栈。\n\n    function throwit() {\n      throw new Error('');\n    }\n    \n    function catchit() {\n      try {\n        throwit();\n      } catch(e) {\n        console.log(e.stack); // print stack trace\n      }\n    }\n    \n    catchit()\n    // Error\n    //    at throwit (~/examples/throwcatch.js:9:11)\n    //    at catchit (~/examples/throwcatch.js:3:9)\n    //    at repl:1:5\n    \n\n上面代码中，错误堆栈的最内层是`throwit`函数，然后是`catchit`函数，最后是函数的运行环境。\n\n原生错误类型\n------\n\n`Error`实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在`Error`的6个派生对象。\n\n### SyntaxError 对象\n\n`SyntaxError`对象是解析代码时发生的语法错误。\n\n    // 变量名错误\n    var 1a;\n    // Uncaught SyntaxError: Invalid or unexpected token\n    \n    // 缺少括号\n    console.log 'hello');\n    // Uncaught SyntaxError: Unexpected string\n    \n\n上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出`SyntaxError`。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。\n\n### ReferenceError 对象\n\n`ReferenceError`对象是引用一个不存在的变量时发生的错误。\n\n    // 使用一个不存在的变量\n    unknownVariable\n    // Uncaught ReferenceError: unknownVariable is not defined\n    \n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者`this`赋值。\n\n    // 等号左侧不是变量\n    console.log() = 1\n    // Uncaught ReferenceError: Invalid left-hand side in assignment\n    \n    // this 对象不能手动赋值\n    this = 1\n    // ReferenceError: Invalid left-hand side in assignment\n    \n\n上面代码对函数`console.log`的运行结果和`this`赋值，结果都引发了`ReferenceError`错误。\n\n### RangeError 对象\n\n`RangeError`对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是`Number`对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n    // 数组长度不得为负数\n    new Array(-1)\n    // Uncaught RangeError: Invalid array length\n    \n\n### TypeError 对象\n\n`TypeError`对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用`new`命令，就会抛出这种错误，因为`new`命令的参数应该是一个构造函数。\n\n    new 123\n    // Uncaught TypeError: number is not a func\n    \n    var obj = {};\n    obj.unknownMethod()\n    // Uncaught TypeError: obj.unknownMethod is not a function\n    \n\n上面代码的第二种情况，调用对象不存在的方法，也会抛出`TypeError`错误，因为`obj.unknownMethod`的值是`undefined`，而不是一个函数。\n\n### URIError 对象\n\n`URIError`对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。\n\n    decodeURI('%2')\n    // URIError: URI malformed\n    \n\n### EvalError 对象\n\n`eval`函数没有被正确执行时，会抛出`EvalError`错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\n\n### 总结\n\n以上这6种派生错误，连同原始的`Error`对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。\n\n    var err1 = new Error('出错了！');\n    var err2 = new RangeError('出错了，变量超出有效范围！');\n    var err3 = new TypeError('出错了，变量类型无效！');\n    \n    err1.message // \"出错了！\"\n    err2.message // \"出错了，变量超出有效范围！\"\n    err3.message // \"出错了，变量类型无效！\"\n    \n\n自定义错误\n-----\n\n除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。\n\n    function UserError(message) {\n      this.message = message || '默认信息';\n      this.name = 'UserError';\n    }\n    \n    UserError.prototype = new Error();\n    UserError.prototype.constructor = UserError;\n    \n\n上面代码自定义一个错误对象`UserError`，让它继承`Error`对象。然后，就可以生成这种自定义类型的错误了。\n\n    new UserError('这是自定义的错误！');\n    \n\nthrow 语句\n--------\n\n`throw`语句的作用是手动中断程序执行，抛出一个错误。\n\n    if (x <= 0) {\n      throw new Error('x 必须为正数');\n    }\n    // Uncaught ReferenceError: x is not defined\n    \n\n上面代码中，如果变量`x`小于等于`0`，就手动抛出一个错误，告诉用户`x`的值不正确，整个程序就会在这里中断执行。可以看到，`throw`抛出的错误就是它的参数，这里是一个`Error`实例。 `throw`也可以抛出自定义错误。\n\n    function UserError(message) {\n      this.message = message || '默认信息';\n      this.name = 'UserError';\n    }\n    \n    throw new UserError('出错了！');\n    // Uncaught UserError {message: \"出错了！\", name: \"UserError\"}\n    \n\n上面代码中，`throw`抛出的是一个`UserError`实例。 实际上，`throw`可以抛出任何类型的值。也就是说，它的参数可以是任何值。\n\n    // 抛出一个字符串\n    throw 'Error！';\n    // Uncaught Error！\n    \n    // 抛出一个数值\n    throw 42;\n    // Uncaught 42\n    \n    // 抛出一个布尔值\n    throw true;\n    // Uncaught true\n    \n    // 抛出一个对象\n    throw {\n      toString: function () {\n        return 'Error!';\n      }\n    };\n    // Uncaught {toString: ƒ}\n    \n\n对于 JavaScript 引擎来说，遇到`throw`语句，程序就中止了。引擎会接收到`throw`抛出的信息，可能是一个错误实例，也可能是其他类型的值。\n\ntry...catch 结构\n--------------\n\n一旦发生错误，程序就中止执行了。JavaScript 提供了`try...catch`结构，允许对错误进行处理，选择是否往下执行。\n\n    try {\n      throw new Error('出错了!');\n    } catch (e) {\n      console.log(e.name + \": \" + e.message);\n      console.log(e.stack);\n    }\n    // Error: 出错了!\n    //   at <anonymous>:3:9\n    //   ...\n    \n\n上面代码中，`try`代码块抛出错误（上例用的是`throw`语句），JavaScript 引擎就立即把代码的执行，转到`catch`代码块，或者说错误被`catch`代码块捕获了。`catch`接受一个参数，表示`try`代码块抛出的值。 如果你不确定某些代码是否会报错，就可以把它们放在`try...catch`代码块之中，便于进一步对错误进行处理。\n\n    try {\n      f();\n    } catch(e) {\n      // 处理错误\n    }\n    \n\n上面代码中，如果函数`f`执行报错，就会进行`catch`代码块，接着对错误进行处理。 `catch`代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。\n\n    try {\n      throw \"出错了\";\n    } catch (e) {\n      console.log(111);\n    }\n    console.log(222);\n    // 111\n    // 222\n    \n\n上面代码中，`try`代码块抛出的错误，被`catch`代码块捕获后，程序会继续向下执行。 `catch`代码块之中，还可以再抛出错误，甚至使用嵌套的`try...catch`结构。\n\n    var n = 100;\n    \n    try {\n      throw n;\n    } catch (e) {\n      if (e <= 50) {\n        // ...\n      } else {\n        throw e;\n      }\n    }\n    // Uncaught 100\n    \n\n上面代码中，`catch`代码之中又抛出了一个错误。 为了捕捉不同类型的错误，`catch`代码块之中可以加入判断语句。\n\n    try {\n      foo.bar();\n    } catch (e) {\n      if (e instanceof EvalError) {\n        console.log(e.name + \": \" + e.message);\n      } else if (e instanceof RangeError) {\n        console.log(e.name + \": \" + e.message);\n      }\n      // ...\n    }\n    \n\n上面代码中，`catch`捕获错误之后，会判断错误类型（`EvalError`还是`RangeError`），进行不同的处理。\n\nfinally 代码块\n-----------\n\n`try...catch`结构允许在最后添加一个`finally`代码块，表示不管是否出现错误，都必需在最后运行的语句。\n\n    function cleansUp() {\n      try {\n        throw new Error('出错了……');\n        console.log('此行不会执行');\n      } finally {\n        console.log('完成清理工作');\n      }\n    }\n    \n    cleansUp()\n    // 完成清理工作\n    // Uncaught Error: 出错了……\n    //    at cleansUp (<anonymous>:3:11)\n    //    at <anonymous>:10:1\n    \n\n上面代码中，由于没有`catch`语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行`finally`代码块，然后再向用户提示报错信息。\n\n    function idle(x) {\n      try {\n        console.log(x);\n        return 'result';\n      } finally {\n        console.log('FINALLY');\n      }\n    }\n    \n    idle('hello')\n    // hello\n    // FINALLY\n    \n\n上面代码中，`try`代码块没有发生错误，而且里面还包括`return`语句，但是`finally`代码块依然会执行。而且，这个函数的返回值还是`result`。 下面的例子说明，`return`语句的执行是排在`finally`代码之前，只是等`finally`代码执行完毕后才返回。\n\n    var count = 0;\n    function countUp() {\n      try {\n        return count;\n      } finally {\n        count++;\n      }\n    }\n    \n    countUp()\n    // 0\n    count\n    // 1\n    \n\n上面代码说明，`return`语句里面的`count`的值，是在`finally`代码块运行之前就获取了。 下面是`finally`代码块用法的典型场景。\n\n    openFile();\n    \n    try {\n      writeFile(Data);\n    } catch(e) {\n      handleError(e);\n    } finally {\n      closeFile();\n    }\n    \n\n上面代码首先打开一个文件，然后在`try`代码块中写入文件，如果没有发生错误，则运行`finally`代码块关闭文件；一旦发生错误，则先使用`catch`代码块处理错误，再使用`finally`代码块关闭文件。 下面的例子充分反映了`try...catch...finally`这三者之间的执行顺序。\n\n    function f() {\n      try {\n        console.log(0);\n        throw 'bug';\n      } catch(e) {\n        console.log(1);\n        return true; // 这句原本会延迟到 finally 代码块结束再执行\n        console.log(2); // 不会运行\n      } finally {\n        console.log(3);\n        return false; // 这句会覆盖掉前面那句 return\n        console.log(4); // 不会运行\n      }\n    \n      console.log(5); // 不会运行\n    }\n    \n    var result = f();\n    // 0\n    // 1\n    // 3\n    \n    result\n    // false\n    \n\n上面代码中，`catch`代码块结束执行之前，会先执行`finally`代码块。 `catch`代码块之中，触发转入`finally`代码快的标志，不仅有`return`语句，还有`throw`语句。\n\n    function f() {\n      try {\n        throw '出错了！';\n      } catch(e) {\n        console.log('捕捉到内部错误');\n        throw e; // 这句原本会等到finally结束再执行\n      } finally {\n        return false; // 直接返回\n      }\n    }\n    \n    try {\n      f();\n    } catch(e) {\n      // 此处不会执行\n      console.log('caught outer \"bogus\"');\n    }\n    \n    //  捕捉到内部错误\n    \n\n上面代码中，进入`catch`代码块之后，一遇到`throw`语句，就会去执行`finally`代码块，其中有`return false`语句，因此就直接返回了，不再会回去执行`catch`代码块剩下的部分了。 `try`代码块内部，还可以再使用`try`代码块。\n\n    try {\n      try {\n        console.log('Hello world!'); // 报错\n      }\n      finally {\n        console.log('Finally');\n      }\n      console.log('Will I run?');\n    } catch(error) {\n      console.error(error.message);\n    }\n    // Finally\n    // consle is not defined\n    \n\n上面代码中，`try`里面还有一个`try`。内层的`try`报错，这时会执行内层的`finally`代码块，然后抛出错误，被外层的`catch`捕获。\n\n参考连接 # \n-------\n\n*   Jani Hartikainen, [JavaScript Errors and How to Fix Them](http://davidwalsh.name/fix-javascript-errors)","slug":"javascript-e9-94-99-e8-af-af-e6-9c-ba-e5-88-b6-e5-a4-84-e7-90-86","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269e9003ic8gseb161fy8","content":"<h2 id=\"Error-实例对象\"><a href=\"#Error-实例对象\" class=\"headerlink\" title=\"Error 实例对象\"></a>Error 实例对象</h2><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例。</p>\n<pre><code>var err = new Error(&#39;出错了&#39;);\nerr.message // &quot;出错了&quot;\n</code></pre>\n<p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>。<code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。 JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>\n<ul>\n<li>  <strong>message</strong>：错误提示信息</li>\n<li>  <strong>name</strong>：错误名称（非标准属性）</li>\n<li>  <strong>stack</strong>：错误的堆栈（非标准属性）</li>\n</ul>\n<p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解。</p>\n<pre><code>if (error.name) &#123;\n  console.log(error.name + &#39;: &#39; + error.message);\n&#125;\n</code></pre>\n<p><code>stack</code>属性用来查看错误发生时的堆栈。</p>\n<pre><code>function throwit() &#123;\n  throw new Error(&#39;&#39;);\n&#125;\n\nfunction catchit() &#123;\n  try &#123;\n    throwit();\n  &#125; catch(e) &#123;\n    console.log(e.stack); // print stack trace\n  &#125;\n&#125;\n\ncatchit()\n// Error\n//    at throwit (~/examples/throwcatch.js:9:11)\n//    at catchit (~/examples/throwcatch.js:3:9)\n//    at repl:1:5\n</code></pre>\n<p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境。</p>\n<h2 id=\"原生错误类型\"><a href=\"#原生错误类型\" class=\"headerlink\" title=\"原生错误类型\"></a>原生错误类型</h2><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象。</p>\n<h3 id=\"SyntaxError-对象\"><a href=\"#SyntaxError-对象\" class=\"headerlink\" title=\"SyntaxError 对象\"></a>SyntaxError 对象</h3><p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p>\n<pre><code>// 变量名错误\nvar 1a;\n// Uncaught SyntaxError: Invalid or unexpected token\n\n// 缺少括号\nconsole.log &#39;hello&#39;);\n// Uncaught SyntaxError: Unexpected string\n</code></pre>\n<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。</p>\n<h3 id=\"ReferenceError-对象\"><a href=\"#ReferenceError-对象\" class=\"headerlink\" title=\"ReferenceError 对象\"></a>ReferenceError 对象</h3><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p>\n<pre><code>// 使用一个不存在的变量\nunknownVariable\n// Uncaught ReferenceError: unknownVariable is not defined\n</code></pre>\n<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者<code>this</code>赋值。</p>\n<pre><code>// 等号左侧不是变量\nconsole.log() = 1\n// Uncaught ReferenceError: Invalid left-hand side in assignment\n\n// this 对象不能手动赋值\nthis = 1\n// ReferenceError: Invalid left-hand side in assignment\n</code></pre>\n<p>上面代码对函数<code>console.log</code>的运行结果和<code>this</code>赋值，结果都引发了<code>ReferenceError</code>错误。</p>\n<h3 id=\"RangeError-对象\"><a href=\"#RangeError-对象\" class=\"headerlink\" title=\"RangeError 对象\"></a>RangeError 对象</h3><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</p>\n<pre><code>// 数组长度不得为负数\nnew Array(-1)\n// Uncaught RangeError: Invalid array length\n</code></pre>\n<h3 id=\"TypeError-对象\"><a href=\"#TypeError-对象\" class=\"headerlink\" title=\"TypeError 对象\"></a>TypeError 对象</h3><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p>\n<pre><code>new 123\n// Uncaught TypeError: number is not a func\n\nvar obj = &#123;&#125;;\nobj.unknownMethod()\n// Uncaught TypeError: obj.unknownMethod is not a function\n</code></pre>\n<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p>\n<h3 id=\"URIError-对象\"><a href=\"#URIError-对象\" class=\"headerlink\" title=\"URIError 对象\"></a>URIError 对象</h3><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p>\n<pre><code>decodeURI(&#39;%2&#39;)\n// URIError: URI malformed\n</code></pre>\n<h3 id=\"EvalError-对象\"><a href=\"#EvalError-对象\" class=\"headerlink\" title=\"EvalError 对象\"></a>EvalError 对象</h3><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p>\n<pre><code>var err1 = new Error(&#39;出错了！&#39;);\nvar err2 = new RangeError(&#39;出错了，变量超出有效范围！&#39;);\nvar err3 = new TypeError(&#39;出错了，变量类型无效！&#39;);\n\nerr1.message // &quot;出错了！&quot;\nerr2.message // &quot;出错了，变量超出有效范围！&quot;\nerr3.message // &quot;出错了，变量类型无效！&quot;\n</code></pre>\n<h2 id=\"自定义错误\"><a href=\"#自定义错误\" class=\"headerlink\" title=\"自定义错误\"></a>自定义错误</h2><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>\n<pre><code>function UserError(message) &#123;\n  this.message = message || &#39;默认信息&#39;;\n  this.name = &#39;UserError&#39;;\n&#125;\n\nUserError.prototype = new Error();\nUserError.prototype.constructor = UserError;\n</code></pre>\n<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p>\n<pre><code>new UserError(&#39;这是自定义的错误！&#39;);\n</code></pre>\n<h2 id=\"throw-语句\"><a href=\"#throw-语句\" class=\"headerlink\" title=\"throw 语句\"></a>throw 语句</h2><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p>\n<pre><code>if (x &lt;= 0) &#123;\n  throw new Error(&#39;x 必须为正数&#39;);\n&#125;\n// Uncaught ReferenceError: x is not defined\n</code></pre>\n<p>上面代码中，如果变量<code>x</code>小于等于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例。 <code>throw</code>也可以抛出自定义错误。</p>\n<pre><code>function UserError(message) &#123;\n  this.message = message || &#39;默认信息&#39;;\n  this.name = &#39;UserError&#39;;\n&#125;\n\nthrow new UserError(&#39;出错了！&#39;);\n// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;\n</code></pre>\n<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。 实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p>\n<pre><code>// 抛出一个字符串\nthrow &#39;Error！&#39;;\n// Uncaught Error！\n\n// 抛出一个数值\nthrow 42;\n// Uncaught 42\n\n// 抛出一个布尔值\nthrow true;\n// Uncaught true\n\n// 抛出一个对象\nthrow &#123;\n  toString: function () &#123;\n    return &#39;Error!&#39;;\n  &#125;\n&#125;;\n// Uncaught &#123;toString: ƒ&#125;\n</code></pre>\n<p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>\n<h2 id=\"try…catch-结构\"><a href=\"#try…catch-结构\" class=\"headerlink\" title=\"try…catch 结构\"></a>try…catch 结构</h2><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>\n<pre><code>try &#123;\n  throw new Error(&#39;出错了!&#39;);\n&#125; catch (e) &#123;\n  console.log(e.name + &quot;: &quot; + e.message);\n  console.log(e.stack);\n&#125;\n// Error: 出错了!\n//   at &lt;anonymous&gt;:3:9\n//   ...\n</code></pre>\n<p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。 如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p>\n<pre><code>try &#123;\n  f();\n&#125; catch(e) &#123;\n  // 处理错误\n&#125;\n</code></pre>\n<p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理。 <code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p>\n<pre><code>try &#123;\n  throw &quot;出错了&quot;;\n&#125; catch (e) &#123;\n  console.log(111);\n&#125;\nconsole.log(222);\n// 111\n// 222\n</code></pre>\n<p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。 <code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构。</p>\n<pre><code>var n = 100;\n\ntry &#123;\n  throw n;\n&#125; catch (e) &#123;\n  if (e &lt;= 50) &#123;\n    // ...\n  &#125; else &#123;\n    throw e;\n  &#125;\n&#125;\n// Uncaught 100\n</code></pre>\n<p>上面代码中，<code>catch</code>代码之中又抛出了一个错误。 为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p>\n<pre><code>try &#123;\n  foo.bar();\n&#125; catch (e) &#123;\n  if (e instanceof EvalError) &#123;\n    console.log(e.name + &quot;: &quot; + e.message);\n  &#125; else if (e instanceof RangeError) &#123;\n    console.log(e.name + &quot;: &quot; + e.message);\n  &#125;\n  // ...\n&#125;\n</code></pre>\n<p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理。</p>\n<h2 id=\"finally-代码块\"><a href=\"#finally-代码块\" class=\"headerlink\" title=\"finally 代码块\"></a>finally 代码块</h2><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>\n<pre><code>function cleansUp() &#123;\n  try &#123;\n    throw new Error(&#39;出错了……&#39;);\n    console.log(&#39;此行不会执行&#39;);\n  &#125; finally &#123;\n    console.log(&#39;完成清理工作&#39;);\n  &#125;\n&#125;\n\ncleansUp()\n// 完成清理工作\n// Uncaught Error: 出错了……\n//    at cleansUp (&lt;anonymous&gt;:3:11)\n//    at &lt;anonymous&gt;:10:1\n</code></pre>\n<p>上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息。</p>\n<pre><code>function idle(x) &#123;\n  try &#123;\n    console.log(x);\n    return &#39;result&#39;;\n  &#125; finally &#123;\n    console.log(&#39;FINALLY&#39;);\n  &#125;\n&#125;\n\nidle(&#39;hello&#39;)\n// hello\n// FINALLY\n</code></pre>\n<p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code>。 下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p>\n<pre><code>var count = 0;\nfunction countUp() &#123;\n  try &#123;\n    return count;\n  &#125; finally &#123;\n    count++;\n  &#125;\n&#125;\n\ncountUp()\n// 0\ncount\n// 1\n</code></pre>\n<p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了。 下面是<code>finally</code>代码块用法的典型场景。</p>\n<pre><code>openFile();\n\ntry &#123;\n  writeFile(Data);\n&#125; catch(e) &#123;\n  handleError(e);\n&#125; finally &#123;\n  closeFile();\n&#125;\n</code></pre>\n<p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件。 下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序。</p>\n<pre><code>function f() &#123;\n  try &#123;\n    console.log(0);\n    throw &#39;bug&#39;;\n  &#125; catch(e) &#123;\n    console.log(1);\n    return true; // 这句原本会延迟到 finally 代码块结束再执行\n    console.log(2); // 不会运行\n  &#125; finally &#123;\n    console.log(3);\n    return false; // 这句会覆盖掉前面那句 return\n    console.log(4); // 不会运行\n  &#125;\n\n  console.log(5); // 不会运行\n&#125;\n\nvar result = f();\n// 0\n// 1\n// 3\n\nresult\n// false\n</code></pre>\n<p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块。 <code>catch</code>代码块之中，触发转入<code>finally</code>代码快的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句。</p>\n<pre><code>function f() &#123;\n  try &#123;\n    throw &#39;出错了！&#39;;\n  &#125; catch(e) &#123;\n    console.log(&#39;捕捉到内部错误&#39;);\n    throw e; // 这句原本会等到finally结束再执行\n  &#125; finally &#123;\n    return false; // 直接返回\n  &#125;\n&#125;\n\ntry &#123;\n  f();\n&#125; catch(e) &#123;\n  // 此处不会执行\n  console.log(&#39;caught outer &quot;bogus&quot;&#39;);\n&#125;\n\n//  捕捉到内部错误\n</code></pre>\n<p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。 <code>try</code>代码块内部，还可以再使用<code>try</code>代码块。</p>\n<pre><code>try &#123;\n  try &#123;\n    console.log(&#39;Hello world!&#39;); // 报错\n  &#125;\n  finally &#123;\n    console.log(&#39;Finally&#39;);\n  &#125;\n  console.log(&#39;Will I run?&#39;);\n&#125; catch(error) &#123;\n  console.error(error.message);\n&#125;\n// Finally\n// consle is not defined\n</code></pre>\n<p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错，这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获。</p>\n<h2 id=\"参考连接\"><a href=\"#参考连接\" class=\"headerlink\" title=\"参考连接 # \"></a>参考连接 # </h2><ul>\n<li>  Jani Hartikainen, <a href=\"http://davidwalsh.name/fix-javascript-errors\">JavaScript Errors and How to Fix Them</a></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"Error-实例对象\"><a href=\"#Error-实例对象\" class=\"headerlink\" title=\"Error 实例对象\"></a>Error 实例对象</h2><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例。</p>\n<pre><code>var err = new Error(&#39;出错了&#39;);\nerr.message // &quot;出错了&quot;\n</code></pre>\n<p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>。<code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数。抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行。 JavaScript 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性。大多数 JavaScript 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>\n<ul>\n<li>  <strong>message</strong>：错误提示信息</li>\n<li>  <strong>name</strong>：错误名称（非标准属性）</li>\n<li>  <strong>stack</strong>：错误的堆栈（非标准属性）</li>\n</ul>\n<p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解。</p>\n<pre><code>if (error.name) &#123;\n  console.log(error.name + &#39;: &#39; + error.message);\n&#125;\n</code></pre>\n<p><code>stack</code>属性用来查看错误发生时的堆栈。</p>\n<pre><code>function throwit() &#123;\n  throw new Error(&#39;&#39;);\n&#125;\n\nfunction catchit() &#123;\n  try &#123;\n    throwit();\n  &#125; catch(e) &#123;\n    console.log(e.stack); // print stack trace\n  &#125;\n&#125;\n\ncatchit()\n// Error\n//    at throwit (~/examples/throwcatch.js:9:11)\n//    at catchit (~/examples/throwcatch.js:3:9)\n//    at repl:1:5\n</code></pre>\n<p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境。</p>\n<h2 id=\"原生错误类型\"><a href=\"#原生错误类型\" class=\"headerlink\" title=\"原生错误类型\"></a>原生错误类型</h2><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，JavaScript 还定义了其他6种错误对象。也就是说，存在<code>Error</code>的6个派生对象。</p>\n<h3 id=\"SyntaxError-对象\"><a href=\"#SyntaxError-对象\" class=\"headerlink\" title=\"SyntaxError 对象\"></a>SyntaxError 对象</h3><p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p>\n<pre><code>// 变量名错误\nvar 1a;\n// Uncaught SyntaxError: Invalid or unexpected token\n\n// 缺少括号\nconsole.log &#39;hello&#39;);\n// Uncaught SyntaxError: Unexpected string\n</code></pre>\n<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”。</p>\n<h3 id=\"ReferenceError-对象\"><a href=\"#ReferenceError-对象\" class=\"headerlink\" title=\"ReferenceError 对象\"></a>ReferenceError 对象</h3><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p>\n<pre><code>// 使用一个不存在的变量\nunknownVariable\n// Uncaught ReferenceError: unknownVariable is not defined\n</code></pre>\n<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者<code>this</code>赋值。</p>\n<pre><code>// 等号左侧不是变量\nconsole.log() = 1\n// Uncaught ReferenceError: Invalid left-hand side in assignment\n\n// this 对象不能手动赋值\nthis = 1\n// ReferenceError: Invalid left-hand side in assignment\n</code></pre>\n<p>上面代码对函数<code>console.log</code>的运行结果和<code>this</code>赋值，结果都引发了<code>ReferenceError</code>错误。</p>\n<h3 id=\"RangeError-对象\"><a href=\"#RangeError-对象\" class=\"headerlink\" title=\"RangeError 对象\"></a>RangeError 对象</h3><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值。</p>\n<pre><code>// 数组长度不得为负数\nnew Array(-1)\n// Uncaught RangeError: Invalid array length\n</code></pre>\n<h3 id=\"TypeError-对象\"><a href=\"#TypeError-对象\" class=\"headerlink\" title=\"TypeError 对象\"></a>TypeError 对象</h3><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p>\n<pre><code>new 123\n// Uncaught TypeError: number is not a func\n\nvar obj = &#123;&#125;;\nobj.unknownMethod()\n// Uncaught TypeError: obj.unknownMethod is not a function\n</code></pre>\n<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p>\n<h3 id=\"URIError-对象\"><a href=\"#URIError-对象\" class=\"headerlink\" title=\"URIError 对象\"></a>URIError 对象</h3><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p>\n<pre><code>decodeURI(&#39;%2&#39;)\n// URIError: URI malformed\n</code></pre>\n<h3 id=\"EvalError-对象\"><a href=\"#EvalError-对象\" class=\"headerlink\" title=\"EvalError 对象\"></a>EvalError 对象</h3><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p>\n<pre><code>var err1 = new Error(&#39;出错了！&#39;);\nvar err2 = new RangeError(&#39;出错了，变量超出有效范围！&#39;);\nvar err3 = new TypeError(&#39;出错了，变量类型无效！&#39;);\n\nerr1.message // &quot;出错了！&quot;\nerr2.message // &quot;出错了，变量超出有效范围！&quot;\nerr3.message // &quot;出错了，变量类型无效！&quot;\n</code></pre>\n<h2 id=\"自定义错误\"><a href=\"#自定义错误\" class=\"headerlink\" title=\"自定义错误\"></a>自定义错误</h2><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象。</p>\n<pre><code>function UserError(message) &#123;\n  this.message = message || &#39;默认信息&#39;;\n  this.name = &#39;UserError&#39;;\n&#125;\n\nUserError.prototype = new Error();\nUserError.prototype.constructor = UserError;\n</code></pre>\n<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p>\n<pre><code>new UserError(&#39;这是自定义的错误！&#39;);\n</code></pre>\n<h2 id=\"throw-语句\"><a href=\"#throw-语句\" class=\"headerlink\" title=\"throw 语句\"></a>throw 语句</h2><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。</p>\n<pre><code>if (x &lt;= 0) &#123;\n  throw new Error(&#39;x 必须为正数&#39;);\n&#125;\n// Uncaught ReferenceError: x is not defined\n</code></pre>\n<p>上面代码中，如果变量<code>x</code>小于等于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例。 <code>throw</code>也可以抛出自定义错误。</p>\n<pre><code>function UserError(message) &#123;\n  this.message = message || &#39;默认信息&#39;;\n  this.name = &#39;UserError&#39;;\n&#125;\n\nthrow new UserError(&#39;出错了！&#39;);\n// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;\n</code></pre>\n<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。 实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值。</p>\n<pre><code>// 抛出一个字符串\nthrow &#39;Error！&#39;;\n// Uncaught Error！\n\n// 抛出一个数值\nthrow 42;\n// Uncaught 42\n\n// 抛出一个布尔值\nthrow true;\n// Uncaught true\n\n// 抛出一个对象\nthrow &#123;\n  toString: function () &#123;\n    return &#39;Error!&#39;;\n  &#125;\n&#125;;\n// Uncaught &#123;toString: ƒ&#125;\n</code></pre>\n<p>对于 JavaScript 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值。</p>\n<h2 id=\"try…catch-结构\"><a href=\"#try…catch-结构\" class=\"headerlink\" title=\"try…catch 结构\"></a>try…catch 结构</h2><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>\n<pre><code>try &#123;\n  throw new Error(&#39;出错了!&#39;);\n&#125; catch (e) &#123;\n  console.log(e.name + &quot;: &quot; + e.message);\n  console.log(e.stack);\n&#125;\n// Error: 出错了!\n//   at &lt;anonymous&gt;:3:9\n//   ...\n</code></pre>\n<p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值。 如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理。</p>\n<pre><code>try &#123;\n  f();\n&#125; catch(e) &#123;\n  // 处理错误\n&#125;\n</code></pre>\n<p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理。 <code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p>\n<pre><code>try &#123;\n  throw &quot;出错了&quot;;\n&#125; catch (e) &#123;\n  console.log(111);\n&#125;\nconsole.log(222);\n// 111\n// 222\n</code></pre>\n<p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行。 <code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构。</p>\n<pre><code>var n = 100;\n\ntry &#123;\n  throw n;\n&#125; catch (e) &#123;\n  if (e &lt;= 50) &#123;\n    // ...\n  &#125; else &#123;\n    throw e;\n  &#125;\n&#125;\n// Uncaught 100\n</code></pre>\n<p>上面代码中，<code>catch</code>代码之中又抛出了一个错误。 为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p>\n<pre><code>try &#123;\n  foo.bar();\n&#125; catch (e) &#123;\n  if (e instanceof EvalError) &#123;\n    console.log(e.name + &quot;: &quot; + e.message);\n  &#125; else if (e instanceof RangeError) &#123;\n    console.log(e.name + &quot;: &quot; + e.message);\n  &#125;\n  // ...\n&#125;\n</code></pre>\n<p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理。</p>\n<h2 id=\"finally-代码块\"><a href=\"#finally-代码块\" class=\"headerlink\" title=\"finally 代码块\"></a>finally 代码块</h2><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>\n<pre><code>function cleansUp() &#123;\n  try &#123;\n    throw new Error(&#39;出错了……&#39;);\n    console.log(&#39;此行不会执行&#39;);\n  &#125; finally &#123;\n    console.log(&#39;完成清理工作&#39;);\n  &#125;\n&#125;\n\ncleansUp()\n// 完成清理工作\n// Uncaught Error: 出错了……\n//    at cleansUp (&lt;anonymous&gt;:3:11)\n//    at &lt;anonymous&gt;:10:1\n</code></pre>\n<p>上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息。</p>\n<pre><code>function idle(x) &#123;\n  try &#123;\n    console.log(x);\n    return &#39;result&#39;;\n  &#125; finally &#123;\n    console.log(&#39;FINALLY&#39;);\n  &#125;\n&#125;\n\nidle(&#39;hello&#39;)\n// hello\n// FINALLY\n</code></pre>\n<p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code>。 下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回。</p>\n<pre><code>var count = 0;\nfunction countUp() &#123;\n  try &#123;\n    return count;\n  &#125; finally &#123;\n    count++;\n  &#125;\n&#125;\n\ncountUp()\n// 0\ncount\n// 1\n</code></pre>\n<p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了。 下面是<code>finally</code>代码块用法的典型场景。</p>\n<pre><code>openFile();\n\ntry &#123;\n  writeFile(Data);\n&#125; catch(e) &#123;\n  handleError(e);\n&#125; finally &#123;\n  closeFile();\n&#125;\n</code></pre>\n<p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件。 下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序。</p>\n<pre><code>function f() &#123;\n  try &#123;\n    console.log(0);\n    throw &#39;bug&#39;;\n  &#125; catch(e) &#123;\n    console.log(1);\n    return true; // 这句原本会延迟到 finally 代码块结束再执行\n    console.log(2); // 不会运行\n  &#125; finally &#123;\n    console.log(3);\n    return false; // 这句会覆盖掉前面那句 return\n    console.log(4); // 不会运行\n  &#125;\n\n  console.log(5); // 不会运行\n&#125;\n\nvar result = f();\n// 0\n// 1\n// 3\n\nresult\n// false\n</code></pre>\n<p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块。 <code>catch</code>代码块之中，触发转入<code>finally</code>代码快的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句。</p>\n<pre><code>function f() &#123;\n  try &#123;\n    throw &#39;出错了！&#39;;\n  &#125; catch(e) &#123;\n    console.log(&#39;捕捉到内部错误&#39;);\n    throw e; // 这句原本会等到finally结束再执行\n  &#125; finally &#123;\n    return false; // 直接返回\n  &#125;\n&#125;\n\ntry &#123;\n  f();\n&#125; catch(e) &#123;\n  // 此处不会执行\n  console.log(&#39;caught outer &quot;bogus&quot;&#39;);\n&#125;\n\n//  捕捉到内部错误\n</code></pre>\n<p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了。 <code>try</code>代码块内部，还可以再使用<code>try</code>代码块。</p>\n<pre><code>try &#123;\n  try &#123;\n    console.log(&#39;Hello world!&#39;); // 报错\n  &#125;\n  finally &#123;\n    console.log(&#39;Finally&#39;);\n  &#125;\n  console.log(&#39;Will I run?&#39;);\n&#125; catch(error) &#123;\n  console.error(error.message);\n&#125;\n// Finally\n// consle is not defined\n</code></pre>\n<p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错，这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获。</p>\n<h2 id=\"参考连接\"><a href=\"#参考连接\" class=\"headerlink\" title=\"参考连接 # \"></a>参考连接 # </h2><ul>\n<li>  Jani Hartikainen, <a href=\"http://davidwalsh.name/fix-javascript-errors\">JavaScript Errors and How to Fix Them</a></li>\n</ul>\n"},{"title":"Mongo入门-1-原理","url":"147.html","id":"147","date":"2019-06-22T09:11:42.000Z","_content":"\n关系型数据库遵循的ACID\n=============\n\n*   A (Atomicity)原子性\n*   C (Consisitency)一致性\n*   I (Isolation)独立性\n*   D (Durability)持久性\n\n为什么使用NoSql\n==========\n\n    不不能是空字符串串(\"\")。\n    不不得含有' '(空格)、.、$、/、\\和\\0 (空字符)。\n    应全部小小写。\n    最多64字节。1234\n\n有一些数据库名是保留的,可以直接访问这些有特殊作用的数据库\n\n*   admin root数据库,将一个用户添加到这个数据库,这个用户自动继承所有数据库的权限.特定的命令只能够这个数据库运行(列出所有的数据库或关闭服务器)\n*   local 这个数据永远不会被复制,可以用来存储限于本地单台服务器的任意集合\n*   config:当Mongo用于分片设置时,config在内部使用,用于保存分片的相关信息\n\n#### 文档\n\n文档是一组kv(BSON).Mongo的文档不需要设置相同的字段,并且相同的字段不需要相同的数据类型,与关系型数据库有很大差别,也是MongoDB的特点\n\n    {\"site\":\"www.baidu.com\"}\n    {\"site\":\"www.google.com\",\"name\":\"Google\"}\n    {\"site\":\"www.runoob.com\",\"name\":\"菜⻦鸟教程\",\"num\":5}123\n\n### MongoDB数据类型","source":"_posts/mongo-e5-85-a5-e9-97-a8-1-e5-8e-9f-e7-90-86.md","raw":"---\ntitle: Mongo入门-1-原理\nurl: 147.html\nid: 147\ncategories:\n  - 服务端\ndate: 2019-06-22 17:11:42\ntags:\n---\n\n关系型数据库遵循的ACID\n=============\n\n*   A (Atomicity)原子性\n*   C (Consisitency)一致性\n*   I (Isolation)独立性\n*   D (Durability)持久性\n\n为什么使用NoSql\n==========\n\n    不不能是空字符串串(\"\")。\n    不不得含有' '(空格)、.、$、/、\\和\\0 (空字符)。\n    应全部小小写。\n    最多64字节。1234\n\n有一些数据库名是保留的,可以直接访问这些有特殊作用的数据库\n\n*   admin root数据库,将一个用户添加到这个数据库,这个用户自动继承所有数据库的权限.特定的命令只能够这个数据库运行(列出所有的数据库或关闭服务器)\n*   local 这个数据永远不会被复制,可以用来存储限于本地单台服务器的任意集合\n*   config:当Mongo用于分片设置时,config在内部使用,用于保存分片的相关信息\n\n#### 文档\n\n文档是一组kv(BSON).Mongo的文档不需要设置相同的字段,并且相同的字段不需要相同的数据类型,与关系型数据库有很大差别,也是MongoDB的特点\n\n    {\"site\":\"www.baidu.com\"}\n    {\"site\":\"www.google.com\",\"name\":\"Google\"}\n    {\"site\":\"www.runoob.com\",\"name\":\"菜⻦鸟教程\",\"num\":5}123\n\n### MongoDB数据类型","slug":"mongo-e5-85-a5-e9-97-a8-1-e5-8e-9f-e7-90-86","published":1,"updated":"2019-09-10T07:46:08.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269ec003lc8gsbura7m34","content":"<h1 id=\"关系型数据库遵循的ACID\"><a href=\"#关系型数据库遵循的ACID\" class=\"headerlink\" title=\"关系型数据库遵循的ACID\"></a>关系型数据库遵循的ACID</h1><ul>\n<li>  A (Atomicity)原子性</li>\n<li>  C (Consisitency)一致性</li>\n<li>  I (Isolation)独立性</li>\n<li>  D (Durability)持久性</li>\n</ul>\n<h1 id=\"为什么使用NoSql\"><a href=\"#为什么使用NoSql\" class=\"headerlink\" title=\"为什么使用NoSql\"></a>为什么使用NoSql</h1><pre><code>不不能是空字符串串(&quot;&quot;)。\n不不得含有&#39; &#39;(空格)、.、$、/、\\和\\0 (空字符)。\n应全部小小写。\n最多64字节。1234\n</code></pre>\n<p>有一些数据库名是保留的,可以直接访问这些有特殊作用的数据库</p>\n<ul>\n<li>  admin root数据库,将一个用户添加到这个数据库,这个用户自动继承所有数据库的权限.特定的命令只能够这个数据库运行(列出所有的数据库或关闭服务器)</li>\n<li>  local 这个数据永远不会被复制,可以用来存储限于本地单台服务器的任意集合</li>\n<li>  config:当Mongo用于分片设置时,config在内部使用,用于保存分片的相关信息</li>\n</ul>\n<h4 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h4><p>文档是一组kv(BSON).Mongo的文档不需要设置相同的字段,并且相同的字段不需要相同的数据类型,与关系型数据库有很大差别,也是MongoDB的特点</p>\n<pre><code>&#123;&quot;site&quot;:&quot;www.baidu.com&quot;&#125;\n&#123;&quot;site&quot;:&quot;www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;&#125;\n&#123;&quot;site&quot;:&quot;www.runoob.com&quot;,&quot;name&quot;:&quot;菜⻦鸟教程&quot;,&quot;num&quot;:5&#125;123\n</code></pre>\n<h3 id=\"MongoDB数据类型\"><a href=\"#MongoDB数据类型\" class=\"headerlink\" title=\"MongoDB数据类型\"></a>MongoDB数据类型</h3>","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"关系型数据库遵循的ACID\"><a href=\"#关系型数据库遵循的ACID\" class=\"headerlink\" title=\"关系型数据库遵循的ACID\"></a>关系型数据库遵循的ACID</h1><ul>\n<li>  A (Atomicity)原子性</li>\n<li>  C (Consisitency)一致性</li>\n<li>  I (Isolation)独立性</li>\n<li>  D (Durability)持久性</li>\n</ul>\n<h1 id=\"为什么使用NoSql\"><a href=\"#为什么使用NoSql\" class=\"headerlink\" title=\"为什么使用NoSql\"></a>为什么使用NoSql</h1><pre><code>不不能是空字符串串(&quot;&quot;)。\n不不得含有&#39; &#39;(空格)、.、$、/、\\和\\0 (空字符)。\n应全部小小写。\n最多64字节。1234\n</code></pre>\n<p>有一些数据库名是保留的,可以直接访问这些有特殊作用的数据库</p>\n<ul>\n<li>  admin root数据库,将一个用户添加到这个数据库,这个用户自动继承所有数据库的权限.特定的命令只能够这个数据库运行(列出所有的数据库或关闭服务器)</li>\n<li>  local 这个数据永远不会被复制,可以用来存储限于本地单台服务器的任意集合</li>\n<li>  config:当Mongo用于分片设置时,config在内部使用,用于保存分片的相关信息</li>\n</ul>\n<h4 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h4><p>文档是一组kv(BSON).Mongo的文档不需要设置相同的字段,并且相同的字段不需要相同的数据类型,与关系型数据库有很大差别,也是MongoDB的特点</p>\n<pre><code>&#123;&quot;site&quot;:&quot;www.baidu.com&quot;&#125;\n&#123;&quot;site&quot;:&quot;www.google.com&quot;,&quot;name&quot;:&quot;Google&quot;&#125;\n&#123;&quot;site&quot;:&quot;www.runoob.com&quot;,&quot;name&quot;:&quot;菜⻦鸟教程&quot;,&quot;num&quot;:5&#125;123\n</code></pre>\n<h3 id=\"MongoDB数据类型\"><a href=\"#MongoDB数据类型\" class=\"headerlink\" title=\"MongoDB数据类型\"></a>MongoDB数据类型</h3>"},{"title":"Mongo入门-2-基本操作","url":"151.html","id":"151","date":"2019-06-22T09:12:57.000Z","_content":"\n创建数据库\n=====\n\n    db.student.insert{\n    stuid : 1,\n    stuname : \"xxx\"\n    }\n\n删除数据库\n\n    sue sdkb\n    db.dropDatabase()\n\n#### 插入文档\n\n若不存在,插入新文档时会自动创建一个新的集合,再插入.\n\n    db.collection.insertOne():向指定的集合插入一条数据\n    db.collection.insertMany():向指定的集合中插入多条数据12\n\n    db.users.insertOne(\n    {\n    \tname:\"sue\",\n    \tage:22,\n    \tstatus:\"xxx\"\n    }\n    )\n\n向users插入多条文档\n\n    db.users.insertMany(\n    [{\n    name:\"zzxb\",\n    age:18,\n    status:\"xxx\"\n    },\n    {\n    name:\"ilyj\",\n    age:38,\n    status:\"stop\"\n    }\n    ]\n    )\n\n#### 更新文档\n\n    db.collection.update(\n    <query>,\n    <update>,\n    {\n    \tupsert:<boolean>,\n    \tmulti:<boolean>,\n    \twriteConcern:<documnet>\n    }\n    )\n\n参数说明:\n\n*   query:update的查询条件,类似sql update查询内where后面的\n*   update:update的对象和一些更新的操作符号\n*   upsert:可选 若不存在update的记录,是否插入objNew,true为插入,默认为false,不插入\n*   multi:可选,只更新找到的第一条记录,true:把按条件查出来的多条记录全部更新\n*   writeConcern:可选 抛出异常的级别\n\n**3.2版本开始 MongoDB提供以下更新集合文档的方法**\n\n    db.collention.updateOne()\n    db.collection.updateMany()\n\n**范例** 将name为zzxb的文档,更新年龄为40\n\n    db.user.update(\n    {\"name\":\"zzxb\"},\n    {$set:{\"age\":40}}\n    )\n\n将年龄小于30的文档,更新状态为stop\n\n    db.users.update(\n    {\"age\":{$lt:30},\n    {$set:{\"status\":\"stop\"}}\n    }\n    )\n\n**大于小于**\n\n*   lt : 小于\n*   gt: 大于\n*   lte : 小于等于\n*   gte : 大于等于\n*   ne: 不等于\n\n**save语法** save()方法通过传入的文档来替换已有的文档\n\n    db.collection.save(\n    <document>,\n    {\n    writeConcern:<document>\n    }\n    )\n\n*   document:文档数据\n*   writeConcern:可选的,抛出异常的级别\n\n替换id为5a67ea03fd6b999d262bae2c的文文档内容\n\n    db.users.save({\n    \t_id:ObjectId(\"5a67...\"),\n    \tname:\"myzzxb\",\n    \tage:28,\n    \tstatus:\"starting\"\n    })\n\n**修改器** 通常文档只会有一部分要更细,使用原子性的更新,指定文档的某些字段进行更新 更新修改器是钟特殊的键.用来指定复杂的更新操作:修改,增加 删除,还可能是操作数据或内嵌文档","source":"_posts/mongo-e5-85-a5-e9-97-a8-2-e5-9f-ba-e6-9c-ac-e6-93-8d-e4-bd-9c.md","raw":"---\ntitle: Mongo入门-2-基本操作\nurl: 151.html\nid: 151\ncategories:\n  - 服务端\ndate: 2019-06-22 17:12:57\ntags:\n---\n\n创建数据库\n=====\n\n    db.student.insert{\n    stuid : 1,\n    stuname : \"xxx\"\n    }\n\n删除数据库\n\n    sue sdkb\n    db.dropDatabase()\n\n#### 插入文档\n\n若不存在,插入新文档时会自动创建一个新的集合,再插入.\n\n    db.collection.insertOne():向指定的集合插入一条数据\n    db.collection.insertMany():向指定的集合中插入多条数据12\n\n    db.users.insertOne(\n    {\n    \tname:\"sue\",\n    \tage:22,\n    \tstatus:\"xxx\"\n    }\n    )\n\n向users插入多条文档\n\n    db.users.insertMany(\n    [{\n    name:\"zzxb\",\n    age:18,\n    status:\"xxx\"\n    },\n    {\n    name:\"ilyj\",\n    age:38,\n    status:\"stop\"\n    }\n    ]\n    )\n\n#### 更新文档\n\n    db.collection.update(\n    <query>,\n    <update>,\n    {\n    \tupsert:<boolean>,\n    \tmulti:<boolean>,\n    \twriteConcern:<documnet>\n    }\n    )\n\n参数说明:\n\n*   query:update的查询条件,类似sql update查询内where后面的\n*   update:update的对象和一些更新的操作符号\n*   upsert:可选 若不存在update的记录,是否插入objNew,true为插入,默认为false,不插入\n*   multi:可选,只更新找到的第一条记录,true:把按条件查出来的多条记录全部更新\n*   writeConcern:可选 抛出异常的级别\n\n**3.2版本开始 MongoDB提供以下更新集合文档的方法**\n\n    db.collention.updateOne()\n    db.collection.updateMany()\n\n**范例** 将name为zzxb的文档,更新年龄为40\n\n    db.user.update(\n    {\"name\":\"zzxb\"},\n    {$set:{\"age\":40}}\n    )\n\n将年龄小于30的文档,更新状态为stop\n\n    db.users.update(\n    {\"age\":{$lt:30},\n    {$set:{\"status\":\"stop\"}}\n    }\n    )\n\n**大于小于**\n\n*   lt : 小于\n*   gt: 大于\n*   lte : 小于等于\n*   gte : 大于等于\n*   ne: 不等于\n\n**save语法** save()方法通过传入的文档来替换已有的文档\n\n    db.collection.save(\n    <document>,\n    {\n    writeConcern:<document>\n    }\n    )\n\n*   document:文档数据\n*   writeConcern:可选的,抛出异常的级别\n\n替换id为5a67ea03fd6b999d262bae2c的文文档内容\n\n    db.users.save({\n    \t_id:ObjectId(\"5a67...\"),\n    \tname:\"myzzxb\",\n    \tage:28,\n    \tstatus:\"starting\"\n    })\n\n**修改器** 通常文档只会有一部分要更细,使用原子性的更新,指定文档的某些字段进行更新 更新修改器是钟特殊的键.用来指定复杂的更新操作:修改,增加 删除,还可能是操作数据或内嵌文档","slug":"mongo-e5-85-a5-e9-97-a8-2-e5-9f-ba-e6-9c-ac-e6-93-8d-e4-bd-9c","published":1,"updated":"2019-09-10T07:46:08.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269eq003oc8gs4c8j22e6","content":"<h1 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h1><pre><code>db.student.insert&#123;\nstuid : 1,\nstuname : &quot;xxx&quot;\n&#125;\n</code></pre>\n<p>删除数据库</p>\n<pre><code>sue sdkb\ndb.dropDatabase()\n</code></pre>\n<h4 id=\"插入文档\"><a href=\"#插入文档\" class=\"headerlink\" title=\"插入文档\"></a>插入文档</h4><p>若不存在,插入新文档时会自动创建一个新的集合,再插入.</p>\n<pre><code>db.collection.insertOne():向指定的集合插入一条数据\ndb.collection.insertMany():向指定的集合中插入多条数据12\n\ndb.users.insertOne(\n&#123;\n    name:&quot;sue&quot;,\n    age:22,\n    status:&quot;xxx&quot;\n&#125;\n)\n</code></pre>\n<p>向users插入多条文档</p>\n<pre><code>db.users.insertMany(\n[&#123;\nname:&quot;zzxb&quot;,\nage:18,\nstatus:&quot;xxx&quot;\n&#125;,\n&#123;\nname:&quot;ilyj&quot;,\nage:38,\nstatus:&quot;stop&quot;\n&#125;\n]\n)\n</code></pre>\n<h4 id=\"更新文档\"><a href=\"#更新文档\" class=\"headerlink\" title=\"更新文档\"></a>更新文档</h4><pre><code>db.collection.update(\n&lt;query&gt;,\n&lt;update&gt;,\n&#123;\n    upsert:&lt;boolean&gt;,\n    multi:&lt;boolean&gt;,\n    writeConcern:&lt;documnet&gt;\n&#125;\n)\n</code></pre>\n<p>参数说明:</p>\n<ul>\n<li>  query:update的查询条件,类似sql update查询内where后面的</li>\n<li>  update:update的对象和一些更新的操作符号</li>\n<li>  upsert:可选 若不存在update的记录,是否插入objNew,true为插入,默认为false,不插入</li>\n<li>  multi:可选,只更新找到的第一条记录,true:把按条件查出来的多条记录全部更新</li>\n<li>  writeConcern:可选 抛出异常的级别</li>\n</ul>\n<p><strong>3.2版本开始 MongoDB提供以下更新集合文档的方法</strong></p>\n<pre><code>db.collention.updateOne()\ndb.collection.updateMany()\n</code></pre>\n<p><strong>范例</strong> 将name为zzxb的文档,更新年龄为40</p>\n<pre><code>db.user.update(\n&#123;&quot;name&quot;:&quot;zzxb&quot;&#125;,\n&#123;$set:&#123;&quot;age&quot;:40&#125;&#125;\n)\n</code></pre>\n<p>将年龄小于30的文档,更新状态为stop</p>\n<pre><code>db.users.update(\n&#123;&quot;age&quot;:&#123;$lt:30&#125;,\n&#123;$set:&#123;&quot;status&quot;:&quot;stop&quot;&#125;&#125;\n&#125;\n)\n</code></pre>\n<p><strong>大于小于</strong></p>\n<ul>\n<li>  lt : 小于</li>\n<li>  gt: 大于</li>\n<li>  lte : 小于等于</li>\n<li>  gte : 大于等于</li>\n<li>  ne: 不等于</li>\n</ul>\n<p><strong>save语法</strong> save()方法通过传入的文档来替换已有的文档</p>\n<pre><code>db.collection.save(\n&lt;document&gt;,\n&#123;\nwriteConcern:&lt;document&gt;\n&#125;\n)\n</code></pre>\n<ul>\n<li>  document:文档数据</li>\n<li>  writeConcern:可选的,抛出异常的级别</li>\n</ul>\n<p>替换id为5a67ea03fd6b999d262bae2c的文文档内容</p>\n<pre><code>db.users.save(&#123;\n    _id:ObjectId(&quot;5a67...&quot;),\n    name:&quot;myzzxb&quot;,\n    age:28,\n    status:&quot;starting&quot;\n&#125;)\n</code></pre>\n<p><strong>修改器</strong> 通常文档只会有一部分要更细,使用原子性的更新,指定文档的某些字段进行更新 更新修改器是钟特殊的键.用来指定复杂的更新操作:修改,增加 删除,还可能是操作数据或内嵌文档</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"创建数据库\"><a href=\"#创建数据库\" class=\"headerlink\" title=\"创建数据库\"></a>创建数据库</h1><pre><code>db.student.insert&#123;\nstuid : 1,\nstuname : &quot;xxx&quot;\n&#125;\n</code></pre>\n<p>删除数据库</p>\n<pre><code>sue sdkb\ndb.dropDatabase()\n</code></pre>\n<h4 id=\"插入文档\"><a href=\"#插入文档\" class=\"headerlink\" title=\"插入文档\"></a>插入文档</h4><p>若不存在,插入新文档时会自动创建一个新的集合,再插入.</p>\n<pre><code>db.collection.insertOne():向指定的集合插入一条数据\ndb.collection.insertMany():向指定的集合中插入多条数据12\n\ndb.users.insertOne(\n&#123;\n    name:&quot;sue&quot;,\n    age:22,\n    status:&quot;xxx&quot;\n&#125;\n)\n</code></pre>\n<p>向users插入多条文档</p>\n<pre><code>db.users.insertMany(\n[&#123;\nname:&quot;zzxb&quot;,\nage:18,\nstatus:&quot;xxx&quot;\n&#125;,\n&#123;\nname:&quot;ilyj&quot;,\nage:38,\nstatus:&quot;stop&quot;\n&#125;\n]\n)\n</code></pre>\n<h4 id=\"更新文档\"><a href=\"#更新文档\" class=\"headerlink\" title=\"更新文档\"></a>更新文档</h4><pre><code>db.collection.update(\n&lt;query&gt;,\n&lt;update&gt;,\n&#123;\n    upsert:&lt;boolean&gt;,\n    multi:&lt;boolean&gt;,\n    writeConcern:&lt;documnet&gt;\n&#125;\n)\n</code></pre>\n<p>参数说明:</p>\n<ul>\n<li>  query:update的查询条件,类似sql update查询内where后面的</li>\n<li>  update:update的对象和一些更新的操作符号</li>\n<li>  upsert:可选 若不存在update的记录,是否插入objNew,true为插入,默认为false,不插入</li>\n<li>  multi:可选,只更新找到的第一条记录,true:把按条件查出来的多条记录全部更新</li>\n<li>  writeConcern:可选 抛出异常的级别</li>\n</ul>\n<p><strong>3.2版本开始 MongoDB提供以下更新集合文档的方法</strong></p>\n<pre><code>db.collention.updateOne()\ndb.collection.updateMany()\n</code></pre>\n<p><strong>范例</strong> 将name为zzxb的文档,更新年龄为40</p>\n<pre><code>db.user.update(\n&#123;&quot;name&quot;:&quot;zzxb&quot;&#125;,\n&#123;$set:&#123;&quot;age&quot;:40&#125;&#125;\n)\n</code></pre>\n<p>将年龄小于30的文档,更新状态为stop</p>\n<pre><code>db.users.update(\n&#123;&quot;age&quot;:&#123;$lt:30&#125;,\n&#123;$set:&#123;&quot;status&quot;:&quot;stop&quot;&#125;&#125;\n&#125;\n)\n</code></pre>\n<p><strong>大于小于</strong></p>\n<ul>\n<li>  lt : 小于</li>\n<li>  gt: 大于</li>\n<li>  lte : 小于等于</li>\n<li>  gte : 大于等于</li>\n<li>  ne: 不等于</li>\n</ul>\n<p><strong>save语法</strong> save()方法通过传入的文档来替换已有的文档</p>\n<pre><code>db.collection.save(\n&lt;document&gt;,\n&#123;\nwriteConcern:&lt;document&gt;\n&#125;\n)\n</code></pre>\n<ul>\n<li>  document:文档数据</li>\n<li>  writeConcern:可选的,抛出异常的级别</li>\n</ul>\n<p>替换id为5a67ea03fd6b999d262bae2c的文文档内容</p>\n<pre><code>db.users.save(&#123;\n    _id:ObjectId(&quot;5a67...&quot;),\n    name:&quot;myzzxb&quot;,\n    age:28,\n    status:&quot;starting&quot;\n&#125;)\n</code></pre>\n<p><strong>修改器</strong> 通常文档只会有一部分要更细,使用原子性的更新,指定文档的某些字段进行更新 更新修改器是钟特殊的键.用来指定复杂的更新操作:修改,增加 删除,还可能是操作数据或内嵌文档</p>\n"},{"title":"NodeCache 免备案CDN/注册Z即送1T免费加速流量","url":"240.html","id":"240","date":"2019-07-11T11:56:00.000Z","_content":"\n**Nodecache 属于GlobalCache旗下品牌，也是免备案的国外CDN。有北美、欧洲、亚太、拉美等节点，注册送1T流量。** **访问地址：   [https://console.nodecache.com](https://console.nodecache.com/)**","source":"_posts/nodecache-e5-85-8d-e5-a4-87-e6-a1-88cdn-e6-b3-a8-e5-86-8cz-e5-8d-b3-e9-80-811t-e5-85-8d-e8-b4-b9-e5-8a-a0-e9-80-9f-e6-b5-81-e9-87-8f.md","raw":"---\ntitle: NodeCache 免备案CDN/注册Z即送1T免费加速流量\nurl: 240.html\nid: 240\ncategories:\n  - 杂谈\ndate: 2019-07-11 19:56:00\ntags:\n---\n\n**Nodecache 属于GlobalCache旗下品牌，也是免备案的国外CDN。有北美、欧洲、亚太、拉美等节点，注册送1T流量。** **访问地址：   [https://console.nodecache.com](https://console.nodecache.com/)**","slug":"nodecache-e5-85-8d-e5-a4-87-e6-a1-88cdn-e6-b3-a8-e5-86-8cz-e5-8d-b3-e9-80-811t-e5-85-8d-e8-b4-b9-e5-8a-a0-e9-80-9f-e6-b5-81-e9-87-8f","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269er003rc8gs8tbqg1sa","content":"<p><strong>Nodecache 属于GlobalCache旗下品牌，也是免备案的国外CDN。有北美、欧洲、亚太、拉美等节点，注册送1T流量。</strong> <strong>访问地址：   <a href=\"https://console.nodecache.com/\">https://console.nodecache.com</a></strong></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p><strong>Nodecache 属于GlobalCache旗下品牌，也是免备案的国外CDN。有北美、欧洲、亚太、拉美等节点，注册送1T流量。</strong> <strong>访问地址：   <a href=\"https://console.nodecache.com/\">https://console.nodecache.com</a></strong></p>\n"},{"title":"Office2019光盘镜像下载","url":"207.html","id":"207","date":"2019-07-05T08:20:12.000Z","_content":"\nOffice2019 正式版发布已经有一些时间了，按照微软官方的说法，是不再提供离线安装版 Office2019 下载的了，但目前网络上还是流出了 img 版的 Office2019 光盘镜像下载。![Office2019光盘镜像下载](https://aliyun.ccswust.org/images/2019/02/2019020614120577.jpg 'Office2019光盘镜像下载') 目前流出的版本是零售版，还没有大企业用的批量授权版本，由于是零售版，所以至于激活，目前有些激活工具是没法激活的，有些已经可以支持了，如果你手上的激活还没法激活 Office2019 的话，可以留言 [Office2019 专业增强版下载](http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2019Retail.img) [Office2019 专业版下载](http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Professional2019Retail.img) [Office2019 Project2019 专业零售版下载](http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectPro2019Retail.img) [Office 2019 Visio 专业零售版下载](http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioPro2019Retail.img) 这应该是 Office2019 比较齐全的下载了吧，包括比较不常用的 Project 和 Visio 都有下载了，所以，大家可以根据自己的需要下载。 Office2019 专业增强版包括下述几大产品：World、Excel、Access、Outlook、OneNote、PowerPoint、Publisher、Skype、OneDrive，因为文件比较大，建议使用迅雷等支持多线程下载工具下载。\n","source":"_posts/office2019-e5-85-89-e7-9b-98-e9-95-9c-e5-83-8f-e4-b8-8b-e8-bd-bd.md","raw":"---\ntitle: Office2019光盘镜像下载\ntags:\n  - Microsoft office\nurl: 207.html\nid: 207\ncategories:\n  - 精选资源\ndate: 2019-07-05 16:20:12\n---\n\nOffice2019 正式版发布已经有一些时间了，按照微软官方的说法，是不再提供离线安装版 Office2019 下载的了，但目前网络上还是流出了 img 版的 Office2019 光盘镜像下载。![Office2019光盘镜像下载](https://aliyun.ccswust.org/images/2019/02/2019020614120577.jpg 'Office2019光盘镜像下载') 目前流出的版本是零售版，还没有大企业用的批量授权版本，由于是零售版，所以至于激活，目前有些激活工具是没法激活的，有些已经可以支持了，如果你手上的激活还没法激活 Office2019 的话，可以留言 [Office2019 专业增强版下载](http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2019Retail.img) [Office2019 专业版下载](http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Professional2019Retail.img) [Office2019 Project2019 专业零售版下载](http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectPro2019Retail.img) [Office 2019 Visio 专业零售版下载](http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioPro2019Retail.img) 这应该是 Office2019 比较齐全的下载了吧，包括比较不常用的 Project 和 Visio 都有下载了，所以，大家可以根据自己的需要下载。 Office2019 专业增强版包括下述几大产品：World、Excel、Access、Outlook、OneNote、PowerPoint、Publisher、Skype、OneDrive，因为文件比较大，建议使用迅雷等支持多线程下载工具下载。\n","slug":"office2019-e5-85-89-e7-9b-98-e9-95-9c-e5-83-8f-e4-b8-8b-e8-bd-bd","published":1,"updated":"2019-09-11T03:08:53.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269et003uc8gs1gkggeml","content":"<p>Office2019 正式版发布已经有一些时间了，按照微软官方的说法，是不再提供离线安装版 Office2019 下载的了，但目前网络上还是流出了 img 版的 Office2019 光盘镜像下载。<img src=\"https://aliyun.ccswust.org/images/2019/02/2019020614120577.jpg\" alt=\"Office2019光盘镜像下载\" title=\"Office2019光盘镜像下载\"> 目前流出的版本是零售版，还没有大企业用的批量授权版本，由于是零售版，所以至于激活，目前有些激活工具是没法激活的，有些已经可以支持了，如果你手上的激活还没法激活 Office2019 的话，可以留言 <a href=\"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2019Retail.img\">Office2019 专业增强版下载</a> <a href=\"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Professional2019Retail.img\">Office2019 专业版下载</a> <a href=\"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectPro2019Retail.img\">Office2019 Project2019 专业零售版下载</a> <a href=\"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioPro2019Retail.img\">Office 2019 Visio 专业零售版下载</a> 这应该是 Office2019 比较齐全的下载了吧，包括比较不常用的 Project 和 Visio 都有下载了，所以，大家可以根据自己的需要下载。 Office2019 专业增强版包括下述几大产品：World、Excel、Access、Outlook、OneNote、PowerPoint、Publisher、Skype、OneDrive，因为文件比较大，建议使用迅雷等支持多线程下载工具下载。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>Office2019 正式版发布已经有一些时间了，按照微软官方的说法，是不再提供离线安装版 Office2019 下载的了，但目前网络上还是流出了 img 版的 Office2019 光盘镜像下载。<img src=\"https://aliyun.ccswust.org/images/2019/02/2019020614120577.jpg\" alt=\"Office2019光盘镜像下载\" title=\"Office2019光盘镜像下载\"> 目前流出的版本是零售版，还没有大企业用的批量授权版本，由于是零售版，所以至于激活，目前有些激活工具是没法激活的，有些已经可以支持了，如果你手上的激活还没法激活 Office2019 的话，可以留言 <a href=\"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProPlus2019Retail.img\">Office2019 专业增强版下载</a> <a href=\"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/Professional2019Retail.img\">Office2019 专业版下载</a> <a href=\"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/ProjectPro2019Retail.img\">Office2019 Project2019 专业零售版下载</a> <a href=\"http://officecdn.microsoft.com/pr/492350f6-3a01-4f97-b9c0-c7c6ddf67d60/media/zh-cn/VisioPro2019Retail.img\">Office 2019 Visio 专业零售版下载</a> 这应该是 Office2019 比较齐全的下载了吧，包括比较不常用的 Project 和 Visio 都有下载了，所以，大家可以根据自己的需要下载。 Office2019 专业增强版包括下述几大产品：World、Excel、Access、Outlook、OneNote、PowerPoint、Publisher、Skype、OneDrive，因为文件比较大，建议使用迅雷等支持多线程下载工具下载。</p>\n"},{"title":"VIP影视APP源码，带商城系统，安卓苹果双端，全新的后台!一键安装引导的版本","url":"131.html","id":"131","date":"2019-06-22T08:42:03.000Z","_content":"\nVIP 影视 APP 源码，带商城系统，安卓苹果双端，全新的后台!一键安装引导的版本 ![](http://cdn.v5ant.com/ueditor/images/1127903508247482368.png) ![](http://cdn.v5ant.com/ueditor/images/1127903507463147520.png) ![](http://cdn.v5ant.com/ueditor/images/1127903507278598144.png)\n","source":"_posts/vip-e5-bd-b1-e8-a7-86app-e6-ba-90-e7-a0-81-ef-bc-8c-e5-b8-a6-e5-95-86-e5-9f-8e-e7-b3-bb-e7-bb-9f-ef-bc-8c-e5-ae-89-e5-8d-93-e8-8b-b9-e6-9e-9c-e5-8f-8c-e7-ab-af-ef-bc-8c-e5-85-a8-e6-96-b0-e7-9a-84.md","raw":"---\ntitle: VIP影视APP源码，带商城系统，安卓苹果双端，全新的后台!一键安装引导的版本\nurl: 131.html\nid: 131\ncategories:\n  - 精选资源\ndate: 2019-06-22 16:42:03\ntags:\n---\n\nVIP 影视 APP 源码，带商城系统，安卓苹果双端，全新的后台!一键安装引导的版本 ![](http://cdn.v5ant.com/ueditor/images/1127903508247482368.png) ![](http://cdn.v5ant.com/ueditor/images/1127903507463147520.png) ![](http://cdn.v5ant.com/ueditor/images/1127903507278598144.png)\n","slug":"vip-e5-bd-b1-e8-a7-86app-e6-ba-90-e7-a0-81-ef-bc-8c-e5-b8-a6-e5-95-86-e5-9f-8e-e7-b3-bb-e7-bb-9f-ef-bc-8c-e5-ae-89-e5-8d-93-e8-8b-b9-e6-9e-9c-e5-8f-8c-e7-ab-af-ef-bc-8c-e5-85-a8-e6-96-b0-e7-9a-84","published":1,"updated":"2019-09-11T03:09:03.861Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269ez003xc8gse69ogobn","content":"<p>VIP 影视 APP 源码，带商城系统，安卓苹果双端，全新的后台!一键安装引导的版本 <img src=\"http://cdn.v5ant.com/ueditor/images/1127903508247482368.png\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1127903507463147520.png\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1127903507278598144.png\"></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>VIP 影视 APP 源码，带商城系统，安卓苹果双端，全新的后台!一键安装引导的版本 <img src=\"http://cdn.v5ant.com/ueditor/images/1127903508247482368.png\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1127903507463147520.png\"> <img src=\"http://cdn.v5ant.com/ueditor/images/1127903507278598144.png\"></p>\n"},{"title":"vue-mini-player 基于Vue的一个轻量级HTML5视频播放器","url":"269.html","id":"269","date":"2019-07-26T03:29:57.000Z","_content":"\nvue-mini-player\n===============\n\n> 基于 Vue 的一个轻量级视频播放组件，适配 PC 和移动端\n\n![avatar](https://webweifeng.github.io/vue-mini-player/preview.jpg)\n\n安装\n--\n\n    $ npm install vue-mini-player -S\n    \n\n使用\n--\n\n    # main.js\n    import vueMiniPlayer from 'vue-mini-player'\n    import 'vue-mini-player/lib/vue-mini-player.css'\n    Vue.use(vueMiniPlayer)\n    \n\n在项目中使用 vueMiniPlayer\n\n    <template>\n      <vueMiniPlayer ref=\"vueMiniPlayer\" :video=\"video\" :mutex=\"true\" @fullscreen=\"handleFullscreen\" />\n    </template>\n    <script>\n      export default {\n        data () {\n          return {\n            video: {\n                url: 'https://api.dogecloud.com/player/get.mp4?vcode=5ac682e6f8231991&userId=17&ext=.mp4',\n                cover: 'https://i.loli.net/2019/06/06/5cf8c5d9c57b510947.png',\n                muted: false,\n                loop: false,\n                preload: 'auto',\n                poster: '',\n                volume: 1,\n                autoplay: false\n            }\n          }\n        },\n        computed(){\n          $video(){\n            return this.$refs.vueMiniPlayer.$video;\n          }\n        },\n        methods:{\n          handleFullscreen(){\n    \n          }\n        }\n      }\n    </script>\n    \n\n💡 特色\n-----\n\n1.轻量级 `HTML5` 播放器，精美 `UI` 控件，简单易上手 `Gzip` 压缩不足 `10k` 2.提供以 `npm` 的形式安装提供全局组件 3.多格式视频配置，移动端+PC 通用模式\n\n*   多类型视频支持\n*   自定义海报\n*   多平台兼容\n*   静音开关\n*   播放时间进度\n*   全屏支持\n*   拖动播放\n*   倍速播放\n*   MSE 支持\n*   弹幕支持\n\n✈️ 参数\n-----\n\n名称\n\n默认值\n\n描述\n\nmutex\n\nfalse\n\n互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器\n\nvideo\n\n-\n\n视频相关参数\n\nvideo.url\n\n-\n\n视频播放源，支持 Array 形式传入多种视频格式\n\nvideo.cover\n\n-\n\n视频海报\n\nvideo.muted\n\nfalse\n\n是否静音播放\n\nvideo.loop\n\nfalse\n\n视频是否循环播放\n\nvideo.preload\n\n‘auto’\n\n视频预加载，可选值: ‘none’, ‘metadata’, ‘auto’\n\nvideo.poster\n\n-\n\n原生视频默认海报暂不设置，只设置 video.cover\n\nvideo.volume\n\n1\n\n默认音量\n\nvideo.autoplay\n\nfalse\n\n视频自动播放\n\n🚀 事件\n-----\n\n名称\n\n描述\n\nfullscreen\n\n全屏事件\n\nready\n\n视频播放器准备好\n\nclearMode\n\n清洁模式执行\n\nvideoPlay\n\n播放器执行 play 或者 pause\n\ncreated\n\n组件生命周期\n\nmounted\n\n组件生命周期\n\nbeforeDestroy\n\n组件生命周期\n\ndestroyed\n\n组件生命周期\n\nGitHub：[https://github.com/webweifeng/vue-mini-player ](https://github.com/webweifeng/vue-mini-player)","source":"_posts/vue-mini-player-e5-9f-ba-e4-ba-8evue-e7-9a-84-e4-b8-80-e4-b8-aa-e8-bd-bb-e9-87-8f-e7-ba-a7html5-e8-a7-86-e9-a2-91-e6-92-ad-e6-94-be-e5-99-a8.md","raw":"---\ntitle: vue-mini-player 基于Vue的一个轻量级HTML5视频播放器\ntags:\n  - player\n  - video-player\n  - 开源 GitHub Vue\nurl: 269.html\nid: 269\ncategories:\n  - 大前端\ndate: 2019-07-26 11:29:57\n---\n\nvue-mini-player\n===============\n\n> 基于 Vue 的一个轻量级视频播放组件，适配 PC 和移动端\n\n![avatar](https://webweifeng.github.io/vue-mini-player/preview.jpg)\n\n安装\n--\n\n    $ npm install vue-mini-player -S\n    \n\n使用\n--\n\n    # main.js\n    import vueMiniPlayer from 'vue-mini-player'\n    import 'vue-mini-player/lib/vue-mini-player.css'\n    Vue.use(vueMiniPlayer)\n    \n\n在项目中使用 vueMiniPlayer\n\n    <template>\n      <vueMiniPlayer ref=\"vueMiniPlayer\" :video=\"video\" :mutex=\"true\" @fullscreen=\"handleFullscreen\" />\n    </template>\n    <script>\n      export default {\n        data () {\n          return {\n            video: {\n                url: 'https://api.dogecloud.com/player/get.mp4?vcode=5ac682e6f8231991&userId=17&ext=.mp4',\n                cover: 'https://i.loli.net/2019/06/06/5cf8c5d9c57b510947.png',\n                muted: false,\n                loop: false,\n                preload: 'auto',\n                poster: '',\n                volume: 1,\n                autoplay: false\n            }\n          }\n        },\n        computed(){\n          $video(){\n            return this.$refs.vueMiniPlayer.$video;\n          }\n        },\n        methods:{\n          handleFullscreen(){\n    \n          }\n        }\n      }\n    </script>\n    \n\n💡 特色\n-----\n\n1.轻量级 `HTML5` 播放器，精美 `UI` 控件，简单易上手 `Gzip` 压缩不足 `10k` 2.提供以 `npm` 的形式安装提供全局组件 3.多格式视频配置，移动端+PC 通用模式\n\n*   多类型视频支持\n*   自定义海报\n*   多平台兼容\n*   静音开关\n*   播放时间进度\n*   全屏支持\n*   拖动播放\n*   倍速播放\n*   MSE 支持\n*   弹幕支持\n\n✈️ 参数\n-----\n\n名称\n\n默认值\n\n描述\n\nmutex\n\nfalse\n\n互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器\n\nvideo\n\n-\n\n视频相关参数\n\nvideo.url\n\n-\n\n视频播放源，支持 Array 形式传入多种视频格式\n\nvideo.cover\n\n-\n\n视频海报\n\nvideo.muted\n\nfalse\n\n是否静音播放\n\nvideo.loop\n\nfalse\n\n视频是否循环播放\n\nvideo.preload\n\n‘auto’\n\n视频预加载，可选值: ‘none’, ‘metadata’, ‘auto’\n\nvideo.poster\n\n-\n\n原生视频默认海报暂不设置，只设置 video.cover\n\nvideo.volume\n\n1\n\n默认音量\n\nvideo.autoplay\n\nfalse\n\n视频自动播放\n\n🚀 事件\n-----\n\n名称\n\n描述\n\nfullscreen\n\n全屏事件\n\nready\n\n视频播放器准备好\n\nclearMode\n\n清洁模式执行\n\nvideoPlay\n\n播放器执行 play 或者 pause\n\ncreated\n\n组件生命周期\n\nmounted\n\n组件生命周期\n\nbeforeDestroy\n\n组件生命周期\n\ndestroyed\n\n组件生命周期\n\nGitHub：[https://github.com/webweifeng/vue-mini-player ](https://github.com/webweifeng/vue-mini-player)","slug":"vue-mini-player-e5-9f-ba-e4-ba-8evue-e7-9a-84-e4-b8-80-e4-b8-aa-e8-bd-bb-e9-87-8f-e7-ba-a7html5-e8-a7-86-e9-a2-91-e6-92-ad-e6-94-be-e5-99-a8","published":1,"updated":"2019-09-10T07:46:08.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269f10040c8gs9ct9ee1m","content":"<h1 id=\"vue-mini-player\"><a href=\"#vue-mini-player\" class=\"headerlink\" title=\"vue-mini-player\"></a>vue-mini-player</h1><blockquote>\n<p>基于 Vue 的一个轻量级视频播放组件，适配 PC 和移动端</p>\n</blockquote>\n<p><img src=\"https://webweifeng.github.io/vue-mini-player/preview.jpg\" alt=\"avatar\"></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><pre><code>$ npm install vue-mini-player -S\n</code></pre>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><pre><code># main.js\nimport vueMiniPlayer from &#39;vue-mini-player&#39;\nimport &#39;vue-mini-player/lib/vue-mini-player.css&#39;\nVue.use(vueMiniPlayer)\n</code></pre>\n<p>在项目中使用 vueMiniPlayer</p>\n<pre><code>&lt;template&gt;\n  &lt;vueMiniPlayer ref=&quot;vueMiniPlayer&quot; :video=&quot;video&quot; :mutex=&quot;true&quot; @fullscreen=&quot;handleFullscreen&quot; /&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  export default &#123;\n    data () &#123;\n      return &#123;\n        video: &#123;\n            url: &#39;https://api.dogecloud.com/player/get.mp4?vcode=5ac682e6f8231991&amp;userId=17&amp;ext=.mp4&#39;,\n            cover: &#39;https://i.loli.net/2019/06/06/5cf8c5d9c57b510947.png&#39;,\n            muted: false,\n            loop: false,\n            preload: &#39;auto&#39;,\n            poster: &#39;&#39;,\n            volume: 1,\n            autoplay: false\n        &#125;\n      &#125;\n    &#125;,\n    computed()&#123;\n      $video()&#123;\n        return this.$refs.vueMiniPlayer.$video;\n      &#125;\n    &#125;,\n    methods:&#123;\n      handleFullscreen()&#123;\n\n      &#125;\n    &#125;\n  &#125;\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"💡-特色\"><a href=\"#💡-特色\" class=\"headerlink\" title=\"💡 特色\"></a>💡 特色</h2><p>1.轻量级 <code>HTML5</code> 播放器，精美 <code>UI</code> 控件，简单易上手 <code>Gzip</code> 压缩不足 <code>10k</code> 2.提供以 <code>npm</code> 的形式安装提供全局组件 3.多格式视频配置，移动端+PC 通用模式</p>\n<ul>\n<li>  多类型视频支持</li>\n<li>  自定义海报</li>\n<li>  多平台兼容</li>\n<li>  静音开关</li>\n<li>  播放时间进度</li>\n<li>  全屏支持</li>\n<li>  拖动播放</li>\n<li>  倍速播放</li>\n<li>  MSE 支持</li>\n<li>  弹幕支持</li>\n</ul>\n<h2 id=\"✈️-参数\"><a href=\"#✈️-参数\" class=\"headerlink\" title=\"✈️ 参数\"></a>✈️ 参数</h2><p>名称</p>\n<p>默认值</p>\n<p>描述</p>\n<p>mutex</p>\n<p>false</p>\n<p>互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器</p>\n<p>video</p>\n<p>-</p>\n<p>视频相关参数</p>\n<p>video.url</p>\n<p>-</p>\n<p>视频播放源，支持 Array 形式传入多种视频格式</p>\n<p>video.cover</p>\n<p>-</p>\n<p>视频海报</p>\n<p>video.muted</p>\n<p>false</p>\n<p>是否静音播放</p>\n<p>video.loop</p>\n<p>false</p>\n<p>视频是否循环播放</p>\n<p>video.preload</p>\n<p>‘auto’</p>\n<p>视频预加载，可选值: ‘none’, ‘metadata’, ‘auto’</p>\n<p>video.poster</p>\n<p>-</p>\n<p>原生视频默认海报暂不设置，只设置 video.cover</p>\n<p>video.volume</p>\n<p>1</p>\n<p>默认音量</p>\n<p>video.autoplay</p>\n<p>false</p>\n<p>视频自动播放</p>\n<h2 id=\"🚀-事件\"><a href=\"#🚀-事件\" class=\"headerlink\" title=\"🚀 事件\"></a>🚀 事件</h2><p>名称</p>\n<p>描述</p>\n<p>fullscreen</p>\n<p>全屏事件</p>\n<p>ready</p>\n<p>视频播放器准备好</p>\n<p>clearMode</p>\n<p>清洁模式执行</p>\n<p>videoPlay</p>\n<p>播放器执行 play 或者 pause</p>\n<p>created</p>\n<p>组件生命周期</p>\n<p>mounted</p>\n<p>组件生命周期</p>\n<p>beforeDestroy</p>\n<p>组件生命周期</p>\n<p>destroyed</p>\n<p>组件生命周期</p>\n<p>GitHub：<a href=\"https://github.com/webweifeng/vue-mini-player\">https://github.com/webweifeng/vue-mini-player </a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h1 id=\"vue-mini-player\"><a href=\"#vue-mini-player\" class=\"headerlink\" title=\"vue-mini-player\"></a>vue-mini-player</h1><blockquote>\n<p>基于 Vue 的一个轻量级视频播放组件，适配 PC 和移动端</p>\n</blockquote>\n<p><img src=\"https://webweifeng.github.io/vue-mini-player/preview.jpg\" alt=\"avatar\"></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><pre><code>$ npm install vue-mini-player -S\n</code></pre>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><pre><code># main.js\nimport vueMiniPlayer from &#39;vue-mini-player&#39;\nimport &#39;vue-mini-player/lib/vue-mini-player.css&#39;\nVue.use(vueMiniPlayer)\n</code></pre>\n<p>在项目中使用 vueMiniPlayer</p>\n<pre><code>&lt;template&gt;\n  &lt;vueMiniPlayer ref=&quot;vueMiniPlayer&quot; :video=&quot;video&quot; :mutex=&quot;true&quot; @fullscreen=&quot;handleFullscreen&quot; /&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  export default &#123;\n    data () &#123;\n      return &#123;\n        video: &#123;\n            url: &#39;https://api.dogecloud.com/player/get.mp4?vcode=5ac682e6f8231991&amp;userId=17&amp;ext=.mp4&#39;,\n            cover: &#39;https://i.loli.net/2019/06/06/5cf8c5d9c57b510947.png&#39;,\n            muted: false,\n            loop: false,\n            preload: &#39;auto&#39;,\n            poster: &#39;&#39;,\n            volume: 1,\n            autoplay: false\n        &#125;\n      &#125;\n    &#125;,\n    computed()&#123;\n      $video()&#123;\n        return this.$refs.vueMiniPlayer.$video;\n      &#125;\n    &#125;,\n    methods:&#123;\n      handleFullscreen()&#123;\n\n      &#125;\n    &#125;\n  &#125;\n&lt;/script&gt;\n</code></pre>\n<h2 id=\"💡-特色\"><a href=\"#💡-特色\" class=\"headerlink\" title=\"💡 特色\"></a>💡 特色</h2><p>1.轻量级 <code>HTML5</code> 播放器，精美 <code>UI</code> 控件，简单易上手 <code>Gzip</code> 压缩不足 <code>10k</code> 2.提供以 <code>npm</code> 的形式安装提供全局组件 3.多格式视频配置，移动端+PC 通用模式</p>\n<ul>\n<li>  多类型视频支持</li>\n<li>  自定义海报</li>\n<li>  多平台兼容</li>\n<li>  静音开关</li>\n<li>  播放时间进度</li>\n<li>  全屏支持</li>\n<li>  拖动播放</li>\n<li>  倍速播放</li>\n<li>  MSE 支持</li>\n<li>  弹幕支持</li>\n</ul>\n<h2 id=\"✈️-参数\"><a href=\"#✈️-参数\" class=\"headerlink\" title=\"✈️ 参数\"></a>✈️ 参数</h2><p>名称</p>\n<p>默认值</p>\n<p>描述</p>\n<p>mutex</p>\n<p>false</p>\n<p>互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器</p>\n<p>video</p>\n<p>-</p>\n<p>视频相关参数</p>\n<p>video.url</p>\n<p>-</p>\n<p>视频播放源，支持 Array 形式传入多种视频格式</p>\n<p>video.cover</p>\n<p>-</p>\n<p>视频海报</p>\n<p>video.muted</p>\n<p>false</p>\n<p>是否静音播放</p>\n<p>video.loop</p>\n<p>false</p>\n<p>视频是否循环播放</p>\n<p>video.preload</p>\n<p>‘auto’</p>\n<p>视频预加载，可选值: ‘none’, ‘metadata’, ‘auto’</p>\n<p>video.poster</p>\n<p>-</p>\n<p>原生视频默认海报暂不设置，只设置 video.cover</p>\n<p>video.volume</p>\n<p>1</p>\n<p>默认音量</p>\n<p>video.autoplay</p>\n<p>false</p>\n<p>视频自动播放</p>\n<h2 id=\"🚀-事件\"><a href=\"#🚀-事件\" class=\"headerlink\" title=\"🚀 事件\"></a>🚀 事件</h2><p>名称</p>\n<p>描述</p>\n<p>fullscreen</p>\n<p>全屏事件</p>\n<p>ready</p>\n<p>视频播放器准备好</p>\n<p>clearMode</p>\n<p>清洁模式执行</p>\n<p>videoPlay</p>\n<p>播放器执行 play 或者 pause</p>\n<p>created</p>\n<p>组件生命周期</p>\n<p>mounted</p>\n<p>组件生命周期</p>\n<p>beforeDestroy</p>\n<p>组件生命周期</p>\n<p>destroyed</p>\n<p>组件生命周期</p>\n<p>GitHub：<a href=\"https://github.com/webweifeng/vue-mini-player\">https://github.com/webweifeng/vue-mini-player </a></p>\n"},{"title":"vue-router源码了解一下","comments":1,"toc":true,"thumbnail":"https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3627583438,2255849752&fm=26&gp=0.jpg","date":"2020-01-14T10:02:34.000Z","updated":"2020-01-14T10:02:34.000Z","_content":"\n突然今天想了想，你自己天天用的 `vue-router` 到底是个啥？这个插件实现的方案是什么？\n\n<!-- more -->\n\n> 以前开发没有前后端分离，前端只做 UI 然后拿去服务器端去做模板渲染，路由这个概念也就是从后台过来的，简单来说就是定位页面 URL 用的，现在分离开发比较流行 单页应用（SPA），大型单页应用最显著特点之一就是采用前端路由系统，通过改变 URL，在不重新请求页面的情况下，更新页面视图。\n\n# 路由模式\n\n目前浏览器中可以实现这种功能的大概有两种方法\n\n- `hash` 利用 `URL` 中的 hash（“#”）\n- `histroy` 利用 `History interface` 在 `HTML5` 中新增的方法\n\n下面我们找到 `vue-router` 源码看看具体他是用的什么方案\n\n源码地址：`https://github.com/vuejs/vue-router/blob/dev/src/index.js`\n\n```js\nexport default class VueRouter {\n  static install: () => void;\n  static version: string;\n\n  app: any;\n  apps: Array<any>;\n  ready: boolean;\n  readyCbs: Array<Function>;\n  options: RouterOptions;\n  mode: string;\n  history: HashHistory | HTML5History | AbstractHistory;\n  matcher: Matcher;\n  fallback: boolean;\n  beforeHooks: Array<?NavigationGuard>;\n  resolveHooks: Array<?NavigationGuard>;\n  afterHooks: Array<?AfterNavigationHook>;\n\n  constructor (options: RouterOptions = {}) {\n    // ... 省略部分\n    let mode = options.mode || 'hash'\n    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false\n    if (this.fallback) {\n      mode = 'hash'\n    }\n    // 如浏览器不支持，'history'模式需回滚为'hash'模式\n    if (!inBrowser) {\n      mode = 'abstract'\n      // 不在浏览器环境下运行需强制为'abstract'模式\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case 'history':\n        this.history = new HTML5History(this, options.base)\n        break\n      case 'hash':\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case 'abstract':\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== 'production') {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }\n```\n\n上面 👆 我 copy 了一部分源码看下，我们知道在使用过程中实例化 `vue-router` 的时候会去传入 `mode`这项，这就设置是否采用哪种方案，源码中很清楚的可以看到默认开启的是`hash`模式，而在非浏览器模式（node）中采用的是`abstract`模式,一般也就是 `ssr` 渲染方案,\n\n# HashHistory\n\n这个方法其实核心就是用到了`URL`中类似 `http://example.com#index`这样的方式去控制页面位置，我们看下具体 `vue-router` 具体源码\n\n```js\npush (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.transitionTo(location, route => {\n    pushHash(route.fullPath)\n    onComplete && onComplete(route)\n  }, onAbort)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path\n}\nreplace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.transitionTo(location, route => {\n    replaceHash(route.fullPath)\n    onComplete && onComplete(route)\n  }, onAbort)\n}\n\nfunction replaceHash (path) {\n  const i = window.location.href.indexOf('#')\n  window.location.replace(\n    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n  )\n}\n\n//注册路由监听事件\n setupListeners () {\n    const router = this.router\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState && expectScroll\n\n    if (supportsScroll) {\n      setupScroll()\n    }\n\n    window.addEventListener(\n      supportsPushState ? 'popstate' : 'hashchange',\n      () => {\n        const current = this.current\n        if (!ensureSlash()) {\n          return\n        }\n        this.transitionTo(getHash(), route => {\n          if (supportsScroll) {\n            handleScroll(this.router, route, current, true)\n          }\n          if (!supportsPushState) {\n            replaceHash(route.fullPath)\n          }\n        })\n      }\n    )\n  }\n```\n\n通过摘录的部分 `HashHistory` 方法可以看到就是通过修改 `href` 去操作的，路由监听是通过`popstate` or `hashchange`'\n\n# HTML5History\n\n`History interface` 是浏览器历史记录栈提供的接口，通过 back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。\n\n从 HTML5 开始，`History interface` 有进一步修炼：pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改：\n\n- stateObject: 当浏览器跳转到新的状态时，将触发 popState 事件，该事件将携带这个 stateObject 参数的副本\n- title: 所添加记录的标题\n- URL: 所添加记录的 URL\n\n上面几句是我抄来的 `history` 概念，看了看我想那么 `vue-router` 中 `history` 八成也是这个原理了，废话不多说看源码\n\n```js\nexport class HTML5History extends History {\n  constructor (router: Router, base: ?string) {\n    super(router, base)\n\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState && expectScroll\n\n    if (supportsScroll) {\n      setupScroll()\n    }\n\n    const initLocation = getLocation(this.base)\n    // 通过popstate页面地址变化\n    window.addEventListener('popstate', e => {\n      const current = this.current\n\n      // Avoiding first `popstate` event dispatched in some browsers but first\n      // history route not updated since async guard at the same time.\n      const location = getLocation(this.base)\n      if (this.current === START && location === initLocation) {\n        return\n      }\n\n      this.transitionTo(location, route => {\n        if (supportsScroll) {\n          handleScroll(router, route, current, true)\n        }\n      })\n    })\n  }\n\n  go (n: number) {\n    window.history.go(n)\n  }\n\n  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this\n    this.transitionTo(location, route => {\n      pushState(cleanPath(this.base + route.fullPath))\n      handleScroll(this.router, route, fromRoute, false)\n      onComplete && onComplete(route)\n    }, onAbort)\n  }\n\n  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this\n    this.transitionTo(location, route => {\n      replaceState(cleanPath(this.base + route.fullPath))\n      handleScroll(this.router, route, fromRoute, false)\n      onComplete && onComplete(route)\n    }, onAbort)\n  }\n```\n\n跟预想的一样没有什么黑科技就是通过 `popstate` `pushState` `replaceState` 这些方法操作的页面地址\n\n# 视图更新\n\n上面提到的俩种方法是用来改版页面地址然后去定位视图，那么如何去定位视图？我们看到了一个`this.transitionTo`方法，不用猜也知道就是用来定位视图的啊，顺藤摸瓜看源码!\n\n```js\nHistory.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {\n  var this$1 = this;\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(\n    route,\n    function() {\n      this$1.updateRoute(route);\n      onComplete && onComplete(route);\n      this$1.ensureURL();\n      // fire ready cbs once\n      if (!this$1.ready) {\n        this$1.ready = true;\n        this$1.readyCbs.forEach(function(cb) {\n          cb(route);\n        });\n      }\n    },\n    function(err) {\n      if (onAbort) {\n        onAbort(err);\n      }\n      if (err && !this$1.ready) {\n        this$1.ready = true;\n        this$1.readyErrorCbs.forEach(function(cb) {\n          cb(err);\n        });\n      }\n    }\n  );\n};\nHistory.prototype.updateRoute = function updateRoute(route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function(hook) {\n    hook && hook(route, prev);\n  });\n};\nHistory.prototype.listen = function listen(cb) {\n  this.cb = cb;\n};\n```\n\n可以看到，当路由变化时，调用了 `History` 中的`this.cb`方法，而 `this.cb` 方法是通过 `History.listen(cb)`进行设置的。回到 `VueRouter` 类定义中，找到了在 `init()`方法中对其进行了设置：\n\n```js\ninit (app: any /* Vue component instance */) {\n  this.apps.push(app)\n  history.listen(route => {\n    this.apps.forEach((app) => {\n      app._route = route\n    })\n  })\n}\n\n```\n\n根据注释，`app` 为 `Vue` 组件实例，但我们知道 `Vue` 作为渐进式的前端框架，本身的组件定义中应该是没有有关路由内置属性`_route`，如果组件中要有这个属性，应该是在插件加载的地方，即 `VueRouter` 的 `install()`方法中混合入 `Vue` 对象的，查看 `install.js` 源码，有如下一段：\n\n```js\nexport function install(Vue) {\n  Vue.mixin({\n    beforeCreate() {\n      if (isDef(this.$options.router)) {\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      }\n      registerInstance(this, this);\n    }\n  });\n}\n```\n\n通过 `Vue.mixin()`方法，全局注册一个混合，影响注册之后所有创建的每个 `Vue` 实例，该混合在 `beforeCreate` 钩子中通过 `Vue.util.defineReactive()`定义了响应式的 `_route` 属性。所谓响应式属性，即当 `_route` 值改变时，会自动调用 `Vue` 实例的 `render()`方法，更新视图。\n\n总结一下，从设置路由改变到视图更新的流程如下：\n`$router.push() -->`\n`HashHistory.push() -->`\n`History.transitionTo() -->`\n`History.updateRoute() -->`\n`{app._route = route} --> vm.render()`\n\n# 两种模式比较\n\n> 在一般的需求场景中，hash 模式与 history 模式是差不多的，但几乎所有的文章都推荐使用 history 模式，理由竟然是：\"#\" 符号太丑...0_0 \"\n\n如果不想要很丑的 hash，我们可以用路由的 history 模式 ——官方文档\n\n当然，严谨的我们肯定不应该用颜值评价技术的好坏。根据 MDN 的介绍，调用 `history.pushState()`相比于直接修改 `hash` 主要有以下优势：\n\n- `pushState` 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改#后面的部分，故只可设置与当前同文档的 URL\n- `pushState` 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈中\n- `pushState` 通过 `stateObject` 可以添加任意类型的数据到记录中；而 hash 只可添加短字符串\n- `pushState` 可额外设置 `title` 属性供后续使用\n","source":"_posts/vue-router源码了解一下.md","raw":"---\ntitle: vue-router源码了解一下\ncomments: true\ntoc: true\ncategories:\n  - 大前端\nthumbnail: 'https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3627583438,2255849752&fm=26&gp=0.jpg'\ndate: 2020-01-14 18:02:34\nupdated: 2020-01-14 18:02:34\ntags:\n---\n\n突然今天想了想，你自己天天用的 `vue-router` 到底是个啥？这个插件实现的方案是什么？\n\n<!-- more -->\n\n> 以前开发没有前后端分离，前端只做 UI 然后拿去服务器端去做模板渲染，路由这个概念也就是从后台过来的，简单来说就是定位页面 URL 用的，现在分离开发比较流行 单页应用（SPA），大型单页应用最显著特点之一就是采用前端路由系统，通过改变 URL，在不重新请求页面的情况下，更新页面视图。\n\n# 路由模式\n\n目前浏览器中可以实现这种功能的大概有两种方法\n\n- `hash` 利用 `URL` 中的 hash（“#”）\n- `histroy` 利用 `History interface` 在 `HTML5` 中新增的方法\n\n下面我们找到 `vue-router` 源码看看具体他是用的什么方案\n\n源码地址：`https://github.com/vuejs/vue-router/blob/dev/src/index.js`\n\n```js\nexport default class VueRouter {\n  static install: () => void;\n  static version: string;\n\n  app: any;\n  apps: Array<any>;\n  ready: boolean;\n  readyCbs: Array<Function>;\n  options: RouterOptions;\n  mode: string;\n  history: HashHistory | HTML5History | AbstractHistory;\n  matcher: Matcher;\n  fallback: boolean;\n  beforeHooks: Array<?NavigationGuard>;\n  resolveHooks: Array<?NavigationGuard>;\n  afterHooks: Array<?AfterNavigationHook>;\n\n  constructor (options: RouterOptions = {}) {\n    // ... 省略部分\n    let mode = options.mode || 'hash'\n    this.fallback = mode === 'history' && !supportsPushState && options.fallback !== false\n    if (this.fallback) {\n      mode = 'hash'\n    }\n    // 如浏览器不支持，'history'模式需回滚为'hash'模式\n    if (!inBrowser) {\n      mode = 'abstract'\n      // 不在浏览器环境下运行需强制为'abstract'模式\n    }\n    this.mode = mode\n\n    switch (mode) {\n      case 'history':\n        this.history = new HTML5History(this, options.base)\n        break\n      case 'hash':\n        this.history = new HashHistory(this, options.base, this.fallback)\n        break\n      case 'abstract':\n        this.history = new AbstractHistory(this, options.base)\n        break\n      default:\n        if (process.env.NODE_ENV !== 'production') {\n          assert(false, `invalid mode: ${mode}`)\n        }\n    }\n  }\n```\n\n上面 👆 我 copy 了一部分源码看下，我们知道在使用过程中实例化 `vue-router` 的时候会去传入 `mode`这项，这就设置是否采用哪种方案，源码中很清楚的可以看到默认开启的是`hash`模式，而在非浏览器模式（node）中采用的是`abstract`模式,一般也就是 `ssr` 渲染方案,\n\n# HashHistory\n\n这个方法其实核心就是用到了`URL`中类似 `http://example.com#index`这样的方式去控制页面位置，我们看下具体 `vue-router` 具体源码\n\n```js\npush (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.transitionTo(location, route => {\n    pushHash(route.fullPath)\n    onComplete && onComplete(route)\n  }, onAbort)\n}\n\nfunction pushHash (path) {\n  window.location.hash = path\n}\nreplace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n  this.transitionTo(location, route => {\n    replaceHash(route.fullPath)\n    onComplete && onComplete(route)\n  }, onAbort)\n}\n\nfunction replaceHash (path) {\n  const i = window.location.href.indexOf('#')\n  window.location.replace(\n    window.location.href.slice(0, i >= 0 ? i : 0) + '#' + path\n  )\n}\n\n//注册路由监听事件\n setupListeners () {\n    const router = this.router\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState && expectScroll\n\n    if (supportsScroll) {\n      setupScroll()\n    }\n\n    window.addEventListener(\n      supportsPushState ? 'popstate' : 'hashchange',\n      () => {\n        const current = this.current\n        if (!ensureSlash()) {\n          return\n        }\n        this.transitionTo(getHash(), route => {\n          if (supportsScroll) {\n            handleScroll(this.router, route, current, true)\n          }\n          if (!supportsPushState) {\n            replaceHash(route.fullPath)\n          }\n        })\n      }\n    )\n  }\n```\n\n通过摘录的部分 `HashHistory` 方法可以看到就是通过修改 `href` 去操作的，路由监听是通过`popstate` or `hashchange`'\n\n# HTML5History\n\n`History interface` 是浏览器历史记录栈提供的接口，通过 back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。\n\n从 HTML5 开始，`History interface` 有进一步修炼：pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改：\n\n- stateObject: 当浏览器跳转到新的状态时，将触发 popState 事件，该事件将携带这个 stateObject 参数的副本\n- title: 所添加记录的标题\n- URL: 所添加记录的 URL\n\n上面几句是我抄来的 `history` 概念，看了看我想那么 `vue-router` 中 `history` 八成也是这个原理了，废话不多说看源码\n\n```js\nexport class HTML5History extends History {\n  constructor (router: Router, base: ?string) {\n    super(router, base)\n\n    const expectScroll = router.options.scrollBehavior\n    const supportsScroll = supportsPushState && expectScroll\n\n    if (supportsScroll) {\n      setupScroll()\n    }\n\n    const initLocation = getLocation(this.base)\n    // 通过popstate页面地址变化\n    window.addEventListener('popstate', e => {\n      const current = this.current\n\n      // Avoiding first `popstate` event dispatched in some browsers but first\n      // history route not updated since async guard at the same time.\n      const location = getLocation(this.base)\n      if (this.current === START && location === initLocation) {\n        return\n      }\n\n      this.transitionTo(location, route => {\n        if (supportsScroll) {\n          handleScroll(router, route, current, true)\n        }\n      })\n    })\n  }\n\n  go (n: number) {\n    window.history.go(n)\n  }\n\n  push (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this\n    this.transitionTo(location, route => {\n      pushState(cleanPath(this.base + route.fullPath))\n      handleScroll(this.router, route, fromRoute, false)\n      onComplete && onComplete(route)\n    }, onAbort)\n  }\n\n  replace (location: RawLocation, onComplete?: Function, onAbort?: Function) {\n    const { current: fromRoute } = this\n    this.transitionTo(location, route => {\n      replaceState(cleanPath(this.base + route.fullPath))\n      handleScroll(this.router, route, fromRoute, false)\n      onComplete && onComplete(route)\n    }, onAbort)\n  }\n```\n\n跟预想的一样没有什么黑科技就是通过 `popstate` `pushState` `replaceState` 这些方法操作的页面地址\n\n# 视图更新\n\n上面提到的俩种方法是用来改版页面地址然后去定位视图，那么如何去定位视图？我们看到了一个`this.transitionTo`方法，不用猜也知道就是用来定位视图的啊，顺藤摸瓜看源码!\n\n```js\nHistory.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {\n  var this$1 = this;\n  var route = this.router.match(location, this.current);\n  this.confirmTransition(\n    route,\n    function() {\n      this$1.updateRoute(route);\n      onComplete && onComplete(route);\n      this$1.ensureURL();\n      // fire ready cbs once\n      if (!this$1.ready) {\n        this$1.ready = true;\n        this$1.readyCbs.forEach(function(cb) {\n          cb(route);\n        });\n      }\n    },\n    function(err) {\n      if (onAbort) {\n        onAbort(err);\n      }\n      if (err && !this$1.ready) {\n        this$1.ready = true;\n        this$1.readyErrorCbs.forEach(function(cb) {\n          cb(err);\n        });\n      }\n    }\n  );\n};\nHistory.prototype.updateRoute = function updateRoute(route) {\n  var prev = this.current;\n  this.current = route;\n  this.cb && this.cb(route);\n  this.router.afterHooks.forEach(function(hook) {\n    hook && hook(route, prev);\n  });\n};\nHistory.prototype.listen = function listen(cb) {\n  this.cb = cb;\n};\n```\n\n可以看到，当路由变化时，调用了 `History` 中的`this.cb`方法，而 `this.cb` 方法是通过 `History.listen(cb)`进行设置的。回到 `VueRouter` 类定义中，找到了在 `init()`方法中对其进行了设置：\n\n```js\ninit (app: any /* Vue component instance */) {\n  this.apps.push(app)\n  history.listen(route => {\n    this.apps.forEach((app) => {\n      app._route = route\n    })\n  })\n}\n\n```\n\n根据注释，`app` 为 `Vue` 组件实例，但我们知道 `Vue` 作为渐进式的前端框架，本身的组件定义中应该是没有有关路由内置属性`_route`，如果组件中要有这个属性，应该是在插件加载的地方，即 `VueRouter` 的 `install()`方法中混合入 `Vue` 对象的，查看 `install.js` 源码，有如下一段：\n\n```js\nexport function install(Vue) {\n  Vue.mixin({\n    beforeCreate() {\n      if (isDef(this.$options.router)) {\n        this._router = this.$options.router;\n        this._router.init(this);\n        Vue.util.defineReactive(this, '_route', this._router.history.current);\n      }\n      registerInstance(this, this);\n    }\n  });\n}\n```\n\n通过 `Vue.mixin()`方法，全局注册一个混合，影响注册之后所有创建的每个 `Vue` 实例，该混合在 `beforeCreate` 钩子中通过 `Vue.util.defineReactive()`定义了响应式的 `_route` 属性。所谓响应式属性，即当 `_route` 值改变时，会自动调用 `Vue` 实例的 `render()`方法，更新视图。\n\n总结一下，从设置路由改变到视图更新的流程如下：\n`$router.push() -->`\n`HashHistory.push() -->`\n`History.transitionTo() -->`\n`History.updateRoute() -->`\n`{app._route = route} --> vm.render()`\n\n# 两种模式比较\n\n> 在一般的需求场景中，hash 模式与 history 模式是差不多的，但几乎所有的文章都推荐使用 history 模式，理由竟然是：\"#\" 符号太丑...0_0 \"\n\n如果不想要很丑的 hash，我们可以用路由的 history 模式 ——官方文档\n\n当然，严谨的我们肯定不应该用颜值评价技术的好坏。根据 MDN 的介绍，调用 `history.pushState()`相比于直接修改 `hash` 主要有以下优势：\n\n- `pushState` 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改#后面的部分，故只可设置与当前同文档的 URL\n- `pushState` 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈中\n- `pushState` 通过 `stateObject` 可以添加任意类型的数据到记录中；而 hash 只可添加短字符串\n- `pushState` 可额外设置 `title` 属性供后续使用\n","slug":"vue-router源码了解一下","published":1,"layout":"post","photos":[],"link":"","_id":"ckmp269f40043c8gsgoly787g","content":"<p>突然今天想了想，你自己天天用的 <code>vue-router</code> 到底是个啥？这个插件实现的方案是什么？</p>\n<span id=\"more\"></span>\n\n<blockquote>\n<p>以前开发没有前后端分离，前端只做 UI 然后拿去服务器端去做模板渲染，路由这个概念也就是从后台过来的，简单来说就是定位页面 URL 用的，现在分离开发比较流行 单页应用（SPA），大型单页应用最显著特点之一就是采用前端路由系统，通过改变 URL，在不重新请求页面的情况下，更新页面视图。</p>\n</blockquote>\n<h1 id=\"路由模式\"><a href=\"#路由模式\" class=\"headerlink\" title=\"路由模式\"></a>路由模式</h1><p>目前浏览器中可以实现这种功能的大概有两种方法</p>\n<ul>\n<li><code>hash</code> 利用 <code>URL</code> 中的 hash（“#”）</li>\n<li><code>histroy</code> 利用 <code>History interface</code> 在 <code>HTML5</code> 中新增的方法</li>\n</ul>\n<p>下面我们找到 <code>vue-router</code> 源码看看具体他是用的什么方案</p>\n<p>源码地址：<code>https://github.com/vuejs/vue-router/blob/dev/src/index.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VueRouter</span> </span>&#123;<br>  <span class=\"hljs-keyword\">static</span> install: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">void</span>;<br>  <span class=\"hljs-keyword\">static</span> version: string;<br><br>  app: any;<br>  apps: <span class=\"hljs-built_in\">Array</span>&lt;any&gt;;<br>  ready: boolean;<br>  readyCbs: <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">Function</span>&gt;;<br>  options: RouterOptions;<br>  mode: string;<br>  history: HashHistory | HTML5History | AbstractHistory;<br>  matcher: Matcher;<br>  fallback: boolean;<br>  beforeHooks: <span class=\"hljs-built_in\">Array</span>&lt;?NavigationGuard&gt;;<br>  resolveHooks: <span class=\"hljs-built_in\">Array</span>&lt;?NavigationGuard&gt;;<br>  afterHooks: <span class=\"hljs-built_in\">Array</span>&lt;?AfterNavigationHook&gt;;<br><br>  <span class=\"hljs-title\">constructor</span> (<span class=\"hljs-params\">options: RouterOptions = &#123;&#125;</span>) &#123;<br>    <span class=\"hljs-comment\">// ... 省略部分</span><br>    <span class=\"hljs-keyword\">let</span> mode = options.mode || <span class=\"hljs-string\">&#x27;hash&#x27;</span><br>    <span class=\"hljs-built_in\">this</span>.fallback = mode === <span class=\"hljs-string\">&#x27;history&#x27;</span> &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.fallback) &#123;<br>      mode = <span class=\"hljs-string\">&#x27;hash&#x27;</span><br>    &#125;<br>    <span class=\"hljs-comment\">// 如浏览器不支持，&#x27;history&#x27;模式需回滚为&#x27;hash&#x27;模式</span><br>    <span class=\"hljs-keyword\">if</span> (!inBrowser) &#123;<br>      mode = <span class=\"hljs-string\">&#x27;abstract&#x27;</span><br>      <span class=\"hljs-comment\">// 不在浏览器环境下运行需强制为&#x27;abstract&#x27;模式</span><br>    &#125;<br>    <span class=\"hljs-built_in\">this</span>.mode = mode<br><br>    <span class=\"hljs-keyword\">switch</span> (mode) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;history&#x27;</span>:<br>        <span class=\"hljs-built_in\">this</span>.history = <span class=\"hljs-keyword\">new</span> HTML5History(<span class=\"hljs-built_in\">this</span>, options.base)<br>        <span class=\"hljs-keyword\">break</span><br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;hash&#x27;</span>:<br>        <span class=\"hljs-built_in\">this</span>.history = <span class=\"hljs-keyword\">new</span> HashHistory(<span class=\"hljs-built_in\">this</span>, options.base, <span class=\"hljs-built_in\">this</span>.fallback)<br>        <span class=\"hljs-keyword\">break</span><br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;abstract&#x27;</span>:<br>        <span class=\"hljs-built_in\">this</span>.history = <span class=\"hljs-keyword\">new</span> AbstractHistory(<span class=\"hljs-built_in\">this</span>, options.base)<br>        <span class=\"hljs-keyword\">break</span><br>      <span class=\"hljs-keyword\">default</span>:<br>        <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&#x27;production&#x27;</span>) &#123;<br>          assert(<span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">`invalid mode: <span class=\"hljs-subst\">$&#123;mode&#125;</span>`</span>)<br>        &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面 👆 我 copy 了一部分源码看下，我们知道在使用过程中实例化 <code>vue-router</code> 的时候会去传入 <code>mode</code>这项，这就设置是否采用哪种方案，源码中很清楚的可以看到默认开启的是<code>hash</code>模式，而在非浏览器模式（node）中采用的是<code>abstract</code>模式,一般也就是 <code>ssr</code> 渲染方案,</p>\n<h1 id=\"HashHistory\"><a href=\"#HashHistory\" class=\"headerlink\" title=\"HashHistory\"></a>HashHistory</h1><p>这个方法其实核心就是用到了<code>URL</code>中类似 <code>http://example.com#index</code>这样的方式去控制页面位置，我们看下具体 <code>vue-router</code> 具体源码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">push (location: RawLocation, onComplete?: <span class=\"hljs-built_in\">Function</span>, onAbort?: <span class=\"hljs-built_in\">Function</span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.transitionTo(location, <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>    pushHash(route.fullPath)<br>    onComplete &amp;&amp; onComplete(route)<br>  &#125;, onAbort)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pushHash</span> (<span class=\"hljs-params\">path</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">window</span>.location.hash = path<br>&#125;<br>replace (location: RawLocation, onComplete?: <span class=\"hljs-built_in\">Function</span>, onAbort?: <span class=\"hljs-built_in\">Function</span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.transitionTo(location, <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>    replaceHash(route.fullPath)<br>    onComplete &amp;&amp; onComplete(route)<br>  &#125;, onAbort)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">replaceHash</span> (<span class=\"hljs-params\">path</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> i = <span class=\"hljs-built_in\">window</span>.location.href.indexOf(<span class=\"hljs-string\">&#x27;#&#x27;</span>)<br>  <span class=\"hljs-built_in\">window</span>.location.replace(<br>    <span class=\"hljs-built_in\">window</span>.location.href.slice(<span class=\"hljs-number\">0</span>, i &gt;= <span class=\"hljs-number\">0</span> ? i : <span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">&#x27;#&#x27;</span> + path<br>  )<br>&#125;<br><br><span class=\"hljs-comment\">//注册路由监听事件</span><br> setupListeners () &#123;<br>    <span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-built_in\">this</span>.router<br>    <span class=\"hljs-keyword\">const</span> expectScroll = router.options.scrollBehavior<br>    <span class=\"hljs-keyword\">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll<br><br>    <span class=\"hljs-keyword\">if</span> (supportsScroll) &#123;<br>      setupScroll()<br>    &#125;<br><br>    <span class=\"hljs-built_in\">window</span>.addEventListener(<br>      supportsPushState ? <span class=\"hljs-string\">&#x27;popstate&#x27;</span> : <span class=\"hljs-string\">&#x27;hashchange&#x27;</span>,<br>      () =&gt; &#123;<br>        <span class=\"hljs-keyword\">const</span> current = <span class=\"hljs-built_in\">this</span>.current<br>        <span class=\"hljs-keyword\">if</span> (!ensureSlash()) &#123;<br>          <span class=\"hljs-keyword\">return</span><br>        &#125;<br>        <span class=\"hljs-built_in\">this</span>.transitionTo(getHash(), <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">if</span> (supportsScroll) &#123;<br>            handleScroll(<span class=\"hljs-built_in\">this</span>.router, route, current, <span class=\"hljs-literal\">true</span>)<br>          &#125;<br>          <span class=\"hljs-keyword\">if</span> (!supportsPushState) &#123;<br>            replaceHash(route.fullPath)<br>          &#125;<br>        &#125;)<br>      &#125;<br>    )<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过摘录的部分 <code>HashHistory</code> 方法可以看到就是通过修改 <code>href</code> 去操作的，路由监听是通过<code>popstate</code> or <code>hashchange</code>‘</p>\n<h1 id=\"HTML5History\"><a href=\"#HTML5History\" class=\"headerlink\" title=\"HTML5History\"></a>HTML5History</h1><p><code>History interface</code> 是浏览器历史记录栈提供的接口，通过 back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。</p>\n<p>从 HTML5 开始，<code>History interface</code> 有进一步修炼：pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改：</p>\n<ul>\n<li>stateObject: 当浏览器跳转到新的状态时，将触发 popState 事件，该事件将携带这个 stateObject 参数的副本</li>\n<li>title: 所添加记录的标题</li>\n<li>URL: 所添加记录的 URL</li>\n</ul>\n<p>上面几句是我抄来的 <code>history</code> 概念，看了看我想那么 <code>vue-router</code> 中 <code>history</code> 八成也是这个原理了，废话不多说看源码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HTML5History</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">History</span> </span>&#123;<br>  <span class=\"hljs-title\">constructor</span> (<span class=\"hljs-params\">router: Router, base: ?string</span>) &#123;<br>    <span class=\"hljs-built_in\">super</span>(router, base)<br><br>    <span class=\"hljs-keyword\">const</span> expectScroll = router.options.scrollBehavior<br>    <span class=\"hljs-keyword\">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll<br><br>    <span class=\"hljs-keyword\">if</span> (supportsScroll) &#123;<br>      setupScroll()<br>    &#125;<br><br>    <span class=\"hljs-keyword\">const</span> initLocation = getLocation(<span class=\"hljs-built_in\">this</span>.base)<br>    <span class=\"hljs-comment\">// 通过popstate页面地址变化</span><br>    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&#x27;popstate&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> current = <span class=\"hljs-built_in\">this</span>.current<br><br>      <span class=\"hljs-comment\">// Avoiding first `popstate` event dispatched in some browsers but first</span><br>      <span class=\"hljs-comment\">// history route not updated since async guard at the same time.</span><br>      <span class=\"hljs-keyword\">const</span> location = getLocation(<span class=\"hljs-built_in\">this</span>.base)<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.current === START &amp;&amp; location === initLocation) &#123;<br>        <span class=\"hljs-keyword\">return</span><br>      &#125;<br><br>      <span class=\"hljs-built_in\">this</span>.transitionTo(location, <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (supportsScroll) &#123;<br>          handleScroll(router, route, current, <span class=\"hljs-literal\">true</span>)<br>        &#125;<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  go (n: number) &#123;<br>    <span class=\"hljs-built_in\">window</span>.history.go(n)<br>  &#125;<br><br>  push (location: RawLocation, onComplete?: <span class=\"hljs-built_in\">Function</span>, onAbort?: <span class=\"hljs-built_in\">Function</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">current</span>: fromRoute &#125; = <span class=\"hljs-built_in\">this</span><br>    <span class=\"hljs-built_in\">this</span>.transitionTo(location, <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>      pushState(cleanPath(<span class=\"hljs-built_in\">this</span>.base + route.fullPath))<br>      handleScroll(<span class=\"hljs-built_in\">this</span>.router, route, fromRoute, <span class=\"hljs-literal\">false</span>)<br>      onComplete &amp;&amp; onComplete(route)<br>    &#125;, onAbort)<br>  &#125;<br><br>  replace (location: RawLocation, onComplete?: <span class=\"hljs-built_in\">Function</span>, onAbort?: <span class=\"hljs-built_in\">Function</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">current</span>: fromRoute &#125; = <span class=\"hljs-built_in\">this</span><br>    <span class=\"hljs-built_in\">this</span>.transitionTo(location, <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>      replaceState(cleanPath(<span class=\"hljs-built_in\">this</span>.base + route.fullPath))<br>      handleScroll(<span class=\"hljs-built_in\">this</span>.router, route, fromRoute, <span class=\"hljs-literal\">false</span>)<br>      onComplete &amp;&amp; onComplete(route)<br>    &#125;, onAbort)<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>跟预想的一样没有什么黑科技就是通过 <code>popstate</code> <code>pushState</code> <code>replaceState</code> 这些方法操作的页面地址</p>\n<h1 id=\"视图更新\"><a href=\"#视图更新\" class=\"headerlink\" title=\"视图更新\"></a>视图更新</h1><p>上面提到的俩种方法是用来改版页面地址然后去定位视图，那么如何去定位视图？我们看到了一个<code>this.transitionTo</code>方法，不用猜也知道就是用来定位视图的啊，顺藤摸瓜看源码!</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">History.prototype.transitionTo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">transitionTo</span>(<span class=\"hljs-params\">location, onComplete, onAbort</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">var</span> this$<span class=\"hljs-number\">1</span> = <span class=\"hljs-built_in\">this</span>;<br>  <span class=\"hljs-keyword\">var</span> route = <span class=\"hljs-built_in\">this</span>.router.match(location, <span class=\"hljs-built_in\">this</span>.current);<br>  <span class=\"hljs-built_in\">this</span>.confirmTransition(<br>    route,<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      this$<span class=\"hljs-number\">1.</span>updateRoute(route);<br>      onComplete &amp;&amp; onComplete(route);<br>      this$<span class=\"hljs-number\">1.</span>ensureURL();<br>      <span class=\"hljs-comment\">// fire ready cbs once</span><br>      <span class=\"hljs-keyword\">if</span> (!this$<span class=\"hljs-number\">1.</span>ready) &#123;<br>        this$<span class=\"hljs-number\">1.</span>ready = <span class=\"hljs-literal\">true</span>;<br>        this$<span class=\"hljs-number\">1.</span>readyCbs.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">cb</span>) </span>&#123;<br>          cb(route);<br>        &#125;);<br>      &#125;<br>    &#125;,<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">if</span> (onAbort) &#123;<br>        onAbort(err);<br>      &#125;<br>      <span class=\"hljs-keyword\">if</span> (err &amp;&amp; !this$<span class=\"hljs-number\">1.</span>ready) &#123;<br>        this$<span class=\"hljs-number\">1.</span>ready = <span class=\"hljs-literal\">true</span>;<br>        this$<span class=\"hljs-number\">1.</span>readyErrorCbs.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">cb</span>) </span>&#123;<br>          cb(err);<br>        &#125;);<br>      &#125;<br>    &#125;<br>  );<br>&#125;;<br>History.prototype.updateRoute = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateRoute</span>(<span class=\"hljs-params\">route</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">var</span> prev = <span class=\"hljs-built_in\">this</span>.current;<br>  <span class=\"hljs-built_in\">this</span>.current = route;<br>  <span class=\"hljs-built_in\">this</span>.cb &amp;&amp; <span class=\"hljs-built_in\">this</span>.cb(route);<br>  <span class=\"hljs-built_in\">this</span>.router.afterHooks.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">hook</span>) </span>&#123;<br>    hook &amp;&amp; hook(route, prev);<br>  &#125;);<br>&#125;;<br>History.prototype.listen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">listen</span>(<span class=\"hljs-params\">cb</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.cb = cb;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，当路由变化时，调用了 <code>History</code> 中的<code>this.cb</code>方法，而 <code>this.cb</code> 方法是通过 <code>History.listen(cb)</code>进行设置的。回到 <code>VueRouter</code> 类定义中，找到了在 <code>init()</code>方法中对其进行了设置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">init (app: any <span class=\"hljs-comment\">/* Vue component instance */</span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.apps.push(app)<br>  history.listen(<span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.apps.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">app</span>) =&gt;</span> &#123;<br>      app._route = route<br>    &#125;)<br>  &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>根据注释，<code>app</code> 为 <code>Vue</code> 组件实例，但我们知道 <code>Vue</code> 作为渐进式的前端框架，本身的组件定义中应该是没有有关路由内置属性<code>_route</code>，如果组件中要有这个属性，应该是在插件加载的地方，即 <code>VueRouter</code> 的 <code>install()</code>方法中混合入 <code>Vue</code> 对象的，查看 <code>install.js</code> 源码，有如下一段：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">install</span>(<span class=\"hljs-params\">Vue</span>) </span>&#123;<br>  Vue.mixin(&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">beforeCreate</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (isDef(<span class=\"hljs-built_in\">this</span>.$options.router)) &#123;<br>        <span class=\"hljs-built_in\">this</span>._router = <span class=\"hljs-built_in\">this</span>.$options.router;<br>        <span class=\"hljs-built_in\">this</span>._router.init(<span class=\"hljs-built_in\">this</span>);<br>        Vue.util.defineReactive(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-string\">&#x27;_route&#x27;</span>, <span class=\"hljs-built_in\">this</span>._router.history.current);<br>      &#125;<br>      registerInstance(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">this</span>);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过 <code>Vue.mixin()</code>方法，全局注册一个混合，影响注册之后所有创建的每个 <code>Vue</code> 实例，该混合在 <code>beforeCreate</code> 钩子中通过 <code>Vue.util.defineReactive()</code>定义了响应式的 <code>_route</code> 属性。所谓响应式属性，即当 <code>_route</code> 值改变时，会自动调用 <code>Vue</code> 实例的 <code>render()</code>方法，更新视图。</p>\n<p>总结一下，从设置路由改变到视图更新的流程如下：<br><code>$router.push() --&gt;</code><br><code>HashHistory.push() --&gt;</code><br><code>History.transitionTo() --&gt;</code><br><code>History.updateRoute() --&gt;</code><br><code>&#123;app._route = route&#125; --&gt; vm.render()</code></p>\n<h1 id=\"两种模式比较\"><a href=\"#两种模式比较\" class=\"headerlink\" title=\"两种模式比较\"></a>两种模式比较</h1><blockquote>\n<p>在一般的需求场景中，hash 模式与 history 模式是差不多的，但几乎所有的文章都推荐使用 history 模式，理由竟然是：”#” 符号太丑…0_0 “</p>\n</blockquote>\n<p>如果不想要很丑的 hash，我们可以用路由的 history 模式 ——官方文档</p>\n<p>当然，严谨的我们肯定不应该用颜值评价技术的好坏。根据 MDN 的介绍，调用 <code>history.pushState()</code>相比于直接修改 <code>hash</code> 主要有以下优势：</p>\n<ul>\n<li><code>pushState</code> 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改#后面的部分，故只可设置与当前同文档的 URL</li>\n<li><code>pushState</code> 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈中</li>\n<li><code>pushState</code> 通过 <code>stateObject</code> 可以添加任意类型的数据到记录中；而 hash 只可添加短字符串</li>\n<li><code>pushState</code> 可额外设置 <code>title</code> 属性供后续使用</li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<p>突然今天想了想，你自己天天用的 <code>vue-router</code> 到底是个啥？这个插件实现的方案是什么？</p>","more":"<blockquote>\n<p>以前开发没有前后端分离，前端只做 UI 然后拿去服务器端去做模板渲染，路由这个概念也就是从后台过来的，简单来说就是定位页面 URL 用的，现在分离开发比较流行 单页应用（SPA），大型单页应用最显著特点之一就是采用前端路由系统，通过改变 URL，在不重新请求页面的情况下，更新页面视图。</p>\n</blockquote>\n<h1 id=\"路由模式\"><a href=\"#路由模式\" class=\"headerlink\" title=\"路由模式\"></a>路由模式</h1><p>目前浏览器中可以实现这种功能的大概有两种方法</p>\n<ul>\n<li><code>hash</code> 利用 <code>URL</code> 中的 hash（“#”）</li>\n<li><code>histroy</code> 利用 <code>History interface</code> 在 <code>HTML5</code> 中新增的方法</li>\n</ul>\n<p>下面我们找到 <code>vue-router</code> 源码看看具体他是用的什么方案</p>\n<p>源码地址：<code>https://github.com/vuejs/vue-router/blob/dev/src/index.js</code></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VueRouter</span> </span>&#123;<br>  <span class=\"hljs-keyword\">static</span> install: <span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-keyword\">void</span>;<br>  <span class=\"hljs-keyword\">static</span> version: string;<br><br>  app: any;<br>  apps: <span class=\"hljs-built_in\">Array</span>&lt;any&gt;;<br>  ready: boolean;<br>  readyCbs: <span class=\"hljs-built_in\">Array</span>&lt;<span class=\"hljs-built_in\">Function</span>&gt;;<br>  options: RouterOptions;<br>  mode: string;<br>  history: HashHistory | HTML5History | AbstractHistory;<br>  matcher: Matcher;<br>  fallback: boolean;<br>  beforeHooks: <span class=\"hljs-built_in\">Array</span>&lt;?NavigationGuard&gt;;<br>  resolveHooks: <span class=\"hljs-built_in\">Array</span>&lt;?NavigationGuard&gt;;<br>  afterHooks: <span class=\"hljs-built_in\">Array</span>&lt;?AfterNavigationHook&gt;;<br><br>  <span class=\"hljs-title\">constructor</span> (<span class=\"hljs-params\">options: RouterOptions = &#123;&#125;</span>) &#123;<br>    <span class=\"hljs-comment\">// ... 省略部分</span><br>    <span class=\"hljs-keyword\">let</span> mode = options.mode || <span class=\"hljs-string\">&#x27;hash&#x27;</span><br>    <span class=\"hljs-built_in\">this</span>.fallback = mode === <span class=\"hljs-string\">&#x27;history&#x27;</span> &amp;&amp; !supportsPushState &amp;&amp; options.fallback !== <span class=\"hljs-literal\">false</span><br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.fallback) &#123;<br>      mode = <span class=\"hljs-string\">&#x27;hash&#x27;</span><br>    &#125;<br>    <span class=\"hljs-comment\">// 如浏览器不支持，&#x27;history&#x27;模式需回滚为&#x27;hash&#x27;模式</span><br>    <span class=\"hljs-keyword\">if</span> (!inBrowser) &#123;<br>      mode = <span class=\"hljs-string\">&#x27;abstract&#x27;</span><br>      <span class=\"hljs-comment\">// 不在浏览器环境下运行需强制为&#x27;abstract&#x27;模式</span><br>    &#125;<br>    <span class=\"hljs-built_in\">this</span>.mode = mode<br><br>    <span class=\"hljs-keyword\">switch</span> (mode) &#123;<br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;history&#x27;</span>:<br>        <span class=\"hljs-built_in\">this</span>.history = <span class=\"hljs-keyword\">new</span> HTML5History(<span class=\"hljs-built_in\">this</span>, options.base)<br>        <span class=\"hljs-keyword\">break</span><br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;hash&#x27;</span>:<br>        <span class=\"hljs-built_in\">this</span>.history = <span class=\"hljs-keyword\">new</span> HashHistory(<span class=\"hljs-built_in\">this</span>, options.base, <span class=\"hljs-built_in\">this</span>.fallback)<br>        <span class=\"hljs-keyword\">break</span><br>      <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;abstract&#x27;</span>:<br>        <span class=\"hljs-built_in\">this</span>.history = <span class=\"hljs-keyword\">new</span> AbstractHistory(<span class=\"hljs-built_in\">this</span>, options.base)<br>        <span class=\"hljs-keyword\">break</span><br>      <span class=\"hljs-keyword\">default</span>:<br>        <span class=\"hljs-keyword\">if</span> (process.env.NODE_ENV !== <span class=\"hljs-string\">&#x27;production&#x27;</span>) &#123;<br>          assert(<span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">`invalid mode: <span class=\"hljs-subst\">$&#123;mode&#125;</span>`</span>)<br>        &#125;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面 👆 我 copy 了一部分源码看下，我们知道在使用过程中实例化 <code>vue-router</code> 的时候会去传入 <code>mode</code>这项，这就设置是否采用哪种方案，源码中很清楚的可以看到默认开启的是<code>hash</code>模式，而在非浏览器模式（node）中采用的是<code>abstract</code>模式,一般也就是 <code>ssr</code> 渲染方案,</p>\n<h1 id=\"HashHistory\"><a href=\"#HashHistory\" class=\"headerlink\" title=\"HashHistory\"></a>HashHistory</h1><p>这个方法其实核心就是用到了<code>URL</code>中类似 <code>http://example.com#index</code>这样的方式去控制页面位置，我们看下具体 <code>vue-router</code> 具体源码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">push (location: RawLocation, onComplete?: <span class=\"hljs-built_in\">Function</span>, onAbort?: <span class=\"hljs-built_in\">Function</span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.transitionTo(location, <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>    pushHash(route.fullPath)<br>    onComplete &amp;&amp; onComplete(route)<br>  &#125;, onAbort)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pushHash</span> (<span class=\"hljs-params\">path</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">window</span>.location.hash = path<br>&#125;<br>replace (location: RawLocation, onComplete?: <span class=\"hljs-built_in\">Function</span>, onAbort?: <span class=\"hljs-built_in\">Function</span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.transitionTo(location, <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>    replaceHash(route.fullPath)<br>    onComplete &amp;&amp; onComplete(route)<br>  &#125;, onAbort)<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">replaceHash</span> (<span class=\"hljs-params\">path</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">const</span> i = <span class=\"hljs-built_in\">window</span>.location.href.indexOf(<span class=\"hljs-string\">&#x27;#&#x27;</span>)<br>  <span class=\"hljs-built_in\">window</span>.location.replace(<br>    <span class=\"hljs-built_in\">window</span>.location.href.slice(<span class=\"hljs-number\">0</span>, i &gt;= <span class=\"hljs-number\">0</span> ? i : <span class=\"hljs-number\">0</span>) + <span class=\"hljs-string\">&#x27;#&#x27;</span> + path<br>  )<br>&#125;<br><br><span class=\"hljs-comment\">//注册路由监听事件</span><br> setupListeners () &#123;<br>    <span class=\"hljs-keyword\">const</span> router = <span class=\"hljs-built_in\">this</span>.router<br>    <span class=\"hljs-keyword\">const</span> expectScroll = router.options.scrollBehavior<br>    <span class=\"hljs-keyword\">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll<br><br>    <span class=\"hljs-keyword\">if</span> (supportsScroll) &#123;<br>      setupScroll()<br>    &#125;<br><br>    <span class=\"hljs-built_in\">window</span>.addEventListener(<br>      supportsPushState ? <span class=\"hljs-string\">&#x27;popstate&#x27;</span> : <span class=\"hljs-string\">&#x27;hashchange&#x27;</span>,<br>      () =&gt; &#123;<br>        <span class=\"hljs-keyword\">const</span> current = <span class=\"hljs-built_in\">this</span>.current<br>        <span class=\"hljs-keyword\">if</span> (!ensureSlash()) &#123;<br>          <span class=\"hljs-keyword\">return</span><br>        &#125;<br>        <span class=\"hljs-built_in\">this</span>.transitionTo(getHash(), <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>          <span class=\"hljs-keyword\">if</span> (supportsScroll) &#123;<br>            handleScroll(<span class=\"hljs-built_in\">this</span>.router, route, current, <span class=\"hljs-literal\">true</span>)<br>          &#125;<br>          <span class=\"hljs-keyword\">if</span> (!supportsPushState) &#123;<br>            replaceHash(route.fullPath)<br>          &#125;<br>        &#125;)<br>      &#125;<br>    )<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过摘录的部分 <code>HashHistory</code> 方法可以看到就是通过修改 <code>href</code> 去操作的，路由监听是通过<code>popstate</code> or <code>hashchange</code>‘</p>\n<h1 id=\"HTML5History\"><a href=\"#HTML5History\" class=\"headerlink\" title=\"HTML5History\"></a>HTML5History</h1><p><code>History interface</code> 是浏览器历史记录栈提供的接口，通过 back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。</p>\n<p>从 HTML5 开始，<code>History interface</code> 有进一步修炼：pushState(), replaceState() 这下不仅是读取了，还可以对浏览器历史记录栈进行修改：</p>\n<ul>\n<li>stateObject: 当浏览器跳转到新的状态时，将触发 popState 事件，该事件将携带这个 stateObject 参数的副本</li>\n<li>title: 所添加记录的标题</li>\n<li>URL: 所添加记录的 URL</li>\n</ul>\n<p>上面几句是我抄来的 <code>history</code> 概念，看了看我想那么 <code>vue-router</code> 中 <code>history</code> 八成也是这个原理了，废话不多说看源码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HTML5History</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">History</span> </span>&#123;<br>  <span class=\"hljs-title\">constructor</span> (<span class=\"hljs-params\">router: Router, base: ?string</span>) &#123;<br>    <span class=\"hljs-built_in\">super</span>(router, base)<br><br>    <span class=\"hljs-keyword\">const</span> expectScroll = router.options.scrollBehavior<br>    <span class=\"hljs-keyword\">const</span> supportsScroll = supportsPushState &amp;&amp; expectScroll<br><br>    <span class=\"hljs-keyword\">if</span> (supportsScroll) &#123;<br>      setupScroll()<br>    &#125;<br><br>    <span class=\"hljs-keyword\">const</span> initLocation = getLocation(<span class=\"hljs-built_in\">this</span>.base)<br>    <span class=\"hljs-comment\">// 通过popstate页面地址变化</span><br>    <span class=\"hljs-built_in\">window</span>.addEventListener(<span class=\"hljs-string\">&#x27;popstate&#x27;</span>, <span class=\"hljs-function\"><span class=\"hljs-params\">e</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> current = <span class=\"hljs-built_in\">this</span>.current<br><br>      <span class=\"hljs-comment\">// Avoiding first `popstate` event dispatched in some browsers but first</span><br>      <span class=\"hljs-comment\">// history route not updated since async guard at the same time.</span><br>      <span class=\"hljs-keyword\">const</span> location = getLocation(<span class=\"hljs-built_in\">this</span>.base)<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.current === START &amp;&amp; location === initLocation) &#123;<br>        <span class=\"hljs-keyword\">return</span><br>      &#125;<br><br>      <span class=\"hljs-built_in\">this</span>.transitionTo(location, <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (supportsScroll) &#123;<br>          handleScroll(router, route, current, <span class=\"hljs-literal\">true</span>)<br>        &#125;<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  go (n: number) &#123;<br>    <span class=\"hljs-built_in\">window</span>.history.go(n)<br>  &#125;<br><br>  push (location: RawLocation, onComplete?: <span class=\"hljs-built_in\">Function</span>, onAbort?: <span class=\"hljs-built_in\">Function</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">current</span>: fromRoute &#125; = <span class=\"hljs-built_in\">this</span><br>    <span class=\"hljs-built_in\">this</span>.transitionTo(location, <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>      pushState(cleanPath(<span class=\"hljs-built_in\">this</span>.base + route.fullPath))<br>      handleScroll(<span class=\"hljs-built_in\">this</span>.router, route, fromRoute, <span class=\"hljs-literal\">false</span>)<br>      onComplete &amp;&amp; onComplete(route)<br>    &#125;, onAbort)<br>  &#125;<br><br>  replace (location: RawLocation, onComplete?: <span class=\"hljs-built_in\">Function</span>, onAbort?: <span class=\"hljs-built_in\">Function</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">current</span>: fromRoute &#125; = <span class=\"hljs-built_in\">this</span><br>    <span class=\"hljs-built_in\">this</span>.transitionTo(location, <span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>      replaceState(cleanPath(<span class=\"hljs-built_in\">this</span>.base + route.fullPath))<br>      handleScroll(<span class=\"hljs-built_in\">this</span>.router, route, fromRoute, <span class=\"hljs-literal\">false</span>)<br>      onComplete &amp;&amp; onComplete(route)<br>    &#125;, onAbort)<br>  &#125;<br></code></pre></td></tr></table></figure>\n\n<p>跟预想的一样没有什么黑科技就是通过 <code>popstate</code> <code>pushState</code> <code>replaceState</code> 这些方法操作的页面地址</p>\n<h1 id=\"视图更新\"><a href=\"#视图更新\" class=\"headerlink\" title=\"视图更新\"></a>视图更新</h1><p>上面提到的俩种方法是用来改版页面地址然后去定位视图，那么如何去定位视图？我们看到了一个<code>this.transitionTo</code>方法，不用猜也知道就是用来定位视图的啊，顺藤摸瓜看源码!</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">History.prototype.transitionTo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">transitionTo</span>(<span class=\"hljs-params\">location, onComplete, onAbort</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">var</span> this$<span class=\"hljs-number\">1</span> = <span class=\"hljs-built_in\">this</span>;<br>  <span class=\"hljs-keyword\">var</span> route = <span class=\"hljs-built_in\">this</span>.router.match(location, <span class=\"hljs-built_in\">this</span>.current);<br>  <span class=\"hljs-built_in\">this</span>.confirmTransition(<br>    route,<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      this$<span class=\"hljs-number\">1.</span>updateRoute(route);<br>      onComplete &amp;&amp; onComplete(route);<br>      this$<span class=\"hljs-number\">1.</span>ensureURL();<br>      <span class=\"hljs-comment\">// fire ready cbs once</span><br>      <span class=\"hljs-keyword\">if</span> (!this$<span class=\"hljs-number\">1.</span>ready) &#123;<br>        this$<span class=\"hljs-number\">1.</span>ready = <span class=\"hljs-literal\">true</span>;<br>        this$<span class=\"hljs-number\">1.</span>readyCbs.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">cb</span>) </span>&#123;<br>          cb(route);<br>        &#125;);<br>      &#125;<br>    &#125;,<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">err</span>) </span>&#123;<br>      <span class=\"hljs-keyword\">if</span> (onAbort) &#123;<br>        onAbort(err);<br>      &#125;<br>      <span class=\"hljs-keyword\">if</span> (err &amp;&amp; !this$<span class=\"hljs-number\">1.</span>ready) &#123;<br>        this$<span class=\"hljs-number\">1.</span>ready = <span class=\"hljs-literal\">true</span>;<br>        this$<span class=\"hljs-number\">1.</span>readyErrorCbs.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">cb</span>) </span>&#123;<br>          cb(err);<br>        &#125;);<br>      &#125;<br>    &#125;<br>  );<br>&#125;;<br>History.prototype.updateRoute = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">updateRoute</span>(<span class=\"hljs-params\">route</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">var</span> prev = <span class=\"hljs-built_in\">this</span>.current;<br>  <span class=\"hljs-built_in\">this</span>.current = route;<br>  <span class=\"hljs-built_in\">this</span>.cb &amp;&amp; <span class=\"hljs-built_in\">this</span>.cb(route);<br>  <span class=\"hljs-built_in\">this</span>.router.afterHooks.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">hook</span>) </span>&#123;<br>    hook &amp;&amp; hook(route, prev);<br>  &#125;);<br>&#125;;<br>History.prototype.listen = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">listen</span>(<span class=\"hljs-params\">cb</span>) </span>&#123;<br>  <span class=\"hljs-built_in\">this</span>.cb = cb;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>可以看到，当路由变化时，调用了 <code>History</code> 中的<code>this.cb</code>方法，而 <code>this.cb</code> 方法是通过 <code>History.listen(cb)</code>进行设置的。回到 <code>VueRouter</code> 类定义中，找到了在 <code>init()</code>方法中对其进行了设置：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">init (app: any <span class=\"hljs-comment\">/* Vue component instance */</span>) &#123;<br>  <span class=\"hljs-built_in\">this</span>.apps.push(app)<br>  history.listen(<span class=\"hljs-function\"><span class=\"hljs-params\">route</span> =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.apps.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">app</span>) =&gt;</span> &#123;<br>      app._route = route<br>    &#125;)<br>  &#125;)<br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<p>根据注释，<code>app</code> 为 <code>Vue</code> 组件实例，但我们知道 <code>Vue</code> 作为渐进式的前端框架，本身的组件定义中应该是没有有关路由内置属性<code>_route</code>，如果组件中要有这个属性，应该是在插件加载的地方，即 <code>VueRouter</code> 的 <code>install()</code>方法中混合入 <code>Vue</code> 对象的，查看 <code>install.js</code> 源码，有如下一段：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">install</span>(<span class=\"hljs-params\">Vue</span>) </span>&#123;<br>  Vue.mixin(&#123;<br>    <span class=\"hljs-function\"><span class=\"hljs-title\">beforeCreate</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (isDef(<span class=\"hljs-built_in\">this</span>.$options.router)) &#123;<br>        <span class=\"hljs-built_in\">this</span>._router = <span class=\"hljs-built_in\">this</span>.$options.router;<br>        <span class=\"hljs-built_in\">this</span>._router.init(<span class=\"hljs-built_in\">this</span>);<br>        Vue.util.defineReactive(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-string\">&#x27;_route&#x27;</span>, <span class=\"hljs-built_in\">this</span>._router.history.current);<br>      &#125;<br>      registerInstance(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">this</span>);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>通过 <code>Vue.mixin()</code>方法，全局注册一个混合，影响注册之后所有创建的每个 <code>Vue</code> 实例，该混合在 <code>beforeCreate</code> 钩子中通过 <code>Vue.util.defineReactive()</code>定义了响应式的 <code>_route</code> 属性。所谓响应式属性，即当 <code>_route</code> 值改变时，会自动调用 <code>Vue</code> 实例的 <code>render()</code>方法，更新视图。</p>\n<p>总结一下，从设置路由改变到视图更新的流程如下：<br><code>$router.push() --&gt;</code><br><code>HashHistory.push() --&gt;</code><br><code>History.transitionTo() --&gt;</code><br><code>History.updateRoute() --&gt;</code><br><code>&#123;app._route = route&#125; --&gt; vm.render()</code></p>\n<h1 id=\"两种模式比较\"><a href=\"#两种模式比较\" class=\"headerlink\" title=\"两种模式比较\"></a>两种模式比较</h1><blockquote>\n<p>在一般的需求场景中，hash 模式与 history 模式是差不多的，但几乎所有的文章都推荐使用 history 模式，理由竟然是：”#” 符号太丑…0_0 “</p>\n</blockquote>\n<p>如果不想要很丑的 hash，我们可以用路由的 history 模式 ——官方文档</p>\n<p>当然，严谨的我们肯定不应该用颜值评价技术的好坏。根据 MDN 的介绍，调用 <code>history.pushState()</code>相比于直接修改 <code>hash</code> 主要有以下优势：</p>\n<ul>\n<li><code>pushState</code> 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改#后面的部分，故只可设置与当前同文档的 URL</li>\n<li><code>pushState</code> 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈中</li>\n<li><code>pushState</code> 通过 <code>stateObject</code> 可以添加任意类型的数据到记录中；而 hash 只可添加短字符串</li>\n<li><code>pushState</code> 可额外设置 <code>title</code> 属性供后续使用</li>\n</ul>"},{"title":"你能简单谈谈什么是 vue 的响应式更新？","thumbnail":"http://img.v5ant.com/images/2019/12/13/timg.md.jpg","comments":1,"toc":true,"layout":"true","date":"2019-11-22T06:42:57.000Z","updated":"2019-11-22T06:42:57.000Z","_content":"\n现在面试官随随便便都会问一句：请简单说一下 `vue` 的响应式原理是如何实现的？\n答：使用 ES5 的`Object.defineProperty`！地球人都知道\n再问：那你能简单的讲一下具体的实现流程吗？\n答：。。。。。（好像知道但是好像又张嘴说不上来 😆 尴哩个尬）\n\n<!-- more -->\n\n看十遍不如上手做一遍，赶紧动手跟我撸一遍试试，免得再面试又被打脸。\n\n## 第一步先熟悉 `Object.defineProperty`\n\n`Object.defineProperty`方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，先来看一下它的语法：\n\n```js\nObject.defineProperty(obj, prop, descriptor);\n```\n\n`obj` 是要在其上定义属性的对象；`prop` 是要定义的属性或者修改的名称；`descriptor` 是将被定义或者修改的属性描述符\n\n比较核心的是 `descriptor`，它有很多可选键值。这里我们最关心的是 `get` 和 `set`，`get` 是一个给属性提供的 `getter` 方法，当我们访问了该属性的时候会触发 `getter` 方法；`set` 是一个给属性提供的 `setter` 方法，当我们对该属性做修改的时候会触发 `setter` 方法。详细参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)\n\n## 第二步了解响应式流程\n\n很重要的一个概念是`发布订阅模式`发布订阅模式是设计模式中比较常见的一种，其中有两个角色：发布者和订阅者。多个订阅者可以向同一发布者订阅一个事件，当事件发生的时候，发布者通知所有订阅该事件的订阅者。\n写个小例子了解一下\n\n```js\n// 一般命名为dep作为订阅者的依赖也就是我们所说的发布者\nclass Dep {\n  constructor() {\n    this.subs = [];\n  }\n  // 增加订阅者\n  addSubs(sub) {\n    Array.from(arguments).forEach(v => {\n      if (!this.subs.includes(v)) {\n        this.subs.push(v);\n      }\n    });\n  }\n  // 通知订阅者\n  notify() {\n    this.subs.forEach(v => v.update());\n  }\n}\nconst dep = new Dep();\nconst sub1 = {\n  update() {\n    console.log('sub1接收到通知');\n  }\n};\nconst sub2 = {\n  update() {\n    console.log('sub2接收到通知');\n  }\n};\ndep.addSubs(sub1, sub2);\ndep.notify();\n// 通过notify发送通知订阅者\n```\n\n小总结:\n\n1.`vue.js` 首先通过 `Object.defineProperty`来对要监听的数据进行 `getter` 和 `setter` 劫持，当数据的属性被赋值/取值的时候，`vue.js` 就可以察觉到并做相应的处理。\n\n2.通过订阅发布模式，我们可以为对象的每个属性都创建一个发布者，当有其他订阅者依赖于这个属性的时候，则将订阅者加入到发布者的队列中。利用 `Object.defineProperty` 的数据劫持，在属性的 `setter` 调用的时候，该属性的发布者通知所有订阅者更新内容。\n\n## 第三步动手实践\n\n```js\n// 简单的一个监听函数用来给对象添加setter 和 getter，用于收集依赖和派发订阅消息,基本上流程参考vue源码\nclass Observer {\n  constructor(data) {\n    this.data = data;\n    this.walk();\n  }\n  // walk是用来遍历对象设置setter和getter,\n  walk() {\n    const keys = Object.keys(this.data);\n    keys.forEach(key => {\n      defineReactive(this.data, keys, this.data[key]);\n    });\n  }\n  // 创建实例化当前属性的一个发布者，劫持属性，收集和派发\n  defineReactive(obj, key, value) {\n    // 实例化一个新的发布者\n    const dep = new Dep();\n    // 这里主要是针对多层级的对象需要进行递归劫持所有属性\n    new Observer(value);\n    Objec.defineProperty({ obj, key,\n      {\n        get(){\n          // 若当前有对该属性的依赖项，则发布者收集依赖\n          if (Dep.target) {\n            dep.addSub(Dep.target);\n          }\n          return value;\n        },\n        set(newValue){\n          // 值没有变化return不做任何操作\n           if (value === newValue) return;\n          // 当对属性进行设置时候就可以去派发订阅消息，通知到所有的订阅者\n          value = newValue;\n          // 对新设置的值进行递归劫持\n          new Observer(newVal);\n          dep.notify()\n        }\n      }\n    });\n  }\n}\n// 发布者,将依赖该属性的watcher都加入subs数组，当该属性改变的时候，则调用所有依赖该属性的watcher的更新函数，触发更新\nclass Dep {\n  constructor() {\n    this.subs = [];\n  }\n  // 增加订阅者\n  addSubs(sub) {\n    Array.from(arguments).forEach(v => {\n      if (!this.subs.includes(v)) {\n        this.subs.push(v);\n      }\n    });\n  }\n  // 通知订阅者\n  notify() {\n    this.subs.forEach(v => v.update());\n  }\n}\nDep.target = null;\n\n// 观察者\nclass Watcher {\n  constructor(data, key, cb) {\n    this.data = data;\n    this.key = key;\n    this.cb = cb;\n    this.value = null;\n    this.get();\n  }\n  get(){\n    // 绑定依赖对象，确认订阅\n    Dep.target = this;\n    this.value= this.data[key];\n    return this.data;\n  }\n  update(){\n    const oldValue = this.value;\n    const newValue = this.get();\n    if (oldValue !== newValue) {\n      this.cb(oldValue, newValue);\n    }\n  }\n}\nlet data = {\n  a:0,\n  b:1\n}\n// 初始化Observer劫持绑定所有set/get\nnew Observer(data);\n// 监听属性 a 的值如果发现变化执行回调函数\nnew Watcher(data, 'a', (oldValue, newValue) => {\n  console.log('这个是watch',oldValue, newValue);\n})\n\n\n```\n\n简单的响应式更新就是这样的了，当然 vue 源码比这复杂的多还要处理其他数据类型，有兴趣可以再看看源码。\n","source":"_posts/vue响应式更新个人实现.md","raw":"---\ntitle: 你能简单谈谈什么是 vue 的响应式更新？\ncategories:\n  - 大前端\nthumbnail: 'http://img.v5ant.com/images/2019/12/13/timg.md.jpg'\ncomments: true\ntoc: true\nlayout: true\ndate: 2019-11-22 14:42:57\nupdated: 2019-11-22 14:42:57\ntags:\n---\n\n现在面试官随随便便都会问一句：请简单说一下 `vue` 的响应式原理是如何实现的？\n答：使用 ES5 的`Object.defineProperty`！地球人都知道\n再问：那你能简单的讲一下具体的实现流程吗？\n答：。。。。。（好像知道但是好像又张嘴说不上来 😆 尴哩个尬）\n\n<!-- more -->\n\n看十遍不如上手做一遍，赶紧动手跟我撸一遍试试，免得再面试又被打脸。\n\n## 第一步先熟悉 `Object.defineProperty`\n\n`Object.defineProperty`方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，先来看一下它的语法：\n\n```js\nObject.defineProperty(obj, prop, descriptor);\n```\n\n`obj` 是要在其上定义属性的对象；`prop` 是要定义的属性或者修改的名称；`descriptor` 是将被定义或者修改的属性描述符\n\n比较核心的是 `descriptor`，它有很多可选键值。这里我们最关心的是 `get` 和 `set`，`get` 是一个给属性提供的 `getter` 方法，当我们访问了该属性的时候会触发 `getter` 方法；`set` 是一个给属性提供的 `setter` 方法，当我们对该属性做修改的时候会触发 `setter` 方法。详细参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)\n\n## 第二步了解响应式流程\n\n很重要的一个概念是`发布订阅模式`发布订阅模式是设计模式中比较常见的一种，其中有两个角色：发布者和订阅者。多个订阅者可以向同一发布者订阅一个事件，当事件发生的时候，发布者通知所有订阅该事件的订阅者。\n写个小例子了解一下\n\n```js\n// 一般命名为dep作为订阅者的依赖也就是我们所说的发布者\nclass Dep {\n  constructor() {\n    this.subs = [];\n  }\n  // 增加订阅者\n  addSubs(sub) {\n    Array.from(arguments).forEach(v => {\n      if (!this.subs.includes(v)) {\n        this.subs.push(v);\n      }\n    });\n  }\n  // 通知订阅者\n  notify() {\n    this.subs.forEach(v => v.update());\n  }\n}\nconst dep = new Dep();\nconst sub1 = {\n  update() {\n    console.log('sub1接收到通知');\n  }\n};\nconst sub2 = {\n  update() {\n    console.log('sub2接收到通知');\n  }\n};\ndep.addSubs(sub1, sub2);\ndep.notify();\n// 通过notify发送通知订阅者\n```\n\n小总结:\n\n1.`vue.js` 首先通过 `Object.defineProperty`来对要监听的数据进行 `getter` 和 `setter` 劫持，当数据的属性被赋值/取值的时候，`vue.js` 就可以察觉到并做相应的处理。\n\n2.通过订阅发布模式，我们可以为对象的每个属性都创建一个发布者，当有其他订阅者依赖于这个属性的时候，则将订阅者加入到发布者的队列中。利用 `Object.defineProperty` 的数据劫持，在属性的 `setter` 调用的时候，该属性的发布者通知所有订阅者更新内容。\n\n## 第三步动手实践\n\n```js\n// 简单的一个监听函数用来给对象添加setter 和 getter，用于收集依赖和派发订阅消息,基本上流程参考vue源码\nclass Observer {\n  constructor(data) {\n    this.data = data;\n    this.walk();\n  }\n  // walk是用来遍历对象设置setter和getter,\n  walk() {\n    const keys = Object.keys(this.data);\n    keys.forEach(key => {\n      defineReactive(this.data, keys, this.data[key]);\n    });\n  }\n  // 创建实例化当前属性的一个发布者，劫持属性，收集和派发\n  defineReactive(obj, key, value) {\n    // 实例化一个新的发布者\n    const dep = new Dep();\n    // 这里主要是针对多层级的对象需要进行递归劫持所有属性\n    new Observer(value);\n    Objec.defineProperty({ obj, key,\n      {\n        get(){\n          // 若当前有对该属性的依赖项，则发布者收集依赖\n          if (Dep.target) {\n            dep.addSub(Dep.target);\n          }\n          return value;\n        },\n        set(newValue){\n          // 值没有变化return不做任何操作\n           if (value === newValue) return;\n          // 当对属性进行设置时候就可以去派发订阅消息，通知到所有的订阅者\n          value = newValue;\n          // 对新设置的值进行递归劫持\n          new Observer(newVal);\n          dep.notify()\n        }\n      }\n    });\n  }\n}\n// 发布者,将依赖该属性的watcher都加入subs数组，当该属性改变的时候，则调用所有依赖该属性的watcher的更新函数，触发更新\nclass Dep {\n  constructor() {\n    this.subs = [];\n  }\n  // 增加订阅者\n  addSubs(sub) {\n    Array.from(arguments).forEach(v => {\n      if (!this.subs.includes(v)) {\n        this.subs.push(v);\n      }\n    });\n  }\n  // 通知订阅者\n  notify() {\n    this.subs.forEach(v => v.update());\n  }\n}\nDep.target = null;\n\n// 观察者\nclass Watcher {\n  constructor(data, key, cb) {\n    this.data = data;\n    this.key = key;\n    this.cb = cb;\n    this.value = null;\n    this.get();\n  }\n  get(){\n    // 绑定依赖对象，确认订阅\n    Dep.target = this;\n    this.value= this.data[key];\n    return this.data;\n  }\n  update(){\n    const oldValue = this.value;\n    const newValue = this.get();\n    if (oldValue !== newValue) {\n      this.cb(oldValue, newValue);\n    }\n  }\n}\nlet data = {\n  a:0,\n  b:1\n}\n// 初始化Observer劫持绑定所有set/get\nnew Observer(data);\n// 监听属性 a 的值如果发现变化执行回调函数\nnew Watcher(data, 'a', (oldValue, newValue) => {\n  console.log('这个是watch',oldValue, newValue);\n})\n\n\n```\n\n简单的响应式更新就是这样的了，当然 vue 源码比这复杂的多还要处理其他数据类型，有兴趣可以再看看源码。\n","slug":"vue响应式更新个人实现","published":1,"photos":[],"link":"","_id":"ckmp269f50046c8gsatrk6es9","content":"<p>现在面试官随随便便都会问一句：请简单说一下 <code>vue</code> 的响应式原理是如何实现的？<br>答：使用 ES5 的<code>Object.defineProperty</code>！地球人都知道<br>再问：那你能简单的讲一下具体的实现流程吗？<br>答：。。。。。（好像知道但是好像又张嘴说不上来 😆 尴哩个尬）</p>\n<span id=\"more\"></span>\n\n<p>看十遍不如上手做一遍，赶紧动手跟我撸一遍试试，免得再面试又被打脸。</p>\n<h2 id=\"第一步先熟悉-Object-defineProperty\"><a href=\"#第一步先熟悉-Object-defineProperty\" class=\"headerlink\" title=\"第一步先熟悉 Object.defineProperty\"></a>第一步先熟悉 <code>Object.defineProperty</code></h2><p><code>Object.defineProperty</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，先来看一下它的语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, prop, descriptor);<br></code></pre></td></tr></table></figure>\n\n<p><code>obj</code> 是要在其上定义属性的对象；<code>prop</code> 是要定义的属性或者修改的名称；<code>descriptor</code> 是将被定义或者修改的属性描述符</p>\n<p>比较核心的是 <code>descriptor</code>，它有很多可选键值。这里我们最关心的是 <code>get</code> 和 <code>set</code>，<code>get</code> 是一个给属性提供的 <code>getter</code> 方法，当我们访问了该属性的时候会触发 <code>getter</code> 方法；<code>set</code> 是一个给属性提供的 <code>setter</code> 方法，当我们对该属性做修改的时候会触发 <code>setter</code> 方法。详细参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">MDN</a></p>\n<h2 id=\"第二步了解响应式流程\"><a href=\"#第二步了解响应式流程\" class=\"headerlink\" title=\"第二步了解响应式流程\"></a>第二步了解响应式流程</h2><p>很重要的一个概念是<code>发布订阅模式</code>发布订阅模式是设计模式中比较常见的一种，其中有两个角色：发布者和订阅者。多个订阅者可以向同一发布者订阅一个事件，当事件发生的时候，发布者通知所有订阅该事件的订阅者。<br>写个小例子了解一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 一般命名为dep作为订阅者的依赖也就是我们所说的发布者</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dep</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.subs = [];<br>  &#125;<br>  <span class=\"hljs-comment\">// 增加订阅者</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">addSubs</span>(<span class=\"hljs-params\">sub</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-built_in\">arguments</span>).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.subs.includes(v)) &#123;<br>        <span class=\"hljs-built_in\">this</span>.subs.push(v);<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <span class=\"hljs-comment\">// 通知订阅者</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">notify</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.subs.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> v.update());<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> dep = <span class=\"hljs-keyword\">new</span> Dep();<br><span class=\"hljs-keyword\">const</span> sub1 = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">update</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;sub1接收到通知&#x27;</span>);<br>  &#125;<br>&#125;;<br><span class=\"hljs-keyword\">const</span> sub2 = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">update</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;sub2接收到通知&#x27;</span>);<br>  &#125;<br>&#125;;<br>dep.addSubs(sub1, sub2);<br>dep.notify();<br><span class=\"hljs-comment\">// 通过notify发送通知订阅者</span><br></code></pre></td></tr></table></figure>\n\n<p>小总结:</p>\n<p>1.<code>vue.js</code> 首先通过 <code>Object.defineProperty</code>来对要监听的数据进行 <code>getter</code> 和 <code>setter</code> 劫持，当数据的属性被赋值/取值的时候，<code>vue.js</code> 就可以察觉到并做相应的处理。</p>\n<p>2.通过订阅发布模式，我们可以为对象的每个属性都创建一个发布者，当有其他订阅者依赖于这个属性的时候，则将订阅者加入到发布者的队列中。利用 <code>Object.defineProperty</code> 的数据劫持，在属性的 <code>setter</code> 调用的时候，该属性的发布者通知所有订阅者更新内容。</p>\n<h2 id=\"第三步动手实践\"><a href=\"#第三步动手实践\" class=\"headerlink\" title=\"第三步动手实践\"></a>第三步动手实践</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 简单的一个监听函数用来给对象添加setter 和 getter，用于收集依赖和派发订阅消息,基本上流程参考vue源码</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Observer</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">data</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.data = data;<br>    <span class=\"hljs-built_in\">this</span>.walk();<br>  &#125;<br>  <span class=\"hljs-comment\">// walk是用来遍历对象设置setter和getter,</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">walk</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> keys = <span class=\"hljs-built_in\">Object</span>.keys(<span class=\"hljs-built_in\">this</span>.data);<br>    keys.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> &#123;<br>      defineReactive(<span class=\"hljs-built_in\">this</span>.data, keys, <span class=\"hljs-built_in\">this</span>.data[key]);<br>    &#125;);<br>  &#125;<br>  <span class=\"hljs-comment\">// 创建实例化当前属性的一个发布者，劫持属性，收集和派发</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">defineReactive</span>(<span class=\"hljs-params\">obj, key, value</span>)</span> &#123;<br>    <span class=\"hljs-comment\">// 实例化一个新的发布者</span><br>    <span class=\"hljs-keyword\">const</span> dep = <span class=\"hljs-keyword\">new</span> Dep();<br>    <span class=\"hljs-comment\">// 这里主要是针对多层级的对象需要进行递归劫持所有属性</span><br>    <span class=\"hljs-keyword\">new</span> Observer(value);<br>    Objec.defineProperty(&#123; obj, key,<br>      &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>          <span class=\"hljs-comment\">// 若当前有对该属性的依赖项，则发布者收集依赖</span><br>          <span class=\"hljs-keyword\">if</span> (Dep.target) &#123;<br>            dep.addSub(Dep.target);<br>          &#125;<br>          <span class=\"hljs-keyword\">return</span> value;<br>        &#125;,<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\">newValue</span>)</span>&#123;<br>          <span class=\"hljs-comment\">// 值没有变化return不做任何操作</span><br>           <span class=\"hljs-keyword\">if</span> (value === newValue) <span class=\"hljs-keyword\">return</span>;<br>          <span class=\"hljs-comment\">// 当对属性进行设置时候就可以去派发订阅消息，通知到所有的订阅者</span><br>          value = newValue;<br>          <span class=\"hljs-comment\">// 对新设置的值进行递归劫持</span><br>          <span class=\"hljs-keyword\">new</span> Observer(newVal);<br>          dep.notify()<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 发布者,将依赖该属性的watcher都加入subs数组，当该属性改变的时候，则调用所有依赖该属性的watcher的更新函数，触发更新</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dep</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.subs = [];<br>  &#125;<br>  <span class=\"hljs-comment\">// 增加订阅者</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">addSubs</span>(<span class=\"hljs-params\">sub</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-built_in\">arguments</span>).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.subs.includes(v)) &#123;<br>        <span class=\"hljs-built_in\">this</span>.subs.push(v);<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <span class=\"hljs-comment\">// 通知订阅者</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">notify</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.subs.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> v.update());<br>  &#125;<br>&#125;<br>Dep.target = <span class=\"hljs-literal\">null</span>;<br><br><span class=\"hljs-comment\">// 观察者</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Watcher</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">data, key, cb</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.data = data;<br>    <span class=\"hljs-built_in\">this</span>.key = key;<br>    <span class=\"hljs-built_in\">this</span>.cb = cb;<br>    <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-literal\">null</span>;<br>    <span class=\"hljs-built_in\">this</span>.get();<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-comment\">// 绑定依赖对象，确认订阅</span><br>    Dep.target = <span class=\"hljs-built_in\">this</span>;<br>    <span class=\"hljs-built_in\">this</span>.value= <span class=\"hljs-built_in\">this</span>.data[key];<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.data;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">update</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> oldValue = <span class=\"hljs-built_in\">this</span>.value;<br>    <span class=\"hljs-keyword\">const</span> newValue = <span class=\"hljs-built_in\">this</span>.get();<br>    <span class=\"hljs-keyword\">if</span> (oldValue !== newValue) &#123;<br>      <span class=\"hljs-built_in\">this</span>.cb(oldValue, newValue);<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">let</span> data = &#123;<br>  a:<span class=\"hljs-number\">0</span>,<br>  b:<span class=\"hljs-number\">1</span><br>&#125;<br><span class=\"hljs-comment\">// 初始化Observer劫持绑定所有set/get</span><br><span class=\"hljs-keyword\">new</span> Observer(data);<br><span class=\"hljs-comment\">// 监听属性 a 的值如果发现变化执行回调函数</span><br><span class=\"hljs-keyword\">new</span> Watcher(data, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">oldValue, newValue</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;这个是watch&#x27;</span>,oldValue, newValue);<br>&#125;)<br><br><br></code></pre></td></tr></table></figure>\n\n<p>简单的响应式更新就是这样的了，当然 vue 源码比这复杂的多还要处理其他数据类型，有兴趣可以再看看源码。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<p>现在面试官随随便便都会问一句：请简单说一下 <code>vue</code> 的响应式原理是如何实现的？<br>答：使用 ES5 的<code>Object.defineProperty</code>！地球人都知道<br>再问：那你能简单的讲一下具体的实现流程吗？<br>答：。。。。。（好像知道但是好像又张嘴说不上来 😆 尴哩个尬）</p>","more":"<p>看十遍不如上手做一遍，赶紧动手跟我撸一遍试试，免得再面试又被打脸。</p>\n<h2 id=\"第一步先熟悉-Object-defineProperty\"><a href=\"#第一步先熟悉-Object-defineProperty\" class=\"headerlink\" title=\"第一步先熟悉 Object.defineProperty\"></a>第一步先熟悉 <code>Object.defineProperty</code></h2><p><code>Object.defineProperty</code>方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，先来看一下它的语法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, prop, descriptor);<br></code></pre></td></tr></table></figure>\n\n<p><code>obj</code> 是要在其上定义属性的对象；<code>prop</code> 是要定义的属性或者修改的名称；<code>descriptor</code> 是将被定义或者修改的属性描述符</p>\n<p>比较核心的是 <code>descriptor</code>，它有很多可选键值。这里我们最关心的是 <code>get</code> 和 <code>set</code>，<code>get</code> 是一个给属性提供的 <code>getter</code> 方法，当我们访问了该属性的时候会触发 <code>getter</code> 方法；<code>set</code> 是一个给属性提供的 <code>setter</code> 方法，当我们对该属性做修改的时候会触发 <code>setter</code> 方法。详细参考<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">MDN</a></p>\n<h2 id=\"第二步了解响应式流程\"><a href=\"#第二步了解响应式流程\" class=\"headerlink\" title=\"第二步了解响应式流程\"></a>第二步了解响应式流程</h2><p>很重要的一个概念是<code>发布订阅模式</code>发布订阅模式是设计模式中比较常见的一种，其中有两个角色：发布者和订阅者。多个订阅者可以向同一发布者订阅一个事件，当事件发生的时候，发布者通知所有订阅该事件的订阅者。<br>写个小例子了解一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 一般命名为dep作为订阅者的依赖也就是我们所说的发布者</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dep</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.subs = [];<br>  &#125;<br>  <span class=\"hljs-comment\">// 增加订阅者</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">addSubs</span>(<span class=\"hljs-params\">sub</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-built_in\">arguments</span>).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.subs.includes(v)) &#123;<br>        <span class=\"hljs-built_in\">this</span>.subs.push(v);<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <span class=\"hljs-comment\">// 通知订阅者</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">notify</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.subs.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> v.update());<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">const</span> dep = <span class=\"hljs-keyword\">new</span> Dep();<br><span class=\"hljs-keyword\">const</span> sub1 = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">update</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;sub1接收到通知&#x27;</span>);<br>  &#125;<br>&#125;;<br><span class=\"hljs-keyword\">const</span> sub2 = &#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">update</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;sub2接收到通知&#x27;</span>);<br>  &#125;<br>&#125;;<br>dep.addSubs(sub1, sub2);<br>dep.notify();<br><span class=\"hljs-comment\">// 通过notify发送通知订阅者</span><br></code></pre></td></tr></table></figure>\n\n<p>小总结:</p>\n<p>1.<code>vue.js</code> 首先通过 <code>Object.defineProperty</code>来对要监听的数据进行 <code>getter</code> 和 <code>setter</code> 劫持，当数据的属性被赋值/取值的时候，<code>vue.js</code> 就可以察觉到并做相应的处理。</p>\n<p>2.通过订阅发布模式，我们可以为对象的每个属性都创建一个发布者，当有其他订阅者依赖于这个属性的时候，则将订阅者加入到发布者的队列中。利用 <code>Object.defineProperty</code> 的数据劫持，在属性的 <code>setter</code> 调用的时候，该属性的发布者通知所有订阅者更新内容。</p>\n<h2 id=\"第三步动手实践\"><a href=\"#第三步动手实践\" class=\"headerlink\" title=\"第三步动手实践\"></a>第三步动手实践</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 简单的一个监听函数用来给对象添加setter 和 getter，用于收集依赖和派发订阅消息,基本上流程参考vue源码</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Observer</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">data</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.data = data;<br>    <span class=\"hljs-built_in\">this</span>.walk();<br>  &#125;<br>  <span class=\"hljs-comment\">// walk是用来遍历对象设置setter和getter,</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">walk</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> keys = <span class=\"hljs-built_in\">Object</span>.keys(<span class=\"hljs-built_in\">this</span>.data);<br>    keys.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> &#123;<br>      defineReactive(<span class=\"hljs-built_in\">this</span>.data, keys, <span class=\"hljs-built_in\">this</span>.data[key]);<br>    &#125;);<br>  &#125;<br>  <span class=\"hljs-comment\">// 创建实例化当前属性的一个发布者，劫持属性，收集和派发</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">defineReactive</span>(<span class=\"hljs-params\">obj, key, value</span>)</span> &#123;<br>    <span class=\"hljs-comment\">// 实例化一个新的发布者</span><br>    <span class=\"hljs-keyword\">const</span> dep = <span class=\"hljs-keyword\">new</span> Dep();<br>    <span class=\"hljs-comment\">// 这里主要是针对多层级的对象需要进行递归劫持所有属性</span><br>    <span class=\"hljs-keyword\">new</span> Observer(value);<br>    Objec.defineProperty(&#123; obj, key,<br>      &#123;<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>          <span class=\"hljs-comment\">// 若当前有对该属性的依赖项，则发布者收集依赖</span><br>          <span class=\"hljs-keyword\">if</span> (Dep.target) &#123;<br>            dep.addSub(Dep.target);<br>          &#125;<br>          <span class=\"hljs-keyword\">return</span> value;<br>        &#125;,<br>        <span class=\"hljs-function\"><span class=\"hljs-title\">set</span>(<span class=\"hljs-params\">newValue</span>)</span>&#123;<br>          <span class=\"hljs-comment\">// 值没有变化return不做任何操作</span><br>           <span class=\"hljs-keyword\">if</span> (value === newValue) <span class=\"hljs-keyword\">return</span>;<br>          <span class=\"hljs-comment\">// 当对属性进行设置时候就可以去派发订阅消息，通知到所有的订阅者</span><br>          value = newValue;<br>          <span class=\"hljs-comment\">// 对新设置的值进行递归劫持</span><br>          <span class=\"hljs-keyword\">new</span> Observer(newVal);<br>          dep.notify()<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 发布者,将依赖该属性的watcher都加入subs数组，当该属性改变的时候，则调用所有依赖该属性的watcher的更新函数，触发更新</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Dep</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.subs = [];<br>  &#125;<br>  <span class=\"hljs-comment\">// 增加订阅者</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">addSubs</span>(<span class=\"hljs-params\">sub</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">Array</span>.from(<span class=\"hljs-built_in\">arguments</span>).forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> &#123;<br>      <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">this</span>.subs.includes(v)) &#123;<br>        <span class=\"hljs-built_in\">this</span>.subs.push(v);<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <span class=\"hljs-comment\">// 通知订阅者</span><br>  <span class=\"hljs-function\"><span class=\"hljs-title\">notify</span>(<span class=\"hljs-params\"></span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.subs.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> v.update());<br>  &#125;<br>&#125;<br>Dep.target = <span class=\"hljs-literal\">null</span>;<br><br><span class=\"hljs-comment\">// 观察者</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Watcher</span> </span>&#123;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">constructor</span>(<span class=\"hljs-params\">data, key, cb</span>)</span> &#123;<br>    <span class=\"hljs-built_in\">this</span>.data = data;<br>    <span class=\"hljs-built_in\">this</span>.key = key;<br>    <span class=\"hljs-built_in\">this</span>.cb = cb;<br>    <span class=\"hljs-built_in\">this</span>.value = <span class=\"hljs-literal\">null</span>;<br>    <span class=\"hljs-built_in\">this</span>.get();<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">get</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-comment\">// 绑定依赖对象，确认订阅</span><br>    Dep.target = <span class=\"hljs-built_in\">this</span>;<br>    <span class=\"hljs-built_in\">this</span>.value= <span class=\"hljs-built_in\">this</span>.data[key];<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.data;<br>  &#125;<br>  <span class=\"hljs-function\"><span class=\"hljs-title\">update</span>(<span class=\"hljs-params\"></span>)</span>&#123;<br>    <span class=\"hljs-keyword\">const</span> oldValue = <span class=\"hljs-built_in\">this</span>.value;<br>    <span class=\"hljs-keyword\">const</span> newValue = <span class=\"hljs-built_in\">this</span>.get();<br>    <span class=\"hljs-keyword\">if</span> (oldValue !== newValue) &#123;<br>      <span class=\"hljs-built_in\">this</span>.cb(oldValue, newValue);<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-keyword\">let</span> data = &#123;<br>  a:<span class=\"hljs-number\">0</span>,<br>  b:<span class=\"hljs-number\">1</span><br>&#125;<br><span class=\"hljs-comment\">// 初始化Observer劫持绑定所有set/get</span><br><span class=\"hljs-keyword\">new</span> Observer(data);<br><span class=\"hljs-comment\">// 监听属性 a 的值如果发现变化执行回调函数</span><br><span class=\"hljs-keyword\">new</span> Watcher(data, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">oldValue, newValue</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;这个是watch&#x27;</span>,oldValue, newValue);<br>&#125;)<br><br><br></code></pre></td></tr></table></figure>\n\n<p>简单的响应式更新就是这样的了，当然 vue 源码比这复杂的多还要处理其他数据类型，有兴趣可以再看看源码。</p>"},{"title":"WordPress 百度熊掌号原创推送插件：Fanly Submit下载","url":"211.html","id":"211","date":"2019-07-05T08:44:17.000Z","_content":"\nFanly Submit 是一款根据百度站长平台原创保护提交...\n\n![WordPress 百度熊掌号原创推送插件：Fanly Submit下载](https://aliyun.ccswust.org/images/2019/05/Fanly-Submit.png \"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\") 百度熊掌号是百度推出的新平台，把你网站的原创内容在最短时间内展现到百度搜索结果中，有助于提高百度搜索排名和权重，也就提高了网站流量。按照百度要求，接入百度熊掌号需要对网站进行一番改造，涉及到的代码不是大家能搞定的，所以介绍两款熊掌号插件 Fanly Submit 和 BaiduXZH Submit，可以有效提交原创内容，省去大把时间，更多精力放在网站上面。\n\n一、Fanly Submit\n--------------\n\nFanly Submit 需要添加熊掌号 APPID 和熊掌号 Token，就能够正常连接到熊掌号并自动推送文章了，非常简单。看下图填写空格，勾选全部选项即可。不过要注意一点，就是说你要知道自己的文章原创程度有多少，如果确实原创的少就别勾选这个选项，熊掌号会自行判断你文章的原创度，如果总是提交一些不达标的伪原创文章，会被降低提交数量的。 ![WordPress 百度熊掌号原创推送插件：Fanly Submit下载](https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-16-49.jpg \"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\") 下面是文章发布页面的选项，上面默认全部勾选后，下面会自动勾选，也可以自己改动。 ![WordPress 百度熊掌号原创推送插件：Fanly Submit下载](https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-19-37.jpg \"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\") 如何验证提交到熊掌号了呢？去熊掌号后台查看提交数量是否变化了就知道了。 Fanly Submit 插件在 wordpress 插件里面是找不到的，只能在作者网站下载到，地址是：[https://zhan.leiue.com/fanly-submit.html](https://blog.ccswust.org/go/?url=aHR0cHM6Ly96aGFuLmxlaXVlLmNvbS9mYW5seS1zdWJtaXQuaHRtbA==) 二、BaiduXZH Submit 百度熊掌号（原百家号、百度站长平台）链接提交，原创保护内容提交，自动提交最新文章以保证 24 小时内可被百度收录，提高站点 SEO。 这个插件和上面的 Fanly Submit 一样都是第三方开发的，这个插件是被 wordpress 官方收录了的，在 wordpress 插件页面可以搜索并安装。设置界面和上面插件几乎相同，没啥大的差距，效果也都一样。就不想详细说了。 ![WordPress 百度熊掌号原创推送插件：Fanly Submit下载](https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-21-09.jpg \"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\") 以上两个插件可以提高百度熊掌号收录，自动推送文章，提高原创比例，因为使用起来也很简单，所以没有什么可以展开来写的东西。有一点要说的是如果你懂代码可以自己改造；如果不懂代码那么就考虑使用类似的插件吧，毕竟更多精力要放到网站运营中。","source":"_posts/wordpress-e7-99-be-e5-ba-a6-e7-86-8a-e6-8e-8c-e5-8f-b7-e5-8e-9f-e5-88-9b-e6-8e-a8-e9-80-81-e6-8f-92-e4-bb-b6-ef-bc-9afanly-submit-e4-b8-8b-e8-bd-bd.md","raw":"---\ntitle: WordPress 百度熊掌号原创推送插件：Fanly Submit下载\ntags:\n  - WordPress\nurl: 211.html\nid: 211\ncategories:\n  - 精选资源\ndate: 2019-07-05 16:44:17\n---\n\nFanly Submit 是一款根据百度站长平台原创保护提交...\n\n![WordPress 百度熊掌号原创推送插件：Fanly Submit下载](https://aliyun.ccswust.org/images/2019/05/Fanly-Submit.png \"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\") 百度熊掌号是百度推出的新平台，把你网站的原创内容在最短时间内展现到百度搜索结果中，有助于提高百度搜索排名和权重，也就提高了网站流量。按照百度要求，接入百度熊掌号需要对网站进行一番改造，涉及到的代码不是大家能搞定的，所以介绍两款熊掌号插件 Fanly Submit 和 BaiduXZH Submit，可以有效提交原创内容，省去大把时间，更多精力放在网站上面。\n\n一、Fanly Submit\n--------------\n\nFanly Submit 需要添加熊掌号 APPID 和熊掌号 Token，就能够正常连接到熊掌号并自动推送文章了，非常简单。看下图填写空格，勾选全部选项即可。不过要注意一点，就是说你要知道自己的文章原创程度有多少，如果确实原创的少就别勾选这个选项，熊掌号会自行判断你文章的原创度，如果总是提交一些不达标的伪原创文章，会被降低提交数量的。 ![WordPress 百度熊掌号原创推送插件：Fanly Submit下载](https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-16-49.jpg \"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\") 下面是文章发布页面的选项，上面默认全部勾选后，下面会自动勾选，也可以自己改动。 ![WordPress 百度熊掌号原创推送插件：Fanly Submit下载](https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-19-37.jpg \"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\") 如何验证提交到熊掌号了呢？去熊掌号后台查看提交数量是否变化了就知道了。 Fanly Submit 插件在 wordpress 插件里面是找不到的，只能在作者网站下载到，地址是：[https://zhan.leiue.com/fanly-submit.html](https://blog.ccswust.org/go/?url=aHR0cHM6Ly96aGFuLmxlaXVlLmNvbS9mYW5seS1zdWJtaXQuaHRtbA==) 二、BaiduXZH Submit 百度熊掌号（原百家号、百度站长平台）链接提交，原创保护内容提交，自动提交最新文章以保证 24 小时内可被百度收录，提高站点 SEO。 这个插件和上面的 Fanly Submit 一样都是第三方开发的，这个插件是被 wordpress 官方收录了的，在 wordpress 插件页面可以搜索并安装。设置界面和上面插件几乎相同，没啥大的差距，效果也都一样。就不想详细说了。 ![WordPress 百度熊掌号原创推送插件：Fanly Submit下载](https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-21-09.jpg \"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\") 以上两个插件可以提高百度熊掌号收录，自动推送文章，提高原创比例，因为使用起来也很简单，所以没有什么可以展开来写的东西。有一点要说的是如果你懂代码可以自己改造；如果不懂代码那么就考虑使用类似的插件吧，毕竟更多精力要放到网站运营中。","slug":"wordpress-e7-99-be-e5-ba-a6-e7-86-8a-e6-8e-8c-e5-8f-b7-e5-8e-9f-e5-88-9b-e6-8e-a8-e9-80-81-e6-8f-92-e4-bb-b6-ef-bc-9afanly-submit-e4-b8-8b-e8-bd-bd","published":1,"updated":"2019-09-10T07:46:08.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269f70049c8gsdjlb39md","content":"<p>Fanly Submit 是一款根据百度站长平台原创保护提交…</p>\n<p><img src=\"https://aliyun.ccswust.org/images/2019/05/Fanly-Submit.png\" alt=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\" title=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\"> 百度熊掌号是百度推出的新平台，把你网站的原创内容在最短时间内展现到百度搜索结果中，有助于提高百度搜索排名和权重，也就提高了网站流量。按照百度要求，接入百度熊掌号需要对网站进行一番改造，涉及到的代码不是大家能搞定的，所以介绍两款熊掌号插件 Fanly Submit 和 BaiduXZH Submit，可以有效提交原创内容，省去大把时间，更多精力放在网站上面。</p>\n<h2 id=\"一、Fanly-Submit\"><a href=\"#一、Fanly-Submit\" class=\"headerlink\" title=\"一、Fanly Submit\"></a>一、Fanly Submit</h2><p>Fanly Submit 需要添加熊掌号 APPID 和熊掌号 Token，就能够正常连接到熊掌号并自动推送文章了，非常简单。看下图填写空格，勾选全部选项即可。不过要注意一点，就是说你要知道自己的文章原创程度有多少，如果确实原创的少就别勾选这个选项，熊掌号会自行判断你文章的原创度，如果总是提交一些不达标的伪原创文章，会被降低提交数量的。 <img src=\"https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-16-49.jpg\" alt=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\" title=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\"> 下面是文章发布页面的选项，上面默认全部勾选后，下面会自动勾选，也可以自己改动。 <img src=\"https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-19-37.jpg\" alt=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\" title=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\"> 如何验证提交到熊掌号了呢？去熊掌号后台查看提交数量是否变化了就知道了。 Fanly Submit 插件在 wordpress 插件里面是找不到的，只能在作者网站下载到，地址是：<a href=\"https://blog.ccswust.org/go/?url=aHR0cHM6Ly96aGFuLmxlaXVlLmNvbS9mYW5seS1zdWJtaXQuaHRtbA==\">https://zhan.leiue.com/fanly-submit.html</a> 二、BaiduXZH Submit 百度熊掌号（原百家号、百度站长平台）链接提交，原创保护内容提交，自动提交最新文章以保证 24 小时内可被百度收录，提高站点 SEO。 这个插件和上面的 Fanly Submit 一样都是第三方开发的，这个插件是被 wordpress 官方收录了的，在 wordpress 插件页面可以搜索并安装。设置界面和上面插件几乎相同，没啥大的差距，效果也都一样。就不想详细说了。 <img src=\"https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-21-09.jpg\" alt=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\" title=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\"> 以上两个插件可以提高百度熊掌号收录，自动推送文章，提高原创比例，因为使用起来也很简单，所以没有什么可以展开来写的东西。有一点要说的是如果你懂代码可以自己改造；如果不懂代码那么就考虑使用类似的插件吧，毕竟更多精力要放到网站运营中。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>Fanly Submit 是一款根据百度站长平台原创保护提交…</p>\n<p><img src=\"https://aliyun.ccswust.org/images/2019/05/Fanly-Submit.png\" alt=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\" title=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\"> 百度熊掌号是百度推出的新平台，把你网站的原创内容在最短时间内展现到百度搜索结果中，有助于提高百度搜索排名和权重，也就提高了网站流量。按照百度要求，接入百度熊掌号需要对网站进行一番改造，涉及到的代码不是大家能搞定的，所以介绍两款熊掌号插件 Fanly Submit 和 BaiduXZH Submit，可以有效提交原创内容，省去大把时间，更多精力放在网站上面。</p>\n<h2 id=\"一、Fanly-Submit\"><a href=\"#一、Fanly-Submit\" class=\"headerlink\" title=\"一、Fanly Submit\"></a>一、Fanly Submit</h2><p>Fanly Submit 需要添加熊掌号 APPID 和熊掌号 Token，就能够正常连接到熊掌号并自动推送文章了，非常简单。看下图填写空格，勾选全部选项即可。不过要注意一点，就是说你要知道自己的文章原创程度有多少，如果确实原创的少就别勾选这个选项，熊掌号会自行判断你文章的原创度，如果总是提交一些不达标的伪原创文章，会被降低提交数量的。 <img src=\"https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-16-49.jpg\" alt=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\" title=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\"> 下面是文章发布页面的选项，上面默认全部勾选后，下面会自动勾选，也可以自己改动。 <img src=\"https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-19-37.jpg\" alt=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\" title=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\"> 如何验证提交到熊掌号了呢？去熊掌号后台查看提交数量是否变化了就知道了。 Fanly Submit 插件在 wordpress 插件里面是找不到的，只能在作者网站下载到，地址是：<a href=\"https://blog.ccswust.org/go/?url=aHR0cHM6Ly96aGFuLmxlaXVlLmNvbS9mYW5seS1zdWJtaXQuaHRtbA==\">https://zhan.leiue.com/fanly-submit.html</a> 二、BaiduXZH Submit 百度熊掌号（原百家号、百度站长平台）链接提交，原创保护内容提交，自动提交最新文章以保证 24 小时内可被百度收录，提高站点 SEO。 这个插件和上面的 Fanly Submit 一样都是第三方开发的，这个插件是被 wordpress 官方收录了的，在 wordpress 插件页面可以搜索并安装。设置界面和上面插件几乎相同，没啥大的差距，效果也都一样。就不想详细说了。 <img src=\"https://aliyun.ccswust.org/images/2019/05/%E8%A5%BF%E5%9F%8E%E7%9F%A5%E9%81%93_2019-05-25_19-21-09.jpg\" alt=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\" title=\"WordPress 百度熊掌号原创推送插件：Fanly Submit下载\"> 以上两个插件可以提高百度熊掌号收录，自动推送文章，提高原创比例，因为使用起来也很简单，所以没有什么可以展开来写的东西。有一点要说的是如果你懂代码可以自己改造；如果不懂代码那么就考虑使用类似的插件吧，毕竟更多精力要放到网站运营中。</p>\n"},{"title":"如何何纯代码为WordPress文章页添加面包屑导航","url":"1.html","id":"1","date":"2019-06-19T23:15:17.000Z","_content":"\n如何纯代码为 WordPress 文章页添加面包屑导航，我们主要通过修改主题 functions.php、single.php、main.css 三个文件来实现。\n\n以下方法转自@蝈蝈要安静。注意以下并非本站所用的面包屑，无法于本站一样，但基本原理相同，经供参考\n\n## 一、修改 functions.php\n\n首先在自己的主题文件中找到 functions.php，并在文件中添加下面代码。\n\n//面包屑导航生成函数\nfunction qgg_breadcrumbs(){\nif( !is_single() ) return false; $categorys = get\\_the\\_category(); $category = $categorys\\[0\\];\n return '当前位置：<a href=\"'.get_bloginfo('url').'\">'.get_bloginfo('name').'</a> <small>></small> '.get\\_category\\_parents($category->term_id, true, ' <small>></small> ').get_the_title();\n}\n\n## 二、修改 single.php\n\n这里是把面包屑导航显示到文章页面，所以我们第二步是修改主题 single.php 文件，把下面代码加到自己想显示的位置即可。\n这里是把面包屑导航显示到文章页面，所以我们第二步是修改主题 single.php 文件，把下面代码加到自己想显示的位置即可。\n\n<!\\-\\- 面包屑导航前端显示代码 -->\n\n<div class=\"breadcrumbs\">\n <div class=\"container\"><?php echo qgg_breadcrumbs() ?></div>\n</div>\n\n如果是想显示到文章内容页面的导航栏下，请把上面代码添加到“<?php get_header(); ?>”下即可。\n![纯代码为WordPress文章页添加面包屑导航](http://img.viapi.cn/wp/uploads/2018/04/20180405083159.jpg '纯代码为WordPress文章页添加面包屑导航')\n\n## 三、添加样式代码\n\n完成上面两个步骤后，清理下浏览器缓存，我们就可以看到正常显示面包屑导航了，但是不美观。所以我们还需进行添加显示样式代码步骤。一般得人主题是把下面这段代码添加到 style.css 文件，DUX 主题是添加到 main.css 文件。\n\n```css\n.breadcrumbs {\n  padding: 15px 0;\n  font-size: 12px;\n  line-height: 1;\n  text-align: left;\n  background-color: #fff;\n  margin-bottom: 15px;\n  margin-top: -15px;\n  border-bottom: 1px solid #ebebeb;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);\n  color: #999;\n}\n.breadcrumbs small {\n  font-size: 12px;\n  font-family: serif;\n  color: #bbb;\n  margin: 0 2px;\n  font-weight: bold;\n}\n.breadcrumbs a {\n  color: #999;\n}\n.breadcrumbs a:hover {\n  color: #666;\n}\n@media (max-width: 640px) {\n  .breadcrumbs {\n    margin-top: 1px;\n    margin-bottom: 0;\n    padding: 10px 15px;\n    border-bottom: none;\n    margin-bottom: 1px;\n  }\n}\n```\n","source":"_posts/wordpress.md","raw":"---\ntitle: 如何何纯代码为WordPress文章页添加面包屑导航\nurl: 1.html\nid: 1\ncategories:\n  - 杂谈\ndate: 2019-06-20 07:15:17\ntags:\n---\n\n如何纯代码为 WordPress 文章页添加面包屑导航，我们主要通过修改主题 functions.php、single.php、main.css 三个文件来实现。\n\n以下方法转自@蝈蝈要安静。注意以下并非本站所用的面包屑，无法于本站一样，但基本原理相同，经供参考\n\n## 一、修改 functions.php\n\n首先在自己的主题文件中找到 functions.php，并在文件中添加下面代码。\n\n//面包屑导航生成函数\nfunction qgg_breadcrumbs(){\nif( !is_single() ) return false; $categorys = get\\_the\\_category(); $category = $categorys\\[0\\];\n return '当前位置：<a href=\"'.get_bloginfo('url').'\">'.get_bloginfo('name').'</a> <small>></small> '.get\\_category\\_parents($category->term_id, true, ' <small>></small> ').get_the_title();\n}\n\n## 二、修改 single.php\n\n这里是把面包屑导航显示到文章页面，所以我们第二步是修改主题 single.php 文件，把下面代码加到自己想显示的位置即可。\n这里是把面包屑导航显示到文章页面，所以我们第二步是修改主题 single.php 文件，把下面代码加到自己想显示的位置即可。\n\n<!\\-\\- 面包屑导航前端显示代码 -->\n\n<div class=\"breadcrumbs\">\n <div class=\"container\"><?php echo qgg_breadcrumbs() ?></div>\n</div>\n\n如果是想显示到文章内容页面的导航栏下，请把上面代码添加到“<?php get_header(); ?>”下即可。\n![纯代码为WordPress文章页添加面包屑导航](http://img.viapi.cn/wp/uploads/2018/04/20180405083159.jpg '纯代码为WordPress文章页添加面包屑导航')\n\n## 三、添加样式代码\n\n完成上面两个步骤后，清理下浏览器缓存，我们就可以看到正常显示面包屑导航了，但是不美观。所以我们还需进行添加显示样式代码步骤。一般得人主题是把下面这段代码添加到 style.css 文件，DUX 主题是添加到 main.css 文件。\n\n```css\n.breadcrumbs {\n  padding: 15px 0;\n  font-size: 12px;\n  line-height: 1;\n  text-align: left;\n  background-color: #fff;\n  margin-bottom: 15px;\n  margin-top: -15px;\n  border-bottom: 1px solid #ebebeb;\n  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.04);\n  color: #999;\n}\n.breadcrumbs small {\n  font-size: 12px;\n  font-family: serif;\n  color: #bbb;\n  margin: 0 2px;\n  font-weight: bold;\n}\n.breadcrumbs a {\n  color: #999;\n}\n.breadcrumbs a:hover {\n  color: #666;\n}\n@media (max-width: 640px) {\n  .breadcrumbs {\n    margin-top: 1px;\n    margin-bottom: 0;\n    padding: 10px 15px;\n    border-bottom: none;\n    margin-bottom: 1px;\n  }\n}\n```\n","slug":"wordpress","published":1,"updated":"2019-09-11T03:09:22.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269f7004cc8gs04q7bh82","content":"<p>如何纯代码为 WordPress 文章页添加面包屑导航，我们主要通过修改主题 functions.php、single.php、main.css 三个文件来实现。</p>\n<p>以下方法转自@蝈蝈要安静。注意以下并非本站所用的面包屑，无法于本站一样，但基本原理相同，经供参考</p>\n<h2 id=\"一、修改-functions-php\"><a href=\"#一、修改-functions-php\" class=\"headerlink\" title=\"一、修改 functions.php\"></a>一、修改 functions.php</h2><p>首先在自己的主题文件中找到 functions.php，并在文件中添加下面代码。</p>\n<p>//面包屑导航生成函数<br>function qgg_breadcrumbs(){<br>if( !is_single() ) return false; $categorys = get_the_category(); $category = $categorys[0];<br> return ‘当前位置：<a href=\"'.get_bloginfo('url').'\">‘.get_bloginfo(‘name’).’</a> <small>&gt;</small> ‘.get_category_parents($category-&gt;term_id, true, ‘ <small>&gt;</small> ‘).get_the_title();<br>}</p>\n<h2 id=\"二、修改-single-php\"><a href=\"#二、修改-single-php\" class=\"headerlink\" title=\"二、修改 single.php\"></a>二、修改 single.php</h2><p>这里是把面包屑导航显示到文章页面，所以我们第二步是修改主题 single.php 文件，把下面代码加到自己想显示的位置即可。<br>这里是把面包屑导航显示到文章页面，所以我们第二步是修改主题 single.php 文件，把下面代码加到自己想显示的位置即可。</p>\n<p>&lt;!-- 面包屑导航前端显示代码 –&gt;</p>\n<div class=\"breadcrumbs\">\n <div class=\"container\"><?php echo qgg_breadcrumbs() ?></div>\n</div>\n\n<p>如果是想显示到文章内容页面的导航栏下，请把上面代码添加到“<?php get_header(); ?>”下即可。<br><img src=\"http://img.viapi.cn/wp/uploads/2018/04/20180405083159.jpg\" alt=\"纯代码为WordPress文章页添加面包屑导航\" title=\"纯代码为WordPress文章页添加面包屑导航\"></p>\n<h2 id=\"三、添加样式代码\"><a href=\"#三、添加样式代码\" class=\"headerlink\" title=\"三、添加样式代码\"></a>三、添加样式代码</h2><p>完成上面两个步骤后，清理下浏览器缓存，我们就可以看到正常显示面包屑导航了，但是不美观。所以我们还需进行添加显示样式代码步骤。一般得人主题是把下面这段代码添加到 style.css 文件，DUX 主题是添加到 main.css 文件。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.breadcrumbs</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">12px</span>;<br>  <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-attribute\">text-align</span>: left;<br>  <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fff</span>;<br>  <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">15px</span>;<br>  <span class=\"hljs-attribute\">margin-top</span>: -<span class=\"hljs-number\">15px</span>;<br>  <span class=\"hljs-attribute\">border-bottom</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#ebebeb</span>;<br>  <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">3px</span> <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.04</span>);<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#999</span>;<br>&#125;<br><span class=\"hljs-selector-class\">.breadcrumbs</span> small &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">12px</span>;<br>  <span class=\"hljs-attribute\">font-family</span>: serif;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#bbb</span>;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">2px</span>;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold;<br>&#125;<br><span class=\"hljs-selector-class\">.breadcrumbs</span> <span class=\"hljs-selector-tag\">a</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#999</span>;<br>&#125;<br><span class=\"hljs-selector-class\">.breadcrumbs</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#666</span>;<br>&#125;<br><span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">640px</span>) &#123;<br>  <span class=\"hljs-selector-class\">.breadcrumbs</span> &#123;<br>    <span class=\"hljs-attribute\">margin-top</span>: <span class=\"hljs-number\">1px</span>;<br>    <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">10px</span> <span class=\"hljs-number\">15px</span>;<br>    <span class=\"hljs-attribute\">border-bottom</span>: none;<br>    <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">1px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>如何纯代码为 WordPress 文章页添加面包屑导航，我们主要通过修改主题 functions.php、single.php、main.css 三个文件来实现。</p>\n<p>以下方法转自@蝈蝈要安静。注意以下并非本站所用的面包屑，无法于本站一样，但基本原理相同，经供参考</p>\n<h2 id=\"一、修改-functions-php\"><a href=\"#一、修改-functions-php\" class=\"headerlink\" title=\"一、修改 functions.php\"></a>一、修改 functions.php</h2><p>首先在自己的主题文件中找到 functions.php，并在文件中添加下面代码。</p>\n<p>//面包屑导航生成函数<br>function qgg_breadcrumbs(){<br>if( !is_single() ) return false; $categorys = get_the_category(); $category = $categorys[0];<br> return ‘当前位置：<a href=\"'.get_bloginfo('url').'\">‘.get_bloginfo(‘name’).’</a> <small>&gt;</small> ‘.get_category_parents($category-&gt;term_id, true, ‘ <small>&gt;</small> ‘).get_the_title();<br>}</p>\n<h2 id=\"二、修改-single-php\"><a href=\"#二、修改-single-php\" class=\"headerlink\" title=\"二、修改 single.php\"></a>二、修改 single.php</h2><p>这里是把面包屑导航显示到文章页面，所以我们第二步是修改主题 single.php 文件，把下面代码加到自己想显示的位置即可。<br>这里是把面包屑导航显示到文章页面，所以我们第二步是修改主题 single.php 文件，把下面代码加到自己想显示的位置即可。</p>\n<p>&lt;!-- 面包屑导航前端显示代码 –&gt;</p>\n<div class=\"breadcrumbs\">\n <div class=\"container\"><?php echo qgg_breadcrumbs() ?></div>\n</div>\n\n<p>如果是想显示到文章内容页面的导航栏下，请把上面代码添加到“<?php get_header(); ?>”下即可。<br><img src=\"http://img.viapi.cn/wp/uploads/2018/04/20180405083159.jpg\" alt=\"纯代码为WordPress文章页添加面包屑导航\" title=\"纯代码为WordPress文章页添加面包屑导航\"></p>\n<h2 id=\"三、添加样式代码\"><a href=\"#三、添加样式代码\" class=\"headerlink\" title=\"三、添加样式代码\"></a>三、添加样式代码</h2><p>完成上面两个步骤后，清理下浏览器缓存，我们就可以看到正常显示面包屑导航了，但是不美观。所以我们还需进行添加显示样式代码步骤。一般得人主题是把下面这段代码添加到 style.css 文件，DUX 主题是添加到 main.css 文件。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs css\"><span class=\"hljs-selector-class\">.breadcrumbs</span> &#123;<br>  <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">15px</span> <span class=\"hljs-number\">0</span>;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">12px</span>;<br>  <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-attribute\">text-align</span>: left;<br>  <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fff</span>;<br>  <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">15px</span>;<br>  <span class=\"hljs-attribute\">margin-top</span>: -<span class=\"hljs-number\">15px</span>;<br>  <span class=\"hljs-attribute\">border-bottom</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#ebebeb</span>;<br>  <span class=\"hljs-attribute\">box-shadow</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1px</span> <span class=\"hljs-number\">3px</span> <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.04</span>);<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#999</span>;<br>&#125;<br><span class=\"hljs-selector-class\">.breadcrumbs</span> small &#123;<br>  <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">12px</span>;<br>  <span class=\"hljs-attribute\">font-family</span>: serif;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#bbb</span>;<br>  <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">2px</span>;<br>  <span class=\"hljs-attribute\">font-weight</span>: bold;<br>&#125;<br><span class=\"hljs-selector-class\">.breadcrumbs</span> <span class=\"hljs-selector-tag\">a</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#999</span>;<br>&#125;<br><span class=\"hljs-selector-class\">.breadcrumbs</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span> &#123;<br>  <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#666</span>;<br>&#125;<br><span class=\"hljs-keyword\">@media</span> (<span class=\"hljs-attribute\">max-width</span>: <span class=\"hljs-number\">640px</span>) &#123;<br>  <span class=\"hljs-selector-class\">.breadcrumbs</span> &#123;<br>    <span class=\"hljs-attribute\">margin-top</span>: <span class=\"hljs-number\">1px</span>;<br>    <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">0</span>;<br>    <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">10px</span> <span class=\"hljs-number\">15px</span>;<br>    <span class=\"hljs-attribute\">border-bottom</span>: none;<br>    <span class=\"hljs-attribute\">margin-bottom</span>: <span class=\"hljs-number\">1px</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"一般插件开发规范结构","comments":1,"toc":true,"date":"2019-09-25T11:41:54.000Z","thumbnail":null,"_content":"\n## 一般的插件封装规范结构\n\n```js\n(function(global) {\n  'use strict';\n  function MyPlugin(el, options) {\n    //some cod\n  }\n  MyPlugin.prototype = {\n    //定义方法\n    show: function() {\n      //some code\n    }\n  };\n  if (typeof module !== 'undefined' && module.exports) {\n    //兼容 CommonJs 规范\n    module.exports = MyPlugin;\n  } else if (typeof define === 'function') {\n    //兼容 AMD/CMD 规范\n    define(function() {\n      return MyPlugin;\n    });\n  } else {\n    //注册全局变量，兼容直接使用 script 标签引入插件\n    global.MyPlugin = MyPlugin;\n  }\n})(this);\n```\n","source":"_posts/一般插件开发规范结构.md","raw":"---\ntitle: 一般插件开发规范结构\ncomments: true\ntoc: true\ndate: 2019-09-25 19:41:54\ntags:\ncategories:\nthumbnail:\n---\n\n## 一般的插件封装规范结构\n\n```js\n(function(global) {\n  'use strict';\n  function MyPlugin(el, options) {\n    //some cod\n  }\n  MyPlugin.prototype = {\n    //定义方法\n    show: function() {\n      //some code\n    }\n  };\n  if (typeof module !== 'undefined' && module.exports) {\n    //兼容 CommonJs 规范\n    module.exports = MyPlugin;\n  } else if (typeof define === 'function') {\n    //兼容 AMD/CMD 规范\n    define(function() {\n      return MyPlugin;\n    });\n  } else {\n    //注册全局变量，兼容直接使用 script 标签引入插件\n    global.MyPlugin = MyPlugin;\n  }\n})(this);\n```\n","slug":"一般插件开发规范结构","published":1,"updated":"2019-09-25T11:42:36.099Z","layout":"post","photos":[],"link":"","_id":"ckmp269fk004fc8gs5xqx0bu8","content":"<h2 id=\"一般的插件封装规范结构\"><a href=\"#一般的插件封装规范结构\" class=\"headerlink\" title=\"一般的插件封装规范结构\"></a>一般的插件封装规范结构</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">global</span></span>) </span>&#123;<br><span class=\"hljs-meta\">  &#x27;use strict&#x27;</span>;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">MyPlugin</span>(<span class=\"hljs-params\">el, options</span>) </span>&#123;<br>    <span class=\"hljs-comment\">//some cod</span><br>  &#125;<br>  MyPlugin.prototype = &#123;<br>    <span class=\"hljs-comment\">//定义方法</span><br>    show: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-comment\">//some code</span><br>    &#125;<br>  &#125;;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">module</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"hljs-built_in\">module</span>.exports) &#123;<br>    <span class=\"hljs-comment\">//兼容 CommonJs 规范</span><br>    <span class=\"hljs-built_in\">module</span>.exports = MyPlugin;<br>  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> define === <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>    <span class=\"hljs-comment\">//兼容 AMD/CMD 规范</span><br>    define(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> MyPlugin;<br>    &#125;);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">//注册全局变量，兼容直接使用 script 标签引入插件</span><br>    <span class=\"hljs-built_in\">global</span>.MyPlugin = MyPlugin;<br>  &#125;<br>&#125;)(<span class=\"hljs-built_in\">this</span>);<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"一般的插件封装规范结构\"><a href=\"#一般的插件封装规范结构\" class=\"headerlink\" title=\"一般的插件封装规范结构\"></a>一般的插件封装规范结构</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">global</span></span>) </span>&#123;<br><span class=\"hljs-meta\">  &#x27;use strict&#x27;</span>;<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">MyPlugin</span>(<span class=\"hljs-params\">el, options</span>) </span>&#123;<br>    <span class=\"hljs-comment\">//some cod</span><br>  &#125;<br>  MyPlugin.prototype = &#123;<br>    <span class=\"hljs-comment\">//定义方法</span><br>    show: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-comment\">//some code</span><br>    &#125;<br>  &#125;;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> <span class=\"hljs-built_in\">module</span> !== <span class=\"hljs-string\">&#x27;undefined&#x27;</span> &amp;&amp; <span class=\"hljs-built_in\">module</span>.exports) &#123;<br>    <span class=\"hljs-comment\">//兼容 CommonJs 规范</span><br>    <span class=\"hljs-built_in\">module</span>.exports = MyPlugin;<br>  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> define === <span class=\"hljs-string\">&#x27;function&#x27;</span>) &#123;<br>    <span class=\"hljs-comment\">//兼容 AMD/CMD 规范</span><br>    define(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-keyword\">return</span> MyPlugin;<br>    &#125;);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">//注册全局变量，兼容直接使用 script 标签引入插件</span><br>    <span class=\"hljs-built_in\">global</span>.MyPlugin = MyPlugin;<br>  &#125;<br>&#125;)(<span class=\"hljs-built_in\">this</span>);<br></code></pre></td></tr></table></figure>\n"},{"title":"了解一些HTTP协议相关知识","thumbnail":"http://img.v5ant.com/images/2019/11/20/6.jpg","comments":1,"toc":true,"layout":"true","date":"2019-12-30T08:49:42.000Z","updated":"2019-12-30T08:49:42.000Z","_content":"\n## 什么是 HTTP？\n\n<!-- more -->\n\n- HTTP 协议构建于 `TCP/IP` 协议之上，是一个应用层协议，默认端口号是 `80`\n- HTTP 是无连接`无状态`的\n\n## 互联网分层模型\n\n> 其实网络分层模式标准有很多，各大厂商有自己的标准但是为了提升标准化，提供兼容性。国际标准化组织 ISO 提出来一套标准的基础分层模式 OSI（Open System Interconnection Reference Model,开放系统互连参考模型）\n\n![OSI分层模式图解](https://images0.cnblogs.com/blog/104032/201502/030916186871744.png)\n\n- 物理层: 在设备之间传输比特流,规定了电平、速度和电缆针脚。\n- 数据链路层:将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用 MAC 地址)来访问介质,并进行差错检测。\n- 网络层:提供逻辑地址,供路由器确定路径。\n- 传输层:提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。\n- 会话层:负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。\n- 表示层:提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。\n- 应用层:OSI 参考模型中最靠近用户的一层,为应用程序提供网络服务 。\n\n我们做为前端开发，接触最多的也就是应用层，当然全方位了解网络传输规范有助于我们发现 bug，优化性能\n\n`HTTP` 协议是以 `ASCII` 码传输。规范把 `HTTP` 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：\n\n```js\n<method>\n<request-URL>\n<version>\n<headers>\n<entity-body>\n```\n\n`HTTP` 定义了与服务器交互的不同方法，最基本的方法有 `4` 种：`GET` , `POST` , `PUT` , `DELETE`。\n注意一点就是`GET`提交的数据量受 `URL` 长度限制，虽然本质上 `HTTP` 协议上并没有对长度做限制但是，出于安全考虑浏览器厂商会有不同的设置标准\n\n简单来说 `HTTP` 协议是解决如果包装应用数据\n\n## 上面说了 `HTTP` 是基于`TCP/IP`的那么`TCP/IP`又是什么？\n\n`TCP/IP`其实是分开的，由 `TCP` 协议+`IP` 协议\n\n- `TCP`属于传输层协议用于规范解决数据如何在网络中传递他是属于传输层的。\n- `IP` 协议属于网络层，他用来解决信息传递到路由的部分，可以理解为网络分发的部分\n\n上面俩个对应数据传传输是息息相关的，所有一般都直接说`TCP/IP`其实就指的是这具体俩层协议\n\n### TCP 的特性\n\n- TCP 提供一种面向连接的、可靠的字节流服务\n- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP\n- TCP 使用校验和，确认和重传机制来保证可靠传输\n- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复\n- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制\n\n> 注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。\n\n### TCP 三次握手\n\n所谓三次握手(Three-way Handshake)，是指建立一个 `TCP` 连接时，需要客户端和服务器总共发送 `3` 个包。\n\n三次握手的目的是连接服务器指定端口，建立 `TCP` 连接，并同步连接双方的序列号和确认号，交换 `TCP` 窗口大小信息。在 `socket` 编程中，客户端执行 `connect()` 时。将触发三次握手。\n\n- 第一次握手 `(SYN=1, seq=x)`:\n  客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。\n\n  发送完毕后，客户端进入 SYN_SEND 状态。\n\n- 第二次握手 `(SYN=1, ACK=1, seq=y, ACKnum=x+1)`:\n\n  服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。\n\n- 第三次握手 `(ACK=1，ACKnum=y+1)`\n\n  客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写 ISN 的+1\n\n  发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。\n\n### TCP 四次挥手\n\nTCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。\n\n- 第一次挥手`(FIN=1，seq=x)`\n\n  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。\n\n  发送完毕后，客户端进入 FIN_WAIT_1 状态。\n\n- 第二次挥手`(ACK=1，ACKnum=x+1)`\n\n  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。\n\n  发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。\n\n- 第三次挥手`(FIN=1，seq=y)`\n\n  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。\n\n  发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。\n\n- 第四次挥手`(ACK=1，ACKnum=y+1)`\n\n  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。\n\n  服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。\n\n  客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。\n\n### 传输层还有一种常见的协议叫 `UDP`\n\n`UDP` 是一个简单的传输层协议。和 `TCP` 相比，`UDP` 有下面几个显著特性：\n\n- UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据 报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次\n- UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收 方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。\n- UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。\n- UDP 支持多播和广播。\n\n### IP 协议\n\n`IP` 协议位于 `TCP/IP` 协议的第三层——网络层。与传输层协议相比，网络层的责任是提供点到点`(hop by hop)`的服务，而传输层（TCP/UDP）则提供端到端`(end to end)`的服务。\n","source":"_posts/了解一些HTTP协议相关知识.md","raw":"---\ntitle: 了解一些HTTP协议相关知识\ncategories:\n  - 大前端\nthumbnail: 'http://img.v5ant.com/images/2019/11/20/6.jpg'\ncomments: true\ntoc: true\nlayout: true\ndate: 2019-12-30 16:49:42\nupdated: 2019-12-30 16:49:42\ntags:\n---\n\n## 什么是 HTTP？\n\n<!-- more -->\n\n- HTTP 协议构建于 `TCP/IP` 协议之上，是一个应用层协议，默认端口号是 `80`\n- HTTP 是无连接`无状态`的\n\n## 互联网分层模型\n\n> 其实网络分层模式标准有很多，各大厂商有自己的标准但是为了提升标准化，提供兼容性。国际标准化组织 ISO 提出来一套标准的基础分层模式 OSI（Open System Interconnection Reference Model,开放系统互连参考模型）\n\n![OSI分层模式图解](https://images0.cnblogs.com/blog/104032/201502/030916186871744.png)\n\n- 物理层: 在设备之间传输比特流,规定了电平、速度和电缆针脚。\n- 数据链路层:将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用 MAC 地址)来访问介质,并进行差错检测。\n- 网络层:提供逻辑地址,供路由器确定路径。\n- 传输层:提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。\n- 会话层:负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。\n- 表示层:提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。\n- 应用层:OSI 参考模型中最靠近用户的一层,为应用程序提供网络服务 。\n\n我们做为前端开发，接触最多的也就是应用层，当然全方位了解网络传输规范有助于我们发现 bug，优化性能\n\n`HTTP` 协议是以 `ASCII` 码传输。规范把 `HTTP` 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：\n\n```js\n<method>\n<request-URL>\n<version>\n<headers>\n<entity-body>\n```\n\n`HTTP` 定义了与服务器交互的不同方法，最基本的方法有 `4` 种：`GET` , `POST` , `PUT` , `DELETE`。\n注意一点就是`GET`提交的数据量受 `URL` 长度限制，虽然本质上 `HTTP` 协议上并没有对长度做限制但是，出于安全考虑浏览器厂商会有不同的设置标准\n\n简单来说 `HTTP` 协议是解决如果包装应用数据\n\n## 上面说了 `HTTP` 是基于`TCP/IP`的那么`TCP/IP`又是什么？\n\n`TCP/IP`其实是分开的，由 `TCP` 协议+`IP` 协议\n\n- `TCP`属于传输层协议用于规范解决数据如何在网络中传递他是属于传输层的。\n- `IP` 协议属于网络层，他用来解决信息传递到路由的部分，可以理解为网络分发的部分\n\n上面俩个对应数据传传输是息息相关的，所有一般都直接说`TCP/IP`其实就指的是这具体俩层协议\n\n### TCP 的特性\n\n- TCP 提供一种面向连接的、可靠的字节流服务\n- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP\n- TCP 使用校验和，确认和重传机制来保证可靠传输\n- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复\n- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制\n\n> 注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。\n\n### TCP 三次握手\n\n所谓三次握手(Three-way Handshake)，是指建立一个 `TCP` 连接时，需要客户端和服务器总共发送 `3` 个包。\n\n三次握手的目的是连接服务器指定端口，建立 `TCP` 连接，并同步连接双方的序列号和确认号，交换 `TCP` 窗口大小信息。在 `socket` 编程中，客户端执行 `connect()` 时。将触发三次握手。\n\n- 第一次握手 `(SYN=1, seq=x)`:\n  客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。\n\n  发送完毕后，客户端进入 SYN_SEND 状态。\n\n- 第二次握手 `(SYN=1, ACK=1, seq=y, ACKnum=x+1)`:\n\n  服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。\n\n- 第三次握手 `(ACK=1，ACKnum=y+1)`\n\n  客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写 ISN 的+1\n\n  发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。\n\n### TCP 四次挥手\n\nTCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。\n\n- 第一次挥手`(FIN=1，seq=x)`\n\n  假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。\n\n  发送完毕后，客户端进入 FIN_WAIT_1 状态。\n\n- 第二次挥手`(ACK=1，ACKnum=x+1)`\n\n  服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。\n\n  发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。\n\n- 第三次挥手`(FIN=1，seq=y)`\n\n  服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。\n\n  发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。\n\n- 第四次挥手`(ACK=1，ACKnum=y+1)`\n\n  客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。\n\n  服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。\n\n  客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。\n\n### 传输层还有一种常见的协议叫 `UDP`\n\n`UDP` 是一个简单的传输层协议。和 `TCP` 相比，`UDP` 有下面几个显著特性：\n\n- UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据 报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次\n- UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收 方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。\n- UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。\n- UDP 支持多播和广播。\n\n### IP 协议\n\n`IP` 协议位于 `TCP/IP` 协议的第三层——网络层。与传输层协议相比，网络层的责任是提供点到点`(hop by hop)`的服务，而传输层（TCP/UDP）则提供端到端`(end to end)`的服务。\n","slug":"了解一些HTTP协议相关知识","published":1,"photos":[],"link":"","_id":"ckmp269fl004ic8gsgqo20ukf","content":"<h2 id=\"什么是-HTTP？\"><a href=\"#什么是-HTTP？\" class=\"headerlink\" title=\"什么是 HTTP？\"></a>什么是 HTTP？</h2><span id=\"more\"></span>\n\n<ul>\n<li>HTTP 协议构建于 <code>TCP/IP</code> 协议之上，是一个应用层协议，默认端口号是 <code>80</code></li>\n<li>HTTP 是无连接<code>无状态</code>的</li>\n</ul>\n<h2 id=\"互联网分层模型\"><a href=\"#互联网分层模型\" class=\"headerlink\" title=\"互联网分层模型\"></a>互联网分层模型</h2><blockquote>\n<p>其实网络分层模式标准有很多，各大厂商有自己的标准但是为了提升标准化，提供兼容性。国际标准化组织 ISO 提出来一套标准的基础分层模式 OSI（Open System Interconnection Reference Model,开放系统互连参考模型）</p>\n</blockquote>\n<p><img src=\"https://images0.cnblogs.com/blog/104032/201502/030916186871744.png\" alt=\"OSI分层模式图解\"></p>\n<ul>\n<li>物理层: 在设备之间传输比特流,规定了电平、速度和电缆针脚。</li>\n<li>数据链路层:将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用 MAC 地址)来访问介质,并进行差错检测。</li>\n<li>网络层:提供逻辑地址,供路由器确定路径。</li>\n<li>传输层:提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。</li>\n<li>会话层:负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</li>\n<li>表示层:提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。</li>\n<li>应用层:OSI 参考模型中最靠近用户的一层,为应用程序提供网络服务 。</li>\n</ul>\n<p>我们做为前端开发，接触最多的也就是应用层，当然全方位了解网络传输规范有助于我们发现 bug，优化性能</p>\n<p><code>HTTP</code> 协议是以 <code>ASCII</code> 码传输。规范把 <code>HTTP</code> 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;method&gt;<br>&lt;request-URL&gt;<br>&lt;version&gt;<br>&lt;headers&gt;<br>&lt;entity-body&gt;<br></code></pre></td></tr></table></figure>\n\n<p><code>HTTP</code> 定义了与服务器交互的不同方法，最基本的方法有 <code>4</code> 种：<code>GET</code> , <code>POST</code> , <code>PUT</code> , <code>DELETE</code>。<br>注意一点就是<code>GET</code>提交的数据量受 <code>URL</code> 长度限制，虽然本质上 <code>HTTP</code> 协议上并没有对长度做限制但是，出于安全考虑浏览器厂商会有不同的设置标准</p>\n<p>简单来说 <code>HTTP</code> 协议是解决如果包装应用数据</p>\n<h2 id=\"上面说了-HTTP-是基于TCP-IP的那么TCP-IP又是什么？\"><a href=\"#上面说了-HTTP-是基于TCP-IP的那么TCP-IP又是什么？\" class=\"headerlink\" title=\"上面说了 HTTP 是基于TCP/IP的那么TCP/IP又是什么？\"></a>上面说了 <code>HTTP</code> 是基于<code>TCP/IP</code>的那么<code>TCP/IP</code>又是什么？</h2><p><code>TCP/IP</code>其实是分开的，由 <code>TCP</code> 协议+<code>IP</code> 协议</p>\n<ul>\n<li><code>TCP</code>属于传输层协议用于规范解决数据如何在网络中传递他是属于传输层的。</li>\n<li><code>IP</code> 协议属于网络层，他用来解决信息传递到路由的部分，可以理解为网络分发的部分</li>\n</ul>\n<p>上面俩个对应数据传传输是息息相关的，所有一般都直接说<code>TCP/IP</code>其实就指的是这具体俩层协议</p>\n<h3 id=\"TCP-的特性\"><a href=\"#TCP-的特性\" class=\"headerlink\" title=\"TCP 的特性\"></a>TCP 的特性</h3><ul>\n<li>TCP 提供一种面向连接的、可靠的字节流服务</li>\n<li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li>\n<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>\n<li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li>\n<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>\n</ul>\n<blockquote>\n<p>注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p>\n</blockquote>\n<h3 id=\"TCP-三次握手\"><a href=\"#TCP-三次握手\" class=\"headerlink\" title=\"TCP 三次握手\"></a>TCP 三次握手</h3><p>所谓三次握手(Three-way Handshake)，是指建立一个 <code>TCP</code> 连接时，需要客户端和服务器总共发送 <code>3</code> 个包。</p>\n<p>三次握手的目的是连接服务器指定端口，建立 <code>TCP</code> 连接，并同步连接双方的序列号和确认号，交换 <code>TCP</code> 窗口大小信息。在 <code>socket</code> 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p>\n<ul>\n<li><p>第一次握手 <code>(SYN=1, seq=x)</code>:<br>客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p>\n<p>发送完毕后，客户端进入 SYN_SEND 状态。</p>\n</li>\n<li><p>第二次握手 <code>(SYN=1, ACK=1, seq=y, ACKnum=x+1)</code>:</p>\n<p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</p>\n</li>\n<li><p>第三次握手 <code>(ACK=1，ACKnum=y+1)</code></p>\n<p>客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写 ISN 的+1</p>\n<p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p>\n</li>\n</ul>\n<h3 id=\"TCP-四次挥手\"><a href=\"#TCP-四次挥手\" class=\"headerlink\" title=\"TCP 四次挥手\"></a>TCP 四次挥手</h3><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p>\n<ul>\n<li><p>第一次挥手<code>(FIN=1，seq=x)</code></p>\n<p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>\n<p>发送完毕后，客户端进入 FIN_WAIT_1 状态。</p>\n</li>\n<li><p>第二次挥手<code>(ACK=1，ACKnum=x+1)</code></p>\n<p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>\n<p>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p>\n</li>\n<li><p>第三次挥手<code>(FIN=1，seq=y)</code></p>\n<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。</p>\n<p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。</p>\n</li>\n<li><p>第四次挥手<code>(ACK=1，ACKnum=y+1)</code></p>\n<p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。</p>\n<p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p>\n<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p>\n</li>\n</ul>\n<h3 id=\"传输层还有一种常见的协议叫-UDP\"><a href=\"#传输层还有一种常见的协议叫-UDP\" class=\"headerlink\" title=\"传输层还有一种常见的协议叫 UDP\"></a>传输层还有一种常见的协议叫 <code>UDP</code></h3><p><code>UDP</code> 是一个简单的传输层协议。和 <code>TCP</code> 相比，<code>UDP</code> 有下面几个显著特性：</p>\n<ul>\n<li>UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据 报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次</li>\n<li>UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收 方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。</li>\n<li>UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。</li>\n<li>UDP 支持多播和广播。</li>\n</ul>\n<h3 id=\"IP-协议\"><a href=\"#IP-协议\" class=\"headerlink\" title=\"IP 协议\"></a>IP 协议</h3><p><code>IP</code> 协议位于 <code>TCP/IP</code> 协议的第三层——网络层。与传输层协议相比，网络层的责任是提供点到点<code>(hop by hop)</code>的服务，而传输层（TCP/UDP）则提供端到端<code>(end to end)</code>的服务。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<h2 id=\"什么是-HTTP？\"><a href=\"#什么是-HTTP？\" class=\"headerlink\" title=\"什么是 HTTP？\"></a>什么是 HTTP？</h2>","more":"<ul>\n<li>HTTP 协议构建于 <code>TCP/IP</code> 协议之上，是一个应用层协议，默认端口号是 <code>80</code></li>\n<li>HTTP 是无连接<code>无状态</code>的</li>\n</ul>\n<h2 id=\"互联网分层模型\"><a href=\"#互联网分层模型\" class=\"headerlink\" title=\"互联网分层模型\"></a>互联网分层模型</h2><blockquote>\n<p>其实网络分层模式标准有很多，各大厂商有自己的标准但是为了提升标准化，提供兼容性。国际标准化组织 ISO 提出来一套标准的基础分层模式 OSI（Open System Interconnection Reference Model,开放系统互连参考模型）</p>\n</blockquote>\n<p><img src=\"https://images0.cnblogs.com/blog/104032/201502/030916186871744.png\" alt=\"OSI分层模式图解\"></p>\n<ul>\n<li>物理层: 在设备之间传输比特流,规定了电平、速度和电缆针脚。</li>\n<li>数据链路层:将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用 MAC 地址)来访问介质,并进行差错检测。</li>\n<li>网络层:提供逻辑地址,供路由器确定路径。</li>\n<li>传输层:提供面向连接或非面向连接的数据传递以及进行重传前的差错检测。</li>\n<li>会话层:负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</li>\n<li>表示层:提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。</li>\n<li>应用层:OSI 参考模型中最靠近用户的一层,为应用程序提供网络服务 。</li>\n</ul>\n<p>我们做为前端开发，接触最多的也就是应用层，当然全方位了解网络传输规范有助于我们发现 bug，优化性能</p>\n<p><code>HTTP</code> 协议是以 <code>ASCII</code> 码传输。规范把 <code>HTTP</code> 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&lt;method&gt;<br>&lt;request-URL&gt;<br>&lt;version&gt;<br>&lt;headers&gt;<br>&lt;entity-body&gt;<br></code></pre></td></tr></table></figure>\n\n<p><code>HTTP</code> 定义了与服务器交互的不同方法，最基本的方法有 <code>4</code> 种：<code>GET</code> , <code>POST</code> , <code>PUT</code> , <code>DELETE</code>。<br>注意一点就是<code>GET</code>提交的数据量受 <code>URL</code> 长度限制，虽然本质上 <code>HTTP</code> 协议上并没有对长度做限制但是，出于安全考虑浏览器厂商会有不同的设置标准</p>\n<p>简单来说 <code>HTTP</code> 协议是解决如果包装应用数据</p>\n<h2 id=\"上面说了-HTTP-是基于TCP-IP的那么TCP-IP又是什么？\"><a href=\"#上面说了-HTTP-是基于TCP-IP的那么TCP-IP又是什么？\" class=\"headerlink\" title=\"上面说了 HTTP 是基于TCP/IP的那么TCP/IP又是什么？\"></a>上面说了 <code>HTTP</code> 是基于<code>TCP/IP</code>的那么<code>TCP/IP</code>又是什么？</h2><p><code>TCP/IP</code>其实是分开的，由 <code>TCP</code> 协议+<code>IP</code> 协议</p>\n<ul>\n<li><code>TCP</code>属于传输层协议用于规范解决数据如何在网络中传递他是属于传输层的。</li>\n<li><code>IP</code> 协议属于网络层，他用来解决信息传递到路由的部分，可以理解为网络分发的部分</li>\n</ul>\n<p>上面俩个对应数据传传输是息息相关的，所有一般都直接说<code>TCP/IP</code>其实就指的是这具体俩层协议</p>\n<h3 id=\"TCP-的特性\"><a href=\"#TCP-的特性\" class=\"headerlink\" title=\"TCP 的特性\"></a>TCP 的特性</h3><ul>\n<li>TCP 提供一种面向连接的、可靠的字节流服务</li>\n<li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li>\n<li>TCP 使用校验和，确认和重传机制来保证可靠传输</li>\n<li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li>\n<li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li>\n</ul>\n<blockquote>\n<p>注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p>\n</blockquote>\n<h3 id=\"TCP-三次握手\"><a href=\"#TCP-三次握手\" class=\"headerlink\" title=\"TCP 三次握手\"></a>TCP 三次握手</h3><p>所谓三次握手(Three-way Handshake)，是指建立一个 <code>TCP</code> 连接时，需要客户端和服务器总共发送 <code>3</code> 个包。</p>\n<p>三次握手的目的是连接服务器指定端口，建立 <code>TCP</code> 连接，并同步连接双方的序列号和确认号，交换 <code>TCP</code> 窗口大小信息。在 <code>socket</code> 编程中，客户端执行 <code>connect()</code> 时。将触发三次握手。</p>\n<ul>\n<li><p>第一次握手 <code>(SYN=1, seq=x)</code>:<br>客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。</p>\n<p>发送完毕后，客户端进入 SYN_SEND 状态。</p>\n</li>\n<li><p>第二次握手 <code>(SYN=1, ACK=1, seq=y, ACKnum=x+1)</code>:</p>\n<p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加 1，即 X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。</p>\n</li>\n<li><p>第三次握手 <code>(ACK=1，ACKnum=y+1)</code></p>\n<p>客户端再次发送确认包(ACK)，SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写 ISN 的+1</p>\n<p>发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p>\n</li>\n</ul>\n<h3 id=\"TCP-四次挥手\"><a href=\"#TCP-四次挥手\" class=\"headerlink\" title=\"TCP 四次挥手\"></a>TCP 四次挥手</h3><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p>\n<ul>\n<li><p>第一次挥手<code>(FIN=1，seq=x)</code></p>\n<p>假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p>\n<p>发送完毕后，客户端进入 FIN_WAIT_1 状态。</p>\n</li>\n<li><p>第二次挥手<code>(ACK=1，ACKnum=x+1)</code></p>\n<p>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p>\n<p>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p>\n</li>\n<li><p>第三次挥手<code>(FIN=1，seq=y)</code></p>\n<p>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。</p>\n<p>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。</p>\n</li>\n<li><p>第四次挥手<code>(ACK=1，ACKnum=y+1)</code></p>\n<p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。</p>\n<p>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。</p>\n<p>客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p>\n</li>\n</ul>\n<h3 id=\"传输层还有一种常见的协议叫-UDP\"><a href=\"#传输层还有一种常见的协议叫-UDP\" class=\"headerlink\" title=\"传输层还有一种常见的协议叫 UDP\"></a>传输层还有一种常见的协议叫 <code>UDP</code></h3><p><code>UDP</code> 是一个简单的传输层协议。和 <code>TCP</code> 相比，<code>UDP</code> 有下面几个显著特性：</p>\n<ul>\n<li>UDP 缺乏可靠性。UDP 本身不提供确认，序列号，超时重传等机制。UDP 数据报可能在网络中被复制，被重新排序。即 UDP 不保证数据 报会到达其最终目的地，也不保证各个数据报的先后顺序，也不保证每个数据报只到达一次</li>\n<li>UDP 数据报是有长度的。每个 UDP 数据报都有长度，如果一个数据报正确地到达目的地，那么该数据报的长度将随数据一起传递给接收 方。而 TCP 是一个字节流协议，没有任何（协议上的）记录边界。</li>\n<li>UDP 是无连接的。UDP 客户和服务器之前不必存在长期的关系。UDP 发送数据报之前也不需要经过握手创建连接的过程。</li>\n<li>UDP 支持多播和广播。</li>\n</ul>\n<h3 id=\"IP-协议\"><a href=\"#IP-协议\" class=\"headerlink\" title=\"IP 协议\"></a>IP 协议</h3><p><code>IP</code> 协议位于 <code>TCP/IP</code> 协议的第三层——网络层。与传输层协议相比，网络层的责任是提供点到点<code>(hop by hop)</code>的服务，而传输层（TCP/UDP）则提供端到端<code>(end to end)</code>的服务。</p>"},{"title":"使徒行者2-谍影行动-HDTC中字在线观看","comments":1,"toc":true,"date":"2019-09-28T10:27:03.000Z","thumbnail":"http://mv.v5ant.com/upload/vod/20190814-2/0a3580ea9c4e886f9dbf8b223cb9aafd.jpg","_content":"\n> 推荐指数 :💛💛💛💛💛💛💛\n\n| 标题：               | 主演：                                                                                                                                                                                 | 导演： | 上映年代： |\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ | ---------- |\n| 使徒行者 2：谍影行动 | 张家辉,古天乐,吴镇宇,姜珮瑶,张亦驰,刘宇宁,黄志忠,蔡洁,马德钟,袁伟豪,陈山聪,王君馨,张宝儿,江嘉敏,李忠希,刘楚恬,欧瑞伟,郑启泰,黄祥兴,徐荣,林伟,吴瑞庭,卫志豪,黎振烨,汤洛雯,许绍雄,关宛珊 | 文伟鸿 | 2019       |\n\n<!-- more -->\n\n![](https://www.klyy.vip/upload/vod/20190814-2/0a3580ea9c4e886f9dbf8b223cb9aafd.jpg)\n\n### 介绍\n\n童年兄弟意外失散，30 年后因一桩罪案相见，两人已身处不同阵营随着对罪案调查的深入，一个多年来隐于幕后的恐怖组织渐渐浮出水面。\n\n### 在线直播\n\n{% iframe http://jx.v5ant.com?v=https://cn3.ruioushang.com/hls/20190912/16f8455175fe8cdeed63f67dbf661bc7/1568279534/index.m3u8 100% 500px %}\n\n[HD1080P 国语](http://jx.v5ant.com?v=https://jingcai.cdn-vipkkyun.com/20190918/4288_ab869b76/index.m3u8)\n[HD1080P 粤语](http://jx.v5ant.com?v=https://jingcai.cdn-vipkkyun.com/20190918/4300_045abf0e/index.m3u8)\n","source":"_posts/使徒行者-在线播放.md","raw":"---\ntitle: 使徒行者2-谍影行动-HDTC中字在线观看\ncomments: true\ntoc: true\ndate: 2019-09-28 18:27:03\ntags:\ncategories:\n  - 影视资源\nthumbnail: http://mv.v5ant.com/upload/vod/20190814-2/0a3580ea9c4e886f9dbf8b223cb9aafd.jpg\n---\n\n> 推荐指数 :💛💛💛💛💛💛💛\n\n| 标题：               | 主演：                                                                                                                                                                                 | 导演： | 上映年代： |\n| -------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------ | ---------- |\n| 使徒行者 2：谍影行动 | 张家辉,古天乐,吴镇宇,姜珮瑶,张亦驰,刘宇宁,黄志忠,蔡洁,马德钟,袁伟豪,陈山聪,王君馨,张宝儿,江嘉敏,李忠希,刘楚恬,欧瑞伟,郑启泰,黄祥兴,徐荣,林伟,吴瑞庭,卫志豪,黎振烨,汤洛雯,许绍雄,关宛珊 | 文伟鸿 | 2019       |\n\n<!-- more -->\n\n![](https://www.klyy.vip/upload/vod/20190814-2/0a3580ea9c4e886f9dbf8b223cb9aafd.jpg)\n\n### 介绍\n\n童年兄弟意外失散，30 年后因一桩罪案相见，两人已身处不同阵营随着对罪案调查的深入，一个多年来隐于幕后的恐怖组织渐渐浮出水面。\n\n### 在线直播\n\n{% iframe http://jx.v5ant.com?v=https://cn3.ruioushang.com/hls/20190912/16f8455175fe8cdeed63f67dbf661bc7/1568279534/index.m3u8 100% 500px %}\n\n[HD1080P 国语](http://jx.v5ant.com?v=https://jingcai.cdn-vipkkyun.com/20190918/4288_ab869b76/index.m3u8)\n[HD1080P 粤语](http://jx.v5ant.com?v=https://jingcai.cdn-vipkkyun.com/20190918/4300_045abf0e/index.m3u8)\n","slug":"使徒行者-在线播放","published":1,"updated":"2020-01-08T03:32:53.414Z","layout":"post","photos":[],"link":"","_id":"ckmp269fm004lc8gsb7prbmw7","content":"<blockquote>\n<p>推荐指数 :💛💛💛💛💛💛💛</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标题：</th>\n<th>主演：</th>\n<th>导演：</th>\n<th>上映年代：</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>使徒行者 2：谍影行动</td>\n<td>张家辉,古天乐,吴镇宇,姜珮瑶,张亦驰,刘宇宁,黄志忠,蔡洁,马德钟,袁伟豪,陈山聪,王君馨,张宝儿,江嘉敏,李忠希,刘楚恬,欧瑞伟,郑启泰,黄祥兴,徐荣,林伟,吴瑞庭,卫志豪,黎振烨,汤洛雯,许绍雄,关宛珊</td>\n<td>文伟鸿</td>\n<td>2019</td>\n</tr>\n</tbody></table>\n<span id=\"more\"></span>\n\n<p><img src=\"https://www.klyy.vip/upload/vod/20190814-2/0a3580ea9c4e886f9dbf8b223cb9aafd.jpg\"></p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>童年兄弟意外失散，30 年后因一桩罪案相见，两人已身处不同阵营随着对罪案调查的深入，一个多年来隐于幕后的恐怖组织渐渐浮出水面。</p>\n<h3 id=\"在线直播\"><a href=\"#在线直播\" class=\"headerlink\" title=\"在线直播\"></a>在线直播</h3><iframe src=\"http://jx.v5ant.com/?v=https://cn3.ruioushang.com/hls/20190912/16f8455175fe8cdeed63f67dbf661bc7/1568279534/index.m3u8\" width=\"100%\" height=\"500px\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n\n<p><a href=\"http://jx.v5ant.com/?v=https://jingcai.cdn-vipkkyun.com/20190918/4288_ab869b76/index.m3u8\">HD1080P 国语</a><br><a href=\"http://jx.v5ant.com/?v=https://jingcai.cdn-vipkkyun.com/20190918/4300_045abf0e/index.m3u8\">HD1080P 粤语</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<blockquote>\n<p>推荐指数 :💛💛💛💛💛💛💛</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标题：</th>\n<th>主演：</th>\n<th>导演：</th>\n<th>上映年代：</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>使徒行者 2：谍影行动</td>\n<td>张家辉,古天乐,吴镇宇,姜珮瑶,张亦驰,刘宇宁,黄志忠,蔡洁,马德钟,袁伟豪,陈山聪,王君馨,张宝儿,江嘉敏,李忠希,刘楚恬,欧瑞伟,郑启泰,黄祥兴,徐荣,林伟,吴瑞庭,卫志豪,黎振烨,汤洛雯,许绍雄,关宛珊</td>\n<td>文伟鸿</td>\n<td>2019</td>\n</tr>\n</tbody></table>","more":"<p><img src=\"https://www.klyy.vip/upload/vod/20190814-2/0a3580ea9c4e886f9dbf8b223cb9aafd.jpg\"></p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>童年兄弟意外失散，30 年后因一桩罪案相见，两人已身处不同阵营随着对罪案调查的深入，一个多年来隐于幕后的恐怖组织渐渐浮出水面。</p>\n<h3 id=\"在线直播\"><a href=\"#在线直播\" class=\"headerlink\" title=\"在线直播\"></a>在线直播</h3><iframe src=\"http://jx.v5ant.com/?v=https://cn3.ruioushang.com/hls/20190912/16f8455175fe8cdeed63f67dbf661bc7/1568279534/index.m3u8\" width=\"100%\" height=\"500px\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n\n<p><a href=\"http://jx.v5ant.com/?v=https://jingcai.cdn-vipkkyun.com/20190918/4288_ab869b76/index.m3u8\">HD1080P 国语</a><br><a href=\"http://jx.v5ant.com/?v=https://jingcai.cdn-vipkkyun.com/20190918/4300_045abf0e/index.m3u8\">HD1080P 粤语</a></p>"},{"title":"前端大厂面试问答[1]","comments":1,"toc":true,"date":"2019-09-11T11:50:58.000Z","thumbnail":null,"_content":"\n> 声明：关于以下面试题收集来源 （壹题）https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md 答案综合了自己理解如有误区请帮忙指出，谢谢 😆\n\n## 第 1 题：（滴滴、饿了么）写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？\n\n<!-- more -->\n\n首先可以知道`React`/`Vue`都是基于 Vnode（虚拟节点）采用 `diff` 算法进行更新，通过 key 值绑定可以更快速，更准确拿到 oldVnode 中对应的 vnode 节点，提高 diff 效率。\n\nvue 部分源码解析\n\n```js\n// vue 项目 src/core/vdom/patch.js -488 行\n// 以下是为了阅读性进行格式化后的代码\n\n// oldCh 是一个旧虚拟节点数组\nif (isUndef(oldKeyToIdx)) {\n  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n}\nif (isDef(newStartVnode.key)) {\n  // map 方式获取\n  idxInOld = oldKeyToIdx[newStartVnode.key];\n} else {\n  // 遍历方式获取\n  idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n}\n```\n\n创建 map 函数\n\n```js\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  let i, key;\n  const map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) map[key] = i;\n  }\n  return map;\n}\n```\n\n遍历寻找\n\n```js\n// sameVnode 是对比新旧节点是否相同的函数\nfunction findIdxInOld(node, oldCh, start, end) {\n  for (let i = start; i < end; i++) {\n    const c = oldCh[i];\n\n    if (isDef(c) && sameVnode(node, c)) return i;\n  }\n}\n```\n\n相对遍历查找 `map` 映射理论上更快速尤其在对比较大的数据量的时候效果就很明显了，还有一个就是数据更新时组件的强制更新，\n以避免“原地复用”带来的副作用。\n\n总结一句就是，`key` 是可以更准确的，更快速的更新节点，而且不建议使用`index`做 `key`，因为每次索引都一样导致更新时候不会有任何效果\n\n## 第 2 题：['1', '2', '3'].map(parseInt) what & why ?\n\n刚看到这个题目大部分人跟我一样都会下意识的认为返回值应该是`[1,2,3]`，好像哪里不对哈，我们一起一步一步分析来看\n这个题主要考察的是 `map` 和 `parseInt` 传参\n\n### map\n\n`map()` 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\n\n```js\nvar new_array = arr.map(function callback(currentValue[,index[, array]]) {\n // Return element for new_array\n }[, thisArg])\n//  currentValue :当前值\n//  index : 索引值\n//  array : callback map 方法被调用的数组\n```\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n\n### parseInt\n\nparseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。\n\n```js\nconst intValue = parseInt(string[, radix]);\n// string : 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。\n// radix : 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。\n// 返回值 : 返回一个整数或NaN\n```\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)\n温习了基础知识后简单分析一下，首先 `map` 函数传了 `parseInt` 作为回调函数，那么 `map` 的相关参数也就直接可以传入 `parseInt` 函数中，map 的 currentValue 作为`parseInt` 要被解析的字符串传入，第二个当前值的索引被当做`radix` 进制数传入，第三个参数忽略。\nmap 遍历大概执行了下面 3 个逻辑\n\n```js\nparseInt('1', 0);\nparseInt('2', 1);\nparseInt('3', 2);\n```\n\n注意：\n在 radix 为 undefined，或者 radix 为 0 或者没有指定的情况下，JavaScript 作如下处理：\n\n- 如果字符串 string 以\"0x\"或者\"0X\"开头, 则基数是 16 (16 进制).\n- 如果字符串 string 以\"0\"开头, 基数是 8（八进制）或者 10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用 10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出 radix 参数的值。\n- 如果字符串 string 以其它任何值开头，则基数是 10 (十进制)。`\n\n结论\n第一个传入基数为 0 并且字符串没有以 `0` 或者 `0x` 开头，默认取 `10` 进制，那么返回值就是`Number` 1\n第二个传入基数为 1 无效，直接返回 `NaN`\n第三个传入基数为 2，那么就是以 2 进制运算解析，但是二进制中只能为`1` or `0`,传入 `3` 为非法值，返回 `NaN`\n返回结果 `[1,NaN,NaN]`\n如何按照我们预期返回对应`Number`类型？\n\n```js\n['1', '2', '3'].map(num => parseInt(num, 10));\n```\n\n## 第 3 题：（挖财）什么是防抖和节流？有什么区别？如何实现？\n\n### 防抖\n\n触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间,简单来说就是避免事件频繁被调用\n\n思路\n每次触发高频操作后取消之前的延时调用\n\n```js\nfunction debounce(fn) {\n  let timer = null;\n  return function() {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, arguments);\n    }, 500);\n  };\n}\nfunction doSomething() {\n  console.log('防抖成功了！');\n}\nconst inp = document.querySelector('#inp');\ninp.addEventListener('input', debounce(doSomething)); // 防抖\n```\n\n### 节流\n\n指定时间段内只允许程序调用一次\n\n思路\n每次调用之前判断是否超时，如未超时拒绝执行等待下次调用\n\n```js\nfunction throttle(fu, time = 500) {\n  let timer = null;\n  return function() {\n    if (timer) return;\n    setTimeout(() => {\n      fn.apply(this, arguments);\n      clearTimeout(timer);\n      timer = null;\n    }, time);\n  };\n}\n```\n","source":"_posts/前端问答.md","raw":"---\ntitle: 前端大厂面试问答[1]\ncomments: true\ntoc: true\ndate: 2019-09-11 19:50:58\ntags:\ncategories:\n- 大前端\n- 面试题类\nthumbnail:\n---\n\n> 声明：关于以下面试题收集来源 （壹题）https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md 答案综合了自己理解如有误区请帮忙指出，谢谢 😆\n\n## 第 1 题：（滴滴、饿了么）写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？\n\n<!-- more -->\n\n首先可以知道`React`/`Vue`都是基于 Vnode（虚拟节点）采用 `diff` 算法进行更新，通过 key 值绑定可以更快速，更准确拿到 oldVnode 中对应的 vnode 节点，提高 diff 效率。\n\nvue 部分源码解析\n\n```js\n// vue 项目 src/core/vdom/patch.js -488 行\n// 以下是为了阅读性进行格式化后的代码\n\n// oldCh 是一个旧虚拟节点数组\nif (isUndef(oldKeyToIdx)) {\n  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n}\nif (isDef(newStartVnode.key)) {\n  // map 方式获取\n  idxInOld = oldKeyToIdx[newStartVnode.key];\n} else {\n  // 遍历方式获取\n  idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n}\n```\n\n创建 map 函数\n\n```js\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n  let i, key;\n  const map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) map[key] = i;\n  }\n  return map;\n}\n```\n\n遍历寻找\n\n```js\n// sameVnode 是对比新旧节点是否相同的函数\nfunction findIdxInOld(node, oldCh, start, end) {\n  for (let i = start; i < end; i++) {\n    const c = oldCh[i];\n\n    if (isDef(c) && sameVnode(node, c)) return i;\n  }\n}\n```\n\n相对遍历查找 `map` 映射理论上更快速尤其在对比较大的数据量的时候效果就很明显了，还有一个就是数据更新时组件的强制更新，\n以避免“原地复用”带来的副作用。\n\n总结一句就是，`key` 是可以更准确的，更快速的更新节点，而且不建议使用`index`做 `key`，因为每次索引都一样导致更新时候不会有任何效果\n\n## 第 2 题：['1', '2', '3'].map(parseInt) what & why ?\n\n刚看到这个题目大部分人跟我一样都会下意识的认为返回值应该是`[1,2,3]`，好像哪里不对哈，我们一起一步一步分析来看\n这个题主要考察的是 `map` 和 `parseInt` 传参\n\n### map\n\n`map()` 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\n\n```js\nvar new_array = arr.map(function callback(currentValue[,index[, array]]) {\n // Return element for new_array\n }[, thisArg])\n//  currentValue :当前值\n//  index : 索引值\n//  array : callback map 方法被调用的数组\n```\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n\n### parseInt\n\nparseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。\n\n```js\nconst intValue = parseInt(string[, radix]);\n// string : 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。\n// radix : 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。\n// 返回值 : 返回一个整数或NaN\n```\n\n[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)\n温习了基础知识后简单分析一下，首先 `map` 函数传了 `parseInt` 作为回调函数，那么 `map` 的相关参数也就直接可以传入 `parseInt` 函数中，map 的 currentValue 作为`parseInt` 要被解析的字符串传入，第二个当前值的索引被当做`radix` 进制数传入，第三个参数忽略。\nmap 遍历大概执行了下面 3 个逻辑\n\n```js\nparseInt('1', 0);\nparseInt('2', 1);\nparseInt('3', 2);\n```\n\n注意：\n在 radix 为 undefined，或者 radix 为 0 或者没有指定的情况下，JavaScript 作如下处理：\n\n- 如果字符串 string 以\"0x\"或者\"0X\"开头, 则基数是 16 (16 进制).\n- 如果字符串 string 以\"0\"开头, 基数是 8（八进制）或者 10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用 10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出 radix 参数的值。\n- 如果字符串 string 以其它任何值开头，则基数是 10 (十进制)。`\n\n结论\n第一个传入基数为 0 并且字符串没有以 `0` 或者 `0x` 开头，默认取 `10` 进制，那么返回值就是`Number` 1\n第二个传入基数为 1 无效，直接返回 `NaN`\n第三个传入基数为 2，那么就是以 2 进制运算解析，但是二进制中只能为`1` or `0`,传入 `3` 为非法值，返回 `NaN`\n返回结果 `[1,NaN,NaN]`\n如何按照我们预期返回对应`Number`类型？\n\n```js\n['1', '2', '3'].map(num => parseInt(num, 10));\n```\n\n## 第 3 题：（挖财）什么是防抖和节流？有什么区别？如何实现？\n\n### 防抖\n\n触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间,简单来说就是避免事件频繁被调用\n\n思路\n每次触发高频操作后取消之前的延时调用\n\n```js\nfunction debounce(fn) {\n  let timer = null;\n  return function() {\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn.apply(this, arguments);\n    }, 500);\n  };\n}\nfunction doSomething() {\n  console.log('防抖成功了！');\n}\nconst inp = document.querySelector('#inp');\ninp.addEventListener('input', debounce(doSomething)); // 防抖\n```\n\n### 节流\n\n指定时间段内只允许程序调用一次\n\n思路\n每次调用之前判断是否超时，如未超时拒绝执行等待下次调用\n\n```js\nfunction throttle(fu, time = 500) {\n  let timer = null;\n  return function() {\n    if (timer) return;\n    setTimeout(() => {\n      fn.apply(this, arguments);\n      clearTimeout(timer);\n      timer = null;\n    }, time);\n  };\n}\n```\n","slug":"前端问答","published":1,"updated":"2019-09-12T11:40:01.495Z","layout":"post","photos":[],"link":"","_id":"ckmp269fn004nc8gsbtmybkit","content":"<blockquote>\n<p>声明：关于以下面试题收集来源 （壹题）<a href=\"https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md\">https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md</a> 答案综合了自己理解如有误区请帮忙指出，谢谢 😆</p>\n</blockquote>\n<h2 id=\"第-1-题：（滴滴、饿了么）写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？\"><a href=\"#第-1-题：（滴滴、饿了么）写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？\" class=\"headerlink\" title=\"第 1 题：（滴滴、饿了么）写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？\"></a>第 1 题：（滴滴、饿了么）写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h2><span id=\"more\"></span>\n\n<p>首先可以知道<code>React</code>/<code>Vue</code>都是基于 Vnode（虚拟节点）采用 <code>diff</code> 算法进行更新，通过 key 值绑定可以更快速，更准确拿到 oldVnode 中对应的 vnode 节点，提高 diff 效率。</p>\n<p>vue 部分源码解析</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// vue 项目 src/core/vdom/patch.js -488 行</span><br><span class=\"hljs-comment\">// 以下是为了阅读性进行格式化后的代码</span><br><br><span class=\"hljs-comment\">// oldCh 是一个旧虚拟节点数组</span><br><span class=\"hljs-keyword\">if</span> (isUndef(oldKeyToIdx)) &#123;<br>  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);<br>&#125;<br><span class=\"hljs-keyword\">if</span> (isDef(newStartVnode.key)) &#123;<br>  <span class=\"hljs-comment\">// map 方式获取</span><br>  idxInOld = oldKeyToIdx[newStartVnode.key];<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  <span class=\"hljs-comment\">// 遍历方式获取</span><br>  idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>创建 map 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createKeyToOldIdx</span>(<span class=\"hljs-params\">children, beginIdx, endIdx</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> i, key;<br>  <span class=\"hljs-keyword\">const</span> map = &#123;&#125;;<br>  <span class=\"hljs-keyword\">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;<br>    key = children[i].key;<br>    <span class=\"hljs-keyword\">if</span> (isDef(key)) map[key] = i;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>遍历寻找</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// sameVnode 是对比新旧节点是否相同的函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">findIdxInOld</span>(<span class=\"hljs-params\">node, oldCh, start, end</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = start; i &lt; end; i++) &#123;<br>    <span class=\"hljs-keyword\">const</span> c = oldCh[i];<br><br>    <span class=\"hljs-keyword\">if</span> (isDef(c) &amp;&amp; sameVnode(node, c)) <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>相对遍历查找 <code>map</code> 映射理论上更快速尤其在对比较大的数据量的时候效果就很明显了，还有一个就是数据更新时组件的强制更新，<br>以避免“原地复用”带来的副作用。</p>\n<p>总结一句就是，<code>key</code> 是可以更准确的，更快速的更新节点，而且不建议使用<code>index</code>做 <code>key</code>，因为每次索引都一样导致更新时候不会有任何效果</p>\n<h2 id=\"第-2-题：-‘1’-‘2’-‘3’-map-parseInt-what-amp-why\"><a href=\"#第-2-题：-‘1’-‘2’-‘3’-map-parseInt-what-amp-why\" class=\"headerlink\" title=\"第 2 题：[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?\"></a>第 2 题：[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?</h2><p>刚看到这个题目大部分人跟我一样都会下意识的认为返回值应该是<code>[1,2,3]</code>，好像哪里不对哈，我们一起一步一步分析来看<br>这个题主要考察的是 <code>map</code> 和 <code>parseInt</code> 传参</p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> new_array = arr.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callback</span>(<span class=\"hljs-params\">currentValue[,index[, array]]</span>) </span>&#123;<br> <span class=\"hljs-comment\">// Return element for new_array</span><br> &#125;[, thisArg])<br><span class=\"hljs-comment\">//  currentValue :当前值</span><br><span class=\"hljs-comment\">//  index : 索引值</span><br><span class=\"hljs-comment\">//  array : callback map 方法被调用的数组</span><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map\">MDN</a></p>\n<h3 id=\"parseInt\"><a href=\"#parseInt\" class=\"headerlink\" title=\"parseInt\"></a>parseInt</h3><p>parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> intValue = <span class=\"hljs-built_in\">parseInt</span>(string[, radix]);<br><span class=\"hljs-comment\">// string : 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。</span><br><span class=\"hljs-comment\">// radix : 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</span><br><span class=\"hljs-comment\">// 返回值 : 返回一个整数或NaN</span><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt\">MDN</a><br>温习了基础知识后简单分析一下，首先 <code>map</code> 函数传了 <code>parseInt</code> 作为回调函数，那么 <code>map</code> 的相关参数也就直接可以传入 <code>parseInt</code> 函数中，map 的 currentValue 作为<code>parseInt</code> 要被解析的字符串传入，第二个当前值的索引被当做<code>radix</code> 进制数传入，第三个参数忽略。<br>map 遍历大概执行了下面 3 个逻辑</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&#x27;1&#x27;</span>, <span class=\"hljs-number\">0</span>);<br><span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&#x27;2&#x27;</span>, <span class=\"hljs-number\">1</span>);<br><span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&#x27;3&#x27;</span>, <span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n\n<p>注意：<br>在 radix 为 undefined，或者 radix 为 0 或者没有指定的情况下，JavaScript 作如下处理：</p>\n<ul>\n<li>如果字符串 string 以”0x”或者”0X”开头, 则基数是 16 (16 进制).</li>\n<li>如果字符串 string 以”0”开头, 基数是 8（八进制）或者 10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用 10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出 radix 参数的值。</li>\n<li>如果字符串 string 以其它任何值开头，则基数是 10 (十进制)。`</li>\n</ul>\n<p>结论<br>第一个传入基数为 0 并且字符串没有以 <code>0</code> 或者 <code>0x</code> 开头，默认取 <code>10</code> 进制，那么返回值就是<code>Number</code> 1<br>第二个传入基数为 1 无效，直接返回 <code>NaN</code><br>第三个传入基数为 2，那么就是以 2 进制运算解析，但是二进制中只能为<code>1</code> or <code>0</code>,传入 <code>3</code> 为非法值，返回 <code>NaN</code><br>返回结果 <code>[1,NaN,NaN]</code><br>如何按照我们预期返回对应<code>Number</code>类型？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">[<span class=\"hljs-string\">&#x27;1&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>, <span class=\"hljs-string\">&#x27;3&#x27;</span>].map(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =&gt;</span> <span class=\"hljs-built_in\">parseInt</span>(num, <span class=\"hljs-number\">10</span>));<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"第-3-题：（挖财）什么是防抖和节流？有什么区别？如何实现？\"><a href=\"#第-3-题：（挖财）什么是防抖和节流？有什么区别？如何实现？\" class=\"headerlink\" title=\"第 3 题：（挖财）什么是防抖和节流？有什么区别？如何实现？\"></a>第 3 题：（挖财）什么是防抖和节流？有什么区别？如何实现？</h2><h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间,简单来说就是避免事件频繁被调用</p>\n<p>思路<br>每次触发高频操作后取消之前的延时调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">debounce</span>(<span class=\"hljs-params\">fn</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-literal\">null</span>;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">clearTimeout</span>(timer);<br>    timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      fn.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);<br>    &#125;, <span class=\"hljs-number\">500</span>);<br>  &#125;;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doSomething</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;防抖成功了！&#x27;</span>);<br>&#125;<br><span class=\"hljs-keyword\">const</span> inp = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;#inp&#x27;</span>);<br>inp.addEventListener(<span class=\"hljs-string\">&#x27;input&#x27;</span>, debounce(doSomething)); <span class=\"hljs-comment\">// 防抖</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>指定时间段内只允许程序调用一次</p>\n<p>思路<br>每次调用之前判断是否超时，如未超时拒绝执行等待下次调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">throttle</span>(<span class=\"hljs-params\">fu, time = <span class=\"hljs-number\">500</span></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-literal\">null</span>;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (timer) <span class=\"hljs-keyword\">return</span>;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      fn.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);<br>      <span class=\"hljs-built_in\">clearTimeout</span>(timer);<br>      timer = <span class=\"hljs-literal\">null</span>;<br>    &#125;, time);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<blockquote>\n<p>声明：关于以下面试题收集来源 （壹题）<a href=\"https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md\">https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md</a> 答案综合了自己理解如有误区请帮忙指出，谢谢 😆</p>\n</blockquote>\n<h2 id=\"第-1-题：（滴滴、饿了么）写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？\"><a href=\"#第-1-题：（滴滴、饿了么）写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？\" class=\"headerlink\" title=\"第 1 题：（滴滴、饿了么）写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？\"></a>第 1 题：（滴滴、饿了么）写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h2>","more":"<p>首先可以知道<code>React</code>/<code>Vue</code>都是基于 Vnode（虚拟节点）采用 <code>diff</code> 算法进行更新，通过 key 值绑定可以更快速，更准确拿到 oldVnode 中对应的 vnode 节点，提高 diff 效率。</p>\n<p>vue 部分源码解析</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// vue 项目 src/core/vdom/patch.js -488 行</span><br><span class=\"hljs-comment\">// 以下是为了阅读性进行格式化后的代码</span><br><br><span class=\"hljs-comment\">// oldCh 是一个旧虚拟节点数组</span><br><span class=\"hljs-keyword\">if</span> (isUndef(oldKeyToIdx)) &#123;<br>  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);<br>&#125;<br><span class=\"hljs-keyword\">if</span> (isDef(newStartVnode.key)) &#123;<br>  <span class=\"hljs-comment\">// map 方式获取</span><br>  idxInOld = oldKeyToIdx[newStartVnode.key];<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  <span class=\"hljs-comment\">// 遍历方式获取</span><br>  idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>创建 map 函数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">createKeyToOldIdx</span>(<span class=\"hljs-params\">children, beginIdx, endIdx</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> i, key;<br>  <span class=\"hljs-keyword\">const</span> map = &#123;&#125;;<br>  <span class=\"hljs-keyword\">for</span> (i = beginIdx; i &lt;= endIdx; ++i) &#123;<br>    key = children[i].key;<br>    <span class=\"hljs-keyword\">if</span> (isDef(key)) map[key] = i;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>遍历寻找</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// sameVnode 是对比新旧节点是否相同的函数</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">findIdxInOld</span>(<span class=\"hljs-params\">node, oldCh, start, end</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = start; i &lt; end; i++) &#123;<br>    <span class=\"hljs-keyword\">const</span> c = oldCh[i];<br><br>    <span class=\"hljs-keyword\">if</span> (isDef(c) &amp;&amp; sameVnode(node, c)) <span class=\"hljs-keyword\">return</span> i;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>相对遍历查找 <code>map</code> 映射理论上更快速尤其在对比较大的数据量的时候效果就很明显了，还有一个就是数据更新时组件的强制更新，<br>以避免“原地复用”带来的副作用。</p>\n<p>总结一句就是，<code>key</code> 是可以更准确的，更快速的更新节点，而且不建议使用<code>index</code>做 <code>key</code>，因为每次索引都一样导致更新时候不会有任何效果</p>\n<h2 id=\"第-2-题：-‘1’-‘2’-‘3’-map-parseInt-what-amp-why\"><a href=\"#第-2-题：-‘1’-‘2’-‘3’-map-parseInt-what-amp-why\" class=\"headerlink\" title=\"第 2 题：[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?\"></a>第 2 题：[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?</h2><p>刚看到这个题目大部分人跟我一样都会下意识的认为返回值应该是<code>[1,2,3]</code>，好像哪里不对哈，我们一起一步一步分析来看<br>这个题主要考察的是 <code>map</code> 和 <code>parseInt</code> 传参</p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> new_array = arr.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">callback</span>(<span class=\"hljs-params\">currentValue[,index[, array]]</span>) </span>&#123;<br> <span class=\"hljs-comment\">// Return element for new_array</span><br> &#125;[, thisArg])<br><span class=\"hljs-comment\">//  currentValue :当前值</span><br><span class=\"hljs-comment\">//  index : 索引值</span><br><span class=\"hljs-comment\">//  array : callback map 方法被调用的数组</span><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map\">MDN</a></p>\n<h3 id=\"parseInt\"><a href=\"#parseInt\" class=\"headerlink\" title=\"parseInt\"></a>parseInt</h3><p>parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> intValue = <span class=\"hljs-built_in\">parseInt</span>(string[, radix]);<br><span class=\"hljs-comment\">// string : 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。</span><br><span class=\"hljs-comment\">// radix : 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。如果该参数小于 2 或者大于 36，则 parseInt() 将返回 NaN。</span><br><span class=\"hljs-comment\">// 返回值 : 返回一个整数或NaN</span><br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt\">MDN</a><br>温习了基础知识后简单分析一下，首先 <code>map</code> 函数传了 <code>parseInt</code> 作为回调函数，那么 <code>map</code> 的相关参数也就直接可以传入 <code>parseInt</code> 函数中，map 的 currentValue 作为<code>parseInt</code> 要被解析的字符串传入，第二个当前值的索引被当做<code>radix</code> 进制数传入，第三个参数忽略。<br>map 遍历大概执行了下面 3 个逻辑</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&#x27;1&#x27;</span>, <span class=\"hljs-number\">0</span>);<br><span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&#x27;2&#x27;</span>, <span class=\"hljs-number\">1</span>);<br><span class=\"hljs-built_in\">parseInt</span>(<span class=\"hljs-string\">&#x27;3&#x27;</span>, <span class=\"hljs-number\">2</span>);<br></code></pre></td></tr></table></figure>\n\n<p>注意：<br>在 radix 为 undefined，或者 radix 为 0 或者没有指定的情况下，JavaScript 作如下处理：</p>\n<ul>\n<li>如果字符串 string 以”0x”或者”0X”开头, 则基数是 16 (16 进制).</li>\n<li>如果字符串 string 以”0”开头, 基数是 8（八进制）或者 10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用 10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出 radix 参数的值。</li>\n<li>如果字符串 string 以其它任何值开头，则基数是 10 (十进制)。`</li>\n</ul>\n<p>结论<br>第一个传入基数为 0 并且字符串没有以 <code>0</code> 或者 <code>0x</code> 开头，默认取 <code>10</code> 进制，那么返回值就是<code>Number</code> 1<br>第二个传入基数为 1 无效，直接返回 <code>NaN</code><br>第三个传入基数为 2，那么就是以 2 进制运算解析，但是二进制中只能为<code>1</code> or <code>0</code>,传入 <code>3</code> 为非法值，返回 <code>NaN</code><br>返回结果 <code>[1,NaN,NaN]</code><br>如何按照我们预期返回对应<code>Number</code>类型？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">[<span class=\"hljs-string\">&#x27;1&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>, <span class=\"hljs-string\">&#x27;3&#x27;</span>].map(<span class=\"hljs-function\"><span class=\"hljs-params\">num</span> =&gt;</span> <span class=\"hljs-built_in\">parseInt</span>(num, <span class=\"hljs-number\">10</span>));<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"第-3-题：（挖财）什么是防抖和节流？有什么区别？如何实现？\"><a href=\"#第-3-题：（挖财）什么是防抖和节流？有什么区别？如何实现？\" class=\"headerlink\" title=\"第 3 题：（挖财）什么是防抖和节流？有什么区别？如何实现？\"></a>第 3 题：（挖财）什么是防抖和节流？有什么区别？如何实现？</h2><h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间,简单来说就是避免事件频繁被调用</p>\n<p>思路<br>每次触发高频操作后取消之前的延时调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">debounce</span>(<span class=\"hljs-params\">fn</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-literal\">null</span>;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">clearTimeout</span>(timer);<br>    timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      fn.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);<br>    &#125;, <span class=\"hljs-number\">500</span>);<br>  &#125;;<br>&#125;<br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">doSomething</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;防抖成功了！&#x27;</span>);<br>&#125;<br><span class=\"hljs-keyword\">const</span> inp = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;#inp&#x27;</span>);<br>inp.addEventListener(<span class=\"hljs-string\">&#x27;input&#x27;</span>, debounce(doSomething)); <span class=\"hljs-comment\">// 防抖</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>指定时间段内只允许程序调用一次</p>\n<p>思路<br>每次调用之前判断是否超时，如未超时拒绝执行等待下次调用</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">throttle</span>(<span class=\"hljs-params\">fu, time = <span class=\"hljs-number\">500</span></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-literal\">null</span>;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">if</span> (timer) <span class=\"hljs-keyword\">return</span>;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      fn.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);<br>      <span class=\"hljs-built_in\">clearTimeout</span>(timer);<br>      timer = <span class=\"hljs-literal\">null</span>;<br>    &#125;, time);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"前端大厂面试问答[2]","comments":1,"toc":true,"date":"2019-09-17T11:26:50.000Z","thumbnail":null,"_content":"\n> 声明：关于以下面试题收集来源\n> [壹题](https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md) 答案综合了自己理解如有误区请帮忙指出，谢谢 😆\n\n## 第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？\n\n后面俩个我都没听过，没事问题不大，一起学习一下。\n\n`Set` 和 `Map` ,是`ES6` 提供的新数据结构\n\n<!-- more -->\n\n### Set\n\n它类似于数组，但是成员的值都是<b>唯一</b>的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。\n\n```js\nlet s = new Set();\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n// for...of 语句创建一个循环来迭代可迭代的对象。也是ES6新增 用来替代for-in（这里提一下forin会遍历到原型链的上非枚举属性）\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n### WeakSet\n\nWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。\n1.WeakSet 的成员`只能是对象`，而不能是其他类型的值。\n2.WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\n\n```js\nconst ws = new WeakSet();\nws.add(1);\n// TypeError: Invalid value used in weak set\nws.add(Symbol());\n// TypeError: invalid value used in weak set\n```\n\nWeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 `WeakSet 不可遍历`。\n!WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n### Map\n\n它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\n简单来说就是记录映射关系的集合\n\n```js\nconst m = new Map();\nconst o = { p: 'Hello World' };\n\nm.set(o, 'content');\nm.get(o); // \"content\"\n\nm.has(o); // true\nm.delete(o); // true\nm.has(o); // false\n```\n\n### WeakMap\n\nWeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。\n`WeakMap` 与 `Map` 的区别有两点。\n\n1.WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名\n2.WeakMap 的键名所指向的对象，不计入垃圾回收机制。(同 WeakSet 一个道理)\n\n```js\nconst wm = new WeakMap();\n\n// size、forEach、clear 方法都不存在\nwm.size; // undefined\nwm.forEach; // undefined\nwm.clear; // undefined\n```\n\n以上就是这几个函数的主要区别，暂不做深入讨论。\n\n## 第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？\n\n### 深度优先遍历 （DFS）\n\n深度优先遍历（Depth-First-Search），是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点 v 的所有边都已被探寻过，将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已探寻源节点到其他所有节点为止，如果还有未被发现的节点，则选择其中一个未被发现的节点为源节点并重复以上操作，直到所有节点都被探寻完成。\n\n※ 简单理解就是遍历完最近的所有子节点\n\n<font color=\"red\">注意：深度 DFS 属于盲目搜索，无法保证搜索到的路径为最短路径，也不是在搜索特定的路径，而是通过搜索来查看图中有哪些路径可以选择。</font>\n\n### 广度优先遍历（BFS）\n\n广度优先遍历（Breadth-First-Search）是从根节点开始，沿着图的宽度遍历节点，如果所有节点均被访问过，则算法终止，BFS 同样属于盲目搜索，一般用队列数据结构来辅助实现 BFS\n\nBFS 从一个节点开始，尝试访问尽可能靠近它的目标节点。本质上这种遍历在图上是逐层移动的，首先检查最靠近第一个节点的层，再逐渐向下移动到离起始节点最远的层\n\n※ 简单理解为按层级依次遍历完每层\n\n下面我们着手去试着简单实现一些\n\n```js\n// 一个模拟随机层级节点对象\nconst obj = {\n  a: {\n    a1: {\n      a11: {},\n      a12: {}\n    },\n    a2: {},\n    a3: {}\n  },\n  b: {\n    b1: {},\n    b2: {}\n    b3: {\n        b31:{}\n    }\n  },\n  c:{\n      c1:{}\n  }\n};\n```\n\n```js\n// 以下代码并非严谨，仅仅用于理解两种遍历算法\n// 深度优先遍历\nfunction dfs(obj) {\n  for (k of obj) {\n    const item = obj[k];\n    if (!!item && typeof item === 'object') {\n      dfs(item);\n    }\n  }\n}\n// 广度优先遍历\nfunction bfs(obj) {\n  let queue = [];\n  for (k of obj) {\n    const item = obj[k];\n    if (!!item && typeof item === 'object') {\n      queue.unshift(item);\n    }\n  }\n  queue.forEach(v => {\n    if (!!v && typeof v === 'object') {\n      bfs(v);\n    }\n  });\n}\n```\n\n## 第 6 期：请分别用深度优先思想和广度优先思想实现一个拷贝函数？\n\n那么结合上面 算法思路我想简单实现一些实际生产环境中遇到的问题，关于对象的深拷贝；\n\n```js\n// ================ 工具函数 ============\nconst TYPE_MAP = {\n  array: '[object Array]',\n  object: '[object Object]',\n  function: '[object Function]',\n  string: '[object String]',\n  null: '[object Null]',\n  undefined: '[object Undefined]',\n  boolean: '[object Boolean]',\n  number: '[object Number]'\n};\nconst _toString = function(obj) {\n  return Object.prototype.toString.call(obj);\n};\nconst isTypeof = function(obj, type = 'object') {\n  if (!TYPE_MAP[type]) throw new Error('传入类型不支持');\n  return _toString(obj) === TYPE_MAP[type];\n};\n// ====================================\nfunction dfsClone(obj) {\n  let newObj = {};\n  if (isTypeof(obj, 'object') || isTypeof(obj, 'array')) {\n    newObj = isTypeof(obj, 'array') ? [] : {};\n    for (k in obj) {\n      newObj[k] = dfsClone(obj[k]);\n    }\n  } else if (isTypeof(obj, 'function')) {\n    newObj = eval(`(${obj.toString()})`);\n  } else {\n    newObj = obj;\n  }\n  return newObj;\n}\n/**\n * 遍历首层对象\n * 依次判断每一项值是不是对象\n * 如果是，存入队列，继续走完当前层\n * 走完队列遍历，判断\n **/\n\nfunction bfsClone(obj) {\n  let newObj = {};\n  let queue = [];\n  let org = [obj];\n  // TODO 没写完大脑一片空白，兄弟们帮忙补一下\n  if (isTypeof(obj, 'object') || isTypeof(obj, 'array')) {\n    for (k in obj) {\n      newObj[k] = obj[k];\n      bfsClone(obj);\n    }\n  }\n}\n```\n\n未完待续。。。\n","source":"_posts/前端问答2.md","raw":"---\ntitle: 前端大厂面试问答[2]\ncomments: true\ntoc: true\ndate: 2019-09-17 19:26:50\ntags:\ncategories:\n- 大前端\n- 面试题类\nthumbnail:\n---\n\n> 声明：关于以下面试题收集来源\n> [壹题](https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md) 答案综合了自己理解如有误区请帮忙指出，谢谢 😆\n\n## 第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？\n\n后面俩个我都没听过，没事问题不大，一起学习一下。\n\n`Set` 和 `Map` ,是`ES6` 提供的新数据结构\n\n<!-- more -->\n\n### Set\n\n它类似于数组，但是成员的值都是<b>唯一</b>的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。\n\n```js\nlet s = new Set();\n[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));\n// for...of 语句创建一个循环来迭代可迭代的对象。也是ES6新增 用来替代for-in（这里提一下forin会遍历到原型链的上非枚举属性）\nfor (let i of s) {\n  console.log(i);\n}\n// 2 3 5 4\n```\n\n### WeakSet\n\nWeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。\n1.WeakSet 的成员`只能是对象`，而不能是其他类型的值。\n2.WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。\n\n```js\nconst ws = new WeakSet();\nws.add(1);\n// TypeError: Invalid value used in weak set\nws.add(Symbol());\n// TypeError: invalid value used in weak set\n```\n\nWeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 `WeakSet 不可遍历`。\n!WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。\n\n### Map\n\n它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。\n\n简单来说就是记录映射关系的集合\n\n```js\nconst m = new Map();\nconst o = { p: 'Hello World' };\n\nm.set(o, 'content');\nm.get(o); // \"content\"\n\nm.has(o); // true\nm.delete(o); // true\nm.has(o); // false\n```\n\n### WeakMap\n\nWeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。\n`WeakMap` 与 `Map` 的区别有两点。\n\n1.WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名\n2.WeakMap 的键名所指向的对象，不计入垃圾回收机制。(同 WeakSet 一个道理)\n\n```js\nconst wm = new WeakMap();\n\n// size、forEach、clear 方法都不存在\nwm.size; // undefined\nwm.forEach; // undefined\nwm.clear; // undefined\n```\n\n以上就是这几个函数的主要区别，暂不做深入讨论。\n\n## 第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？\n\n### 深度优先遍历 （DFS）\n\n深度优先遍历（Depth-First-Search），是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点 v 的所有边都已被探寻过，将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已探寻源节点到其他所有节点为止，如果还有未被发现的节点，则选择其中一个未被发现的节点为源节点并重复以上操作，直到所有节点都被探寻完成。\n\n※ 简单理解就是遍历完最近的所有子节点\n\n<font color=\"red\">注意：深度 DFS 属于盲目搜索，无法保证搜索到的路径为最短路径，也不是在搜索特定的路径，而是通过搜索来查看图中有哪些路径可以选择。</font>\n\n### 广度优先遍历（BFS）\n\n广度优先遍历（Breadth-First-Search）是从根节点开始，沿着图的宽度遍历节点，如果所有节点均被访问过，则算法终止，BFS 同样属于盲目搜索，一般用队列数据结构来辅助实现 BFS\n\nBFS 从一个节点开始，尝试访问尽可能靠近它的目标节点。本质上这种遍历在图上是逐层移动的，首先检查最靠近第一个节点的层，再逐渐向下移动到离起始节点最远的层\n\n※ 简单理解为按层级依次遍历完每层\n\n下面我们着手去试着简单实现一些\n\n```js\n// 一个模拟随机层级节点对象\nconst obj = {\n  a: {\n    a1: {\n      a11: {},\n      a12: {}\n    },\n    a2: {},\n    a3: {}\n  },\n  b: {\n    b1: {},\n    b2: {}\n    b3: {\n        b31:{}\n    }\n  },\n  c:{\n      c1:{}\n  }\n};\n```\n\n```js\n// 以下代码并非严谨，仅仅用于理解两种遍历算法\n// 深度优先遍历\nfunction dfs(obj) {\n  for (k of obj) {\n    const item = obj[k];\n    if (!!item && typeof item === 'object') {\n      dfs(item);\n    }\n  }\n}\n// 广度优先遍历\nfunction bfs(obj) {\n  let queue = [];\n  for (k of obj) {\n    const item = obj[k];\n    if (!!item && typeof item === 'object') {\n      queue.unshift(item);\n    }\n  }\n  queue.forEach(v => {\n    if (!!v && typeof v === 'object') {\n      bfs(v);\n    }\n  });\n}\n```\n\n## 第 6 期：请分别用深度优先思想和广度优先思想实现一个拷贝函数？\n\n那么结合上面 算法思路我想简单实现一些实际生产环境中遇到的问题，关于对象的深拷贝；\n\n```js\n// ================ 工具函数 ============\nconst TYPE_MAP = {\n  array: '[object Array]',\n  object: '[object Object]',\n  function: '[object Function]',\n  string: '[object String]',\n  null: '[object Null]',\n  undefined: '[object Undefined]',\n  boolean: '[object Boolean]',\n  number: '[object Number]'\n};\nconst _toString = function(obj) {\n  return Object.prototype.toString.call(obj);\n};\nconst isTypeof = function(obj, type = 'object') {\n  if (!TYPE_MAP[type]) throw new Error('传入类型不支持');\n  return _toString(obj) === TYPE_MAP[type];\n};\n// ====================================\nfunction dfsClone(obj) {\n  let newObj = {};\n  if (isTypeof(obj, 'object') || isTypeof(obj, 'array')) {\n    newObj = isTypeof(obj, 'array') ? [] : {};\n    for (k in obj) {\n      newObj[k] = dfsClone(obj[k]);\n    }\n  } else if (isTypeof(obj, 'function')) {\n    newObj = eval(`(${obj.toString()})`);\n  } else {\n    newObj = obj;\n  }\n  return newObj;\n}\n/**\n * 遍历首层对象\n * 依次判断每一项值是不是对象\n * 如果是，存入队列，继续走完当前层\n * 走完队列遍历，判断\n **/\n\nfunction bfsClone(obj) {\n  let newObj = {};\n  let queue = [];\n  let org = [obj];\n  // TODO 没写完大脑一片空白，兄弟们帮忙补一下\n  if (isTypeof(obj, 'object') || isTypeof(obj, 'array')) {\n    for (k in obj) {\n      newObj[k] = obj[k];\n      bfsClone(obj);\n    }\n  }\n}\n```\n\n未完待续。。。\n","slug":"前端问答2","published":1,"updated":"2019-10-10T11:47:47.228Z","layout":"post","photos":[],"link":"","_id":"ckmp269fo004oc8gsbi4jceop","content":"<blockquote>\n<p>声明：关于以下面试题收集来源<br><a href=\"https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md\">壹题</a> 答案综合了自己理解如有误区请帮忙指出，谢谢 😆</p>\n</blockquote>\n<h2 id=\"第-4-题：介绍下-Set、Map、WeakSet-和-WeakMap-的区别？\"><a href=\"#第-4-题：介绍下-Set、Map、WeakSet-和-WeakMap-的区别？\" class=\"headerlink\" title=\"第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？\"></a>第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</h2><p>后面俩个我都没听过，没事问题不大，一起学习一下。</p>\n<p><code>Set</code> 和 <code>Map</code> ,是<code>ES6</code> 提供的新数据结构</p>\n<span id=\"more\"></span>\n\n<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>它类似于数组，但是成员的值都是<b>唯一</b>的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();<br>[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>].forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> s.add(x));<br><span class=\"hljs-comment\">// for...of 语句创建一个循环来迭代可迭代的对象。也是ES6新增 用来替代for-in（这里提一下forin会遍历到原型链的上非枚举属性）</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> s) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(i);<br>&#125;<br><span class=\"hljs-comment\">// 2 3 5 4</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。<br>1.WeakSet 的成员<code>只能是对象</code>，而不能是其他类型的值。<br>2.WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakSet</span>();<br>ws.add(<span class=\"hljs-number\">1</span>);<br><span class=\"hljs-comment\">// TypeError: Invalid value used in weak set</span><br>ws.add(<span class=\"hljs-built_in\">Symbol</span>());<br><span class=\"hljs-comment\">// TypeError: invalid value used in weak set</span><br></code></pre></td></tr></table></figure>\n\n<p>WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <code>WeakSet 不可遍历</code>。<br>!WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<p>简单来说就是记录映射关系的集合</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();<br><span class=\"hljs-keyword\">const</span> o = &#123; <span class=\"hljs-attr\">p</span>: <span class=\"hljs-string\">&#x27;Hello World&#x27;</span> &#125;;<br><br>m.set(o, <span class=\"hljs-string\">&#x27;content&#x27;</span>);<br>m.get(o); <span class=\"hljs-comment\">// &quot;content&quot;</span><br><br>m.has(o); <span class=\"hljs-comment\">// true</span><br>m.delete(o); <span class=\"hljs-comment\">// true</span><br>m.has(o); <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。<br><code>WeakMap</code> 与 <code>Map</code> 的区别有两点。</p>\n<p>1.WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名<br>2.WeakMap 的键名所指向的对象，不计入垃圾回收机制。(同 WeakSet 一个道理)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> wm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>();<br><br><span class=\"hljs-comment\">// size、forEach、clear 方法都不存在</span><br>wm.size; <span class=\"hljs-comment\">// undefined</span><br>wm.forEach; <span class=\"hljs-comment\">// undefined</span><br>wm.clear; <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n\n<p>以上就是这几个函数的主要区别，暂不做深入讨论。</p>\n<h2 id=\"第-5-题：介绍下深度优先遍历和广度优先遍历，如何实现？\"><a href=\"#第-5-题：介绍下深度优先遍历和广度优先遍历，如何实现？\" class=\"headerlink\" title=\"第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？\"></a>第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？</h2><h3 id=\"深度优先遍历-（DFS）\"><a href=\"#深度优先遍历-（DFS）\" class=\"headerlink\" title=\"深度优先遍历 （DFS）\"></a>深度优先遍历 （DFS）</h3><p>深度优先遍历（Depth-First-Search），是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点 v 的所有边都已被探寻过，将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已探寻源节点到其他所有节点为止，如果还有未被发现的节点，则选择其中一个未被发现的节点为源节点并重复以上操作，直到所有节点都被探寻完成。</p>\n<p>※ 简单理解就是遍历完最近的所有子节点</p>\n<p><font color=\"red\">注意：深度 DFS 属于盲目搜索，无法保证搜索到的路径为最短路径，也不是在搜索特定的路径，而是通过搜索来查看图中有哪些路径可以选择。</font></p>\n<h3 id=\"广度优先遍历（BFS）\"><a href=\"#广度优先遍历（BFS）\" class=\"headerlink\" title=\"广度优先遍历（BFS）\"></a>广度优先遍历（BFS）</h3><p>广度优先遍历（Breadth-First-Search）是从根节点开始，沿着图的宽度遍历节点，如果所有节点均被访问过，则算法终止，BFS 同样属于盲目搜索，一般用队列数据结构来辅助实现 BFS</p>\n<p>BFS 从一个节点开始，尝试访问尽可能靠近它的目标节点。本质上这种遍历在图上是逐层移动的，首先检查最靠近第一个节点的层，再逐渐向下移动到离起始节点最远的层</p>\n<p>※ 简单理解为按层级依次遍历完每层</p>\n<p>下面我们着手去试着简单实现一些</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 一个模拟随机层级节点对象</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  a: &#123;<br>    a1: &#123;<br>      a11: &#123;&#125;,<br>      a12: &#123;&#125;<br>    &#125;,<br>    a2: &#123;&#125;,<br>    a3: &#123;&#125;<br>  &#125;,<br>  b: &#123;<br>    b1: &#123;&#125;,<br>    b2: &#123;&#125;<br>    b3: &#123;<br>        b31:&#123;&#125;<br>    &#125;<br>  &#125;,<br>  c:&#123;<br>      c1:&#123;&#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 以下代码并非严谨，仅仅用于理解两种遍历算法</span><br><span class=\"hljs-comment\">// 深度优先遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (k <span class=\"hljs-keyword\">of</span> obj) &#123;<br>    <span class=\"hljs-keyword\">const</span> item = obj[k];<br>    <span class=\"hljs-keyword\">if</span> (!!item &amp;&amp; <span class=\"hljs-keyword\">typeof</span> item === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>      dfs(item);<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 广度优先遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bfs</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> queue = [];<br>  <span class=\"hljs-keyword\">for</span> (k <span class=\"hljs-keyword\">of</span> obj) &#123;<br>    <span class=\"hljs-keyword\">const</span> item = obj[k];<br>    <span class=\"hljs-keyword\">if</span> (!!item &amp;&amp; <span class=\"hljs-keyword\">typeof</span> item === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>      queue.unshift(item);<br>    &#125;<br>  &#125;<br>  queue.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (!!v &amp;&amp; <span class=\"hljs-keyword\">typeof</span> v === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>      bfs(v);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"第-6-期：请分别用深度优先思想和广度优先思想实现一个拷贝函数？\"><a href=\"#第-6-期：请分别用深度优先思想和广度优先思想实现一个拷贝函数？\" class=\"headerlink\" title=\"第 6 期：请分别用深度优先思想和广度优先思想实现一个拷贝函数？\"></a>第 6 期：请分别用深度优先思想和广度优先思想实现一个拷贝函数？</h2><p>那么结合上面 算法思路我想简单实现一些实际生产环境中遇到的问题，关于对象的深拷贝；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ================ 工具函数 ============</span><br><span class=\"hljs-keyword\">const</span> TYPE_MAP = &#123;<br>  array: <span class=\"hljs-string\">&#x27;[object Array]&#x27;</span>,<br>  object: <span class=\"hljs-string\">&#x27;[object Object]&#x27;</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">Function</span>]&#x27;,</span><br><span class=\"hljs-function\">  <span class=\"hljs-title\">string</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">String</span>]&#x27;,</span><br><span class=\"hljs-function\">  <span class=\"hljs-title\">null</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">Null</span>]&#x27;,</span><br><span class=\"hljs-function\">  <span class=\"hljs-title\">undefined</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">Undefined</span>]&#x27;,</span><br><span class=\"hljs-function\">  <span class=\"hljs-title\">boolean</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">Boolean</span>]&#x27;,</span><br><span class=\"hljs-function\">  <span class=\"hljs-title\">number</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">Number</span>]&#x27;</span><br><span class=\"hljs-function\">&#125;</span>;<br><span class=\"hljs-keyword\">const</span> _toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj);<br>&#125;;<br><span class=\"hljs-keyword\">const</span> isTypeof = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">obj, type = <span class=\"hljs-string\">&#x27;object&#x27;</span></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!TYPE_MAP[type]) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;传入类型不支持&#x27;</span>);<br>  <span class=\"hljs-keyword\">return</span> _toString(obj) === TYPE_MAP[type];<br>&#125;;<br><span class=\"hljs-comment\">// ====================================</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfsClone</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> newObj = &#123;&#125;;<br>  <span class=\"hljs-keyword\">if</span> (isTypeof(obj, <span class=\"hljs-string\">&#x27;object&#x27;</span>) || isTypeof(obj, <span class=\"hljs-string\">&#x27;array&#x27;</span>)) &#123;<br>    newObj = isTypeof(obj, <span class=\"hljs-string\">&#x27;array&#x27;</span>) ? [] : &#123;&#125;;<br>    <span class=\"hljs-keyword\">for</span> (k <span class=\"hljs-keyword\">in</span> obj) &#123;<br>      newObj[k] = dfsClone(obj[k]);<br>    &#125;<br>  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isTypeof(obj, <span class=\"hljs-string\">&#x27;function&#x27;</span>)) &#123;<br>    newObj = <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">`(<span class=\"hljs-subst\">$&#123;obj.toString()&#125;</span>)`</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    newObj = obj;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> newObj;<br>&#125;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 遍历首层对象</span><br><span class=\"hljs-comment\"> * 依次判断每一项值是不是对象</span><br><span class=\"hljs-comment\"> * 如果是，存入队列，继续走完当前层</span><br><span class=\"hljs-comment\"> * 走完队列遍历，判断</span><br><span class=\"hljs-comment\"> **/</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bfsClone</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> newObj = &#123;&#125;;<br>  <span class=\"hljs-keyword\">let</span> queue = [];<br>  <span class=\"hljs-keyword\">let</span> org = [obj];<br>  <span class=\"hljs-comment\">// TODO 没写完大脑一片空白，兄弟们帮忙补一下</span><br>  <span class=\"hljs-keyword\">if</span> (isTypeof(obj, <span class=\"hljs-string\">&#x27;object&#x27;</span>) || isTypeof(obj, <span class=\"hljs-string\">&#x27;array&#x27;</span>)) &#123;<br>    <span class=\"hljs-keyword\">for</span> (k <span class=\"hljs-keyword\">in</span> obj) &#123;<br>      newObj[k] = obj[k];<br>      bfsClone(obj);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>未完待续。。。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<blockquote>\n<p>声明：关于以下面试题收集来源<br><a href=\"https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md\">壹题</a> 答案综合了自己理解如有误区请帮忙指出，谢谢 😆</p>\n</blockquote>\n<h2 id=\"第-4-题：介绍下-Set、Map、WeakSet-和-WeakMap-的区别？\"><a href=\"#第-4-题：介绍下-Set、Map、WeakSet-和-WeakMap-的区别？\" class=\"headerlink\" title=\"第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？\"></a>第 4 题：介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</h2><p>后面俩个我都没听过，没事问题不大，一起学习一下。</p>\n<p><code>Set</code> 和 <code>Map</code> ,是<code>ES6</code> 提供的新数据结构</p>","more":"<h3 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h3><p>它类似于数组，但是成员的值都是<b>唯一</b>的，没有重复的值。Set 本身是一个构造函数，用来生成 Set 数据结构。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>();<br>[<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>].forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> s.add(x));<br><span class=\"hljs-comment\">// for...of 语句创建一个循环来迭代可迭代的对象。也是ES6新增 用来替代for-in（这里提一下forin会遍历到原型链的上非枚举属性）</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i <span class=\"hljs-keyword\">of</span> s) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(i);<br>&#125;<br><span class=\"hljs-comment\">// 2 3 5 4</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"WeakSet\"><a href=\"#WeakSet\" class=\"headerlink\" title=\"WeakSet\"></a>WeakSet</h3><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。<br>1.WeakSet 的成员<code>只能是对象</code>，而不能是其他类型的值。<br>2.WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> ws = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakSet</span>();<br>ws.add(<span class=\"hljs-number\">1</span>);<br><span class=\"hljs-comment\">// TypeError: Invalid value used in weak set</span><br>ws.add(<span class=\"hljs-built_in\">Symbol</span>());<br><span class=\"hljs-comment\">// TypeError: invalid value used in weak set</span><br></code></pre></td></tr></table></figure>\n\n<p>WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <code>WeakSet 不可遍历</code>。<br>!WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p>它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p>\n<p>简单来说就是记录映射关系的集合</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>();<br><span class=\"hljs-keyword\">const</span> o = &#123; <span class=\"hljs-attr\">p</span>: <span class=\"hljs-string\">&#x27;Hello World&#x27;</span> &#125;;<br><br>m.set(o, <span class=\"hljs-string\">&#x27;content&#x27;</span>);<br>m.get(o); <span class=\"hljs-comment\">// &quot;content&quot;</span><br><br>m.has(o); <span class=\"hljs-comment\">// true</span><br>m.delete(o); <span class=\"hljs-comment\">// true</span><br>m.has(o); <span class=\"hljs-comment\">// false</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"WeakMap\"><a href=\"#WeakMap\" class=\"headerlink\" title=\"WeakMap\"></a>WeakMap</h3><p>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。<br><code>WeakMap</code> 与 <code>Map</code> 的区别有两点。</p>\n<p>1.WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名<br>2.WeakMap 的键名所指向的对象，不计入垃圾回收机制。(同 WeakSet 一个道理)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> wm = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakMap</span>();<br><br><span class=\"hljs-comment\">// size、forEach、clear 方法都不存在</span><br>wm.size; <span class=\"hljs-comment\">// undefined</span><br>wm.forEach; <span class=\"hljs-comment\">// undefined</span><br>wm.clear; <span class=\"hljs-comment\">// undefined</span><br></code></pre></td></tr></table></figure>\n\n<p>以上就是这几个函数的主要区别，暂不做深入讨论。</p>\n<h2 id=\"第-5-题：介绍下深度优先遍历和广度优先遍历，如何实现？\"><a href=\"#第-5-题：介绍下深度优先遍历和广度优先遍历，如何实现？\" class=\"headerlink\" title=\"第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？\"></a>第 5 题：介绍下深度优先遍历和广度优先遍历，如何实现？</h2><h3 id=\"深度优先遍历-（DFS）\"><a href=\"#深度优先遍历-（DFS）\" class=\"headerlink\" title=\"深度优先遍历 （DFS）\"></a>深度优先遍历 （DFS）</h3><p>深度优先遍历（Depth-First-Search），是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点 v 的所有边都已被探寻过，将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已探寻源节点到其他所有节点为止，如果还有未被发现的节点，则选择其中一个未被发现的节点为源节点并重复以上操作，直到所有节点都被探寻完成。</p>\n<p>※ 简单理解就是遍历完最近的所有子节点</p>\n<p><font color=\"red\">注意：深度 DFS 属于盲目搜索，无法保证搜索到的路径为最短路径，也不是在搜索特定的路径，而是通过搜索来查看图中有哪些路径可以选择。</font></p>\n<h3 id=\"广度优先遍历（BFS）\"><a href=\"#广度优先遍历（BFS）\" class=\"headerlink\" title=\"广度优先遍历（BFS）\"></a>广度优先遍历（BFS）</h3><p>广度优先遍历（Breadth-First-Search）是从根节点开始，沿着图的宽度遍历节点，如果所有节点均被访问过，则算法终止，BFS 同样属于盲目搜索，一般用队列数据结构来辅助实现 BFS</p>\n<p>BFS 从一个节点开始，尝试访问尽可能靠近它的目标节点。本质上这种遍历在图上是逐层移动的，首先检查最靠近第一个节点的层，再逐渐向下移动到离起始节点最远的层</p>\n<p>※ 简单理解为按层级依次遍历完每层</p>\n<p>下面我们着手去试着简单实现一些</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 一个模拟随机层级节点对象</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  a: &#123;<br>    a1: &#123;<br>      a11: &#123;&#125;,<br>      a12: &#123;&#125;<br>    &#125;,<br>    a2: &#123;&#125;,<br>    a3: &#123;&#125;<br>  &#125;,<br>  b: &#123;<br>    b1: &#123;&#125;,<br>    b2: &#123;&#125;<br>    b3: &#123;<br>        b31:&#123;&#125;<br>    &#125;<br>  &#125;,<br>  c:&#123;<br>      c1:&#123;&#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 以下代码并非严谨，仅仅用于理解两种遍历算法</span><br><span class=\"hljs-comment\">// 深度优先遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfs</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">for</span> (k <span class=\"hljs-keyword\">of</span> obj) &#123;<br>    <span class=\"hljs-keyword\">const</span> item = obj[k];<br>    <span class=\"hljs-keyword\">if</span> (!!item &amp;&amp; <span class=\"hljs-keyword\">typeof</span> item === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>      dfs(item);<br>    &#125;<br>  &#125;<br>&#125;<br><span class=\"hljs-comment\">// 广度优先遍历</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bfs</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> queue = [];<br>  <span class=\"hljs-keyword\">for</span> (k <span class=\"hljs-keyword\">of</span> obj) &#123;<br>    <span class=\"hljs-keyword\">const</span> item = obj[k];<br>    <span class=\"hljs-keyword\">if</span> (!!item &amp;&amp; <span class=\"hljs-keyword\">typeof</span> item === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>      queue.unshift(item);<br>    &#125;<br>  &#125;<br>  queue.forEach(<span class=\"hljs-function\"><span class=\"hljs-params\">v</span> =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (!!v &amp;&amp; <span class=\"hljs-keyword\">typeof</span> v === <span class=\"hljs-string\">&#x27;object&#x27;</span>) &#123;<br>      bfs(v);<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"第-6-期：请分别用深度优先思想和广度优先思想实现一个拷贝函数？\"><a href=\"#第-6-期：请分别用深度优先思想和广度优先思想实现一个拷贝函数？\" class=\"headerlink\" title=\"第 6 期：请分别用深度优先思想和广度优先思想实现一个拷贝函数？\"></a>第 6 期：请分别用深度优先思想和广度优先思想实现一个拷贝函数？</h2><p>那么结合上面 算法思路我想简单实现一些实际生产环境中遇到的问题，关于对象的深拷贝；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// ================ 工具函数 ============</span><br><span class=\"hljs-keyword\">const</span> TYPE_MAP = &#123;<br>  array: <span class=\"hljs-string\">&#x27;[object Array]&#x27;</span>,<br>  object: <span class=\"hljs-string\">&#x27;[object Object]&#x27;</span>,<br>  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">Function</span>]&#x27;,</span><br><span class=\"hljs-function\">  <span class=\"hljs-title\">string</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">String</span>]&#x27;,</span><br><span class=\"hljs-function\">  <span class=\"hljs-title\">null</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">Null</span>]&#x27;,</span><br><span class=\"hljs-function\">  <span class=\"hljs-title\">undefined</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">Undefined</span>]&#x27;,</span><br><span class=\"hljs-function\">  <span class=\"hljs-title\">boolean</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">Boolean</span>]&#x27;,</span><br><span class=\"hljs-function\">  <span class=\"hljs-title\">number</span>: &#x27;[<span class=\"hljs-title\">object</span> <span class=\"hljs-title\">Number</span>]&#x27;</span><br><span class=\"hljs-function\">&#125;</span>;<br><span class=\"hljs-keyword\">const</span> _toString = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Object</span>.prototype.toString.call(obj);<br>&#125;;<br><span class=\"hljs-keyword\">const</span> isTypeof = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">obj, type = <span class=\"hljs-string\">&#x27;object&#x27;</span></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!TYPE_MAP[type]) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Error</span>(<span class=\"hljs-string\">&#x27;传入类型不支持&#x27;</span>);<br>  <span class=\"hljs-keyword\">return</span> _toString(obj) === TYPE_MAP[type];<br>&#125;;<br><span class=\"hljs-comment\">// ====================================</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dfsClone</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> newObj = &#123;&#125;;<br>  <span class=\"hljs-keyword\">if</span> (isTypeof(obj, <span class=\"hljs-string\">&#x27;object&#x27;</span>) || isTypeof(obj, <span class=\"hljs-string\">&#x27;array&#x27;</span>)) &#123;<br>    newObj = isTypeof(obj, <span class=\"hljs-string\">&#x27;array&#x27;</span>) ? [] : &#123;&#125;;<br>    <span class=\"hljs-keyword\">for</span> (k <span class=\"hljs-keyword\">in</span> obj) &#123;<br>      newObj[k] = dfsClone(obj[k]);<br>    &#125;<br>  &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (isTypeof(obj, <span class=\"hljs-string\">&#x27;function&#x27;</span>)) &#123;<br>    newObj = <span class=\"hljs-built_in\">eval</span>(<span class=\"hljs-string\">`(<span class=\"hljs-subst\">$&#123;obj.toString()&#125;</span>)`</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    newObj = obj;<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> newObj;<br>&#125;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 遍历首层对象</span><br><span class=\"hljs-comment\"> * 依次判断每一项值是不是对象</span><br><span class=\"hljs-comment\"> * 如果是，存入队列，继续走完当前层</span><br><span class=\"hljs-comment\"> * 走完队列遍历，判断</span><br><span class=\"hljs-comment\"> **/</span><br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bfsClone</span>(<span class=\"hljs-params\">obj</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">let</span> newObj = &#123;&#125;;<br>  <span class=\"hljs-keyword\">let</span> queue = [];<br>  <span class=\"hljs-keyword\">let</span> org = [obj];<br>  <span class=\"hljs-comment\">// TODO 没写完大脑一片空白，兄弟们帮忙补一下</span><br>  <span class=\"hljs-keyword\">if</span> (isTypeof(obj, <span class=\"hljs-string\">&#x27;object&#x27;</span>) || isTypeof(obj, <span class=\"hljs-string\">&#x27;array&#x27;</span>)) &#123;<br>    <span class=\"hljs-keyword\">for</span> (k <span class=\"hljs-keyword\">in</span> obj) &#123;<br>      newObj[k] = obj[k];<br>      bfsClone(obj);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>未完待续。。。</p>"},{"title":"微信小程序云开发初体验","comments":1,"toc":true,"date":"2019-11-20T06:57:35.000Z","thumbnail":"http://img.v5ant.com/images/2019/11/20/59642964509d5.jpg","_content":"\n> 云开发简单来说是配合微信小程序开发的一个弱后后端逻辑的一个东西，就是你不需要要再招一个 PHP，go，Java 这些程序员，前端就可以搞的，当然前端也需要一定的入门，需要了解非关系数据库中的集合，字段查询等等\n\n<!-- more -->\n\n## 了解云开发\n\n云开发提供了 `4` 大块云端能力\n\n| 能力   | 作用               | 说明                                                                         |\n| ------ | ------------------ | ---------------------------------------------------------------------------- |\n| 云函数 | 无需自建服务器     | 在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码       |\n| 数据库 | 无需自建数据库     | 一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库                   |\n| 存储   | 无需自建存储和 CDN | 在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理                  |\n| 云调用 | 原生微信服务集成   | 基于云函数免鉴权使用小程序开放接口的能力，包括服务端调用、获取开放数据等能力 |\n\n## 配置云开发环境\n\n基本配置官方介绍的十分详细，建议尽量看官方文章[教程入口](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/quickstart.html#_1-%E6%96%B0%E5%BB%BA%E4%BA%91%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF)\n\n以下是我尝试开发的租房小小管家的云开发目录配置，初始化生成的文件我都删掉了，里面这个五个目录都是新增的\n[![WX20191120-1643192x.md.png](http://img.v5ant.com/images/2019/11/20/WX20191120-1643192x.md.png)](http://img.v5ant.com/image/C0Y)\n每个云函数都需要调用`wx-server-sdk`这个包，注意需要安装一遍`npm install` 再全部上传云端，后面就不需要选择全部上传（包含 node_modules）\n\n```javascript\n// 云函数入口文件\nconst cloud = require('wx-server-sdk');\n\ncloud.init({\n  traceUser: true,\n  env: 'fast-nav-xxx'\n});\n// env是你的云开发环境标识\n```\n\n使用用函数调用的好处在于所有鉴权工作都交给了微信去处理，安全且方便，而且比在小程序前端直接调用云 `API` 权限要高很多，可以直接拿到用户的 openID,所有我推荐这类使用\n\n## 云函数的简单对接写法\n\n下面是我自己一个云函数写法，因为是第一次也不晓得怎么写比较合理，所有有大神觉得哪里不合理帮我提出来 😆\n\n```javascript\n// 云函数入口文件\n// 云函数入口文件\nconst cloud = require('wx-server-sdk');\nconst md5 = require('md5-node');\n\ncloud.init({\n  traceUser: true,\n  env: 'fast-nav-xxx'\n});\nconst db = cloud.database();\nconst _ = db.command;\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const wxContext = cloud.getWXContext();\n  switch (event.handle) {\n    case 'get':\n      return handlerGet(event, context, wxContext);\n    case 'set':\n      return handlerSet(event, context, wxContext);\n    case 'update':\n      return handlerUpdate(event, context, wxContext);\n    case 'delete':\n      return handlerDelete(event, context, wxContext);\n  }\n};\n```\n\n通过函数参数`handle`控制不同的具体操作接口，参数的话也通过 `event.data` 拿到,到这来简单的云函数完成，然后鼠标右键上传云端\n\n## 小程序端的请求调用\n\n首先小程序端 `app.js` 中需要授权初始化\n\n```javascript\n   /**\n   * 检查云开发环境并初始化\n   */\n  onLaunch: function() {\n    if (!wx.cloud) {\n      console.error('请使用 2.2.3 或以上的基础库以使用云能力');\n    } else {\n      //云开发初始化\n      wx.cloud.init({\n        env: 'fast-nav-xxx',\n        traceUser: true\n      });\n    }}\n```\n\n小程序端通过 `wx.cloud.callFunction`方法进行云函数调用请求，我们可以理解为`ajax`,需要注意的是调整接口的时候就不能去之前`xhr`里面查看了,需要去`cloud`分类里面，如下图\n\n[![WX20191120-1708272x.md.png](http://img.v5ant.com/images/2019/11/20/WX20191120-1708272x.md.png)](http://img.v5ant.com/image/RxZ)\n\n下面是我封装的一个简单的接口 `API`\n\n```javascript\nexport const apiCloud = function(name, data = {}) {\n  return new Promise((resolve, reject) => {\n    wx.cloud.callFunction({\n      name,\n      data,\n      success: res => {\n        if (res.errMsg == 'cloud.callFunction:ok') {\n          resolve(res);\n        } else {\n          reject(err);\n          wx.showToast({\n            title: err.msg,\n            duration: 800,\n            icon: 'none'\n          });\n        }\n      },\n      fail: err => {\n        reject(err);\n        wx.showToast({\n          title: '请检查网络您的状态',\n          duration: 800,\n          icon: 'none'\n        });\n      }\n    });\n  });\n};\n```\n\n调用方式为 `apiCloud('house', { handle: 'get', data })`，apiCloud 返回的是一个`promise`对象 可以使用 `then-catch` 或者 `async-await` 接收\n\n以上为云开发和小程序端接口交互的一些案例，后面我们再学习一下关于云开发中，查数据库，取集合的操作\n\n[![gh_225bd06d4e02_258.jpg](http://img.v5ant.com/images/2019/11/20/gh_225bd06d4e02_258.jpg)](http://img.v5ant.com/image/zFN)\n\n欢迎浏览我的小程序：`租房小小管家`，有问题或者这好的建议请与我联系，留言。\n","source":"_posts/微信小程序云开发初体验.md","raw":"---\ntitle: 微信小程序云开发初体验\ncomments: true\ntoc: true\ndate: 2019-11-20 14:57:35\ntags:\n  - 微信小程序\n  - 云开发\ncategories:\n  - 大前端\n  - 微信小程序\nthumbnail: http://img.v5ant.com/images/2019/11/20/59642964509d5.jpg\n---\n\n> 云开发简单来说是配合微信小程序开发的一个弱后后端逻辑的一个东西，就是你不需要要再招一个 PHP，go，Java 这些程序员，前端就可以搞的，当然前端也需要一定的入门，需要了解非关系数据库中的集合，字段查询等等\n\n<!-- more -->\n\n## 了解云开发\n\n云开发提供了 `4` 大块云端能力\n\n| 能力   | 作用               | 说明                                                                         |\n| ------ | ------------------ | ---------------------------------------------------------------------------- |\n| 云函数 | 无需自建服务器     | 在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码       |\n| 数据库 | 无需自建数据库     | 一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库                   |\n| 存储   | 无需自建存储和 CDN | 在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理                  |\n| 云调用 | 原生微信服务集成   | 基于云函数免鉴权使用小程序开放接口的能力，包括服务端调用、获取开放数据等能力 |\n\n## 配置云开发环境\n\n基本配置官方介绍的十分详细，建议尽量看官方文章[教程入口](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/quickstart.html#_1-%E6%96%B0%E5%BB%BA%E4%BA%91%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF)\n\n以下是我尝试开发的租房小小管家的云开发目录配置，初始化生成的文件我都删掉了，里面这个五个目录都是新增的\n[![WX20191120-1643192x.md.png](http://img.v5ant.com/images/2019/11/20/WX20191120-1643192x.md.png)](http://img.v5ant.com/image/C0Y)\n每个云函数都需要调用`wx-server-sdk`这个包，注意需要安装一遍`npm install` 再全部上传云端，后面就不需要选择全部上传（包含 node_modules）\n\n```javascript\n// 云函数入口文件\nconst cloud = require('wx-server-sdk');\n\ncloud.init({\n  traceUser: true,\n  env: 'fast-nav-xxx'\n});\n// env是你的云开发环境标识\n```\n\n使用用函数调用的好处在于所有鉴权工作都交给了微信去处理，安全且方便，而且比在小程序前端直接调用云 `API` 权限要高很多，可以直接拿到用户的 openID,所有我推荐这类使用\n\n## 云函数的简单对接写法\n\n下面是我自己一个云函数写法，因为是第一次也不晓得怎么写比较合理，所有有大神觉得哪里不合理帮我提出来 😆\n\n```javascript\n// 云函数入口文件\n// 云函数入口文件\nconst cloud = require('wx-server-sdk');\nconst md5 = require('md5-node');\n\ncloud.init({\n  traceUser: true,\n  env: 'fast-nav-xxx'\n});\nconst db = cloud.database();\nconst _ = db.command;\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const wxContext = cloud.getWXContext();\n  switch (event.handle) {\n    case 'get':\n      return handlerGet(event, context, wxContext);\n    case 'set':\n      return handlerSet(event, context, wxContext);\n    case 'update':\n      return handlerUpdate(event, context, wxContext);\n    case 'delete':\n      return handlerDelete(event, context, wxContext);\n  }\n};\n```\n\n通过函数参数`handle`控制不同的具体操作接口，参数的话也通过 `event.data` 拿到,到这来简单的云函数完成，然后鼠标右键上传云端\n\n## 小程序端的请求调用\n\n首先小程序端 `app.js` 中需要授权初始化\n\n```javascript\n   /**\n   * 检查云开发环境并初始化\n   */\n  onLaunch: function() {\n    if (!wx.cloud) {\n      console.error('请使用 2.2.3 或以上的基础库以使用云能力');\n    } else {\n      //云开发初始化\n      wx.cloud.init({\n        env: 'fast-nav-xxx',\n        traceUser: true\n      });\n    }}\n```\n\n小程序端通过 `wx.cloud.callFunction`方法进行云函数调用请求，我们可以理解为`ajax`,需要注意的是调整接口的时候就不能去之前`xhr`里面查看了,需要去`cloud`分类里面，如下图\n\n[![WX20191120-1708272x.md.png](http://img.v5ant.com/images/2019/11/20/WX20191120-1708272x.md.png)](http://img.v5ant.com/image/RxZ)\n\n下面是我封装的一个简单的接口 `API`\n\n```javascript\nexport const apiCloud = function(name, data = {}) {\n  return new Promise((resolve, reject) => {\n    wx.cloud.callFunction({\n      name,\n      data,\n      success: res => {\n        if (res.errMsg == 'cloud.callFunction:ok') {\n          resolve(res);\n        } else {\n          reject(err);\n          wx.showToast({\n            title: err.msg,\n            duration: 800,\n            icon: 'none'\n          });\n        }\n      },\n      fail: err => {\n        reject(err);\n        wx.showToast({\n          title: '请检查网络您的状态',\n          duration: 800,\n          icon: 'none'\n        });\n      }\n    });\n  });\n};\n```\n\n调用方式为 `apiCloud('house', { handle: 'get', data })`，apiCloud 返回的是一个`promise`对象 可以使用 `then-catch` 或者 `async-await` 接收\n\n以上为云开发和小程序端接口交互的一些案例，后面我们再学习一下关于云开发中，查数据库，取集合的操作\n\n[![gh_225bd06d4e02_258.jpg](http://img.v5ant.com/images/2019/11/20/gh_225bd06d4e02_258.jpg)](http://img.v5ant.com/image/zFN)\n\n欢迎浏览我的小程序：`租房小小管家`，有问题或者这好的建议请与我联系，留言。\n","slug":"微信小程序云开发初体验","published":1,"updated":"2019-11-20T10:02:32.738Z","layout":"post","photos":[],"link":"","_id":"ckmp269fq004qc8gs96y725vd","content":"<blockquote>\n<p>云开发简单来说是配合微信小程序开发的一个弱后后端逻辑的一个东西，就是你不需要要再招一个 PHP，go，Java 这些程序员，前端就可以搞的，当然前端也需要一定的入门，需要了解非关系数据库中的集合，字段查询等等</p>\n</blockquote>\n<span id=\"more\"></span>\n\n<h2 id=\"了解云开发\"><a href=\"#了解云开发\" class=\"headerlink\" title=\"了解云开发\"></a>了解云开发</h2><p>云开发提供了 <code>4</code> 大块云端能力</p>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>作用</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>云函数</td>\n<td>无需自建服务器</td>\n<td>在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码</td>\n</tr>\n<tr>\n<td>数据库</td>\n<td>无需自建数据库</td>\n<td>一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库</td>\n</tr>\n<tr>\n<td>存储</td>\n<td>无需自建存储和 CDN</td>\n<td>在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理</td>\n</tr>\n<tr>\n<td>云调用</td>\n<td>原生微信服务集成</td>\n<td>基于云函数免鉴权使用小程序开放接口的能力，包括服务端调用、获取开放数据等能力</td>\n</tr>\n</tbody></table>\n<h2 id=\"配置云开发环境\"><a href=\"#配置云开发环境\" class=\"headerlink\" title=\"配置云开发环境\"></a>配置云开发环境</h2><p>基本配置官方介绍的十分详细，建议尽量看官方文章<a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/quickstart.html#_1-%E6%96%B0%E5%BB%BA%E4%BA%91%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF\">教程入口</a></p>\n<p>以下是我尝试开发的租房小小管家的云开发目录配置，初始化生成的文件我都删掉了，里面这个五个目录都是新增的<br><a href=\"http://img.v5ant.com/image/C0Y\"><img src=\"http://img.v5ant.com/images/2019/11/20/WX20191120-1643192x.md.png\" alt=\"WX20191120-1643192x.md.png\"></a><br>每个云函数都需要调用<code>wx-server-sdk</code>这个包，注意需要安装一遍<code>npm install</code> 再全部上传云端，后面就不需要选择全部上传（包含 node_modules）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 云函数入口文件</span><br><span class=\"hljs-keyword\">const</span> cloud = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;wx-server-sdk&#x27;</span>);<br><br>cloud.init(&#123;<br>  traceUser: <span class=\"hljs-literal\">true</span>,<br>  env: <span class=\"hljs-string\">&#x27;fast-nav-xxx&#x27;</span><br>&#125;);<br><span class=\"hljs-comment\">// env是你的云开发环境标识</span><br></code></pre></td></tr></table></figure>\n\n<p>使用用函数调用的好处在于所有鉴权工作都交给了微信去处理，安全且方便，而且比在小程序前端直接调用云 <code>API</code> 权限要高很多，可以直接拿到用户的 openID,所有我推荐这类使用</p>\n<h2 id=\"云函数的简单对接写法\"><a href=\"#云函数的简单对接写法\" class=\"headerlink\" title=\"云函数的简单对接写法\"></a>云函数的简单对接写法</h2><p>下面是我自己一个云函数写法，因为是第一次也不晓得怎么写比较合理，所有有大神觉得哪里不合理帮我提出来 😆</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 云函数入口文件</span><br><span class=\"hljs-comment\">// 云函数入口文件</span><br><span class=\"hljs-keyword\">const</span> cloud = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;wx-server-sdk&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> md5 = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;md5-node&#x27;</span>);<br><br>cloud.init(&#123;<br>  traceUser: <span class=\"hljs-literal\">true</span>,<br>  env: <span class=\"hljs-string\">&#x27;fast-nav-xxx&#x27;</span><br>&#125;);<br><span class=\"hljs-keyword\">const</span> db = cloud.database();<br><span class=\"hljs-keyword\">const</span> _ = db.command;<br><span class=\"hljs-comment\">// 云函数入口函数</span><br><span class=\"hljs-built_in\">exports</span>.main = <span class=\"hljs-keyword\">async</span> (event, context) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> wxContext = cloud.getWXContext();<br>  <span class=\"hljs-keyword\">switch</span> (event.handle) &#123;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;get&#x27;</span>:<br>      <span class=\"hljs-keyword\">return</span> handlerGet(event, context, wxContext);<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;set&#x27;</span>:<br>      <span class=\"hljs-keyword\">return</span> handlerSet(event, context, wxContext);<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;update&#x27;</span>:<br>      <span class=\"hljs-keyword\">return</span> handlerUpdate(event, context, wxContext);<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;delete&#x27;</span>:<br>      <span class=\"hljs-keyword\">return</span> handlerDelete(event, context, wxContext);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>通过函数参数<code>handle</code>控制不同的具体操作接口，参数的话也通过 <code>event.data</code> 拿到,到这来简单的云函数完成，然后鼠标右键上传云端</p>\n<h2 id=\"小程序端的请求调用\"><a href=\"#小程序端的请求调用\" class=\"headerlink\" title=\"小程序端的请求调用\"></a>小程序端的请求调用</h2><p>首先小程序端 <code>app.js</code> 中需要授权初始化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"> <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 检查云开发环境并初始化</span><br><span class=\"hljs-comment\"> */</span><br>onLaunch: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!wx.cloud) &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&#x27;请使用 2.2.3 或以上的基础库以使用云能力&#x27;</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">//云开发初始化</span><br>    wx.cloud.init(&#123;<br>      env: <span class=\"hljs-string\">&#x27;fast-nav-xxx&#x27;</span>,<br>      traceUser: <span class=\"hljs-literal\">true</span><br>    &#125;);<br>  &#125;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>小程序端通过 <code>wx.cloud.callFunction</code>方法进行云函数调用请求，我们可以理解为<code>ajax</code>,需要注意的是调整接口的时候就不能去之前<code>xhr</code>里面查看了,需要去<code>cloud</code>分类里面，如下图</p>\n<p><a href=\"http://img.v5ant.com/image/RxZ\"><img src=\"http://img.v5ant.com/images/2019/11/20/WX20191120-1708272x.md.png\" alt=\"WX20191120-1708272x.md.png\"></a></p>\n<p>下面是我封装的一个简单的接口 <code>API</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> apiCloud = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name, data = &#123;&#125;</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    wx.cloud.callFunction(&#123;<br>      name,<br>      data,<br>      success: <span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (res.errMsg == <span class=\"hljs-string\">&#x27;cloud.callFunction:ok&#x27;</span>) &#123;<br>          resolve(res);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>          reject(err);<br>          wx.showToast(&#123;<br>            title: err.msg,<br>            duration: <span class=\"hljs-number\">800</span>,<br>            icon: <span class=\"hljs-string\">&#x27;none&#x27;</span><br>          &#125;);<br>        &#125;<br>      &#125;,<br>      fail: <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;<br>        reject(err);<br>        wx.showToast(&#123;<br>          title: <span class=\"hljs-string\">&#x27;请检查网络您的状态&#x27;</span>,<br>          duration: <span class=\"hljs-number\">800</span>,<br>          icon: <span class=\"hljs-string\">&#x27;none&#x27;</span><br>        &#125;);<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>调用方式为 <code>apiCloud(&#39;house&#39;, &#123; handle: &#39;get&#39;, data &#125;)</code>，apiCloud 返回的是一个<code>promise</code>对象 可以使用 <code>then-catch</code> 或者 <code>async-await</code> 接收</p>\n<p>以上为云开发和小程序端接口交互的一些案例，后面我们再学习一下关于云开发中，查数据库，取集合的操作</p>\n<p><a href=\"http://img.v5ant.com/image/zFN\"><img src=\"http://img.v5ant.com/images/2019/11/20/gh_225bd06d4e02_258.jpg\" alt=\"gh_225bd06d4e02_258.jpg\"></a></p>\n<p>欢迎浏览我的小程序：<code>租房小小管家</code>，有问题或者这好的建议请与我联系，留言。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<blockquote>\n<p>云开发简单来说是配合微信小程序开发的一个弱后后端逻辑的一个东西，就是你不需要要再招一个 PHP，go，Java 这些程序员，前端就可以搞的，当然前端也需要一定的入门，需要了解非关系数据库中的集合，字段查询等等</p>\n</blockquote>","more":"<h2 id=\"了解云开发\"><a href=\"#了解云开发\" class=\"headerlink\" title=\"了解云开发\"></a>了解云开发</h2><p>云开发提供了 <code>4</code> 大块云端能力</p>\n<table>\n<thead>\n<tr>\n<th>能力</th>\n<th>作用</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>云函数</td>\n<td>无需自建服务器</td>\n<td>在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码</td>\n</tr>\n<tr>\n<td>数据库</td>\n<td>无需自建数据库</td>\n<td>一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库</td>\n</tr>\n<tr>\n<td>存储</td>\n<td>无需自建存储和 CDN</td>\n<td>在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理</td>\n</tr>\n<tr>\n<td>云调用</td>\n<td>原生微信服务集成</td>\n<td>基于云函数免鉴权使用小程序开放接口的能力，包括服务端调用、获取开放数据等能力</td>\n</tr>\n</tbody></table>\n<h2 id=\"配置云开发环境\"><a href=\"#配置云开发环境\" class=\"headerlink\" title=\"配置云开发环境\"></a>配置云开发环境</h2><p>基本配置官方介绍的十分详细，建议尽量看官方文章<a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/quickstart.html#_1-%E6%96%B0%E5%BB%BA%E4%BA%91%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF\">教程入口</a></p>\n<p>以下是我尝试开发的租房小小管家的云开发目录配置，初始化生成的文件我都删掉了，里面这个五个目录都是新增的<br><a href=\"http://img.v5ant.com/image/C0Y\"><img src=\"http://img.v5ant.com/images/2019/11/20/WX20191120-1643192x.md.png\" alt=\"WX20191120-1643192x.md.png\"></a><br>每个云函数都需要调用<code>wx-server-sdk</code>这个包，注意需要安装一遍<code>npm install</code> 再全部上传云端，后面就不需要选择全部上传（包含 node_modules）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 云函数入口文件</span><br><span class=\"hljs-keyword\">const</span> cloud = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;wx-server-sdk&#x27;</span>);<br><br>cloud.init(&#123;<br>  traceUser: <span class=\"hljs-literal\">true</span>,<br>  env: <span class=\"hljs-string\">&#x27;fast-nav-xxx&#x27;</span><br>&#125;);<br><span class=\"hljs-comment\">// env是你的云开发环境标识</span><br></code></pre></td></tr></table></figure>\n\n<p>使用用函数调用的好处在于所有鉴权工作都交给了微信去处理，安全且方便，而且比在小程序前端直接调用云 <code>API</code> 权限要高很多，可以直接拿到用户的 openID,所有我推荐这类使用</p>\n<h2 id=\"云函数的简单对接写法\"><a href=\"#云函数的简单对接写法\" class=\"headerlink\" title=\"云函数的简单对接写法\"></a>云函数的简单对接写法</h2><p>下面是我自己一个云函数写法，因为是第一次也不晓得怎么写比较合理，所有有大神觉得哪里不合理帮我提出来 😆</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 云函数入口文件</span><br><span class=\"hljs-comment\">// 云函数入口文件</span><br><span class=\"hljs-keyword\">const</span> cloud = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;wx-server-sdk&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> md5 = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;md5-node&#x27;</span>);<br><br>cloud.init(&#123;<br>  traceUser: <span class=\"hljs-literal\">true</span>,<br>  env: <span class=\"hljs-string\">&#x27;fast-nav-xxx&#x27;</span><br>&#125;);<br><span class=\"hljs-keyword\">const</span> db = cloud.database();<br><span class=\"hljs-keyword\">const</span> _ = db.command;<br><span class=\"hljs-comment\">// 云函数入口函数</span><br><span class=\"hljs-built_in\">exports</span>.main = <span class=\"hljs-keyword\">async</span> (event, context) =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> wxContext = cloud.getWXContext();<br>  <span class=\"hljs-keyword\">switch</span> (event.handle) &#123;<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;get&#x27;</span>:<br>      <span class=\"hljs-keyword\">return</span> handlerGet(event, context, wxContext);<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;set&#x27;</span>:<br>      <span class=\"hljs-keyword\">return</span> handlerSet(event, context, wxContext);<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;update&#x27;</span>:<br>      <span class=\"hljs-keyword\">return</span> handlerUpdate(event, context, wxContext);<br>    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;delete&#x27;</span>:<br>      <span class=\"hljs-keyword\">return</span> handlerDelete(event, context, wxContext);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>通过函数参数<code>handle</code>控制不同的具体操作接口，参数的话也通过 <code>event.data</code> 拿到,到这来简单的云函数完成，然后鼠标右键上传云端</p>\n<h2 id=\"小程序端的请求调用\"><a href=\"#小程序端的请求调用\" class=\"headerlink\" title=\"小程序端的请求调用\"></a>小程序端的请求调用</h2><p>首先小程序端 <code>app.js</code> 中需要授权初始化</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"> <span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 检查云开发环境并初始化</span><br><span class=\"hljs-comment\"> */</span><br>onLaunch: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>  <span class=\"hljs-keyword\">if</span> (!wx.cloud) &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&#x27;请使用 2.2.3 或以上的基础库以使用云能力&#x27;</span>);<br>  &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>    <span class=\"hljs-comment\">//云开发初始化</span><br>    wx.cloud.init(&#123;<br>      env: <span class=\"hljs-string\">&#x27;fast-nav-xxx&#x27;</span>,<br>      traceUser: <span class=\"hljs-literal\">true</span><br>    &#125;);<br>  &#125;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>小程序端通过 <code>wx.cloud.callFunction</code>方法进行云函数调用请求，我们可以理解为<code>ajax</code>,需要注意的是调整接口的时候就不能去之前<code>xhr</code>里面查看了,需要去<code>cloud</code>分类里面，如下图</p>\n<p><a href=\"http://img.v5ant.com/image/RxZ\"><img src=\"http://img.v5ant.com/images/2019/11/20/WX20191120-1708272x.md.png\" alt=\"WX20191120-1708272x.md.png\"></a></p>\n<p>下面是我封装的一个简单的接口 <code>API</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> apiCloud = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name, data = &#123;&#125;</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>    wx.cloud.callFunction(&#123;<br>      name,<br>      data,<br>      success: <span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> &#123;<br>        <span class=\"hljs-keyword\">if</span> (res.errMsg == <span class=\"hljs-string\">&#x27;cloud.callFunction:ok&#x27;</span>) &#123;<br>          resolve(res);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>          reject(err);<br>          wx.showToast(&#123;<br>            title: err.msg,<br>            duration: <span class=\"hljs-number\">800</span>,<br>            icon: <span class=\"hljs-string\">&#x27;none&#x27;</span><br>          &#125;);<br>        &#125;<br>      &#125;,<br>      fail: <span class=\"hljs-function\"><span class=\"hljs-params\">err</span> =&gt;</span> &#123;<br>        reject(err);<br>        wx.showToast(&#123;<br>          title: <span class=\"hljs-string\">&#x27;请检查网络您的状态&#x27;</span>,<br>          duration: <span class=\"hljs-number\">800</span>,<br>          icon: <span class=\"hljs-string\">&#x27;none&#x27;</span><br>        &#125;);<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>调用方式为 <code>apiCloud(&#39;house&#39;, &#123; handle: &#39;get&#39;, data &#125;)</code>，apiCloud 返回的是一个<code>promise</code>对象 可以使用 <code>then-catch</code> 或者 <code>async-await</code> 接收</p>\n<p>以上为云开发和小程序端接口交互的一些案例，后面我们再学习一下关于云开发中，查数据库，取集合的操作</p>\n<p><a href=\"http://img.v5ant.com/image/zFN\"><img src=\"http://img.v5ant.com/images/2019/11/20/gh_225bd06d4e02_258.jpg\" alt=\"gh_225bd06d4e02_258.jpg\"></a></p>\n<p>欢迎浏览我的小程序：<code>租房小小管家</code>，有问题或者这好的建议请与我联系，留言。</p>"},{"title":"理解RESTful没有那么难","thumbnail":"http://img.v5ant.com/images/2019/11/20/2.jpg","comments":1,"toc":true,"layout":"true","date":"2019-11-21T04:29:16.000Z","updated":"2019-11-21T04:29:16.000Z","_content":"\n## 什么是 RESTful ？\n\n<!-- more -->\n\nrest 不是重置哈，它标识缩写`Representational State Transfer`（表述性状态转移），这太学术了我也不懂了，\n简单来说 `RESTful` 不是一种新技术，而是一种规范，对应应用程序交互，也就是我们平时接触最多的接口 `API` 定制规则，为的是让 API 理解更加直观，明了，规范，可以实现客户端无需借助任何文档即能调用到所有的服务器资源。\n一般服务端设计接口不遵守规范的话可能是这样的：\n\n```js\napi/getGoods?id=xxx GET\napi/setUGoods POST\napi/updateGoods POST\napi/deleteGoods?id=xxx GET/POST\n```\n\n这样的其实具体用什么`get，post`都一样没什么区别的,当然我们具体操作必须查看文档，你也无法推断出删除商品人家是 `delGoods` 还是 `deleteGoods` 还是其他,这完全取决于你后端老大的心情，而且但凡这类存在增删改查的接口都起码 4 个接口，而且接口的请求方式也是没有具体要求的，也是必须按照文档去一一比对\n如果我们按照 `RESTful` 规范出接口会是什么样子的呢？\n\n```js\napi/Goods?id=xxx GET\napi/Goods POST\napi/Goods PUT\napi/Goods?id=xxx DELETE\n```\n\n看到这里应该很明白了吧，规范完全按照 HTTP 请求规范类型一一对应，而且只有一个接口，那就是商品接口，拿到商品接口理论上我可以直接进行增删改查操作，是不是很直观，很方便？\n\n> 以上完全是个人理解，切不可当做作为正经解释 😁\n\n## RESTful 是最佳实践\n\n### URL 接口设计\n\n`RESTful` 的核心思想就是，客户端发出的数据操作指令都是\"动词 + 宾语\"的结构,比如 `GET /Goods`,这个命令，`GET` 是动词，`/articles` 是宾语。\n\n- GET：获取（Get）\n- POST：新建（Create）\n- PUT：更新（Update）\n- PATCH：更新（Update），通常是部分更新\n- DELETE：删除（Delete）\n\n根据 `HTTP` 规范，动词一律大写。\n\n有些客户端只能使用 `GET` 和 `POST` 这两种方法。服务器必须接受 `POST` 模拟其他三个方法`（PUT、PATCH、DELETE）`。\n\n这时，客户端发出的 `HTTP` 请求，要加上 `X-HTTP-Method-Override` 属性，告诉服务器应该使用哪一个动词，覆盖 POST 方法。\n\n```js\nPOST /api/Goods/1 HTTP/1.1\nX-HTTP-Method-Override: PUT\n```\n\n上面代码中，`X-HTTP-Method-Override` 指定本次请求的方法是 `PUT`，而不是 `POST`。\n宾语是 `API` 中的 `URL` 部分 上面之前那种 `api/getGoods`就显然不合理,里面不要包含动词`get,put,post`之类，因为本身请求类型已经明确了需要什么操作的\n而且，这里宾语尽量使用复数，毕竟你操作的是一个集合嘛\n\n避免多级 `URL`\n常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。\n\n`GET /authors/12/categories/2`\n这种 `URL` 不利于扩展，语义也不明确，往往要想一会，才能明白含义。\n\n更好的做法是，除了第一级，其他级别都用查询字符串表达。\n\n`GET /authors/12?categories=2`\n下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。\n\n`GET /articles/published`\n查询字符串的写法明显更好。\n\n`GET /articles?published=true`\n\n### 状态码 设计\n\n1. `200` 状态码表示操作成功，但是不同的方法可以返回更精确的状态码。\n\n```\nGET: 200 OK\nPOST: 201 Created\nPUT: 200 OK\nPATCH: 200 OK\nDELETE: 204 No Content\n```\n\n上面代码中，`POST` 返回 `201` 状态码，表示生成了新的资源；`DELETE`返回 `204` 状态码，表示资源已经不存在。\n\n此外，`202 Accepted`状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。\n\n```js\n// HTTP/1.1 202 Accepted\n{\n\"task\": {\n\"href\": \"/api/company/job-management/jobs/xxx\",\n\"id\": \"xxx\"\n}\n}\n```\n\n2. `3xx` 状态码\n   API 用不到 `301` 状态码（永久重定向）和 `302` 状态码（暂时重定向，307 也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。\n\nAPI 用到的 `3xx` 状态码，主要是 `303 See Other`，表示参考另一个 `URL`。它与 `302` 和 `307` 的含义一样，也是\"暂时重定向\"，区别在于 `302` 和 `307` 用于 `GET` 请求，而 `303` 用于 `POST、PUT` 和 `DELETE` 请求。收到 `303` 以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。\n\n```js\nHTTP/1.1 303 See Other\nLocation: /api/orders/12345\n```\n\n3. `4xx` 状态码\n   `4xx` 状态码表示客户端错误，主要有下面几种。\n\n```js\n// 400 Bad Request：服务器不理解客户端的请求，未做任何处理。\n\n// 401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。\n\n// 403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。\n\n// 404 Not Found：所请求的资源不存在，或不可用。\n\n// 405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。\n\n// 410 Gone：所请求的资源已从这个地址转移，不再可用。\n\n// 415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。\n\n// 422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。\n\n// 429 Too Many Requests：客户端的请求次数超过限额。\n```\n\n4. `5xx` 状态码\n   `5xx` 状态码表示服务端错误。一般来说，`API` 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。\n\n```js\n// 500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。\n\n// 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。\n```\n\n### 服务端响应的一些注意\n\n1. 不要返回纯本文\n   `API` 返回的数据格式，不应该是纯文本，而应该是一个 `JSON` 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 `HTTP` 头的 `Content-Type` 属性要设为 `application/json`。客户端请求时，也要明确告诉服务器，可以接受 `JSON` 格式，即请求的 `HTTP` 头的 `ACCEPT` 属性也要设成 `application/json`。下面是一个例子。\n\n```js\nGET /orders/2 HTTP/1.1\nAccept: application/json\n```\n\n2. 发生错误时，不要返回 `200` 状态码\n   有一种不恰当的做法是，即使发生错误，也返回 `200` 状态码，把错误信息放在数据体里面，就像下面这样。\n\n```js\n// HTTP/1.1 200 OK\n// Content-Type: application/json\n{\n\"status\": \"failure\",\n\"data\": {\n\"error\": \"Expected at least two items in list.\"\n}\n}\n```\n\n上面代码中，解析数据体以后，才能得知操作失败。\n\n这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。\n\n```js\n// HTTP/1.1 400 Bad Request\n// Content-Type: application/json\n\n{\n\"error\": \"Invalid payoad.\",\n\"detail\": {\n\"surname\": \"This field is required.\"\n}\n}\n```\n\n3. 提供链接\n   `API` 的使用者未必知道，`URL` 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个`URL`，就可以发现其他的 `URL`。这种方法叫做 `HATEOAS`。\n\n举例来说，`GitHub` 的 `API` 都在 `api.github.com` 这个域名。访问它，就可以得到其他 `URL`。\n\n```js\n{\n...\n\"feeds_url\": \"https://api.github.com/feeds\",\n\"followers_url\": \"https://api.github.com/user/followers\",\n\"following_url\": \"https://api.github.com/user/following{/target}\",\n\"gists_url\": \"https://api.github.com/gists{/gist_id}\",\n\"hub_url\": \"https://api.github.com/hub\",\n...\n}\n```\n\n上面的回应中，挑一个 `URL` 访问，又可以得到别的 `URL`。对于用户来说，不需要记住`URL` 设计，只要从 `api.github.com` 一步步查找就可以了。\n\n`HATEOAS` 的格式没有统一规定，上面例子中，`GitHub` 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。\n\n```js\n// HTTP/1.1 200 OK\n// Content-Type: application/json\n\n{\n\"status\": \"In progress\",\n\"links\": {[\n{ \"rel\":\"cancel\", \"method\": \"delete\", \"href\":\"/api/status/12345\" } ,\n{ \"rel\":\"edit\", \"method\": \"put\", \"href\":\"/api/status/12345\" }\n]}\n}\n```\n\n听说好的规范可以提升编码的幸福感，是吗？\n\n> 参考文章： 阮一峰老师文章=> http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html\n","source":"_posts/理解RESTful没有那么难.md","raw":"---\ntitle: 理解RESTful没有那么难\ncategories:\n  - 服务端\nthumbnail: 'http://img.v5ant.com/images/2019/11/20/2.jpg'\ncomments: true\ntoc: true\nlayout: true\ndate: 2019-11-21 12:29:16\nupdated: 2019-11-21 12:29:16\ntags:\n---\n\n## 什么是 RESTful ？\n\n<!-- more -->\n\nrest 不是重置哈，它标识缩写`Representational State Transfer`（表述性状态转移），这太学术了我也不懂了，\n简单来说 `RESTful` 不是一种新技术，而是一种规范，对应应用程序交互，也就是我们平时接触最多的接口 `API` 定制规则，为的是让 API 理解更加直观，明了，规范，可以实现客户端无需借助任何文档即能调用到所有的服务器资源。\n一般服务端设计接口不遵守规范的话可能是这样的：\n\n```js\napi/getGoods?id=xxx GET\napi/setUGoods POST\napi/updateGoods POST\napi/deleteGoods?id=xxx GET/POST\n```\n\n这样的其实具体用什么`get，post`都一样没什么区别的,当然我们具体操作必须查看文档，你也无法推断出删除商品人家是 `delGoods` 还是 `deleteGoods` 还是其他,这完全取决于你后端老大的心情，而且但凡这类存在增删改查的接口都起码 4 个接口，而且接口的请求方式也是没有具体要求的，也是必须按照文档去一一比对\n如果我们按照 `RESTful` 规范出接口会是什么样子的呢？\n\n```js\napi/Goods?id=xxx GET\napi/Goods POST\napi/Goods PUT\napi/Goods?id=xxx DELETE\n```\n\n看到这里应该很明白了吧，规范完全按照 HTTP 请求规范类型一一对应，而且只有一个接口，那就是商品接口，拿到商品接口理论上我可以直接进行增删改查操作，是不是很直观，很方便？\n\n> 以上完全是个人理解，切不可当做作为正经解释 😁\n\n## RESTful 是最佳实践\n\n### URL 接口设计\n\n`RESTful` 的核心思想就是，客户端发出的数据操作指令都是\"动词 + 宾语\"的结构,比如 `GET /Goods`,这个命令，`GET` 是动词，`/articles` 是宾语。\n\n- GET：获取（Get）\n- POST：新建（Create）\n- PUT：更新（Update）\n- PATCH：更新（Update），通常是部分更新\n- DELETE：删除（Delete）\n\n根据 `HTTP` 规范，动词一律大写。\n\n有些客户端只能使用 `GET` 和 `POST` 这两种方法。服务器必须接受 `POST` 模拟其他三个方法`（PUT、PATCH、DELETE）`。\n\n这时，客户端发出的 `HTTP` 请求，要加上 `X-HTTP-Method-Override` 属性，告诉服务器应该使用哪一个动词，覆盖 POST 方法。\n\n```js\nPOST /api/Goods/1 HTTP/1.1\nX-HTTP-Method-Override: PUT\n```\n\n上面代码中，`X-HTTP-Method-Override` 指定本次请求的方法是 `PUT`，而不是 `POST`。\n宾语是 `API` 中的 `URL` 部分 上面之前那种 `api/getGoods`就显然不合理,里面不要包含动词`get,put,post`之类，因为本身请求类型已经明确了需要什么操作的\n而且，这里宾语尽量使用复数，毕竟你操作的是一个集合嘛\n\n避免多级 `URL`\n常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。\n\n`GET /authors/12/categories/2`\n这种 `URL` 不利于扩展，语义也不明确，往往要想一会，才能明白含义。\n\n更好的做法是，除了第一级，其他级别都用查询字符串表达。\n\n`GET /authors/12?categories=2`\n下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。\n\n`GET /articles/published`\n查询字符串的写法明显更好。\n\n`GET /articles?published=true`\n\n### 状态码 设计\n\n1. `200` 状态码表示操作成功，但是不同的方法可以返回更精确的状态码。\n\n```\nGET: 200 OK\nPOST: 201 Created\nPUT: 200 OK\nPATCH: 200 OK\nDELETE: 204 No Content\n```\n\n上面代码中，`POST` 返回 `201` 状态码，表示生成了新的资源；`DELETE`返回 `204` 状态码，表示资源已经不存在。\n\n此外，`202 Accepted`状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。\n\n```js\n// HTTP/1.1 202 Accepted\n{\n\"task\": {\n\"href\": \"/api/company/job-management/jobs/xxx\",\n\"id\": \"xxx\"\n}\n}\n```\n\n2. `3xx` 状态码\n   API 用不到 `301` 状态码（永久重定向）和 `302` 状态码（暂时重定向，307 也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。\n\nAPI 用到的 `3xx` 状态码，主要是 `303 See Other`，表示参考另一个 `URL`。它与 `302` 和 `307` 的含义一样，也是\"暂时重定向\"，区别在于 `302` 和 `307` 用于 `GET` 请求，而 `303` 用于 `POST、PUT` 和 `DELETE` 请求。收到 `303` 以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。\n\n```js\nHTTP/1.1 303 See Other\nLocation: /api/orders/12345\n```\n\n3. `4xx` 状态码\n   `4xx` 状态码表示客户端错误，主要有下面几种。\n\n```js\n// 400 Bad Request：服务器不理解客户端的请求，未做任何处理。\n\n// 401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。\n\n// 403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。\n\n// 404 Not Found：所请求的资源不存在，或不可用。\n\n// 405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。\n\n// 410 Gone：所请求的资源已从这个地址转移，不再可用。\n\n// 415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。\n\n// 422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。\n\n// 429 Too Many Requests：客户端的请求次数超过限额。\n```\n\n4. `5xx` 状态码\n   `5xx` 状态码表示服务端错误。一般来说，`API` 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。\n\n```js\n// 500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。\n\n// 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。\n```\n\n### 服务端响应的一些注意\n\n1. 不要返回纯本文\n   `API` 返回的数据格式，不应该是纯文本，而应该是一个 `JSON` 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 `HTTP` 头的 `Content-Type` 属性要设为 `application/json`。客户端请求时，也要明确告诉服务器，可以接受 `JSON` 格式，即请求的 `HTTP` 头的 `ACCEPT` 属性也要设成 `application/json`。下面是一个例子。\n\n```js\nGET /orders/2 HTTP/1.1\nAccept: application/json\n```\n\n2. 发生错误时，不要返回 `200` 状态码\n   有一种不恰当的做法是，即使发生错误，也返回 `200` 状态码，把错误信息放在数据体里面，就像下面这样。\n\n```js\n// HTTP/1.1 200 OK\n// Content-Type: application/json\n{\n\"status\": \"failure\",\n\"data\": {\n\"error\": \"Expected at least two items in list.\"\n}\n}\n```\n\n上面代码中，解析数据体以后，才能得知操作失败。\n\n这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。\n\n```js\n// HTTP/1.1 400 Bad Request\n// Content-Type: application/json\n\n{\n\"error\": \"Invalid payoad.\",\n\"detail\": {\n\"surname\": \"This field is required.\"\n}\n}\n```\n\n3. 提供链接\n   `API` 的使用者未必知道，`URL` 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个`URL`，就可以发现其他的 `URL`。这种方法叫做 `HATEOAS`。\n\n举例来说，`GitHub` 的 `API` 都在 `api.github.com` 这个域名。访问它，就可以得到其他 `URL`。\n\n```js\n{\n...\n\"feeds_url\": \"https://api.github.com/feeds\",\n\"followers_url\": \"https://api.github.com/user/followers\",\n\"following_url\": \"https://api.github.com/user/following{/target}\",\n\"gists_url\": \"https://api.github.com/gists{/gist_id}\",\n\"hub_url\": \"https://api.github.com/hub\",\n...\n}\n```\n\n上面的回应中，挑一个 `URL` 访问，又可以得到别的 `URL`。对于用户来说，不需要记住`URL` 设计，只要从 `api.github.com` 一步步查找就可以了。\n\n`HATEOAS` 的格式没有统一规定，上面例子中，`GitHub` 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。\n\n```js\n// HTTP/1.1 200 OK\n// Content-Type: application/json\n\n{\n\"status\": \"In progress\",\n\"links\": {[\n{ \"rel\":\"cancel\", \"method\": \"delete\", \"href\":\"/api/status/12345\" } ,\n{ \"rel\":\"edit\", \"method\": \"put\", \"href\":\"/api/status/12345\" }\n]}\n}\n```\n\n听说好的规范可以提升编码的幸福感，是吗？\n\n> 参考文章： 阮一峰老师文章=> http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html\n","slug":"理解RESTful没有那么难","published":1,"photos":[],"link":"","_id":"ckmp269fs004sc8gs1dibe0t8","content":"<h2 id=\"什么是-RESTful-？\"><a href=\"#什么是-RESTful-？\" class=\"headerlink\" title=\"什么是 RESTful ？\"></a>什么是 RESTful ？</h2><span id=\"more\"></span>\n\n<p>rest 不是重置哈，它标识缩写<code>Representational State Transfer</code>（表述性状态转移），这太学术了我也不懂了，<br>简单来说 <code>RESTful</code> 不是一种新技术，而是一种规范，对应应用程序交互，也就是我们平时接触最多的接口 <code>API</code> 定制规则，为的是让 API 理解更加直观，明了，规范，可以实现客户端无需借助任何文档即能调用到所有的服务器资源。<br>一般服务端设计接口不遵守规范的话可能是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">api/getGoods?id=xxx GET<br>api/setUGoods POST<br>api/updateGoods POST<br>api/deleteGoods?id=xxx GET/POST<br></code></pre></td></tr></table></figure>\n\n<p>这样的其实具体用什么<code>get，post</code>都一样没什么区别的,当然我们具体操作必须查看文档，你也无法推断出删除商品人家是 <code>delGoods</code> 还是 <code>deleteGoods</code> 还是其他,这完全取决于你后端老大的心情，而且但凡这类存在增删改查的接口都起码 4 个接口，而且接口的请求方式也是没有具体要求的，也是必须按照文档去一一比对<br>如果我们按照 <code>RESTful</code> 规范出接口会是什么样子的呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">api/Goods?id=xxx GET<br>api/Goods POST<br>api/Goods PUT<br>api/Goods?id=xxx DELETE<br></code></pre></td></tr></table></figure>\n\n<p>看到这里应该很明白了吧，规范完全按照 HTTP 请求规范类型一一对应，而且只有一个接口，那就是商品接口，拿到商品接口理论上我可以直接进行增删改查操作，是不是很直观，很方便？</p>\n<blockquote>\n<p>以上完全是个人理解，切不可当做作为正经解释 😁</p>\n</blockquote>\n<h2 id=\"RESTful-是最佳实践\"><a href=\"#RESTful-是最佳实践\" class=\"headerlink\" title=\"RESTful 是最佳实践\"></a>RESTful 是最佳实践</h2><h3 id=\"URL-接口设计\"><a href=\"#URL-接口设计\" class=\"headerlink\" title=\"URL 接口设计\"></a>URL 接口设计</h3><p><code>RESTful</code> 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构,比如 <code>GET /Goods</code>,这个命令，<code>GET</code> 是动词，<code>/articles</code> 是宾语。</p>\n<ul>\n<li>GET：获取（Get）</li>\n<li>POST：新建（Create）</li>\n<li>PUT：更新（Update）</li>\n<li>PATCH：更新（Update），通常是部分更新</li>\n<li>DELETE：删除（Delete）</li>\n</ul>\n<p>根据 <code>HTTP</code> 规范，动词一律大写。</p>\n<p>有些客户端只能使用 <code>GET</code> 和 <code>POST</code> 这两种方法。服务器必须接受 <code>POST</code> 模拟其他三个方法<code>（PUT、PATCH、DELETE）</code>。</p>\n<p>这时，客户端发出的 <code>HTTP</code> 请求，要加上 <code>X-HTTP-Method-Override</code> 属性，告诉服务器应该使用哪一个动词，覆盖 POST 方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">POST /api/Goods/<span class=\"hljs-number\">1</span> HTTP/<span class=\"hljs-number\">1.1</span><br>X-HTTP-Method-Override: PUT<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>X-HTTP-Method-Override</code> 指定本次请求的方法是 <code>PUT</code>，而不是 <code>POST</code>。<br>宾语是 <code>API</code> 中的 <code>URL</code> 部分 上面之前那种 <code>api/getGoods</code>就显然不合理,里面不要包含动词<code>get,put,post</code>之类，因为本身请求类型已经明确了需要什么操作的<br>而且，这里宾语尽量使用复数，毕竟你操作的是一个集合嘛</p>\n<p>避免多级 <code>URL</code><br>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p>\n<p><code>GET /authors/12/categories/2</code><br>这种 <code>URL</code> 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p>\n<p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p>\n<p><code>GET /authors/12?categories=2</code><br>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p>\n<p><code>GET /articles/published</code><br>查询字符串的写法明显更好。</p>\n<p><code>GET /articles?published=true</code></p>\n<h3 id=\"状态码-设计\"><a href=\"#状态码-设计\" class=\"headerlink\" title=\"状态码 设计\"></a>状态码 设计</h3><ol>\n<li><code>200</code> 状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">GET:</span> <span class=\"hljs-number\">200</span> <span class=\"hljs-string\">OK</span><br><span class=\"hljs-attr\">POST:</span> <span class=\"hljs-number\">201</span> <span class=\"hljs-string\">Created</span><br><span class=\"hljs-attr\">PUT:</span> <span class=\"hljs-number\">200</span> <span class=\"hljs-string\">OK</span><br><span class=\"hljs-attr\">PATCH:</span> <span class=\"hljs-number\">200</span> <span class=\"hljs-string\">OK</span><br><span class=\"hljs-attr\">DELETE:</span> <span class=\"hljs-number\">204</span> <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">Content</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>POST</code> 返回 <code>201</code> 状态码，表示生成了新的资源；<code>DELETE</code>返回 <code>204</code> 状态码，表示资源已经不存在。</p>\n<p>此外，<code>202 Accepted</code>状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// HTTP/1.1 202 Accepted</span><br>&#123;<br><span class=\"hljs-string\">&quot;task&quot;</span>: &#123;<br><span class=\"hljs-string\">&quot;href&quot;</span>: <span class=\"hljs-string\">&quot;/api/company/job-management/jobs/xxx&quot;</span>,<br><span class=\"hljs-string\">&quot;id&quot;</span>: <span class=\"hljs-string\">&quot;xxx&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>3xx</code> 状态码<br>API 用不到 <code>301</code> 状态码（永久重定向）和 <code>302</code> 状态码（暂时重定向，307 也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</li>\n</ol>\n<p>API 用到的 <code>3xx</code> 状态码，主要是 <code>303 See Other</code>，表示参考另一个 <code>URL</code>。它与 <code>302</code> 和 <code>307</code> 的含义一样，也是”暂时重定向”，区别在于 <code>302</code> 和 <code>307</code> 用于 <code>GET</code> 请求，而 <code>303</code> 用于 <code>POST、PUT</code> 和 <code>DELETE</code> 请求。收到 <code>303</code> 以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">HTTP/<span class=\"hljs-number\">1.1</span> <span class=\"hljs-number\">303</span> See Other<br>Location: <span class=\"hljs-regexp\">/api/</span>orders/<span class=\"hljs-number\">12345</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><code>4xx</code> 状态码<br><code>4xx</code> 状态码表示客户端错误，主要有下面几种。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 400 Bad Request：服务器不理解客户端的请求，未做任何处理。</span><br><br><span class=\"hljs-comment\">// 401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</span><br><br><span class=\"hljs-comment\">// 403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</span><br><br><span class=\"hljs-comment\">// 404 Not Found：所请求的资源不存在，或不可用。</span><br><br><span class=\"hljs-comment\">// 405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</span><br><br><span class=\"hljs-comment\">// 410 Gone：所请求的资源已从这个地址转移，不再可用。</span><br><br><span class=\"hljs-comment\">// 415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</span><br><br><span class=\"hljs-comment\">// 422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</span><br><br><span class=\"hljs-comment\">// 429 Too Many Requests：客户端的请求次数超过限额。</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><code>5xx</code> 状态码<br><code>5xx</code> 状态码表示服务端错误。一般来说，<code>API</code> 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。</span><br><br><span class=\"hljs-comment\">// 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"服务端响应的一些注意\"><a href=\"#服务端响应的一些注意\" class=\"headerlink\" title=\"服务端响应的一些注意\"></a>服务端响应的一些注意</h3><ol>\n<li>不要返回纯本文<br><code>API</code> 返回的数据格式，不应该是纯文本，而应该是一个 <code>JSON</code> 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 <code>HTTP</code> 头的 <code>Content-Type</code> 属性要设为 <code>application/json</code>。客户端请求时，也要明确告诉服务器，可以接受 <code>JSON</code> 格式，即请求的 <code>HTTP</code> 头的 <code>ACCEPT</code> 属性也要设成 <code>application/json</code>。下面是一个例子。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">GET /orders/<span class=\"hljs-number\">2</span> HTTP/<span class=\"hljs-number\">1.1</span><br>Accept: application/json<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>发生错误时，不要返回 <code>200</code> 状态码<br>有一种不恰当的做法是，即使发生错误，也返回 <code>200</code> 状态码，把错误信息放在数据体里面，就像下面这样。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// HTTP/1.1 200 OK</span><br><span class=\"hljs-comment\">// Content-Type: application/json</span><br>&#123;<br><span class=\"hljs-string\">&quot;status&quot;</span>: <span class=\"hljs-string\">&quot;failure&quot;</span>,<br><span class=\"hljs-string\">&quot;data&quot;</span>: &#123;<br><span class=\"hljs-string\">&quot;error&quot;</span>: <span class=\"hljs-string\">&quot;Expected at least two items in list.&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，解析数据体以后，才能得知操作失败。</p>\n<p>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// HTTP/1.1 400 Bad Request</span><br><span class=\"hljs-comment\">// Content-Type: application/json</span><br><br>&#123;<br><span class=\"hljs-string\">&quot;error&quot;</span>: <span class=\"hljs-string\">&quot;Invalid payoad.&quot;</span>,<br><span class=\"hljs-string\">&quot;detail&quot;</span>: &#123;<br><span class=\"hljs-string\">&quot;surname&quot;</span>: <span class=\"hljs-string\">&quot;This field is required.&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>提供链接<br><code>API</code> 的使用者未必知道，<code>URL</code> 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个<code>URL</code>，就可以发现其他的 <code>URL</code>。这种方法叫做 <code>HATEOAS</code>。</li>\n</ol>\n<p>举例来说，<code>GitHub</code> 的 <code>API</code> 都在 <code>api.github.com</code> 这个域名。访问它，就可以得到其他 <code>URL</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;<br>...<br><span class=\"hljs-string\">&quot;feeds_url&quot;</span>: <span class=\"hljs-string\">&quot;https://api.github.com/feeds&quot;</span>,<br><span class=\"hljs-string\">&quot;followers_url&quot;</span>: <span class=\"hljs-string\">&quot;https://api.github.com/user/followers&quot;</span>,<br><span class=\"hljs-string\">&quot;following_url&quot;</span>: <span class=\"hljs-string\">&quot;https://api.github.com/user/following&#123;/target&#125;&quot;</span>,<br><span class=\"hljs-string\">&quot;gists_url&quot;</span>: <span class=\"hljs-string\">&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;</span>,<br><span class=\"hljs-string\">&quot;hub_url&quot;</span>: <span class=\"hljs-string\">&quot;https://api.github.com/hub&quot;</span>,<br>...<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的回应中，挑一个 <code>URL</code> 访问，又可以得到别的 <code>URL</code>。对于用户来说，不需要记住<code>URL</code> 设计，只要从 <code>api.github.com</code> 一步步查找就可以了。</p>\n<p><code>HATEOAS</code> 的格式没有统一规定，上面例子中，<code>GitHub</code> 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// HTTP/1.1 200 OK</span><br><span class=\"hljs-comment\">// Content-Type: application/json</span><br><br>&#123;<br><span class=\"hljs-string\">&quot;status&quot;</span>: <span class=\"hljs-string\">&quot;In progress&quot;</span>,<br><span class=\"hljs-string\">&quot;links&quot;</span>: &#123;[<br>&#123; <span class=\"hljs-string\">&quot;rel&quot;</span>:<span class=\"hljs-string\">&quot;cancel&quot;</span>, <span class=\"hljs-string\">&quot;method&quot;</span>: <span class=\"hljs-string\">&quot;delete&quot;</span>, <span class=\"hljs-string\">&quot;href&quot;</span>:<span class=\"hljs-string\">&quot;/api/status/12345&quot;</span> &#125; ,<br>&#123; <span class=\"hljs-string\">&quot;rel&quot;</span>:<span class=\"hljs-string\">&quot;edit&quot;</span>, <span class=\"hljs-string\">&quot;method&quot;</span>: <span class=\"hljs-string\">&quot;put&quot;</span>, <span class=\"hljs-string\">&quot;href&quot;</span>:<span class=\"hljs-string\">&quot;/api/status/12345&quot;</span> &#125;<br>]&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>听说好的规范可以提升编码的幸福感，是吗？</p>\n<blockquote>\n<p>参考文章： 阮一峰老师文章=&gt; <a href=\"http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html\">http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a></p>\n</blockquote>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<h2 id=\"什么是-RESTful-？\"><a href=\"#什么是-RESTful-？\" class=\"headerlink\" title=\"什么是 RESTful ？\"></a>什么是 RESTful ？</h2>","more":"<p>rest 不是重置哈，它标识缩写<code>Representational State Transfer</code>（表述性状态转移），这太学术了我也不懂了，<br>简单来说 <code>RESTful</code> 不是一种新技术，而是一种规范，对应应用程序交互，也就是我们平时接触最多的接口 <code>API</code> 定制规则，为的是让 API 理解更加直观，明了，规范，可以实现客户端无需借助任何文档即能调用到所有的服务器资源。<br>一般服务端设计接口不遵守规范的话可能是这样的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">api/getGoods?id=xxx GET<br>api/setUGoods POST<br>api/updateGoods POST<br>api/deleteGoods?id=xxx GET/POST<br></code></pre></td></tr></table></figure>\n\n<p>这样的其实具体用什么<code>get，post</code>都一样没什么区别的,当然我们具体操作必须查看文档，你也无法推断出删除商品人家是 <code>delGoods</code> 还是 <code>deleteGoods</code> 还是其他,这完全取决于你后端老大的心情，而且但凡这类存在增删改查的接口都起码 4 个接口，而且接口的请求方式也是没有具体要求的，也是必须按照文档去一一比对<br>如果我们按照 <code>RESTful</code> 规范出接口会是什么样子的呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">api/Goods?id=xxx GET<br>api/Goods POST<br>api/Goods PUT<br>api/Goods?id=xxx DELETE<br></code></pre></td></tr></table></figure>\n\n<p>看到这里应该很明白了吧，规范完全按照 HTTP 请求规范类型一一对应，而且只有一个接口，那就是商品接口，拿到商品接口理论上我可以直接进行增删改查操作，是不是很直观，很方便？</p>\n<blockquote>\n<p>以上完全是个人理解，切不可当做作为正经解释 😁</p>\n</blockquote>\n<h2 id=\"RESTful-是最佳实践\"><a href=\"#RESTful-是最佳实践\" class=\"headerlink\" title=\"RESTful 是最佳实践\"></a>RESTful 是最佳实践</h2><h3 id=\"URL-接口设计\"><a href=\"#URL-接口设计\" class=\"headerlink\" title=\"URL 接口设计\"></a>URL 接口设计</h3><p><code>RESTful</code> 的核心思想就是，客户端发出的数据操作指令都是”动词 + 宾语”的结构,比如 <code>GET /Goods</code>,这个命令，<code>GET</code> 是动词，<code>/articles</code> 是宾语。</p>\n<ul>\n<li>GET：获取（Get）</li>\n<li>POST：新建（Create）</li>\n<li>PUT：更新（Update）</li>\n<li>PATCH：更新（Update），通常是部分更新</li>\n<li>DELETE：删除（Delete）</li>\n</ul>\n<p>根据 <code>HTTP</code> 规范，动词一律大写。</p>\n<p>有些客户端只能使用 <code>GET</code> 和 <code>POST</code> 这两种方法。服务器必须接受 <code>POST</code> 模拟其他三个方法<code>（PUT、PATCH、DELETE）</code>。</p>\n<p>这时，客户端发出的 <code>HTTP</code> 请求，要加上 <code>X-HTTP-Method-Override</code> 属性，告诉服务器应该使用哪一个动词，覆盖 POST 方法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">POST /api/Goods/<span class=\"hljs-number\">1</span> HTTP/<span class=\"hljs-number\">1.1</span><br>X-HTTP-Method-Override: PUT<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>X-HTTP-Method-Override</code> 指定本次请求的方法是 <code>PUT</code>，而不是 <code>POST</code>。<br>宾语是 <code>API</code> 中的 <code>URL</code> 部分 上面之前那种 <code>api/getGoods</code>就显然不合理,里面不要包含动词<code>get,put,post</code>之类，因为本身请求类型已经明确了需要什么操作的<br>而且，这里宾语尽量使用复数，毕竟你操作的是一个集合嘛</p>\n<p>避免多级 <code>URL</code><br>常见的情况是，资源需要多级分类，因此很容易写出多级的 URL，比如获取某个作者的某一类文章。</p>\n<p><code>GET /authors/12/categories/2</code><br>这种 <code>URL</code> 不利于扩展，语义也不明确，往往要想一会，才能明白含义。</p>\n<p>更好的做法是，除了第一级，其他级别都用查询字符串表达。</p>\n<p><code>GET /authors/12?categories=2</code><br>下面是另一个例子，查询已发布的文章。你可能会设计成下面的 URL。</p>\n<p><code>GET /articles/published</code><br>查询字符串的写法明显更好。</p>\n<p><code>GET /articles?published=true</code></p>\n<h3 id=\"状态码-设计\"><a href=\"#状态码-设计\" class=\"headerlink\" title=\"状态码 设计\"></a>状态码 设计</h3><ol>\n<li><code>200</code> 状态码表示操作成功，但是不同的方法可以返回更精确的状态码。</li>\n</ol>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">GET:</span> <span class=\"hljs-number\">200</span> <span class=\"hljs-string\">OK</span><br><span class=\"hljs-attr\">POST:</span> <span class=\"hljs-number\">201</span> <span class=\"hljs-string\">Created</span><br><span class=\"hljs-attr\">PUT:</span> <span class=\"hljs-number\">200</span> <span class=\"hljs-string\">OK</span><br><span class=\"hljs-attr\">PATCH:</span> <span class=\"hljs-number\">200</span> <span class=\"hljs-string\">OK</span><br><span class=\"hljs-attr\">DELETE:</span> <span class=\"hljs-number\">204</span> <span class=\"hljs-literal\">No</span> <span class=\"hljs-string\">Content</span><br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，<code>POST</code> 返回 <code>201</code> 状态码，表示生成了新的资源；<code>DELETE</code>返回 <code>204</code> 状态码，表示资源已经不存在。</p>\n<p>此外，<code>202 Accepted</code>状态码表示服务器已经收到请求，但还未进行处理，会在未来再处理，通常用于异步操作。下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// HTTP/1.1 202 Accepted</span><br>&#123;<br><span class=\"hljs-string\">&quot;task&quot;</span>: &#123;<br><span class=\"hljs-string\">&quot;href&quot;</span>: <span class=\"hljs-string\">&quot;/api/company/job-management/jobs/xxx&quot;</span>,<br><span class=\"hljs-string\">&quot;id&quot;</span>: <span class=\"hljs-string\">&quot;xxx&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><code>3xx</code> 状态码<br>API 用不到 <code>301</code> 状态码（永久重定向）和 <code>302</code> 状态码（暂时重定向，307 也是这个含义），因为它们可以由应用级别返回，浏览器会直接跳转，API 级别可以不考虑这两种情况。</li>\n</ol>\n<p>API 用到的 <code>3xx</code> 状态码，主要是 <code>303 See Other</code>，表示参考另一个 <code>URL</code>。它与 <code>302</code> 和 <code>307</code> 的含义一样，也是”暂时重定向”，区别在于 <code>302</code> 和 <code>307</code> 用于 <code>GET</code> 请求，而 <code>303</code> 用于 <code>POST、PUT</code> 和 <code>DELETE</code> 请求。收到 <code>303</code> 以后，浏览器不会自动跳转，而会让用户自己决定下一步怎么办。下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">HTTP/<span class=\"hljs-number\">1.1</span> <span class=\"hljs-number\">303</span> See Other<br>Location: <span class=\"hljs-regexp\">/api/</span>orders/<span class=\"hljs-number\">12345</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><code>4xx</code> 状态码<br><code>4xx</code> 状态码表示客户端错误，主要有下面几种。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 400 Bad Request：服务器不理解客户端的请求，未做任何处理。</span><br><br><span class=\"hljs-comment\">// 401 Unauthorized：用户未提供身份验证凭据，或者没有通过身份验证。</span><br><br><span class=\"hljs-comment\">// 403 Forbidden：用户通过了身份验证，但是不具有访问资源所需的权限。</span><br><br><span class=\"hljs-comment\">// 404 Not Found：所请求的资源不存在，或不可用。</span><br><br><span class=\"hljs-comment\">// 405 Method Not Allowed：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。</span><br><br><span class=\"hljs-comment\">// 410 Gone：所请求的资源已从这个地址转移，不再可用。</span><br><br><span class=\"hljs-comment\">// 415 Unsupported Media Type：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。</span><br><br><span class=\"hljs-comment\">// 422 Unprocessable Entity ：客户端上传的附件无法处理，导致请求失败。</span><br><br><span class=\"hljs-comment\">// 429 Too Many Requests：客户端的请求次数超过限额。</span><br></code></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li><code>5xx</code> 状态码<br><code>5xx</code> 状态码表示服务端错误。一般来说，<code>API</code> 不会向用户透露服务器的详细信息，所以只要两个状态码就够了。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// 500 Internal Server Error：客户端请求有效，服务器处理时发生了意外。</span><br><br><span class=\"hljs-comment\">// 503 Service Unavailable：服务器无法处理请求，一般用于网站维护状态。</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"服务端响应的一些注意\"><a href=\"#服务端响应的一些注意\" class=\"headerlink\" title=\"服务端响应的一些注意\"></a>服务端响应的一些注意</h3><ol>\n<li>不要返回纯本文<br><code>API</code> 返回的数据格式，不应该是纯文本，而应该是一个 <code>JSON</code> 对象，因为这样才能返回标准的结构化数据。所以，服务器回应的 <code>HTTP</code> 头的 <code>Content-Type</code> 属性要设为 <code>application/json</code>。客户端请求时，也要明确告诉服务器，可以接受 <code>JSON</code> 格式，即请求的 <code>HTTP</code> 头的 <code>ACCEPT</code> 属性也要设成 <code>application/json</code>。下面是一个例子。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">GET /orders/<span class=\"hljs-number\">2</span> HTTP/<span class=\"hljs-number\">1.1</span><br>Accept: application/json<br></code></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>发生错误时，不要返回 <code>200</code> 状态码<br>有一种不恰当的做法是，即使发生错误，也返回 <code>200</code> 状态码，把错误信息放在数据体里面，就像下面这样。</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// HTTP/1.1 200 OK</span><br><span class=\"hljs-comment\">// Content-Type: application/json</span><br>&#123;<br><span class=\"hljs-string\">&quot;status&quot;</span>: <span class=\"hljs-string\">&quot;failure&quot;</span>,<br><span class=\"hljs-string\">&quot;data&quot;</span>: &#123;<br><span class=\"hljs-string\">&quot;error&quot;</span>: <span class=\"hljs-string\">&quot;Expected at least two items in list.&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面代码中，解析数据体以后，才能得知操作失败。</p>\n<p>这张做法实际上取消了状态码，这是完全不可取的。正确的做法是，状态码反映发生的错误，具体的错误信息放在数据体里面返回。下面是一个例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// HTTP/1.1 400 Bad Request</span><br><span class=\"hljs-comment\">// Content-Type: application/json</span><br><br>&#123;<br><span class=\"hljs-string\">&quot;error&quot;</span>: <span class=\"hljs-string\">&quot;Invalid payoad.&quot;</span>,<br><span class=\"hljs-string\">&quot;detail&quot;</span>: &#123;<br><span class=\"hljs-string\">&quot;surname&quot;</span>: <span class=\"hljs-string\">&quot;This field is required.&quot;</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>提供链接<br><code>API</code> 的使用者未必知道，<code>URL</code> 是怎么设计的。一个解决方法就是，在回应中，给出相关链接，便于下一步操作。这样的话，用户只要记住一个<code>URL</code>，就可以发现其他的 <code>URL</code>。这种方法叫做 <code>HATEOAS</code>。</li>\n</ol>\n<p>举例来说，<code>GitHub</code> 的 <code>API</code> 都在 <code>api.github.com</code> 这个域名。访问它，就可以得到其他 <code>URL</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">&#123;<br>...<br><span class=\"hljs-string\">&quot;feeds_url&quot;</span>: <span class=\"hljs-string\">&quot;https://api.github.com/feeds&quot;</span>,<br><span class=\"hljs-string\">&quot;followers_url&quot;</span>: <span class=\"hljs-string\">&quot;https://api.github.com/user/followers&quot;</span>,<br><span class=\"hljs-string\">&quot;following_url&quot;</span>: <span class=\"hljs-string\">&quot;https://api.github.com/user/following&#123;/target&#125;&quot;</span>,<br><span class=\"hljs-string\">&quot;gists_url&quot;</span>: <span class=\"hljs-string\">&quot;https://api.github.com/gists&#123;/gist_id&#125;&quot;</span>,<br><span class=\"hljs-string\">&quot;hub_url&quot;</span>: <span class=\"hljs-string\">&quot;https://api.github.com/hub&quot;</span>,<br>...<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的回应中，挑一个 <code>URL</code> 访问，又可以得到别的 <code>URL</code>。对于用户来说，不需要记住<code>URL</code> 设计，只要从 <code>api.github.com</code> 一步步查找就可以了。</p>\n<p><code>HATEOAS</code> 的格式没有统一规定，上面例子中，<code>GitHub</code> 将它们与其他属性放在一起。更好的做法应该是，将相关链接与其他属性分开。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// HTTP/1.1 200 OK</span><br><span class=\"hljs-comment\">// Content-Type: application/json</span><br><br>&#123;<br><span class=\"hljs-string\">&quot;status&quot;</span>: <span class=\"hljs-string\">&quot;In progress&quot;</span>,<br><span class=\"hljs-string\">&quot;links&quot;</span>: &#123;[<br>&#123; <span class=\"hljs-string\">&quot;rel&quot;</span>:<span class=\"hljs-string\">&quot;cancel&quot;</span>, <span class=\"hljs-string\">&quot;method&quot;</span>: <span class=\"hljs-string\">&quot;delete&quot;</span>, <span class=\"hljs-string\">&quot;href&quot;</span>:<span class=\"hljs-string\">&quot;/api/status/12345&quot;</span> &#125; ,<br>&#123; <span class=\"hljs-string\">&quot;rel&quot;</span>:<span class=\"hljs-string\">&quot;edit&quot;</span>, <span class=\"hljs-string\">&quot;method&quot;</span>: <span class=\"hljs-string\">&quot;put&quot;</span>, <span class=\"hljs-string\">&quot;href&quot;</span>:<span class=\"hljs-string\">&quot;/api/status/12345&quot;</span> &#125;<br>]&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>听说好的规范可以提升编码的幸福感，是吗？</p>\n<blockquote>\n<p>参考文章： 阮一峰老师文章=&gt; <a href=\"http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html\">http://www.ruanyifeng.com/blog/2018/10/restful-api-best-practices.html</a></p>\n</blockquote>"},{"title":"电影-中国机长","comments":1,"toc":true,"date":"2019-10-11T04:12:26.000Z","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1570543896163&di=6454addc25323e3da83af8a5c9acacb4&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20190917%2F10dd465a62b64513a38b24bd4735da6a.jpeg","_content":"\n> 推荐指数 :💛💛💛💛\n\n| 标题：   | 主演：                       | 导演： | 上映年代： |\n| -------- | ---------------------------- | ------ | ---------- |\n| 中国机长 | 张涵予,欧豪,杜江,袁泉,张天爱 | 刘伟强 | 2019       |\n\n<!-- more -->\n\n![](https://img.kuyun88.com/pic/uploadimg/2019-9/201993015461798730.jpg)\n\n### 介绍\n\n电影《中国机长》根据 2018 年 5 月 14 日四川航空 3U8633 航班机组成功处置特情真实事件改编：机组执行航班任务时，在万米高空突遇驾驶舱风挡玻璃爆裂脱落、座舱释压的极端罕见险情，生死关头，他们临危不乱、\n\n### 在线直播\n\n{% iframe http://jx.v5ant.com?v=https://www.7639616.com/hls/20191008/1a9119f38a09fa50fad79a564bb61145/1570522437/index.m3u8 100% 500px %}\n","source":"_posts/电影-中国机长.md","raw":"---\ntitle: 电影-中国机长\ncomments: true\ntoc: true\ndate: 2019-10-11 12:12:26\ntags:\n  - 高清\n  - 在线影视\ncategories:\n  - 影视资源\nthumbnail: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1570543896163&di=6454addc25323e3da83af8a5c9acacb4&imgtype=0&src=http%3A%2F%2F5b0988e595225.cdn.sohucs.com%2Fimages%2F20190917%2F10dd465a62b64513a38b24bd4735da6a.jpeg\n---\n\n> 推荐指数 :💛💛💛💛\n\n| 标题：   | 主演：                       | 导演： | 上映年代： |\n| -------- | ---------------------------- | ------ | ---------- |\n| 中国机长 | 张涵予,欧豪,杜江,袁泉,张天爱 | 刘伟强 | 2019       |\n\n<!-- more -->\n\n![](https://img.kuyun88.com/pic/uploadimg/2019-9/201993015461798730.jpg)\n\n### 介绍\n\n电影《中国机长》根据 2018 年 5 月 14 日四川航空 3U8633 航班机组成功处置特情真实事件改编：机组执行航班任务时，在万米高空突遇驾驶舱风挡玻璃爆裂脱落、座舱释压的极端罕见险情，生死关头，他们临危不乱、\n\n### 在线直播\n\n{% iframe http://jx.v5ant.com?v=https://www.7639616.com/hls/20191008/1a9119f38a09fa50fad79a564bb61145/1570522437/index.m3u8 100% 500px %}\n","slug":"电影-中国机长","published":1,"updated":"2019-10-11T04:18:53.859Z","layout":"post","photos":[],"link":"","_id":"ckmp269fy004vc8gs96ffd9zs","content":"<blockquote>\n<p>推荐指数 :💛💛💛💛</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标题：</th>\n<th>主演：</th>\n<th>导演：</th>\n<th>上映年代：</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>中国机长</td>\n<td>张涵予,欧豪,杜江,袁泉,张天爱</td>\n<td>刘伟强</td>\n<td>2019</td>\n</tr>\n</tbody></table>\n<span id=\"more\"></span>\n\n<p><img src=\"https://img.kuyun88.com/pic/uploadimg/2019-9/201993015461798730.jpg\"></p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>电影《中国机长》根据 2018 年 5 月 14 日四川航空 3U8633 航班机组成功处置特情真实事件改编：机组执行航班任务时，在万米高空突遇驾驶舱风挡玻璃爆裂脱落、座舱释压的极端罕见险情，生死关头，他们临危不乱、</p>\n<h3 id=\"在线直播\"><a href=\"#在线直播\" class=\"headerlink\" title=\"在线直播\"></a>在线直播</h3><iframe src=\"http://jx.v5ant.com/?v=https://www.7639616.com/hls/20191008/1a9119f38a09fa50fad79a564bb61145/1570522437/index.m3u8\" width=\"100%\" height=\"500px\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<blockquote>\n<p>推荐指数 :💛💛💛💛</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标题：</th>\n<th>主演：</th>\n<th>导演：</th>\n<th>上映年代：</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>中国机长</td>\n<td>张涵予,欧豪,杜江,袁泉,张天爱</td>\n<td>刘伟强</td>\n<td>2019</td>\n</tr>\n</tbody></table>","more":"<p><img src=\"https://img.kuyun88.com/pic/uploadimg/2019-9/201993015461798730.jpg\"></p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>电影《中国机长》根据 2018 年 5 月 14 日四川航空 3U8633 航班机组成功处置特情真实事件改编：机组执行航班任务时，在万米高空突遇驾驶舱风挡玻璃爆裂脱落、座舱释压的极端罕见险情，生死关头，他们临危不乱、</p>\n<h3 id=\"在线直播\"><a href=\"#在线直播\" class=\"headerlink\" title=\"在线直播\"></a>在线直播</h3><iframe src=\"http://jx.v5ant.com/?v=https://www.7639616.com/hls/20191008/1a9119f38a09fa50fad79a564bb61145/1570522437/index.m3u8\" width=\"100%\" height=\"500px\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>"},{"title":"蜘蛛侠:英雄远征-HDTC中字在线观看","comments":1,"toc":true,"date":"2019-09-17T10:27:03.000Z","thumbnail":"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1568727119279&di=6d9d5be67ed5f3241c32e99386c96e87&imgtype=0&src=http%3A%2F%2Fpic1.win4000.com%2Fpic%2F5%2F6d%2F03bbaa191b.jpg","_content":"\n> 推荐指数 :💛💛💛💛💛💛💛\n\n| 标题：           | 主演：                                         | 导演：  | 上映年代： |\n| ---------------- | ---------------------------------------------- | ------- | ---------- |\n| 蜘蛛侠：英雄远征 | 汤姆·赫兰德,赞达亚,杰克·吉伦哈尔,寇碧·史莫德斯 | 乔·沃茨 | 2019       |\n\n<!-- more -->\n\n![](https://www.imov.vip/upload/vod/20190629-1/c0089ddc277db1e6c80ab303e3d99e01.jpg)\n\n### 介绍\n\n最受关注的漫威超级英雄大片《蜘蛛侠：英雄远征》依旧由导演乔·沃茨执导，汤姆·赫兰德继续饰演蜘蛛侠彼得·帕克此次蜘蛛侠将前往欧洲展开新的征程，并将对抗由杰克·吉伦哈尔加盟饰演的大反派神秘客，赞达亚、雅各布·巴特朗、托尼·雷沃罗利等原班人马也将悉数回归。本片将于 2019 年 7 月 5 日北美上映，经历了第一部的成长经历后，蜘蛛侠又会面临怎样的危机？敬请期待。\n\n### 在线直播\n\n{% iframe http://jx.v5ant.com?v=https://cn3.ruioushang.com/hls/20190912/16f8455175fe8cdeed63f67dbf661bc7/1568279534/index.m3u8 100% 500px %}\n\n[HD1080P 中字](http://jx.v5ant.com?v=https://jingcai.cdn-vipkkyun.com/20190911/3451_80479376/index.m3u8)\n[HD1080P 国语](http://jx.v5ant.com?v=https://jingcai.cdn-vipkkyun.com/20190911/3457_aef0b950/index.m3u8)\n","source":"_posts/蜘蛛侠-英雄远征.md","raw":"---\ntitle: 蜘蛛侠:英雄远征-HDTC中字在线观看\ncomments: true\ntoc: true\ndate: 2019-09-17 18:27:03\ntags:\ncategories:\n  - 影视资源\nthumbnail: https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1568727119279&di=6d9d5be67ed5f3241c32e99386c96e87&imgtype=0&src=http%3A%2F%2Fpic1.win4000.com%2Fpic%2F5%2F6d%2F03bbaa191b.jpg\n---\n\n> 推荐指数 :💛💛💛💛💛💛💛\n\n| 标题：           | 主演：                                         | 导演：  | 上映年代： |\n| ---------------- | ---------------------------------------------- | ------- | ---------- |\n| 蜘蛛侠：英雄远征 | 汤姆·赫兰德,赞达亚,杰克·吉伦哈尔,寇碧·史莫德斯 | 乔·沃茨 | 2019       |\n\n<!-- more -->\n\n![](https://www.imov.vip/upload/vod/20190629-1/c0089ddc277db1e6c80ab303e3d99e01.jpg)\n\n### 介绍\n\n最受关注的漫威超级英雄大片《蜘蛛侠：英雄远征》依旧由导演乔·沃茨执导，汤姆·赫兰德继续饰演蜘蛛侠彼得·帕克此次蜘蛛侠将前往欧洲展开新的征程，并将对抗由杰克·吉伦哈尔加盟饰演的大反派神秘客，赞达亚、雅各布·巴特朗、托尼·雷沃罗利等原班人马也将悉数回归。本片将于 2019 年 7 月 5 日北美上映，经历了第一部的成长经历后，蜘蛛侠又会面临怎样的危机？敬请期待。\n\n### 在线直播\n\n{% iframe http://jx.v5ant.com?v=https://cn3.ruioushang.com/hls/20190912/16f8455175fe8cdeed63f67dbf661bc7/1568279534/index.m3u8 100% 500px %}\n\n[HD1080P 中字](http://jx.v5ant.com?v=https://jingcai.cdn-vipkkyun.com/20190911/3451_80479376/index.m3u8)\n[HD1080P 国语](http://jx.v5ant.com?v=https://jingcai.cdn-vipkkyun.com/20190911/3457_aef0b950/index.m3u8)\n","slug":"蜘蛛侠-英雄远征","published":1,"updated":"2019-09-17T10:44:07.855Z","layout":"post","photos":[],"link":"","_id":"ckmp269fz004yc8gsev8x0gmy","content":"<blockquote>\n<p>推荐指数 :💛💛💛💛💛💛💛</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标题：</th>\n<th>主演：</th>\n<th>导演：</th>\n<th>上映年代：</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蜘蛛侠：英雄远征</td>\n<td>汤姆·赫兰德,赞达亚,杰克·吉伦哈尔,寇碧·史莫德斯</td>\n<td>乔·沃茨</td>\n<td>2019</td>\n</tr>\n</tbody></table>\n<span id=\"more\"></span>\n\n<p><img src=\"https://www.imov.vip/upload/vod/20190629-1/c0089ddc277db1e6c80ab303e3d99e01.jpg\"></p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>最受关注的漫威超级英雄大片《蜘蛛侠：英雄远征》依旧由导演乔·沃茨执导，汤姆·赫兰德继续饰演蜘蛛侠彼得·帕克此次蜘蛛侠将前往欧洲展开新的征程，并将对抗由杰克·吉伦哈尔加盟饰演的大反派神秘客，赞达亚、雅各布·巴特朗、托尼·雷沃罗利等原班人马也将悉数回归。本片将于 2019 年 7 月 5 日北美上映，经历了第一部的成长经历后，蜘蛛侠又会面临怎样的危机？敬请期待。</p>\n<h3 id=\"在线直播\"><a href=\"#在线直播\" class=\"headerlink\" title=\"在线直播\"></a>在线直播</h3><iframe src=\"http://jx.v5ant.com/?v=https://cn3.ruioushang.com/hls/20190912/16f8455175fe8cdeed63f67dbf661bc7/1568279534/index.m3u8\" width=\"100%\" height=\"500px\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n\n<p><a href=\"http://jx.v5ant.com/?v=https://jingcai.cdn-vipkkyun.com/20190911/3451_80479376/index.m3u8\">HD1080P 中字</a><br><a href=\"http://jx.v5ant.com/?v=https://jingcai.cdn-vipkkyun.com/20190911/3457_aef0b950/index.m3u8\">HD1080P 国语</a></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<blockquote>\n<p>推荐指数 :💛💛💛💛💛💛💛</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标题：</th>\n<th>主演：</th>\n<th>导演：</th>\n<th>上映年代：</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>蜘蛛侠：英雄远征</td>\n<td>汤姆·赫兰德,赞达亚,杰克·吉伦哈尔,寇碧·史莫德斯</td>\n<td>乔·沃茨</td>\n<td>2019</td>\n</tr>\n</tbody></table>","more":"<p><img src=\"https://www.imov.vip/upload/vod/20190629-1/c0089ddc277db1e6c80ab303e3d99e01.jpg\"></p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>最受关注的漫威超级英雄大片《蜘蛛侠：英雄远征》依旧由导演乔·沃茨执导，汤姆·赫兰德继续饰演蜘蛛侠彼得·帕克此次蜘蛛侠将前往欧洲展开新的征程，并将对抗由杰克·吉伦哈尔加盟饰演的大反派神秘客，赞达亚、雅各布·巴特朗、托尼·雷沃罗利等原班人马也将悉数回归。本片将于 2019 年 7 月 5 日北美上映，经历了第一部的成长经历后，蜘蛛侠又会面临怎样的危机？敬请期待。</p>\n<h3 id=\"在线直播\"><a href=\"#在线直播\" class=\"headerlink\" title=\"在线直播\"></a>在线直播</h3><iframe src=\"http://jx.v5ant.com/?v=https://cn3.ruioushang.com/hls/20190912/16f8455175fe8cdeed63f67dbf661bc7/1568279534/index.m3u8\" width=\"100%\" height=\"500px\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n\n<p><a href=\"http://jx.v5ant.com/?v=https://jingcai.cdn-vipkkyun.com/20190911/3451_80479376/index.m3u8\">HD1080P 中字</a><br><a href=\"http://jx.v5ant.com/?v=https://jingcai.cdn-vipkkyun.com/20190911/3457_aef0b950/index.m3u8\">HD1080P 国语</a></p>"},{"title":"敢死队2-HDTC中英字在线观看","comments":1,"toc":true,"thumbnail":"http://mv.v5ant.com/upload/vod/20190604-1/f995c128b8ffa24e0ed07f9d8b1915f8.jpg","date":"2020-01-08T03:48:19.000Z","updated":"2020-01-08T03:48:19.000Z","_content":"\n> 推荐指数 :💛💛💛💛💛💛💛\n\n| 标题：   | 主演：                                                | 导演：      | 上映年代： |\n| -------- | ----------------------------------------------------- | ----------- | ---------- |\n| 敢死队 2 | 西尔维斯特·史泰龙,杰森·斯坦森,李连杰,余男,查克·诺瑞斯 | 西蒙·韦斯特 | 2012       |\n\n<!-- more -->\n\n![](http://mv.v5ant.com/upload/vod/20190604-1/f995c128b8ffa24e0ed07f9d8b1915f8.jpg)\n\n### 介绍\n\n再次经历了一番炮火密集的血雨腥风，巴尼（西尔维斯特·史泰龙 Sylvester Stallone 饰）、圣诞（杰森·斯坦森 Jason Statham 饰）、贡纳（杜夫·龙格尔 Dolph Lundgren 饰）、比利（利亚姆·海姆斯沃斯 Liam Hemsworth 饰）、收费公路（兰迪·库卓 Randy Couture 饰）和凯撒（泰瑞·克鲁斯 Terry Crews 饰）这几个敢死队的铁哥们正享受大战之后的难得惬意可是好景不长，某晚教堂（布鲁斯·威利斯 Bruce Willis 饰）找上门来，迫令他前往阿尔巴尼亚噶扎克山区找一架被击落飞机上的保险箱，并确保箱子不会落入敌人之手，教堂还委派麦琪·张（余男 饰）与这群硬汉同行。\n\n看似简单的任务实则充满凶险，比利被对手残忍杀害。这已不再是一项任务，而是一场关乎战士们友情与荣誉的战争……\n\n### 在线直播\n\n{% iframe http://jx.v5ant.com?v=https://youku.mhyunbo.com/20200106/G84QzAdC/index.m3u8 100% 500px %}\n\n[HD1080P 中字(普通话版)](http://jx.v5ant.com?v=https://rebo.rebo5566.com/20190606/yIYoq9Fs/index.m3u8)\n[HD1080P 中字(原声版)](http://jx.v5ant.com?v=https://rebo.rebo5566.com/20190606/FkvHdI2n/index.m3u8)\n[BD720P 国语](http://jx.v5ant.com?v=https://www.rebo5566.com/20190529/fO5MtFjS/index.m3u8)\n\n<font color=\"red\">如遇到不能播放或者无法加载出播放窗口，请检测是否浏览器是否开启了脚本阻止，也可以前往http://mv.v5ant.com 搜索更多影视资源</font>\n","source":"_posts/高清在线直播-1.md","raw":"---\ntitle: 敢死队2-HDTC中英字在线观看\ncomments: true\ntoc: true\ncategories:\n  - 影视资源\nthumbnail: http://mv.v5ant.com/upload/vod/20190604-1/f995c128b8ffa24e0ed07f9d8b1915f8.jpg\ndate: 2020-01-08 11:48:19\nupdated: 2020-01-08 11:48:19\ntags:\n---\n\n> 推荐指数 :💛💛💛💛💛💛💛\n\n| 标题：   | 主演：                                                | 导演：      | 上映年代： |\n| -------- | ----------------------------------------------------- | ----------- | ---------- |\n| 敢死队 2 | 西尔维斯特·史泰龙,杰森·斯坦森,李连杰,余男,查克·诺瑞斯 | 西蒙·韦斯特 | 2012       |\n\n<!-- more -->\n\n![](http://mv.v5ant.com/upload/vod/20190604-1/f995c128b8ffa24e0ed07f9d8b1915f8.jpg)\n\n### 介绍\n\n再次经历了一番炮火密集的血雨腥风，巴尼（西尔维斯特·史泰龙 Sylvester Stallone 饰）、圣诞（杰森·斯坦森 Jason Statham 饰）、贡纳（杜夫·龙格尔 Dolph Lundgren 饰）、比利（利亚姆·海姆斯沃斯 Liam Hemsworth 饰）、收费公路（兰迪·库卓 Randy Couture 饰）和凯撒（泰瑞·克鲁斯 Terry Crews 饰）这几个敢死队的铁哥们正享受大战之后的难得惬意可是好景不长，某晚教堂（布鲁斯·威利斯 Bruce Willis 饰）找上门来，迫令他前往阿尔巴尼亚噶扎克山区找一架被击落飞机上的保险箱，并确保箱子不会落入敌人之手，教堂还委派麦琪·张（余男 饰）与这群硬汉同行。\n\n看似简单的任务实则充满凶险，比利被对手残忍杀害。这已不再是一项任务，而是一场关乎战士们友情与荣誉的战争……\n\n### 在线直播\n\n{% iframe http://jx.v5ant.com?v=https://youku.mhyunbo.com/20200106/G84QzAdC/index.m3u8 100% 500px %}\n\n[HD1080P 中字(普通话版)](http://jx.v5ant.com?v=https://rebo.rebo5566.com/20190606/yIYoq9Fs/index.m3u8)\n[HD1080P 中字(原声版)](http://jx.v5ant.com?v=https://rebo.rebo5566.com/20190606/FkvHdI2n/index.m3u8)\n[BD720P 国语](http://jx.v5ant.com?v=https://www.rebo5566.com/20190529/fO5MtFjS/index.m3u8)\n\n<font color=\"red\">如遇到不能播放或者无法加载出播放窗口，请检测是否浏览器是否开启了脚本阻止，也可以前往http://mv.v5ant.com 搜索更多影视资源</font>\n","slug":"高清在线直播-1","published":1,"layout":"post","photos":[],"link":"","_id":"ckmp269g00051c8gs573g3lvj","content":"<blockquote>\n<p>推荐指数 :💛💛💛💛💛💛💛</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标题：</th>\n<th>主演：</th>\n<th>导演：</th>\n<th>上映年代：</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>敢死队 2</td>\n<td>西尔维斯特·史泰龙,杰森·斯坦森,李连杰,余男,查克·诺瑞斯</td>\n<td>西蒙·韦斯特</td>\n<td>2012</td>\n</tr>\n</tbody></table>\n<span id=\"more\"></span>\n\n<p><img src=\"http://mv.v5ant.com/upload/vod/20190604-1/f995c128b8ffa24e0ed07f9d8b1915f8.jpg\"></p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>再次经历了一番炮火密集的血雨腥风，巴尼（西尔维斯特·史泰龙 Sylvester Stallone 饰）、圣诞（杰森·斯坦森 Jason Statham 饰）、贡纳（杜夫·龙格尔 Dolph Lundgren 饰）、比利（利亚姆·海姆斯沃斯 Liam Hemsworth 饰）、收费公路（兰迪·库卓 Randy Couture 饰）和凯撒（泰瑞·克鲁斯 Terry Crews 饰）这几个敢死队的铁哥们正享受大战之后的难得惬意可是好景不长，某晚教堂（布鲁斯·威利斯 Bruce Willis 饰）找上门来，迫令他前往阿尔巴尼亚噶扎克山区找一架被击落飞机上的保险箱，并确保箱子不会落入敌人之手，教堂还委派麦琪·张（余男 饰）与这群硬汉同行。</p>\n<p>看似简单的任务实则充满凶险，比利被对手残忍杀害。这已不再是一项任务，而是一场关乎战士们友情与荣誉的战争……</p>\n<h3 id=\"在线直播\"><a href=\"#在线直播\" class=\"headerlink\" title=\"在线直播\"></a>在线直播</h3><iframe src=\"http://jx.v5ant.com/?v=https://youku.mhyunbo.com/20200106/G84QzAdC/index.m3u8\" width=\"100%\" height=\"500px\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n\n<p><a href=\"http://jx.v5ant.com/?v=https://rebo.rebo5566.com/20190606/yIYoq9Fs/index.m3u8\">HD1080P 中字(普通话版)</a><br><a href=\"http://jx.v5ant.com/?v=https://rebo.rebo5566.com/20190606/FkvHdI2n/index.m3u8\">HD1080P 中字(原声版)</a><br><a href=\"http://jx.v5ant.com/?v=https://www.rebo5566.com/20190529/fO5MtFjS/index.m3u8\">BD720P 国语</a></p>\n<p><font color=\"red\">如遇到不能播放或者无法加载出播放窗口，请检测是否浏览器是否开启了脚本阻止，也可以前往<a href=\"http://mv.v5ant.com/\">http://mv.v5ant.com</a> 搜索更多影视资源</font></p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"<blockquote>\n<p>推荐指数 :💛💛💛💛💛💛💛</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>标题：</th>\n<th>主演：</th>\n<th>导演：</th>\n<th>上映年代：</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>敢死队 2</td>\n<td>西尔维斯特·史泰龙,杰森·斯坦森,李连杰,余男,查克·诺瑞斯</td>\n<td>西蒙·韦斯特</td>\n<td>2012</td>\n</tr>\n</tbody></table>","more":"<p><img src=\"http://mv.v5ant.com/upload/vod/20190604-1/f995c128b8ffa24e0ed07f9d8b1915f8.jpg\"></p>\n<h3 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h3><p>再次经历了一番炮火密集的血雨腥风，巴尼（西尔维斯特·史泰龙 Sylvester Stallone 饰）、圣诞（杰森·斯坦森 Jason Statham 饰）、贡纳（杜夫·龙格尔 Dolph Lundgren 饰）、比利（利亚姆·海姆斯沃斯 Liam Hemsworth 饰）、收费公路（兰迪·库卓 Randy Couture 饰）和凯撒（泰瑞·克鲁斯 Terry Crews 饰）这几个敢死队的铁哥们正享受大战之后的难得惬意可是好景不长，某晚教堂（布鲁斯·威利斯 Bruce Willis 饰）找上门来，迫令他前往阿尔巴尼亚噶扎克山区找一架被击落飞机上的保险箱，并确保箱子不会落入敌人之手，教堂还委派麦琪·张（余男 饰）与这群硬汉同行。</p>\n<p>看似简单的任务实则充满凶险，比利被对手残忍杀害。这已不再是一项任务，而是一场关乎战士们友情与荣誉的战争……</p>\n<h3 id=\"在线直播\"><a href=\"#在线直播\" class=\"headerlink\" title=\"在线直播\"></a>在线直播</h3><iframe src=\"http://jx.v5ant.com/?v=https://youku.mhyunbo.com/20200106/G84QzAdC/index.m3u8\" width=\"100%\" height=\"500px\" frameborder=\"0\" loading=\"lazy\" allowfullscreen></iframe>\n\n<p><a href=\"http://jx.v5ant.com/?v=https://rebo.rebo5566.com/20190606/yIYoq9Fs/index.m3u8\">HD1080P 中字(普通话版)</a><br><a href=\"http://jx.v5ant.com/?v=https://rebo.rebo5566.com/20190606/FkvHdI2n/index.m3u8\">HD1080P 中字(原声版)</a><br><a href=\"http://jx.v5ant.com/?v=https://www.rebo5566.com/20190529/fO5MtFjS/index.m3u8\">BD720P 国语</a></p>\n<p><font color=\"red\">如遇到不能播放或者无法加载出播放窗口，请检测是否浏览器是否开启了脚本阻止，也可以前往<a href=\"http://mv.v5ant.com/\">http://mv.v5ant.com</a> 搜索更多影视资源</font></p>"},{"title":"2019最新前端知识梳理(周边部分)-面试宝典","url":"166.html","id":"166","date":"2019-06-22T09:23:47.000Z","_content":"\n## 八、编程题\n\n### 1 写一个通用的事件侦听器函数\n\n// event(事件)工具集，来源：github.com/markyun\n    markyun.Event = {\n\n//  视能力分别使用 dom0||dom2||IE 方式   来绑定事件\n        //  参数：  操作的元素,事件名称  ,事件处理程序\n        addEvent : function(element, type, handler) {\n            if (element.addEventListener) {\n                //事件类型、需要执行的函数、是否捕捉\n                element.addEventListener(type, handler, false);\n            } else if (element.attachEvent) {\n                element.attachEvent('on' + type, function() {\n                    handler.call(element);\n                });\n            } else {\n                element\\['on' + type\\] = handler;\n            }\n        },\n        //  移除事件\n        removeEvent : function(element, type, handler) {\n            if (element.removeEventListener) {\n                element.removeEventListener(type, handler, false);\n            } else if (element.datachEvent) {\n                element.detachEvent('on' + type, handler);\n            } else {\n                element\\['on' + type\\] = null;\n            }\n        },\n        //  阻止事件  (主要是事件冒泡，因为 IE 不支持事件捕获)\n        stopPropagation : function(ev) {\n            if (ev.stopPropagation) {\n                ev.stopPropagation();\n            } else {\n                ev.cancelBubble = true;\n            }\n        },\n        //  取消事件的默认行为\n        preventDefault : function(event) {\n            if (event.preventDefault) {\n                event.preventDefault();\n            } else {\n                event.returnValue = false;\n            }\n        },\n        //  获取事件目标\n        getTarget : function(event) {\n            return event.target || event.srcElement;\n        }\n\n### 2 如何判断一个对象是否为数组\n\nfunction isArray(arg) {\n    if (typeof arg === 'object') {\n        return Object.prototype.toString.call(arg) === '\\[object Array\\]';\n    }\n    return false;}\n\n### 3 冒泡排序\n\n- 每次比较相邻的两个数，如果后一个比前一个小，换位置\n\nvar arr = \\[3, 1, 4, 6, 5, 7, 2\\];function bubbleSort(arr) {for (var i = 0; i < arr.length - 1; i++) {\n    for(var j = 0; j < arr.length - i - 1; j++) {\n        if(arr\\[j + 1\\] < arr\\[j\\]) {\n            var temp;\n            temp = arr\\[j\\];\n            arr\\[j\\] = arr\\[j + 1\\];\n            arr\\[j + 1\\] = temp;\n        }\n    }}return arr;}console.log(bubbleSort(arr));\n\n### 4 快速排序\n\n- 采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边\n\nvar arr = \\[3, 1, 4, 6, 5, 7, 2\\];function quickSort(arr) {\n    if(arr.length == 0) {\n        return \\[\\];    //  返回空数组\n    }\n\nvar cIndex = Math.floor(arr.length / 2);\n    var c = arr.splice(cIndex, 1);\n    var l = \\[\\];\n    var r = \\[\\];\n\nfor (var i = 0; i < arr.length; i++) {\n        if(arr\\[i\\] < c) {\n            l.push(arr\\[i\\]);\n        } else {\n            r.push(arr\\[i\\]);\n        }\n    }\n\nreturn quickSort(l).concat(c, quickSort(r));}console.log(quickSort(arr));\n\n### 5 编写一个方法 求一个字符串的字节长度\n\n- 假设：一个英文字符占用一个字节，一个中文字符占用两个字节\n\nfunction GetBytes(str){\n\nvar len = str.length;\n\nvar bytes = len;\n\nfor(var i=0; i<len; i++){\n\nif (str.charCodeAt(i) > 255) bytes++;\n\n}\n\nreturn bytes;\n\n}alert(GetBytes(\"你好,as\"));\n\n### 6 bind 的用法，以及如何实现 bind 的函数和需要注意的点\n\n- `bind`的作用与`call`和`apply`相同，区别是`call`和`apply`是立即调用函数，而`bind`是返回了一个函数，需要调用的时候再执行。 一个简单的`bind`函数实现如下\n\nFunction.prototype.bind = function(ctx) {\n    var fn = this;\n    return function() {\n        fn.apply(ctx, arguments);\n    };};\n\n### 7 实现一个函数 clone\n\n> 可以对`JavaScript`中的 5 种主要的数据类型,包括`Number`、`String`、`Object`、`Array`、`Boolean`）进行值复\n\n- 考察点 1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚\n- 考察点 2：是否知道如何判断一个变量是什么类型的\n- 考察点 3：递归算法的设计\n\n//  方法一：\n  Object.prototype.clone = function(){\n          var o = this.constructor === Array ? \\[\\] : {};\n          for(var e in this){\n                  o\\[e\\] = typeof this\\[e\\] === \"object\" ? this\\[e\\].clone() : this\\[e\\];\n          }\n          return o;\n  }\n\n//方法二：\n   /\\*\\*\n      *  克隆一个对象\n      * @param Obj\n      * @returns\n      */\n     function clone(Obj) {   \n         var buf;   \n         if (Obj instanceof Array) {   \n             buf = \\[\\];                    //创建一个空的数组\n             var i = Obj.length;   \n             while (i--) {   \n                 buf\\[i\\] = clone(Obj\\[i\\]);   \n             }   \n             return buf;    \n         }else if (Obj instanceof Object){   \n             buf = {};                   //创建一个空对象\n             for (var k in Obj) {           //为这个对象添加新的属性\n                 buf\\[k\\] = clone(Obj\\[k\\]);   \n             }   \n             return buf;   \n         }else{                         //普通变量直接赋值\n             return Obj;   \n         }   \n     }\n\n### 8 下面这个 ul，如何点击每一列的时候 alert 其 index\n\n> \b 考察闭包\n\n<ul id=”test”>\n     <li>这是第一条</li>\n     <li>这是第二条</li>\n     <li>这是第三条</li>\n </ul>\n\n//  方法一：\n  var lis=document.getElementById('2223').getElementsByTagName('li');\n  for(var i=0;i<3;i++)\n  {\n      lis\\[i\\].index=i;\n      lis\\[i\\].onclick=function(){\n          alert(this.index);\n  }\n\n//方法二：\n var lis=document.getElementById('2223').getElementsByTagName('li');\n for(var i=0;i<3;i++)\n {\n     lis\\[i\\].index=i;\n     lis\\[i\\].onclick=(function(a){\n         return function() {\n             alert(a);\n         }\n     })(i);\n }\n\n### 9 定义一个 log 方法，让它可以代理 console.log 的方法\n\n可行的方法一： function log(msg)　{\n     console.log(msg);\n }\n\nlog(\"hello world!\") // hello world!\n\n> 如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是：\n\nfunction log(){\n     console.log.apply(console, arguments);\n };\n\n### 10 输出今天的日期\n\n> 以`YYYY-MM-DD`的方式，比如今天是 2014 年 9 月 26 日，则输出 2014-09-26\n\nvar d = new Date();\n  //  获取年，getFullYear()返回 4 位的数字\n  var year = d.getFullYear();\n  //  获取月，月份比较特殊，0 是 1 月，11 是 12 月\n  var month = d.getMonth() + 1;\n  //  变成两位\n  month = month < 10 ? '0' + month : month;\n  //  获取日\n  var day = d.getDate();\n day = day < 10 ? '0' + day : day;\n alert(year + '-' + month + '-' + day);\n\n### 11 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序\n\nvar iArray = \\[\\];\n funtion getRandom(istart, iend){\n         var iChoice = istart - iend +1;\n         return Math.floor(Math.random() \\* iChoice + istart;\n }\n for(var i=0; i<10; i++){\n         iArray.push(getRandom(10,100));\n }\n iArray.sort();\n\n### 12 写一段 JS 程序提取 URL 中的各个 GET 参数\n\n> 有这样一个`URL`：`http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e`，请写一段 JS 程序提取 URL 中的各个 GET 参数(参数名和参数个数不确定)，将其按`key-value`形式返回到一个`json`结构中，如`{a:'1', b:'2', c:'', d:'xxx', e:undefined}`\n\nfunction serilizeUrl(url) {\n     var result = {};\n     url = url.split(\"?\")\\[1\\];\n     var map = url.split(\"&\");\n     for(var i = 0, len = map.length; i < len; i++) {\n         result\\[map\\[i\\].split(\"=\")\\[0\\]\\] = map\\[i\\].split(\"=\")\\[1\\];\n     }\n     return result;\n }\n\n### 13 写一个`function`，清除字符串前后的空格\n\n> 使用自带接口`trim()`，考虑兼容性：\n\nif (!String.prototype.trim) {\n    String.prototype.trim = function() {\n        return this.replace(/^\\\\s+/, \"\").replace(/\\\\s+\\$/,\"\");\n    }}\n\n// test the function\n var str = \" \\\\t\\\\n test string \".trim();\n alert(str == \"test string\"); // alerts \"true\"\n\n### 14 实现每隔一秒钟输出 1,2,3...数字\n\nfor(var i=0;i<10;i++){\n  (function(j){\n     setTimeout(function(){\n       console.log(j+1)\n     },j\\*1000)\n   })(i)}\n\n### 15 实现一个函数，判断输入是不是回文字符串\n\nfunction run(input) {\n  if (typeof input !== 'string') return false;\n  return input.split('').reverse().join('') === input;}\n\n### 16、数组扁平化处理\n\n> 实现一个`flatten`方法，使得输入一个数组，该数组里面的元素也可以是数组，该方法会输出一个扁平化的数组\n\nfunction flatten(arr){\n    return arr.reduce(function(prev,item){\n        return prev.concat(Array.isArray(item)?flatten(item):item);\n    },\\[\\]);}\n\n## 九、其他\n\n### 1 负载均衡\n\n> 多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用\n\n- `http`重定向负载均衡：调度者根据策略选择服务器以 302 响应请求，缺点只有第一次有效果，后续操作维持在该服务器 dns 负载均衡：解析域名时，访问多个`ip`服务器中的一个（可监控性较弱）\n- 反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量\n\n### 2 CDN\n\n> 内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。\n\n### 3 内存泄漏\n\n> 定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。\n\njs 中可能出现的内存泄漏情况\n\n> 结果：变慢，崩溃，延迟大等，原因：\n\n- 全局变量\n- `dom`清空时，还存在引用\n- `ie`中使用闭包\n- 定时器未清除\n- 子元素存在引起的内存泄露\n\n避免策略\n\n- 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；\n- 注意程序逻辑，避免“死循环”之类的 ；\n- 避免创建过多的对象 原则：不用了的东西要及时归还。\n- 减少层级过多的引用\n\n### 4 babel 原理\n\n> `ES6、7`代码输入 -> `babylon`进行解析 -\\> 得到`AST`（抽象语法树）-> `plugin`用 b`abel-traverse`对`AST`树进行遍历转译 ->得到新的`AST`树->用`babel-generator`通过`AST`树生成`ES5`代码\n\n### 5 js 自定义事件\n\n> 三要素： `document.createEvent()` ` event.initEvent()``element.dispatchEvent() `\n\n// (en:自定义事件名称，fn:事件处理函数，addEvent:为 DOM 元素添加自定义事件，triggerEvent:触发自定义事件)window.onload = function(){\n    var demo = document.getElementById(\"demo\");\n    demo.addEvent(\"test\",function(){console.log(\"handler1\")});\n    demo.addEvent(\"test\",function(){console.log(\"handler2\")});\n    demo.onclick = function(){\n        this.triggerEvent(\"test\");\n    }}Element.prototype.addEvent = function(en,fn){\n    this.pools = this.pools || {};\n    if(en in this.pools){\n        this.pools\\[en\\].push(fn);\n    }else{\n        this.pools\\[en\\] = \\[\\];\n        this.pools\\[en\\].push(fn);\n    }}Element.prototype.triggerEvent  = function(en){\n    if(en in this.pools){\n        var fns = this.pools\\[en\\];\n        for(var i=0,il=fns.length;i<il;i++){\n            fns\\[i\\]();\n        }\n    }else{\n        return;\n    }}\n\n### 6 前后端路由差别\n\n- 后端每次路由请求都是重新访问服务器\n- 前端路由实际上只是`JS`根据`URL`来操作`DOM`元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合\n\n## 十、综合\n\n### 1 谈谈你对重构的理解\n\n- 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化， 在扩展的同时保持一致的 UI\n- 对于传统的网站来说重构通常是：\n  - 表格(`table`)布局改为`DIV+CSS`\n  - 使网站前端兼容于现代浏览器(针对于不合规范的`CSS`、如对 IE6 有效的)\n  - 对于移动平台的优化\n  - 针对于`SEO`进行优化\n\n### 2 什么样的前端代码是好的\n\n- 高复用低耦合，这样文件小，好维护，而且好扩展。\n- 具有可用性、健壮性、可靠性、宽容性等特点\n- 遵循设计模式的六大原则\n\n### 3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样\n\n- 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近\n  - 实现界面交互\n  - 提升用户体验\n  - 基于 NodeJS，可跨平台开发\n- 前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好，\n- 与团队成员，`UI`设计，产品经理的沟通；\n- 做好的页面结构，页面重构和用户体验；\n\n### 4 你觉得前端工程的价值体现在哪\n\n- 为简化用户使用提供技术支持（交互部分）\n- 为多个浏览器兼容性提供支持\n- 为提高用户浏览速度（浏览器性能）提供支持\n- 为跨平台或者其他基于 webkit 或其他渲染引擎的应用提供支持\n- 为展示数据提供支持（数据接口）\n\n### 5 平时如何管理你的项目\n\n- 先期团队必须确定好全局样式（`globe.css`），编码模式(`utf-8`) 等；\n- 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；\n- 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；\n- 页面进行标注（例如 页面 模块 开始和结束）；\n- `CSS`跟`HTML`  分文件夹并行存放，命名都得统一（例如`style.css`）；\n- `JS`  分文件夹存放 命名以该`JS`功能为准的英文翻译。\n- 图片采用整合的  `images.png png8`  格式文件使用 \\- 尽量整合在一起使用方便将来的管理\n\n### 6 组件封装\n\n> 目的：为了重用，提高开发效率和代码质量 注意：低耦合，单一职责，可复用性，可维护性 常用操作\n\n- 分析布局\n- 初步开发\n- 化繁为简\n- 组件抽象\n","source":"_posts/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e5-91-a8-e8-be-b9-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8.md","raw":"---\ntitle: 2019最新前端知识梳理(周边部分)-面试宝典\ntags:\n  - 面试题\nurl: 166.html\nid: 166\ncategories:\n  - 大前端\n  - 面试题类\ndate: 2019-06-22 17:23:47\n---\n\n## 八、编程题\n\n### 1 写一个通用的事件侦听器函数\n\n// event(事件)工具集，来源：github.com/markyun\n    markyun.Event = {\n\n//  视能力分别使用 dom0||dom2||IE 方式   来绑定事件\n        //  参数：  操作的元素,事件名称  ,事件处理程序\n        addEvent : function(element, type, handler) {\n            if (element.addEventListener) {\n                //事件类型、需要执行的函数、是否捕捉\n                element.addEventListener(type, handler, false);\n            } else if (element.attachEvent) {\n                element.attachEvent('on' + type, function() {\n                    handler.call(element);\n                });\n            } else {\n                element\\['on' + type\\] = handler;\n            }\n        },\n        //  移除事件\n        removeEvent : function(element, type, handler) {\n            if (element.removeEventListener) {\n                element.removeEventListener(type, handler, false);\n            } else if (element.datachEvent) {\n                element.detachEvent('on' + type, handler);\n            } else {\n                element\\['on' + type\\] = null;\n            }\n        },\n        //  阻止事件  (主要是事件冒泡，因为 IE 不支持事件捕获)\n        stopPropagation : function(ev) {\n            if (ev.stopPropagation) {\n                ev.stopPropagation();\n            } else {\n                ev.cancelBubble = true;\n            }\n        },\n        //  取消事件的默认行为\n        preventDefault : function(event) {\n            if (event.preventDefault) {\n                event.preventDefault();\n            } else {\n                event.returnValue = false;\n            }\n        },\n        //  获取事件目标\n        getTarget : function(event) {\n            return event.target || event.srcElement;\n        }\n\n### 2 如何判断一个对象是否为数组\n\nfunction isArray(arg) {\n    if (typeof arg === 'object') {\n        return Object.prototype.toString.call(arg) === '\\[object Array\\]';\n    }\n    return false;}\n\n### 3 冒泡排序\n\n- 每次比较相邻的两个数，如果后一个比前一个小，换位置\n\nvar arr = \\[3, 1, 4, 6, 5, 7, 2\\];function bubbleSort(arr) {for (var i = 0; i < arr.length - 1; i++) {\n    for(var j = 0; j < arr.length - i - 1; j++) {\n        if(arr\\[j + 1\\] < arr\\[j\\]) {\n            var temp;\n            temp = arr\\[j\\];\n            arr\\[j\\] = arr\\[j + 1\\];\n            arr\\[j + 1\\] = temp;\n        }\n    }}return arr;}console.log(bubbleSort(arr));\n\n### 4 快速排序\n\n- 采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边\n\nvar arr = \\[3, 1, 4, 6, 5, 7, 2\\];function quickSort(arr) {\n    if(arr.length == 0) {\n        return \\[\\];    //  返回空数组\n    }\n\nvar cIndex = Math.floor(arr.length / 2);\n    var c = arr.splice(cIndex, 1);\n    var l = \\[\\];\n    var r = \\[\\];\n\nfor (var i = 0; i < arr.length; i++) {\n        if(arr\\[i\\] < c) {\n            l.push(arr\\[i\\]);\n        } else {\n            r.push(arr\\[i\\]);\n        }\n    }\n\nreturn quickSort(l).concat(c, quickSort(r));}console.log(quickSort(arr));\n\n### 5 编写一个方法 求一个字符串的字节长度\n\n- 假设：一个英文字符占用一个字节，一个中文字符占用两个字节\n\nfunction GetBytes(str){\n\nvar len = str.length;\n\nvar bytes = len;\n\nfor(var i=0; i<len; i++){\n\nif (str.charCodeAt(i) > 255) bytes++;\n\n}\n\nreturn bytes;\n\n}alert(GetBytes(\"你好,as\"));\n\n### 6 bind 的用法，以及如何实现 bind 的函数和需要注意的点\n\n- `bind`的作用与`call`和`apply`相同，区别是`call`和`apply`是立即调用函数，而`bind`是返回了一个函数，需要调用的时候再执行。 一个简单的`bind`函数实现如下\n\nFunction.prototype.bind = function(ctx) {\n    var fn = this;\n    return function() {\n        fn.apply(ctx, arguments);\n    };};\n\n### 7 实现一个函数 clone\n\n> 可以对`JavaScript`中的 5 种主要的数据类型,包括`Number`、`String`、`Object`、`Array`、`Boolean`）进行值复\n\n- 考察点 1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚\n- 考察点 2：是否知道如何判断一个变量是什么类型的\n- 考察点 3：递归算法的设计\n\n//  方法一：\n  Object.prototype.clone = function(){\n          var o = this.constructor === Array ? \\[\\] : {};\n          for(var e in this){\n                  o\\[e\\] = typeof this\\[e\\] === \"object\" ? this\\[e\\].clone() : this\\[e\\];\n          }\n          return o;\n  }\n\n//方法二：\n   /\\*\\*\n      *  克隆一个对象\n      * @param Obj\n      * @returns\n      */\n     function clone(Obj) {   \n         var buf;   \n         if (Obj instanceof Array) {   \n             buf = \\[\\];                    //创建一个空的数组\n             var i = Obj.length;   \n             while (i--) {   \n                 buf\\[i\\] = clone(Obj\\[i\\]);   \n             }   \n             return buf;    \n         }else if (Obj instanceof Object){   \n             buf = {};                   //创建一个空对象\n             for (var k in Obj) {           //为这个对象添加新的属性\n                 buf\\[k\\] = clone(Obj\\[k\\]);   \n             }   \n             return buf;   \n         }else{                         //普通变量直接赋值\n             return Obj;   \n         }   \n     }\n\n### 8 下面这个 ul，如何点击每一列的时候 alert 其 index\n\n> \b 考察闭包\n\n<ul id=”test”>\n     <li>这是第一条</li>\n     <li>这是第二条</li>\n     <li>这是第三条</li>\n </ul>\n\n//  方法一：\n  var lis=document.getElementById('2223').getElementsByTagName('li');\n  for(var i=0;i<3;i++)\n  {\n      lis\\[i\\].index=i;\n      lis\\[i\\].onclick=function(){\n          alert(this.index);\n  }\n\n//方法二：\n var lis=document.getElementById('2223').getElementsByTagName('li');\n for(var i=0;i<3;i++)\n {\n     lis\\[i\\].index=i;\n     lis\\[i\\].onclick=(function(a){\n         return function() {\n             alert(a);\n         }\n     })(i);\n }\n\n### 9 定义一个 log 方法，让它可以代理 console.log 的方法\n\n可行的方法一： function log(msg)　{\n     console.log(msg);\n }\n\nlog(\"hello world!\") // hello world!\n\n> 如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是：\n\nfunction log(){\n     console.log.apply(console, arguments);\n };\n\n### 10 输出今天的日期\n\n> 以`YYYY-MM-DD`的方式，比如今天是 2014 年 9 月 26 日，则输出 2014-09-26\n\nvar d = new Date();\n  //  获取年，getFullYear()返回 4 位的数字\n  var year = d.getFullYear();\n  //  获取月，月份比较特殊，0 是 1 月，11 是 12 月\n  var month = d.getMonth() + 1;\n  //  变成两位\n  month = month < 10 ? '0' + month : month;\n  //  获取日\n  var day = d.getDate();\n day = day < 10 ? '0' + day : day;\n alert(year + '-' + month + '-' + day);\n\n### 11 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序\n\nvar iArray = \\[\\];\n funtion getRandom(istart, iend){\n         var iChoice = istart - iend +1;\n         return Math.floor(Math.random() \\* iChoice + istart;\n }\n for(var i=0; i<10; i++){\n         iArray.push(getRandom(10,100));\n }\n iArray.sort();\n\n### 12 写一段 JS 程序提取 URL 中的各个 GET 参数\n\n> 有这样一个`URL`：`http://item.taobao.com/item.htm?a=1&b=2&c=&d=xxx&e`，请写一段 JS 程序提取 URL 中的各个 GET 参数(参数名和参数个数不确定)，将其按`key-value`形式返回到一个`json`结构中，如`{a:'1', b:'2', c:'', d:'xxx', e:undefined}`\n\nfunction serilizeUrl(url) {\n     var result = {};\n     url = url.split(\"?\")\\[1\\];\n     var map = url.split(\"&\");\n     for(var i = 0, len = map.length; i < len; i++) {\n         result\\[map\\[i\\].split(\"=\")\\[0\\]\\] = map\\[i\\].split(\"=\")\\[1\\];\n     }\n     return result;\n }\n\n### 13 写一个`function`，清除字符串前后的空格\n\n> 使用自带接口`trim()`，考虑兼容性：\n\nif (!String.prototype.trim) {\n    String.prototype.trim = function() {\n        return this.replace(/^\\\\s+/, \"\").replace(/\\\\s+\\$/,\"\");\n    }}\n\n// test the function\n var str = \" \\\\t\\\\n test string \".trim();\n alert(str == \"test string\"); // alerts \"true\"\n\n### 14 实现每隔一秒钟输出 1,2,3...数字\n\nfor(var i=0;i<10;i++){\n  (function(j){\n     setTimeout(function(){\n       console.log(j+1)\n     },j\\*1000)\n   })(i)}\n\n### 15 实现一个函数，判断输入是不是回文字符串\n\nfunction run(input) {\n  if (typeof input !== 'string') return false;\n  return input.split('').reverse().join('') === input;}\n\n### 16、数组扁平化处理\n\n> 实现一个`flatten`方法，使得输入一个数组，该数组里面的元素也可以是数组，该方法会输出一个扁平化的数组\n\nfunction flatten(arr){\n    return arr.reduce(function(prev,item){\n        return prev.concat(Array.isArray(item)?flatten(item):item);\n    },\\[\\]);}\n\n## 九、其他\n\n### 1 负载均衡\n\n> 多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用\n\n- `http`重定向负载均衡：调度者根据策略选择服务器以 302 响应请求，缺点只有第一次有效果，后续操作维持在该服务器 dns 负载均衡：解析域名时，访问多个`ip`服务器中的一个（可监控性较弱）\n- 反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量\n\n### 2 CDN\n\n> 内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。\n\n### 3 内存泄漏\n\n> 定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。\n\njs 中可能出现的内存泄漏情况\n\n> 结果：变慢，崩溃，延迟大等，原因：\n\n- 全局变量\n- `dom`清空时，还存在引用\n- `ie`中使用闭包\n- 定时器未清除\n- 子元素存在引起的内存泄露\n\n避免策略\n\n- 减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；\n- 注意程序逻辑，避免“死循环”之类的 ；\n- 避免创建过多的对象 原则：不用了的东西要及时归还。\n- 减少层级过多的引用\n\n### 4 babel 原理\n\n> `ES6、7`代码输入 -> `babylon`进行解析 -\\> 得到`AST`（抽象语法树）-> `plugin`用 b`abel-traverse`对`AST`树进行遍历转译 ->得到新的`AST`树->用`babel-generator`通过`AST`树生成`ES5`代码\n\n### 5 js 自定义事件\n\n> 三要素： `document.createEvent()` ` event.initEvent()``element.dispatchEvent() `\n\n// (en:自定义事件名称，fn:事件处理函数，addEvent:为 DOM 元素添加自定义事件，triggerEvent:触发自定义事件)window.onload = function(){\n    var demo = document.getElementById(\"demo\");\n    demo.addEvent(\"test\",function(){console.log(\"handler1\")});\n    demo.addEvent(\"test\",function(){console.log(\"handler2\")});\n    demo.onclick = function(){\n        this.triggerEvent(\"test\");\n    }}Element.prototype.addEvent = function(en,fn){\n    this.pools = this.pools || {};\n    if(en in this.pools){\n        this.pools\\[en\\].push(fn);\n    }else{\n        this.pools\\[en\\] = \\[\\];\n        this.pools\\[en\\].push(fn);\n    }}Element.prototype.triggerEvent  = function(en){\n    if(en in this.pools){\n        var fns = this.pools\\[en\\];\n        for(var i=0,il=fns.length;i<il;i++){\n            fns\\[i\\]();\n        }\n    }else{\n        return;\n    }}\n\n### 6 前后端路由差别\n\n- 后端每次路由请求都是重新访问服务器\n- 前端路由实际上只是`JS`根据`URL`来操作`DOM`元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合\n\n## 十、综合\n\n### 1 谈谈你对重构的理解\n\n- 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化， 在扩展的同时保持一致的 UI\n- 对于传统的网站来说重构通常是：\n  - 表格(`table`)布局改为`DIV+CSS`\n  - 使网站前端兼容于现代浏览器(针对于不合规范的`CSS`、如对 IE6 有效的)\n  - 对于移动平台的优化\n  - 针对于`SEO`进行优化\n\n### 2 什么样的前端代码是好的\n\n- 高复用低耦合，这样文件小，好维护，而且好扩展。\n- 具有可用性、健壮性、可靠性、宽容性等特点\n- 遵循设计模式的六大原则\n\n### 3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样\n\n- 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近\n  - 实现界面交互\n  - 提升用户体验\n  - 基于 NodeJS，可跨平台开发\n- 前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好，\n- 与团队成员，`UI`设计，产品经理的沟通；\n- 做好的页面结构，页面重构和用户体验；\n\n### 4 你觉得前端工程的价值体现在哪\n\n- 为简化用户使用提供技术支持（交互部分）\n- 为多个浏览器兼容性提供支持\n- 为提高用户浏览速度（浏览器性能）提供支持\n- 为跨平台或者其他基于 webkit 或其他渲染引擎的应用提供支持\n- 为展示数据提供支持（数据接口）\n\n### 5 平时如何管理你的项目\n\n- 先期团队必须确定好全局样式（`globe.css`），编码模式(`utf-8`) 等；\n- 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；\n- 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；\n- 页面进行标注（例如 页面 模块 开始和结束）；\n- `CSS`跟`HTML`  分文件夹并行存放，命名都得统一（例如`style.css`）；\n- `JS`  分文件夹存放 命名以该`JS`功能为准的英文翻译。\n- 图片采用整合的  `images.png png8`  格式文件使用 \\- 尽量整合在一起使用方便将来的管理\n\n### 6 组件封装\n\n> 目的：为了重用，提高开发效率和代码质量 注意：低耦合，单一职责，可复用性，可维护性 常用操作\n\n- 分析布局\n- 初步开发\n- 化繁为简\n- 组件抽象\n","slug":"2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e5-91-a8-e8-be-b9-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8","published":1,"updated":"2019-09-12T02:59:35.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269g5005ac8gsep10hthh","content":"<h2 id=\"八、编程题\"><a href=\"#八、编程题\" class=\"headerlink\" title=\"八、编程题\"></a>八、编程题</h2><h3 id=\"1-写一个通用的事件侦听器函数\"><a href=\"#1-写一个通用的事件侦听器函数\" class=\"headerlink\" title=\"1 写一个通用的事件侦听器函数\"></a>1 写一个通用的事件侦听器函数</h3><p>// event(事件)工具集，来源：github.com/markyun<br>    markyun.Event = {</p>\n<p>//  视能力分别使用 dom0||dom2||IE 方式   来绑定事件<br>        //  参数：  操作的元素,事件名称  ,事件处理程序<br>        addEvent : function(element, type, handler) {<br>            if (element.addEventListener) {<br>                //事件类型、需要执行的函数、是否捕捉<br>                element.addEventListener(type, handler, false);<br>            } else if (element.attachEvent) {<br>                element.attachEvent(‘on’ + type, function() {<br>                    handler.call(element);<br>                });<br>            } else {<br>                element[‘on’ + type] = handler;<br>            }<br>        },<br>        //  移除事件<br>        removeEvent : function(element, type, handler) {<br>            if (element.removeEventListener) {<br>                element.removeEventListener(type, handler, false);<br>            } else if (element.datachEvent) {<br>                element.detachEvent(‘on’ + type, handler);<br>            } else {<br>                element[‘on’ + type] = null;<br>            }<br>        },<br>        //  阻止事件  (主要是事件冒泡，因为 IE 不支持事件捕获)<br>        stopPropagation : function(ev) {<br>            if (ev.stopPropagation) {<br>                ev.stopPropagation();<br>            } else {<br>                ev.cancelBubble = true;<br>            }<br>        },<br>        //  取消事件的默认行为<br>        preventDefault : function(event) {<br>            if (event.preventDefault) {<br>                event.preventDefault();<br>            } else {<br>                event.returnValue = false;<br>            }<br>        },<br>        //  获取事件目标<br>        getTarget : function(event) {<br>            return event.target || event.srcElement;<br>        }</p>\n<h3 id=\"2-如何判断一个对象是否为数组\"><a href=\"#2-如何判断一个对象是否为数组\" class=\"headerlink\" title=\"2 如何判断一个对象是否为数组\"></a>2 如何判断一个对象是否为数组</h3><p>function isArray(arg) {<br>    if (typeof arg === ‘object’) {<br>        return Object.prototype.toString.call(arg) === ‘[object Array]‘;<br>    }<br>    return false;}</p>\n<h3 id=\"3-冒泡排序\"><a href=\"#3-冒泡排序\" class=\"headerlink\" title=\"3 冒泡排序\"></a>3 冒泡排序</h3><ul>\n<li>每次比较相邻的两个数，如果后一个比前一个小，换位置</li>\n</ul>\n<p>var arr = [3, 1, 4, 6, 5, 7, 2];function bubbleSort(arr) {for (var i = 0; i &lt; arr.length - 1; i++) {<br>    for(var j = 0; j &lt; arr.length - i - 1; j++) {<br>        if(arr[j + 1] &lt; arr[j]) {<br>            var temp;<br>            temp = arr[j];<br>            arr[j] = arr[j + 1];<br>            arr[j + 1] = temp;<br>        }<br>    }}return arr;}console.log(bubbleSort(arr));</p>\n<h3 id=\"4-快速排序\"><a href=\"#4-快速排序\" class=\"headerlink\" title=\"4 快速排序\"></a>4 快速排序</h3><ul>\n<li>采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边</li>\n</ul>\n<p>var arr = [3, 1, 4, 6, 5, 7, 2];function quickSort(arr) {<br>    if(arr.length == 0) {<br>        return [];    //  返回空数组<br>    }</p>\n<p>var cIndex = Math.floor(arr.length / 2);<br>    var c = arr.splice(cIndex, 1);<br>    var l = [];<br>    var r = [];</p>\n<p>for (var i = 0; i &lt; arr.length; i++) {<br>        if(arr[i] &lt; c) {<br>            l.push(arr[i]);<br>        } else {<br>            r.push(arr[i]);<br>        }<br>    }</p>\n<p>return quickSort(l).concat(c, quickSort(r));}console.log(quickSort(arr));</p>\n<h3 id=\"5-编写一个方法-求一个字符串的字节长度\"><a href=\"#5-编写一个方法-求一个字符串的字节长度\" class=\"headerlink\" title=\"5 编写一个方法 求一个字符串的字节长度\"></a>5 编写一个方法 求一个字符串的字节长度</h3><ul>\n<li>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</li>\n</ul>\n<p>function GetBytes(str){</p>\n<p>var len = str.length;</p>\n<p>var bytes = len;</p>\n<p>for(var i=0; i&lt;len; i++){</p>\n<p>if (str.charCodeAt(i) &gt; 255) bytes++;</p>\n<p>}</p>\n<p>return bytes;</p>\n<p>}alert(GetBytes(“你好,as”));</p>\n<h3 id=\"6-bind-的用法，以及如何实现-bind-的函数和需要注意的点\"><a href=\"#6-bind-的用法，以及如何实现-bind-的函数和需要注意的点\" class=\"headerlink\" title=\"6 bind 的用法，以及如何实现 bind 的函数和需要注意的点\"></a>6 bind 的用法，以及如何实现 bind 的函数和需要注意的点</h3><ul>\n<li><code>bind</code>的作用与<code>call</code>和<code>apply</code>相同，区别是<code>call</code>和<code>apply</code>是立即调用函数，而<code>bind</code>是返回了一个函数，需要调用的时候再执行。 一个简单的<code>bind</code>函数实现如下</li>\n</ul>\n<p>Function.prototype.bind = function(ctx) {<br>    var fn = this;<br>    return function() {<br>        fn.apply(ctx, arguments);<br>    };};</p>\n<h3 id=\"7-实现一个函数-clone\"><a href=\"#7-实现一个函数-clone\" class=\"headerlink\" title=\"7 实现一个函数 clone\"></a>7 实现一个函数 clone</h3><blockquote>\n<p>可以对<code>JavaScript</code>中的 5 种主要的数据类型,包括<code>Number</code>、<code>String</code>、<code>Object</code>、<code>Array</code>、<code>Boolean</code>）进行值复</p>\n</blockquote>\n<ul>\n<li>考察点 1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚</li>\n<li>考察点 2：是否知道如何判断一个变量是什么类型的</li>\n<li>考察点 3：递归算法的设计</li>\n</ul>\n<p>//  方法一：<br>  Object.prototype.clone = function(){<br>          var o = this.constructor === Array ? [] : {};<br>          for(var e in this){<br>                  o[e] = typeof this[e] === “object” ? this[e].clone() : this[e];<br>          }<br>          return o;<br>  }</p>\n<p>//方法二：<br>   /**<br>      *  克隆一个对象<br>      * @param Obj<br>      * @returns<br>      */<br>     function clone(Obj) {   <br>         var buf;   <br>         if (Obj instanceof Array) {   <br>             buf = [];                    //创建一个空的数组<br>             var i = Obj.length;   <br>             while (i–) {   <br>                 buf[i] = clone(Obj[i]);   <br>             }   <br>             return buf;    <br>         }else if (Obj instanceof Object){   <br>             buf = {};                   //创建一个空对象<br>             for (var k in Obj) {           //为这个对象添加新的属性<br>                 buf[k] = clone(Obj[k]);   <br>             }   <br>             return buf;   <br>         }else{                         //普通变量直接赋值<br>             return Obj;   <br>         }   <br>     }</p>\n<h3 id=\"8-下面这个-ul，如何点击每一列的时候-alert-其-index\"><a href=\"#8-下面这个-ul，如何点击每一列的时候-alert-其-index\" class=\"headerlink\" title=\"8 下面这个 ul，如何点击每一列的时候 alert 其 index\"></a>8 下面这个 ul，如何点击每一列的时候 alert 其 index</h3><blockquote>\n<p>\b 考察闭包</p>\n</blockquote>\n<p><ul id=”test”><br>     <li>这是第一条</li><br>     <li>这是第二条</li><br>     <li>这是第三条</li><br> </ul></p>\n<p>//  方法一：<br>  var lis=document.getElementById(‘2223’).getElementsByTagName(‘li’);<br>  for(var i=0;i&lt;3;i++)<br>  {<br>      lis[i].index=i;<br>      lis[i].onclick=function(){<br>          alert(this.index);<br>  }</p>\n<p>//方法二：<br> var lis=document.getElementById(‘2223’).getElementsByTagName(‘li’);<br> for(var i=0;i&lt;3;i++)<br> {<br>     lis[i].index=i;<br>     lis[i].onclick=(function(a){<br>         return function() {<br>             alert(a);<br>         }<br>     })(i);<br> }</p>\n<h3 id=\"9-定义一个-log-方法，让它可以代理-console-log-的方法\"><a href=\"#9-定义一个-log-方法，让它可以代理-console-log-的方法\" class=\"headerlink\" title=\"9 定义一个 log 方法，让它可以代理 console.log 的方法\"></a>9 定义一个 log 方法，让它可以代理 console.log 的方法</h3><p>可行的方法一： function log(msg)　{<br>     console.log(msg);<br> }</p>\n<p>log(“hello world!”) // hello world!</p>\n<blockquote>\n<p>如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是：</p>\n</blockquote>\n<p>function log(){<br>     console.log.apply(console, arguments);<br> };</p>\n<h3 id=\"10-输出今天的日期\"><a href=\"#10-输出今天的日期\" class=\"headerlink\" title=\"10 输出今天的日期\"></a>10 输出今天的日期</h3><blockquote>\n<p>以<code>YYYY-MM-DD</code>的方式，比如今天是 2014 年 9 月 26 日，则输出 2014-09-26</p>\n</blockquote>\n<p>var d = new Date();<br>  //  获取年，getFullYear()返回 4 位的数字<br>  var year = d.getFullYear();<br>  //  获取月，月份比较特殊，0 是 1 月，11 是 12 月<br>  var month = d.getMonth() + 1;<br>  //  变成两位<br>  month = month &lt; 10 ? ‘0’ + month : month;<br>  //  获取日<br>  var day = d.getDate();<br> day = day &lt; 10 ? ‘0’ + day : day;<br> alert(year + ‘-‘ + month + ‘-‘ + day);</p>\n<h3 id=\"11-用-js-实现随机选取-10–100-之间的-10-个数字，存入一个数组，并排序\"><a href=\"#11-用-js-实现随机选取-10–100-之间的-10-个数字，存入一个数组，并排序\" class=\"headerlink\" title=\"11 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序\"></a>11 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序</h3><p>var iArray = [];<br> funtion getRandom(istart, iend){<br>         var iChoice = istart - iend +1;<br>         return Math.floor(Math.random() * iChoice + istart;<br> }<br> for(var i=0; i&lt;10; i++){<br>         iArray.push(getRandom(10,100));<br> }<br> iArray.sort();</p>\n<h3 id=\"12-写一段-JS-程序提取-URL-中的各个-GET-参数\"><a href=\"#12-写一段-JS-程序提取-URL-中的各个-GET-参数\" class=\"headerlink\" title=\"12 写一段 JS 程序提取 URL 中的各个 GET 参数\"></a>12 写一段 JS 程序提取 URL 中的各个 GET 参数</h3><blockquote>\n<p>有这样一个<code>URL</code>：<code>http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e</code>，请写一段 JS 程序提取 URL 中的各个 GET 参数(参数名和参数个数不确定)，将其按<code>key-value</code>形式返回到一个<code>json</code>结构中，如<code>&#123;a:&#39;1&#39;, b:&#39;2&#39;, c:&#39;&#39;, d:&#39;xxx&#39;, e:undefined&#125;</code></p>\n</blockquote>\n<p>function serilizeUrl(url) {<br>     var result = {};<br>     url = url.split(“?”)[1];<br>     var map = url.split(“&amp;”);<br>     for(var i = 0, len = map.length; i &lt; len; i++) {<br>         result[map[i].split(“=”)[0]] = map[i].split(“=”)[1];<br>     }<br>     return result;<br> }</p>\n<h3 id=\"13-写一个function，清除字符串前后的空格\"><a href=\"#13-写一个function，清除字符串前后的空格\" class=\"headerlink\" title=\"13 写一个function，清除字符串前后的空格\"></a>13 写一个<code>function</code>，清除字符串前后的空格</h3><blockquote>\n<p>使用自带接口<code>trim()</code>，考虑兼容性：</p>\n</blockquote>\n<p>if (!String.prototype.trim) {<br>    String.prototype.trim = function() {<br>        return this.replace(/^\\s+/, “”).replace(/\\s+$/,””);<br>    }}</p>\n<p>// test the function<br> var str = “ \\t\\n test string “.trim();<br> alert(str == “test string”); // alerts “true”</p>\n<h3 id=\"14-实现每隔一秒钟输出-1-2-3…数字\"><a href=\"#14-实现每隔一秒钟输出-1-2-3…数字\" class=\"headerlink\" title=\"14 实现每隔一秒钟输出 1,2,3…数字\"></a>14 实现每隔一秒钟输出 1,2,3…数字</h3><p>for(var i=0;i&lt;10;i++){<br>  (function(j){<br>     setTimeout(function(){<br>       console.log(j+1)<br>     },j*1000)<br>   })(i)}</p>\n<h3 id=\"15-实现一个函数，判断输入是不是回文字符串\"><a href=\"#15-实现一个函数，判断输入是不是回文字符串\" class=\"headerlink\" title=\"15 实现一个函数，判断输入是不是回文字符串\"></a>15 实现一个函数，判断输入是不是回文字符串</h3><p>function run(input) {<br>  if (typeof input !== ‘string’) return false;<br>  return input.split(‘’).reverse().join(‘’) === input;}</p>\n<h3 id=\"16、数组扁平化处理\"><a href=\"#16、数组扁平化处理\" class=\"headerlink\" title=\"16、数组扁平化处理\"></a>16、数组扁平化处理</h3><blockquote>\n<p>实现一个<code>flatten</code>方法，使得输入一个数组，该数组里面的元素也可以是数组，该方法会输出一个扁平化的数组</p>\n</blockquote>\n<p>function flatten(arr){<br>    return arr.reduce(function(prev,item){<br>        return prev.concat(Array.isArray(item)?flatten(item):item);<br>    },[]);}</p>\n<h2 id=\"九、其他\"><a href=\"#九、其他\" class=\"headerlink\" title=\"九、其他\"></a>九、其他</h2><h3 id=\"1-负载均衡\"><a href=\"#1-负载均衡\" class=\"headerlink\" title=\"1 负载均衡\"></a>1 负载均衡</h3><blockquote>\n<p>多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用</p>\n</blockquote>\n<ul>\n<li><code>http</code>重定向负载均衡：调度者根据策略选择服务器以 302 响应请求，缺点只有第一次有效果，后续操作维持在该服务器 dns 负载均衡：解析域名时，访问多个<code>ip</code>服务器中的一个（可监控性较弱）</li>\n<li>反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量</li>\n</ul>\n<h3 id=\"2-CDN\"><a href=\"#2-CDN\" class=\"headerlink\" title=\"2 CDN\"></a>2 CDN</h3><blockquote>\n<p>内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</p>\n</blockquote>\n<h3 id=\"3-内存泄漏\"><a href=\"#3-内存泄漏\" class=\"headerlink\" title=\"3 内存泄漏\"></a>3 内存泄漏</h3><blockquote>\n<p>定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。</p>\n</blockquote>\n<p>js 中可能出现的内存泄漏情况</p>\n<blockquote>\n<p>结果：变慢，崩溃，延迟大等，原因：</p>\n</blockquote>\n<ul>\n<li>全局变量</li>\n<li><code>dom</code>清空时，还存在引用</li>\n<li><code>ie</code>中使用闭包</li>\n<li>定时器未清除</li>\n<li>子元素存在引起的内存泄露</li>\n</ul>\n<p>避免策略</p>\n<ul>\n<li>减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</li>\n<li>注意程序逻辑，避免“死循环”之类的 ；</li>\n<li>避免创建过多的对象 原则：不用了的东西要及时归还。</li>\n<li>减少层级过多的引用</li>\n</ul>\n<h3 id=\"4-babel-原理\"><a href=\"#4-babel-原理\" class=\"headerlink\" title=\"4 babel 原理\"></a>4 babel 原理</h3><blockquote>\n<p><code>ES6、7</code>代码输入 -&gt; <code>babylon</code>进行解析 -&gt; 得到<code>AST</code>（抽象语法树）-&gt; <code>plugin</code>用 b<code>abel-traverse</code>对<code>AST</code>树进行遍历转译 -&gt;得到新的<code>AST</code>树-&gt;用<code>babel-generator</code>通过<code>AST</code>树生成<code>ES5</code>代码</p>\n</blockquote>\n<h3 id=\"5-js-自定义事件\"><a href=\"#5-js-自定义事件\" class=\"headerlink\" title=\"5 js 自定义事件\"></a>5 js 自定义事件</h3><blockquote>\n<p>三要素： <code>document.createEvent()</code> <code>event.initEvent()``element.dispatchEvent()</code></p>\n</blockquote>\n<p>// (en:自定义事件名称，fn:事件处理函数，addEvent:为 DOM 元素添加自定义事件，triggerEvent:触发自定义事件)window.onload = function(){<br>    var demo = document.getElementById(“demo”);<br>    demo.addEvent(“test”,function(){console.log(“handler1”)});<br>    demo.addEvent(“test”,function(){console.log(“handler2”)});<br>    demo.onclick = function(){<br>        this.triggerEvent(“test”);<br>    }}Element.prototype.addEvent = function(en,fn){<br>    this.pools = this.pools || {};<br>    if(en in this.pools){<br>        this.pools[en].push(fn);<br>    }else{<br>        this.pools[en] = [];<br>        this.pools[en].push(fn);<br>    }}Element.prototype.triggerEvent  = function(en){<br>    if(en in this.pools){<br>        var fns = this.pools[en];<br>        for(var i=0,il=fns.length;i&lt;il;i++){<br>            fns[i]();<br>        }<br>    }else{<br>        return;<br>    }}</p>\n<h3 id=\"6-前后端路由差别\"><a href=\"#6-前后端路由差别\" class=\"headerlink\" title=\"6 前后端路由差别\"></a>6 前后端路由差别</h3><ul>\n<li>后端每次路由请求都是重新访问服务器</li>\n<li>前端路由实际上只是<code>JS</code>根据<code>URL</code>来操作<code>DOM</code>元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合</li>\n</ul>\n<h2 id=\"十、综合\"><a href=\"#十、综合\" class=\"headerlink\" title=\"十、综合\"></a>十、综合</h2><h3 id=\"1-谈谈你对重构的理解\"><a href=\"#1-谈谈你对重构的理解\" class=\"headerlink\" title=\"1 谈谈你对重构的理解\"></a>1 谈谈你对重构的理解</h3><ul>\n<li>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化， 在扩展的同时保持一致的 UI</li>\n<li>对于传统的网站来说重构通常是：<ul>\n<li>表格(<code>table</code>)布局改为<code>DIV+CSS</code></li>\n<li>使网站前端兼容于现代浏览器(针对于不合规范的<code>CSS</code>、如对 IE6 有效的)</li>\n<li>对于移动平台的优化</li>\n<li>针对于<code>SEO</code>进行优化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-什么样的前端代码是好的\"><a href=\"#2-什么样的前端代码是好的\" class=\"headerlink\" title=\"2 什么样的前端代码是好的\"></a>2 什么样的前端代码是好的</h3><ul>\n<li>高复用低耦合，这样文件小，好维护，而且好扩展。</li>\n<li>具有可用性、健壮性、可靠性、宽容性等特点</li>\n<li>遵循设计模式的六大原则</li>\n</ul>\n<h3 id=\"3-对前端工程师这个职位是怎么样理解的？它的前景会怎么样\"><a href=\"#3-对前端工程师这个职位是怎么样理解的？它的前景会怎么样\" class=\"headerlink\" title=\"3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样\"></a>3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样</h3><ul>\n<li>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近<ul>\n<li>实现界面交互</li>\n<li>提升用户体验</li>\n<li>基于 NodeJS，可跨平台开发</li>\n</ul>\n</li>\n<li>前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好，</li>\n<li>与团队成员，<code>UI</code>设计，产品经理的沟通；</li>\n<li>做好的页面结构，页面重构和用户体验；</li>\n</ul>\n<h3 id=\"4-你觉得前端工程的价值体现在哪\"><a href=\"#4-你觉得前端工程的价值体现在哪\" class=\"headerlink\" title=\"4 你觉得前端工程的价值体现在哪\"></a>4 你觉得前端工程的价值体现在哪</h3><ul>\n<li>为简化用户使用提供技术支持（交互部分）</li>\n<li>为多个浏览器兼容性提供支持</li>\n<li>为提高用户浏览速度（浏览器性能）提供支持</li>\n<li>为跨平台或者其他基于 webkit 或其他渲染引擎的应用提供支持</li>\n<li>为展示数据提供支持（数据接口）</li>\n</ul>\n<h3 id=\"5-平时如何管理你的项目\"><a href=\"#5-平时如何管理你的项目\" class=\"headerlink\" title=\"5 平时如何管理你的项目\"></a>5 平时如何管理你的项目</h3><ul>\n<li>先期团队必须确定好全局样式（<code>globe.css</code>），编码模式(<code>utf-8</code>) 等；</li>\n<li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li>\n<li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li>\n<li>页面进行标注（例如 页面 模块 开始和结束）；</li>\n<li><code>CSS</code>跟<code>HTML</code>  分文件夹并行存放，命名都得统一（例如<code>style.css</code>）；</li>\n<li><code>JS</code>  分文件夹存放 命名以该<code>JS</code>功能为准的英文翻译。</li>\n<li>图片采用整合的  <code>images.png png8</code>  格式文件使用 - 尽量整合在一起使用方便将来的管理</li>\n</ul>\n<h3 id=\"6-组件封装\"><a href=\"#6-组件封装\" class=\"headerlink\" title=\"6 组件封装\"></a>6 组件封装</h3><blockquote>\n<p>目的：为了重用，提高开发效率和代码质量 注意：低耦合，单一职责，可复用性，可维护性 常用操作</p>\n</blockquote>\n<ul>\n<li>分析布局</li>\n<li>初步开发</li>\n<li>化繁为简</li>\n<li>组件抽象</li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"八、编程题\"><a href=\"#八、编程题\" class=\"headerlink\" title=\"八、编程题\"></a>八、编程题</h2><h3 id=\"1-写一个通用的事件侦听器函数\"><a href=\"#1-写一个通用的事件侦听器函数\" class=\"headerlink\" title=\"1 写一个通用的事件侦听器函数\"></a>1 写一个通用的事件侦听器函数</h3><p>// event(事件)工具集，来源：github.com/markyun<br>    markyun.Event = {</p>\n<p>//  视能力分别使用 dom0||dom2||IE 方式   来绑定事件<br>        //  参数：  操作的元素,事件名称  ,事件处理程序<br>        addEvent : function(element, type, handler) {<br>            if (element.addEventListener) {<br>                //事件类型、需要执行的函数、是否捕捉<br>                element.addEventListener(type, handler, false);<br>            } else if (element.attachEvent) {<br>                element.attachEvent(‘on’ + type, function() {<br>                    handler.call(element);<br>                });<br>            } else {<br>                element[‘on’ + type] = handler;<br>            }<br>        },<br>        //  移除事件<br>        removeEvent : function(element, type, handler) {<br>            if (element.removeEventListener) {<br>                element.removeEventListener(type, handler, false);<br>            } else if (element.datachEvent) {<br>                element.detachEvent(‘on’ + type, handler);<br>            } else {<br>                element[‘on’ + type] = null;<br>            }<br>        },<br>        //  阻止事件  (主要是事件冒泡，因为 IE 不支持事件捕获)<br>        stopPropagation : function(ev) {<br>            if (ev.stopPropagation) {<br>                ev.stopPropagation();<br>            } else {<br>                ev.cancelBubble = true;<br>            }<br>        },<br>        //  取消事件的默认行为<br>        preventDefault : function(event) {<br>            if (event.preventDefault) {<br>                event.preventDefault();<br>            } else {<br>                event.returnValue = false;<br>            }<br>        },<br>        //  获取事件目标<br>        getTarget : function(event) {<br>            return event.target || event.srcElement;<br>        }</p>\n<h3 id=\"2-如何判断一个对象是否为数组\"><a href=\"#2-如何判断一个对象是否为数组\" class=\"headerlink\" title=\"2 如何判断一个对象是否为数组\"></a>2 如何判断一个对象是否为数组</h3><p>function isArray(arg) {<br>    if (typeof arg === ‘object’) {<br>        return Object.prototype.toString.call(arg) === ‘[object Array]‘;<br>    }<br>    return false;}</p>\n<h3 id=\"3-冒泡排序\"><a href=\"#3-冒泡排序\" class=\"headerlink\" title=\"3 冒泡排序\"></a>3 冒泡排序</h3><ul>\n<li>每次比较相邻的两个数，如果后一个比前一个小，换位置</li>\n</ul>\n<p>var arr = [3, 1, 4, 6, 5, 7, 2];function bubbleSort(arr) {for (var i = 0; i &lt; arr.length - 1; i++) {<br>    for(var j = 0; j &lt; arr.length - i - 1; j++) {<br>        if(arr[j + 1] &lt; arr[j]) {<br>            var temp;<br>            temp = arr[j];<br>            arr[j] = arr[j + 1];<br>            arr[j + 1] = temp;<br>        }<br>    }}return arr;}console.log(bubbleSort(arr));</p>\n<h3 id=\"4-快速排序\"><a href=\"#4-快速排序\" class=\"headerlink\" title=\"4 快速排序\"></a>4 快速排序</h3><ul>\n<li>采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边</li>\n</ul>\n<p>var arr = [3, 1, 4, 6, 5, 7, 2];function quickSort(arr) {<br>    if(arr.length == 0) {<br>        return [];    //  返回空数组<br>    }</p>\n<p>var cIndex = Math.floor(arr.length / 2);<br>    var c = arr.splice(cIndex, 1);<br>    var l = [];<br>    var r = [];</p>\n<p>for (var i = 0; i &lt; arr.length; i++) {<br>        if(arr[i] &lt; c) {<br>            l.push(arr[i]);<br>        } else {<br>            r.push(arr[i]);<br>        }<br>    }</p>\n<p>return quickSort(l).concat(c, quickSort(r));}console.log(quickSort(arr));</p>\n<h3 id=\"5-编写一个方法-求一个字符串的字节长度\"><a href=\"#5-编写一个方法-求一个字符串的字节长度\" class=\"headerlink\" title=\"5 编写一个方法 求一个字符串的字节长度\"></a>5 编写一个方法 求一个字符串的字节长度</h3><ul>\n<li>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</li>\n</ul>\n<p>function GetBytes(str){</p>\n<p>var len = str.length;</p>\n<p>var bytes = len;</p>\n<p>for(var i=0; i&lt;len; i++){</p>\n<p>if (str.charCodeAt(i) &gt; 255) bytes++;</p>\n<p>}</p>\n<p>return bytes;</p>\n<p>}alert(GetBytes(“你好,as”));</p>\n<h3 id=\"6-bind-的用法，以及如何实现-bind-的函数和需要注意的点\"><a href=\"#6-bind-的用法，以及如何实现-bind-的函数和需要注意的点\" class=\"headerlink\" title=\"6 bind 的用法，以及如何实现 bind 的函数和需要注意的点\"></a>6 bind 的用法，以及如何实现 bind 的函数和需要注意的点</h3><ul>\n<li><code>bind</code>的作用与<code>call</code>和<code>apply</code>相同，区别是<code>call</code>和<code>apply</code>是立即调用函数，而<code>bind</code>是返回了一个函数，需要调用的时候再执行。 一个简单的<code>bind</code>函数实现如下</li>\n</ul>\n<p>Function.prototype.bind = function(ctx) {<br>    var fn = this;<br>    return function() {<br>        fn.apply(ctx, arguments);<br>    };};</p>\n<h3 id=\"7-实现一个函数-clone\"><a href=\"#7-实现一个函数-clone\" class=\"headerlink\" title=\"7 实现一个函数 clone\"></a>7 实现一个函数 clone</h3><blockquote>\n<p>可以对<code>JavaScript</code>中的 5 种主要的数据类型,包括<code>Number</code>、<code>String</code>、<code>Object</code>、<code>Array</code>、<code>Boolean</code>）进行值复</p>\n</blockquote>\n<ul>\n<li>考察点 1：对于基本数据类型和引用数据类型在内存中存放的是值还是指针这一区别是否清楚</li>\n<li>考察点 2：是否知道如何判断一个变量是什么类型的</li>\n<li>考察点 3：递归算法的设计</li>\n</ul>\n<p>//  方法一：<br>  Object.prototype.clone = function(){<br>          var o = this.constructor === Array ? [] : {};<br>          for(var e in this){<br>                  o[e] = typeof this[e] === “object” ? this[e].clone() : this[e];<br>          }<br>          return o;<br>  }</p>\n<p>//方法二：<br>   /**<br>      *  克隆一个对象<br>      * @param Obj<br>      * @returns<br>      */<br>     function clone(Obj) {   <br>         var buf;   <br>         if (Obj instanceof Array) {   <br>             buf = [];                    //创建一个空的数组<br>             var i = Obj.length;   <br>             while (i–) {   <br>                 buf[i] = clone(Obj[i]);   <br>             }   <br>             return buf;    <br>         }else if (Obj instanceof Object){   <br>             buf = {};                   //创建一个空对象<br>             for (var k in Obj) {           //为这个对象添加新的属性<br>                 buf[k] = clone(Obj[k]);   <br>             }   <br>             return buf;   <br>         }else{                         //普通变量直接赋值<br>             return Obj;   <br>         }   <br>     }</p>\n<h3 id=\"8-下面这个-ul，如何点击每一列的时候-alert-其-index\"><a href=\"#8-下面这个-ul，如何点击每一列的时候-alert-其-index\" class=\"headerlink\" title=\"8 下面这个 ul，如何点击每一列的时候 alert 其 index\"></a>8 下面这个 ul，如何点击每一列的时候 alert 其 index</h3><blockquote>\n<p>\b 考察闭包</p>\n</blockquote>\n<p><ul id=”test”><br>     <li>这是第一条</li><br>     <li>这是第二条</li><br>     <li>这是第三条</li><br> </ul></p>\n<p>//  方法一：<br>  var lis=document.getElementById(‘2223’).getElementsByTagName(‘li’);<br>  for(var i=0;i&lt;3;i++)<br>  {<br>      lis[i].index=i;<br>      lis[i].onclick=function(){<br>          alert(this.index);<br>  }</p>\n<p>//方法二：<br> var lis=document.getElementById(‘2223’).getElementsByTagName(‘li’);<br> for(var i=0;i&lt;3;i++)<br> {<br>     lis[i].index=i;<br>     lis[i].onclick=(function(a){<br>         return function() {<br>             alert(a);<br>         }<br>     })(i);<br> }</p>\n<h3 id=\"9-定义一个-log-方法，让它可以代理-console-log-的方法\"><a href=\"#9-定义一个-log-方法，让它可以代理-console-log-的方法\" class=\"headerlink\" title=\"9 定义一个 log 方法，让它可以代理 console.log 的方法\"></a>9 定义一个 log 方法，让它可以代理 console.log 的方法</h3><p>可行的方法一： function log(msg)　{<br>     console.log(msg);<br> }</p>\n<p>log(“hello world!”) // hello world!</p>\n<blockquote>\n<p>如果要传入多个参数呢？显然上面的方法不能满足要求，所以更好的方法是：</p>\n</blockquote>\n<p>function log(){<br>     console.log.apply(console, arguments);<br> };</p>\n<h3 id=\"10-输出今天的日期\"><a href=\"#10-输出今天的日期\" class=\"headerlink\" title=\"10 输出今天的日期\"></a>10 输出今天的日期</h3><blockquote>\n<p>以<code>YYYY-MM-DD</code>的方式，比如今天是 2014 年 9 月 26 日，则输出 2014-09-26</p>\n</blockquote>\n<p>var d = new Date();<br>  //  获取年，getFullYear()返回 4 位的数字<br>  var year = d.getFullYear();<br>  //  获取月，月份比较特殊，0 是 1 月，11 是 12 月<br>  var month = d.getMonth() + 1;<br>  //  变成两位<br>  month = month &lt; 10 ? ‘0’ + month : month;<br>  //  获取日<br>  var day = d.getDate();<br> day = day &lt; 10 ? ‘0’ + day : day;<br> alert(year + ‘-‘ + month + ‘-‘ + day);</p>\n<h3 id=\"11-用-js-实现随机选取-10–100-之间的-10-个数字，存入一个数组，并排序\"><a href=\"#11-用-js-实现随机选取-10–100-之间的-10-个数字，存入一个数组，并排序\" class=\"headerlink\" title=\"11 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序\"></a>11 用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序</h3><p>var iArray = [];<br> funtion getRandom(istart, iend){<br>         var iChoice = istart - iend +1;<br>         return Math.floor(Math.random() * iChoice + istart;<br> }<br> for(var i=0; i&lt;10; i++){<br>         iArray.push(getRandom(10,100));<br> }<br> iArray.sort();</p>\n<h3 id=\"12-写一段-JS-程序提取-URL-中的各个-GET-参数\"><a href=\"#12-写一段-JS-程序提取-URL-中的各个-GET-参数\" class=\"headerlink\" title=\"12 写一段 JS 程序提取 URL 中的各个 GET 参数\"></a>12 写一段 JS 程序提取 URL 中的各个 GET 参数</h3><blockquote>\n<p>有这样一个<code>URL</code>：<code>http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e</code>，请写一段 JS 程序提取 URL 中的各个 GET 参数(参数名和参数个数不确定)，将其按<code>key-value</code>形式返回到一个<code>json</code>结构中，如<code>&#123;a:&#39;1&#39;, b:&#39;2&#39;, c:&#39;&#39;, d:&#39;xxx&#39;, e:undefined&#125;</code></p>\n</blockquote>\n<p>function serilizeUrl(url) {<br>     var result = {};<br>     url = url.split(“?”)[1];<br>     var map = url.split(“&amp;”);<br>     for(var i = 0, len = map.length; i &lt; len; i++) {<br>         result[map[i].split(“=”)[0]] = map[i].split(“=”)[1];<br>     }<br>     return result;<br> }</p>\n<h3 id=\"13-写一个function，清除字符串前后的空格\"><a href=\"#13-写一个function，清除字符串前后的空格\" class=\"headerlink\" title=\"13 写一个function，清除字符串前后的空格\"></a>13 写一个<code>function</code>，清除字符串前后的空格</h3><blockquote>\n<p>使用自带接口<code>trim()</code>，考虑兼容性：</p>\n</blockquote>\n<p>if (!String.prototype.trim) {<br>    String.prototype.trim = function() {<br>        return this.replace(/^\\s+/, “”).replace(/\\s+$/,””);<br>    }}</p>\n<p>// test the function<br> var str = “ \\t\\n test string “.trim();<br> alert(str == “test string”); // alerts “true”</p>\n<h3 id=\"14-实现每隔一秒钟输出-1-2-3…数字\"><a href=\"#14-实现每隔一秒钟输出-1-2-3…数字\" class=\"headerlink\" title=\"14 实现每隔一秒钟输出 1,2,3…数字\"></a>14 实现每隔一秒钟输出 1,2,3…数字</h3><p>for(var i=0;i&lt;10;i++){<br>  (function(j){<br>     setTimeout(function(){<br>       console.log(j+1)<br>     },j*1000)<br>   })(i)}</p>\n<h3 id=\"15-实现一个函数，判断输入是不是回文字符串\"><a href=\"#15-实现一个函数，判断输入是不是回文字符串\" class=\"headerlink\" title=\"15 实现一个函数，判断输入是不是回文字符串\"></a>15 实现一个函数，判断输入是不是回文字符串</h3><p>function run(input) {<br>  if (typeof input !== ‘string’) return false;<br>  return input.split(‘’).reverse().join(‘’) === input;}</p>\n<h3 id=\"16、数组扁平化处理\"><a href=\"#16、数组扁平化处理\" class=\"headerlink\" title=\"16、数组扁平化处理\"></a>16、数组扁平化处理</h3><blockquote>\n<p>实现一个<code>flatten</code>方法，使得输入一个数组，该数组里面的元素也可以是数组，该方法会输出一个扁平化的数组</p>\n</blockquote>\n<p>function flatten(arr){<br>    return arr.reduce(function(prev,item){<br>        return prev.concat(Array.isArray(item)?flatten(item):item);<br>    },[]);}</p>\n<h2 id=\"九、其他\"><a href=\"#九、其他\" class=\"headerlink\" title=\"九、其他\"></a>九、其他</h2><h3 id=\"1-负载均衡\"><a href=\"#1-负载均衡\" class=\"headerlink\" title=\"1 负载均衡\"></a>1 负载均衡</h3><blockquote>\n<p>多台服务器共同协作，不让其中某一台或几台超额工作，发挥服务器的最大作用</p>\n</blockquote>\n<ul>\n<li><code>http</code>重定向负载均衡：调度者根据策略选择服务器以 302 响应请求，缺点只有第一次有效果，后续操作维持在该服务器 dns 负载均衡：解析域名时，访问多个<code>ip</code>服务器中的一个（可监控性较弱）</li>\n<li>反向代理负载均衡：访问统一的服务器，由服务器进行调度访问实际的某个服务器，对统一的服务器要求大，性能受到 服务器群的数量</li>\n</ul>\n<h3 id=\"2-CDN\"><a href=\"#2-CDN\" class=\"headerlink\" title=\"2 CDN\"></a>2 CDN</h3><blockquote>\n<p>内容分发网络，基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</p>\n</blockquote>\n<h3 id=\"3-内存泄漏\"><a href=\"#3-内存泄漏\" class=\"headerlink\" title=\"3 内存泄漏\"></a>3 内存泄漏</h3><blockquote>\n<p>定义：程序中己动态分配的堆内存由于某种原因程序未释放或无法释放引发的各种问题。</p>\n</blockquote>\n<p>js 中可能出现的内存泄漏情况</p>\n<blockquote>\n<p>结果：变慢，崩溃，延迟大等，原因：</p>\n</blockquote>\n<ul>\n<li>全局变量</li>\n<li><code>dom</code>清空时，还存在引用</li>\n<li><code>ie</code>中使用闭包</li>\n<li>定时器未清除</li>\n<li>子元素存在引起的内存泄露</li>\n</ul>\n<p>避免策略</p>\n<ul>\n<li>减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</li>\n<li>注意程序逻辑，避免“死循环”之类的 ；</li>\n<li>避免创建过多的对象 原则：不用了的东西要及时归还。</li>\n<li>减少层级过多的引用</li>\n</ul>\n<h3 id=\"4-babel-原理\"><a href=\"#4-babel-原理\" class=\"headerlink\" title=\"4 babel 原理\"></a>4 babel 原理</h3><blockquote>\n<p><code>ES6、7</code>代码输入 -&gt; <code>babylon</code>进行解析 -&gt; 得到<code>AST</code>（抽象语法树）-&gt; <code>plugin</code>用 b<code>abel-traverse</code>对<code>AST</code>树进行遍历转译 -&gt;得到新的<code>AST</code>树-&gt;用<code>babel-generator</code>通过<code>AST</code>树生成<code>ES5</code>代码</p>\n</blockquote>\n<h3 id=\"5-js-自定义事件\"><a href=\"#5-js-自定义事件\" class=\"headerlink\" title=\"5 js 自定义事件\"></a>5 js 自定义事件</h3><blockquote>\n<p>三要素： <code>document.createEvent()</code> <code>event.initEvent()``element.dispatchEvent()</code></p>\n</blockquote>\n<p>// (en:自定义事件名称，fn:事件处理函数，addEvent:为 DOM 元素添加自定义事件，triggerEvent:触发自定义事件)window.onload = function(){<br>    var demo = document.getElementById(“demo”);<br>    demo.addEvent(“test”,function(){console.log(“handler1”)});<br>    demo.addEvent(“test”,function(){console.log(“handler2”)});<br>    demo.onclick = function(){<br>        this.triggerEvent(“test”);<br>    }}Element.prototype.addEvent = function(en,fn){<br>    this.pools = this.pools || {};<br>    if(en in this.pools){<br>        this.pools[en].push(fn);<br>    }else{<br>        this.pools[en] = [];<br>        this.pools[en].push(fn);<br>    }}Element.prototype.triggerEvent  = function(en){<br>    if(en in this.pools){<br>        var fns = this.pools[en];<br>        for(var i=0,il=fns.length;i&lt;il;i++){<br>            fns[i]();<br>        }<br>    }else{<br>        return;<br>    }}</p>\n<h3 id=\"6-前后端路由差别\"><a href=\"#6-前后端路由差别\" class=\"headerlink\" title=\"6 前后端路由差别\"></a>6 前后端路由差别</h3><ul>\n<li>后端每次路由请求都是重新访问服务器</li>\n<li>前端路由实际上只是<code>JS</code>根据<code>URL</code>来操作<code>DOM</code>元素，根据每个页面需要的去服务端请求数据，返回数据后和模板进行组合</li>\n</ul>\n<h2 id=\"十、综合\"><a href=\"#十、综合\" class=\"headerlink\" title=\"十、综合\"></a>十、综合</h2><h3 id=\"1-谈谈你对重构的理解\"><a href=\"#1-谈谈你对重构的理解\" class=\"headerlink\" title=\"1 谈谈你对重构的理解\"></a>1 谈谈你对重构的理解</h3><ul>\n<li>网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变 UI 的情况下，对网站进行优化， 在扩展的同时保持一致的 UI</li>\n<li>对于传统的网站来说重构通常是：<ul>\n<li>表格(<code>table</code>)布局改为<code>DIV+CSS</code></li>\n<li>使网站前端兼容于现代浏览器(针对于不合规范的<code>CSS</code>、如对 IE6 有效的)</li>\n<li>对于移动平台的优化</li>\n<li>针对于<code>SEO</code>进行优化</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-什么样的前端代码是好的\"><a href=\"#2-什么样的前端代码是好的\" class=\"headerlink\" title=\"2 什么样的前端代码是好的\"></a>2 什么样的前端代码是好的</h3><ul>\n<li>高复用低耦合，这样文件小，好维护，而且好扩展。</li>\n<li>具有可用性、健壮性、可靠性、宽容性等特点</li>\n<li>遵循设计模式的六大原则</li>\n</ul>\n<h3 id=\"3-对前端工程师这个职位是怎么样理解的？它的前景会怎么样\"><a href=\"#3-对前端工程师这个职位是怎么样理解的？它的前景会怎么样\" class=\"headerlink\" title=\"3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样\"></a>3 对前端工程师这个职位是怎么样理解的？它的前景会怎么样</h3><ul>\n<li>前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近<ul>\n<li>实现界面交互</li>\n<li>提升用户体验</li>\n<li>基于 NodeJS，可跨平台开发</li>\n</ul>\n</li>\n<li>前端是最贴近用户的程序员，前端的能力就是能让产品从 90 分进化到 100 分，甚至更好，</li>\n<li>与团队成员，<code>UI</code>设计，产品经理的沟通；</li>\n<li>做好的页面结构，页面重构和用户体验；</li>\n</ul>\n<h3 id=\"4-你觉得前端工程的价值体现在哪\"><a href=\"#4-你觉得前端工程的价值体现在哪\" class=\"headerlink\" title=\"4 你觉得前端工程的价值体现在哪\"></a>4 你觉得前端工程的价值体现在哪</h3><ul>\n<li>为简化用户使用提供技术支持（交互部分）</li>\n<li>为多个浏览器兼容性提供支持</li>\n<li>为提高用户浏览速度（浏览器性能）提供支持</li>\n<li>为跨平台或者其他基于 webkit 或其他渲染引擎的应用提供支持</li>\n<li>为展示数据提供支持（数据接口）</li>\n</ul>\n<h3 id=\"5-平时如何管理你的项目\"><a href=\"#5-平时如何管理你的项目\" class=\"headerlink\" title=\"5 平时如何管理你的项目\"></a>5 平时如何管理你的项目</h3><ul>\n<li>先期团队必须确定好全局样式（<code>globe.css</code>），编码模式(<code>utf-8</code>) 等；</li>\n<li>编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）；</li>\n<li>标注样式编写人，各模块都及时标注（标注关键样式调用的地方）；</li>\n<li>页面进行标注（例如 页面 模块 开始和结束）；</li>\n<li><code>CSS</code>跟<code>HTML</code>  分文件夹并行存放，命名都得统一（例如<code>style.css</code>）；</li>\n<li><code>JS</code>  分文件夹存放 命名以该<code>JS</code>功能为准的英文翻译。</li>\n<li>图片采用整合的  <code>images.png png8</code>  格式文件使用 - 尽量整合在一起使用方便将来的管理</li>\n</ul>\n<h3 id=\"6-组件封装\"><a href=\"#6-组件封装\" class=\"headerlink\" title=\"6 组件封装\"></a>6 组件封装</h3><blockquote>\n<p>目的：为了重用，提高开发效率和代码质量 注意：低耦合，单一职责，可复用性，可维护性 常用操作</p>\n</blockquote>\n<ul>\n<li>分析布局</li>\n<li>初步开发</li>\n<li>化繁为简</li>\n<li>组件抽象</li>\n</ul>\n"},{"title":"2019最新前端知识梳理(第三方库部分)-面试宝典","url":"164.html","id":"164","date":"2019-06-22T09:22:58.000Z","_content":"\n## 四、jQuery\n\n### 1 你觉得 jQuery 或 zepto 源码有哪些写的好的地方\n\n- jquery 源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入 window 对象参数，可以使 window 对象作为局部变量使用，好处是当 jquery 中访问 window 对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问 window 对象。同样，传入 undefined 参数，可以缩短查找 undefined 时的作用域链\n\n(function( window, undefined ) {\n\n//用一个函数域包起来，就是所谓的沙箱\n\n//在这里边 var 定义的变量，属于这个函数域内的局部变量，避免污染全局\n\n//把当前沙箱需要的外部变量通过函数参数引入进来\n\n//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数\n\nwindow.jQuery = window.\\$ = jQuery;\n\n})( window );\n\n- jquery 将一些原型属性和方法封装在了 jquery.prototype 中，为了缩短名称，又赋值给了 jquery.fn，这是很形象的写法\n- 有一些数组或对象的方法经常能使用到，jQuery 将其保存为局部变量以提高访问速度\n- jquery 实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率\n\n### 2 jQuery 的实现原理\n\n- `(function(window, undefined) {})(window);`\n- `jQuery`  利用  `JS`  函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题\n- `window.jQuery = window.$ = jQuery;`\n- 在闭包当中将 jQuery 和 $ 绑定到 window 上，从而将 jQuery 和 $ 暴露为全局变量\n\n### 3 `jQuery.fn`  的  `init`  方法返回的  `this`  指的是什么对象\n\n- jQuery.fn 的 init 方法 返回的 this 就是 jQuery 对象\n- 用户使用 jQuery() 或 \\$() 即可初始化 jQuery 对象，不需要动态的去调用 init 方法\n\n### 4 jQuery.extend 与 jQuery.fn.extend 的区别\n\n- `$.fn.extend()`  和  `$.extend()`  是  `jQuery`  为扩展插件提拱了两个方法\n- `$.extend(object)`; // 为 jQuery 添加“静态方法”（工具方法）\n\n$.extend({　　min: function(a, b) { return a < b ? a : b; },　　max: function(a, b) { return a > b ? a : b; }});$.min(2,3); //  2\\$.max(4,5); //  5\n\n- \\$.extend(\\[true,\\] targetObject, object1\\[, object2\\]); // 对 targt 对象进行扩展\n\nvar settings = {validate:false, limit:5};var options = {validate:true, name:\"bar\"};\\$.extend(settings, options);  //  注意：不支持第一个参数传  false// settings == {validate:true, limit:5, name:\"bar\"}\n\n- `$.fn.extend(json)`; // 为 jQuery 添加“成员函数”（实例方法）\n\n$.fn.extend({\n   alertValue: function() {\n      $(this).click(function(){\n        alert($(this).val());\n      });\n   }});$(\"email\").alertValue();\n\n### 5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝\n\n- 浅拷贝（只复制一份原始对象的引用） `var newObject = $.extend({}, oldObject);`\n- 深拷贝（对原始对象属性所引用的对象进行进行递归拷贝） `var newObject = $.extend(true, {}, oldObject);`\n\n### 6 jQuery 的队列是如何实现的\n\n- jQuery 核心中有一组队列控制方法，由  `queue()/dequeue()/clearQueue()`  三个方法组成。\n- 主要应用于  `animate()`，`ajax`，其他要按时间顺序执行的事件中\n\nvar func1 = function(){alert('事件 1');}var func2 = function(){alert('事件 2');}var func3 = function(){alert('事件 3');}var func4 = function(){alert('事件 4');}//  入栈队列事件$('box').queue(\"queue1\", func1);  // push func1 to queue1$('box').queue(\"queue1\", func2);  // push func2 to queue1//  替换队列事件$('box').queue(\"queue1\", \\[\\]);  // delete queue1 with empty array$('box').queue(\"queue1\", \\[func3, func4\\]);  // replace queue1//  获取队列事件（返回一个函数数组）$('box').queue(\"queue1\");  // \\[func3(), func4()\\]// 出栈队列事件并执行$('box').dequeue(\"queue1\"); // return func3 and do func3$('box').dequeue(\"queue1\"); // return func4 and do func4// 清空整个队列$('box').clearQueue(\"queue1\"); // delete queue1 with clearQueue\n\n### 7 jQuery 中的 bind(), live(), delegate(), on()的区别\n\n- `bind()`  直接绑定在目标元素上\n- `live()`  通过冒泡传播事件，默认`document`上，支持动态数据\n- `delegate()`  更精确的小范围使用事件代理，性能优于 live\n- `on()`  是最新的`1.9`版本整合了之前的三种方式的新事件绑定机制\n\n### 8 是否知道自定义事件\n\n- 事件即“发布/订阅”模式，自定义事件即“消息发布”，事件的监听即“订阅订阅”\n- JS 原生支持自定义事件，示例：\n\ndocument.createEvent(type); //  创建事件\n  event.initEvent(eventType, canBubble, prevent); //  初始化事件\n  target.addEventListener('dataavailable', handler, false); //  监听事件\n  target.dispatchEvent(e);  //  触发事件\n\n- jQuery 里的`fire`  函数用于调用`jQuery`自定义事件列表中的事件\n\n### 9 jQuery 通过哪个方法和 Sizzle 选择器结合的\n\n- `Sizzle`  选择器采取  `Right To Left`  的匹配模式，先搜寻所有匹配标签，再判断它的父节点\n- `jQuery`  通过  `$(selecter).find(selecter);`  和  `Sizzle`  选择器结合\n\n### 10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来\n\n//  通过原生  JSON.stringify/JSON.parse  扩展  jQuery  实现\n \\$.array2json = function(array) {\n    return JSON.stringify(array);\n }\n\n$.json2array = function(array) {\n    // $.parseJSON(array); // 3.0  开始，已过时\n    return JSON.parse(array);\n }\n\n//  调用\n var json = $.array2json(\\['a', 'b', 'c'\\]);\n var array = $.json2array(json);\n\n### 11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的\n\n\\$(\"btn\").on(\"mouseover mouseout\", func);\n\n\\$(\"btn\").on({\n      mouseover: func1,\n      mouseout: func2,\n      click: func3  });\n\n### 12 针对 jQuery 的优化方法\n\n- 缓存频繁操作`DOM`对象\n- 尽量使用`id`选择器代替`class`选择器\n- 总是从`id`选择器来继承\n- 尽量使用链式操作\n- 使用时间委托  `on`绑定事件\n- 采用`jQuery`的内部函数`data()`来存储数据\n- 使用最新版本的  `jQuery`\n\n### 13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢\n\n- 在触发元素上的事件设置为延迟处理：使用  `JS`  原生  `setTimeout`  方法\n- 在触发元素的事件时预先停止所有的动画，再执行相应的动画事件：`$('.tab').stop().slideUp();`\n\n### 14 jQuery UI 如何自定义组件\n\n- 通过向  `$.widget()`  传递组件名称和一个原型对象来完成\n- `$.widget(\"ns.widgetName\", [baseWidget], widgetPrototype);`\n\n### 15 jQuery 与 jQuery UI、jQuery Mobile 区别\n\n- `jQuery`  是  `JS`  库，兼容各种 PC 浏览器，主要用作更方便地处理  `DOM`、事件、动画、`AJAX`\n- `jQuery UI`  是建立在  `jQuery`  库上的一组用户界面交互、特效、小部件及主题\n- `jQuery Mobile`  以  `jQuery`  为基础，用于创建“移动 Web 应用”的框架\n\n### 16 jQuery 和 Zepto 的区别？ 各自的使用场景\n\n- `jQuery`  主要目标是`PC`的网页中，兼容全部主流浏览器。在移动设备方面，单独推出 `jQuery Mobile\n- `Zepto`从一开始就定`位移动设备，相对更轻量级。它的`API `基本兼容`jQuery`，但对 PC 浏览器兼容不理想\n\n### 17 jQuery 对象的特点\n\n- 只有  `JQuery`对象才能使用  `JQuery`  方法\n- `JQuery`  对象是一个数组对象\n\n## 五、Bootstrap\n\n### 1 什么是 Bootstrap？以及为什么要使用 Bootstrap？\n\n> `Bootstrap`  是一个用于快速开发  `Web`应用程序和网站的前端框架。`Bootstrap`是基于  `HTML`、`CSS`、`JAVASCRIPT`  的\n\n- `Bootstrap`具有移动设备优先、浏览器支持良好、容易上手、响应式设计等优点，所以`Bootstrap`被广泛应用\n\n### 2 使用 Bootstrap 时，要声明的文档类型是什么？以及为什么要这样声明？\n\n- 使用`Bootstrap`时，需要使用  `HTML5`  文档类型（`Doctype`）。`<!DOCTYPE html>`\n- 因为`Bootstrap`使用了一些  `HTML5`  元素和  `CSS`  属性，如果在  `Bootstrap`创建的网页开头不使用  `HTML5`  的文档类型（`Doctype`），可能会面临一些浏览器显示不一致的问题，甚至可能面临一些特定情境下的不一致，以致于代码不能通过  `W3C`  标准的验证\n\n### 3 什么是 Bootstrap 网格系统\n\n> `Bootstrap`  包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到  `12`  列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类\n\n- 响应式网格系统随着屏幕或视口（`viewport`）尺寸的增加，系统会自动分为最多`12`列。\n\n### 4 Bootstrap 网格系统（Grid System）的工作原理\n\n- （1）行必须放置在  `.container class`  内，以便获得适当的对齐（`alignment`）和内边距（`padding`）。\n- （2）使用行来创建列的水平组。\n- （3）内容应该放置在列内，且唯有列可以是行的直接子元素。\n- （4）预定义的网格类，比如  `.row`  和  `.col-xs-4`，可用于快速创建网格布局。`LESS`  混合类可用于更多语义布局。\n- （5）列通过内边距（`padding`）来创建列内容之间的间隙。该内边距是通过  `.rows`  上的外边距（`margin`）取负，表示第一列和最后一列的行偏移。\n- （6）网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个  `.col-xs-4`\n\n### 5 对于各类尺寸的设备，Bootstrap 设置的 class 前缀分别是什么\n\n- 超小设备手机（`<768px`）：`.col-xs-*`\n- 小型设备平板电脑（`>=768px`）：`.col-sm-*`\n- 中型设备台式电脑（`>=992px`）：`.col-md-*`\n- 大型设备台式电脑（`>=1200px`）：`.col-lg-*`\n\n### 6 Bootstrap 网格系统列与列之间的间隙宽度是多少\n\n> 间隙宽度为`30px`（一个列的每边分别是`15px`）\n\n### 7 如果需要在一个标题的旁边创建副标题，可以怎样操作\n\n> 在元素两旁添加`<small>`，或者添加`.small`的`class`\n\n### 8 用 Bootstrap，如何设置文字的对齐方式？\n\n- `class=\"text-center\"`  设置居中文本\n- `class=\"text-right\"`  设置向右对齐文本\n- `class=\"text-left\"`  设置向左对齐文本\n\n### 9 Bootstrap 如何设置响应式表格？\n\n> 增加`class=\"table-responsive\"`\n\n### 10 使用 Bootstrap 创建垂直表单的基本步骤？\n\n- （1）向父`<form>`元素添加`role=\"form\"`；\n- （2）把标签和控件放在一个带有`class=\"form-group\"`的`<div>`中，这是获取最佳间距所必需的；\n- （3）向所有的文本元素`<input>`、`<textarea>`、`<select>`添加`class=\"form-control\"`\n\n### 11 使用 Bootstrap 创建水平表单的基本步骤？\n\n- （1）向父`<form>`元素添加`class=\"form-horizontal\"`；\n- （2）把标签和控件放在一个带有`class=\"form-group\"`的`<div>`中；\n- （3）向标签添加`class=\"control-label\"`。\n\n### 12 使用 Bootstrap 如何创建表单控件的帮助文本？\n\n> 增加`class=\"help-block\"`的`span`标签或`p`标签。\n\n### 13 使用 Bootstrap 激活或禁用按钮要如何操作？\n\n- 激活按钮：给按钮增加`.active`的`class`\n- 禁用按钮：给按钮增加`disabled=\"disabled\"`的属性\n\n### 14 Bootstrap 有哪些关于的 class？\n\n- （1）`.img-rounded`  为图片添加圆角\n- （2）`.img-circle`  将图片变为圆形\n- （3）`.img-thumbnail`  缩略图功能\n- （4）`.img-responsive`  图片响应式 (将很好地扩展到父元素)\n\n### 15 Bootstrap 中有关元素浮动及清除浮动的 class？\n\n- （1）`class=\"pull-left\"`  元素浮动到左边\n- （2）`class=\"pull-right\"`  元素浮动到右边\n- （3）`class=\"clearfix\"`  清除浮动\n\n### 16 除了屏幕阅读器外，其他设备上隐藏元素的 class？\n\n> \\`class=\"sr-only\"\\`\\`\n\n### 17 Bootstrap 如何制作下拉菜单？\n\n- （1）将下拉菜单包裹在`class=\"dropdown\"`的`<div>`中；\n- （2）在触发下拉菜单的按钮中添加：`class=\"btn dropdown-toggle\" id=\"dropdownMenu1\" data-toggle=\"dropdown\"`\n- （3）在包裹下拉菜单的 ul 中添加：`class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"dropdownMenu1\"`\n- （4）在下拉菜单的列表项中添加：`role=\"presentation\"`。其中，下拉菜单的标题要添加`class=\"dropdown-header\"`，选项部分要添加`tabindex=\"-1\"`。\n\n### 18 Bootstrap 如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？\n\n- （1）用`class=\"btn-group\"`的`<div>`去包裹按钮组；`class=\"btn-group-vertical\"`可设置垂直按钮组。\n- （2）`btn-group`的优先级高于`btn-group-vertical`的优先级。\n\n### 19 Bootstrap 如何设置按钮的下拉菜单？\n\n> 在一个  `.btn-group`  中放置按钮和下拉菜单即可。\n\n### 20 Bootstrap 中的输入框组如何制作？\n\n- （1）把前缀或者后缀元素放在一个带有`class=\"input-group\"`中的`<div>`中\n- （2）在该`<div>`内，在`class=\"input-group-addon\"`的`<span>`里面放置额外的内容；\n- （3）把`<span>`放在`<input>`元素的前面或后面。\n\n### 21 Bootstrap 中的导航都有哪些？\n\n- （1）导航元素：有`class=\"nav nav-tabs\"`的标签页导航，还有`class=\"nav nav-pills\"`的胶囊式标签页导航；\n- （2）导航栏：`class=\"navbar navbar-default\" role=\"navigation\"`；\n- （3）面包屑导航：`class=\"breadcrumb\"`\n\n### 22 Bootstrap 中设置分页的 class？\n\n- 默认的分页：`class=\"pagination\"`\n- 默认的翻页：`class=\"pager\"`\n\n### 23 Bootstrap 中显示标签的 class？\n\n> `class=\"label\"`\n\n### 24 Bootstrap 中如何制作徽章？\n\n> `<span class=\"badge\">26</span>`\n\n### 25 Bootstrap 中超大屏幕的作用是什么？\n\n> 设置`class=\"jumbotron\"`可以制作超大屏幕，该组件可以增加标题的大小并增加更多的外边距\n\n## 六、微信小程序\n\n### 1 微信小程序有几个文件\n\n- `WXSS (WeiXin Style Sheets)`是一套样式语言，用于描述  `WXML`  的组件样式， `js`  逻辑处理，网络请求`json`小程序设置，如页面注册，页面标题及  `tabBar`。\n- `app.json`  必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的`window`  背景色，配置导航条样式，配置默认标题。\n- `app.js`  必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。\n- `app.wxss`  配置全局  `css`\n\n### 2 微信小程序怎样跟事件传值\n\n> 给  `HTML`  元素添加  `data-*`属性来传递我们需要的值，然后通过  `e.currentTarget.dataset`  或`onload`的`param`参数获取。但  `data -`  名称不能有大写字母和不可以存放对象\n\n### 3 小程序的 wxss 和 css 有哪些不一样的地方？\n\n- `wxss`的图片引入需使用外链地址\n- 没有  `Body`；样式可直接使用  `import`  导入\n\n### 4 小程序关联微信公众号如何确定用户的唯一性\n\n> 使用  `wx.getUserInfo`  方法  `withCredentials`  为  `true`  时 可获取  `encryptedData`，里面有  `union_id`。后端需要进行对称解密\n\n### 5 微信小程序与 vue 区别\n\n- 生命周期不一样，微信小程序生命周期比较简单\n- 数据绑定也不同，微信小程序数据绑定需要使用`{ {}}`，`vue`  直接`:`就可以\n- 显示与隐藏元素，`vue`中，使用  `v-if`  和  `v-show`  控制元素的显示和隐藏，小程序中，使用`wx-if`  和`hidden`  控制元素的显示和隐藏\n- 事件处理不同，小程序中，全用  `bindtap(bind+event)`，或者  `catchtap(catch+event)`  绑定事件,`vue：`使用  `v-on:event`  绑定事件，或者使用`@event`  绑定事件\n- 数据双向绑定也不也不一样在  `vue`中,只需要再表单元素上加上  `v-model`,然后再绑定  `data`中对应的一个值，当表单元素内容发生变化时，`data`中对应的值也会相应改变，这是  `vue`非常 nice 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个  `data`中声明的变量。\n\n## 七、webpack 相关\n\n### 1 打包体积 优化思路\n\n- 提取第三方库或通过引用外部文件的方式引入第三方库\n- 代码压缩插件`UglifyJsPlugin`\n- 服务器启用 gzip 压缩\n- 按需加载资源文件  `require.ensure`\n- 优化`devtool`中的`source-map`\n- 剥离`css`文件，单独打包\n- 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致\n\n### 2 打包效率\n\n- 开发环境采用增量构建，启用热更新\n- 开发环境不做无意义的工作如提取`css`计算文件 hash 等\n- 配置`devtool`\n- 选择合适的`loader`\n- 个别`loader`开启`cache`  如`babel-loader`\n- 第三方库采用引入方式\n- 提取公共代码\n- 优化构建时的搜索路径 指明需要构建目录及不需要构建目录\n- 模块化引入需要的部分\n\n### 3 Loader\n\n编写一个 loader\n\n> `loader`就是一个`node`模块，它输出了一个函数。当某种资源需要用这个`loader`转换时，这个函数会被调用。并且，这个函数可以通过提供给它的`this`上下文访问`Loader API`。 `reverse-txt-loader`\n\n//  定义 module.exports = function(src) {\n  //src 是原文件内容（abcde），下面对内容进行处理，这里是反转\n  var result = src.split('').reverse().join('');\n  //返回 JavaScript 源码，必须是 String 或者 Buffer\n  return \\`module.exports = '${result}'\\`;}//使用{\n\ttest: /\\\\.txt$/,\nuse: \\[\n{\n'./path/reverse-txt-loader'\n}\n\\]},\n\n### 4 说一下 webpack 的一些 plugin，怎么使用 webpack 对项目进行优化\n\n构建优化\n\n- 减少编译体积  `ContextReplacementPugin`、`IgnorePlugin`、`babel-plugin-import`、`babel-plugin-transform-runtime`\n- 并行编译  `happypack`、`thread-loader`、`uglifyjsWebpackPlugin`开启并行\n- 缓存  `cache-loader`、`hard-source-webpack-plugin`、`uglifyjsWebpackPlugin`开启缓存、`babel-loader`开启缓存\n- 预编译  `dllWebpackPlugin && DllReferencePlugin`、`auto-dll-webapck-plugin`\n\n性能优化\n\n- 减少编译体积  `Tree-shaking`、`Scope Hositing`\n- `hash`缓存  `webpack-md5-plugin`\n- 拆包  `splitChunksPlugin`、`import()`、`require.ensure`\n","source":"_posts/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e7-ac-ac-e4-b8-89-e6-96-b9-e5-ba-93-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8.md","raw":"---\ntitle: 2019最新前端知识梳理(第三方库部分)-面试宝典\ntags:\n  - 类库\n  - 面试题\nurl: 164.html\nid: 164\ncategories:\n  - 大前端\n  - 面试题类\ndate: 2019-06-22 17:22:58\n---\n\n## 四、jQuery\n\n### 1 你觉得 jQuery 或 zepto 源码有哪些写的好的地方\n\n- jquery 源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入 window 对象参数，可以使 window 对象作为局部变量使用，好处是当 jquery 中访问 window 对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问 window 对象。同样，传入 undefined 参数，可以缩短查找 undefined 时的作用域链\n\n(function( window, undefined ) {\n\n//用一个函数域包起来，就是所谓的沙箱\n\n//在这里边 var 定义的变量，属于这个函数域内的局部变量，避免污染全局\n\n//把当前沙箱需要的外部变量通过函数参数引入进来\n\n//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数\n\nwindow.jQuery = window.\\$ = jQuery;\n\n})( window );\n\n- jquery 将一些原型属性和方法封装在了 jquery.prototype 中，为了缩短名称，又赋值给了 jquery.fn，这是很形象的写法\n- 有一些数组或对象的方法经常能使用到，jQuery 将其保存为局部变量以提高访问速度\n- jquery 实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率\n\n### 2 jQuery 的实现原理\n\n- `(function(window, undefined) {})(window);`\n- `jQuery`  利用  `JS`  函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题\n- `window.jQuery = window.$ = jQuery;`\n- 在闭包当中将 jQuery 和 $ 绑定到 window 上，从而将 jQuery 和 $ 暴露为全局变量\n\n### 3 `jQuery.fn`  的  `init`  方法返回的  `this`  指的是什么对象\n\n- jQuery.fn 的 init 方法 返回的 this 就是 jQuery 对象\n- 用户使用 jQuery() 或 \\$() 即可初始化 jQuery 对象，不需要动态的去调用 init 方法\n\n### 4 jQuery.extend 与 jQuery.fn.extend 的区别\n\n- `$.fn.extend()`  和  `$.extend()`  是  `jQuery`  为扩展插件提拱了两个方法\n- `$.extend(object)`; // 为 jQuery 添加“静态方法”（工具方法）\n\n$.extend({　　min: function(a, b) { return a < b ? a : b; },　　max: function(a, b) { return a > b ? a : b; }});$.min(2,3); //  2\\$.max(4,5); //  5\n\n- \\$.extend(\\[true,\\] targetObject, object1\\[, object2\\]); // 对 targt 对象进行扩展\n\nvar settings = {validate:false, limit:5};var options = {validate:true, name:\"bar\"};\\$.extend(settings, options);  //  注意：不支持第一个参数传  false// settings == {validate:true, limit:5, name:\"bar\"}\n\n- `$.fn.extend(json)`; // 为 jQuery 添加“成员函数”（实例方法）\n\n$.fn.extend({\n   alertValue: function() {\n      $(this).click(function(){\n        alert($(this).val());\n      });\n   }});$(\"email\").alertValue();\n\n### 5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝\n\n- 浅拷贝（只复制一份原始对象的引用） `var newObject = $.extend({}, oldObject);`\n- 深拷贝（对原始对象属性所引用的对象进行进行递归拷贝） `var newObject = $.extend(true, {}, oldObject);`\n\n### 6 jQuery 的队列是如何实现的\n\n- jQuery 核心中有一组队列控制方法，由  `queue()/dequeue()/clearQueue()`  三个方法组成。\n- 主要应用于  `animate()`，`ajax`，其他要按时间顺序执行的事件中\n\nvar func1 = function(){alert('事件 1');}var func2 = function(){alert('事件 2');}var func3 = function(){alert('事件 3');}var func4 = function(){alert('事件 4');}//  入栈队列事件$('box').queue(\"queue1\", func1);  // push func1 to queue1$('box').queue(\"queue1\", func2);  // push func2 to queue1//  替换队列事件$('box').queue(\"queue1\", \\[\\]);  // delete queue1 with empty array$('box').queue(\"queue1\", \\[func3, func4\\]);  // replace queue1//  获取队列事件（返回一个函数数组）$('box').queue(\"queue1\");  // \\[func3(), func4()\\]// 出栈队列事件并执行$('box').dequeue(\"queue1\"); // return func3 and do func3$('box').dequeue(\"queue1\"); // return func4 and do func4// 清空整个队列$('box').clearQueue(\"queue1\"); // delete queue1 with clearQueue\n\n### 7 jQuery 中的 bind(), live(), delegate(), on()的区别\n\n- `bind()`  直接绑定在目标元素上\n- `live()`  通过冒泡传播事件，默认`document`上，支持动态数据\n- `delegate()`  更精确的小范围使用事件代理，性能优于 live\n- `on()`  是最新的`1.9`版本整合了之前的三种方式的新事件绑定机制\n\n### 8 是否知道自定义事件\n\n- 事件即“发布/订阅”模式，自定义事件即“消息发布”，事件的监听即“订阅订阅”\n- JS 原生支持自定义事件，示例：\n\ndocument.createEvent(type); //  创建事件\n  event.initEvent(eventType, canBubble, prevent); //  初始化事件\n  target.addEventListener('dataavailable', handler, false); //  监听事件\n  target.dispatchEvent(e);  //  触发事件\n\n- jQuery 里的`fire`  函数用于调用`jQuery`自定义事件列表中的事件\n\n### 9 jQuery 通过哪个方法和 Sizzle 选择器结合的\n\n- `Sizzle`  选择器采取  `Right To Left`  的匹配模式，先搜寻所有匹配标签，再判断它的父节点\n- `jQuery`  通过  `$(selecter).find(selecter);`  和  `Sizzle`  选择器结合\n\n### 10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来\n\n//  通过原生  JSON.stringify/JSON.parse  扩展  jQuery  实现\n \\$.array2json = function(array) {\n    return JSON.stringify(array);\n }\n\n$.json2array = function(array) {\n    // $.parseJSON(array); // 3.0  开始，已过时\n    return JSON.parse(array);\n }\n\n//  调用\n var json = $.array2json(\\['a', 'b', 'c'\\]);\n var array = $.json2array(json);\n\n### 11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的\n\n\\$(\"btn\").on(\"mouseover mouseout\", func);\n\n\\$(\"btn\").on({\n      mouseover: func1,\n      mouseout: func2,\n      click: func3  });\n\n### 12 针对 jQuery 的优化方法\n\n- 缓存频繁操作`DOM`对象\n- 尽量使用`id`选择器代替`class`选择器\n- 总是从`id`选择器来继承\n- 尽量使用链式操作\n- 使用时间委托  `on`绑定事件\n- 采用`jQuery`的内部函数`data()`来存储数据\n- 使用最新版本的  `jQuery`\n\n### 13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢\n\n- 在触发元素上的事件设置为延迟处理：使用  `JS`  原生  `setTimeout`  方法\n- 在触发元素的事件时预先停止所有的动画，再执行相应的动画事件：`$('.tab').stop().slideUp();`\n\n### 14 jQuery UI 如何自定义组件\n\n- 通过向  `$.widget()`  传递组件名称和一个原型对象来完成\n- `$.widget(\"ns.widgetName\", [baseWidget], widgetPrototype);`\n\n### 15 jQuery 与 jQuery UI、jQuery Mobile 区别\n\n- `jQuery`  是  `JS`  库，兼容各种 PC 浏览器，主要用作更方便地处理  `DOM`、事件、动画、`AJAX`\n- `jQuery UI`  是建立在  `jQuery`  库上的一组用户界面交互、特效、小部件及主题\n- `jQuery Mobile`  以  `jQuery`  为基础，用于创建“移动 Web 应用”的框架\n\n### 16 jQuery 和 Zepto 的区别？ 各自的使用场景\n\n- `jQuery`  主要目标是`PC`的网页中，兼容全部主流浏览器。在移动设备方面，单独推出 `jQuery Mobile\n- `Zepto`从一开始就定`位移动设备，相对更轻量级。它的`API `基本兼容`jQuery`，但对 PC 浏览器兼容不理想\n\n### 17 jQuery 对象的特点\n\n- 只有  `JQuery`对象才能使用  `JQuery`  方法\n- `JQuery`  对象是一个数组对象\n\n## 五、Bootstrap\n\n### 1 什么是 Bootstrap？以及为什么要使用 Bootstrap？\n\n> `Bootstrap`  是一个用于快速开发  `Web`应用程序和网站的前端框架。`Bootstrap`是基于  `HTML`、`CSS`、`JAVASCRIPT`  的\n\n- `Bootstrap`具有移动设备优先、浏览器支持良好、容易上手、响应式设计等优点，所以`Bootstrap`被广泛应用\n\n### 2 使用 Bootstrap 时，要声明的文档类型是什么？以及为什么要这样声明？\n\n- 使用`Bootstrap`时，需要使用  `HTML5`  文档类型（`Doctype`）。`<!DOCTYPE html>`\n- 因为`Bootstrap`使用了一些  `HTML5`  元素和  `CSS`  属性，如果在  `Bootstrap`创建的网页开头不使用  `HTML5`  的文档类型（`Doctype`），可能会面临一些浏览器显示不一致的问题，甚至可能面临一些特定情境下的不一致，以致于代码不能通过  `W3C`  标准的验证\n\n### 3 什么是 Bootstrap 网格系统\n\n> `Bootstrap`  包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到  `12`  列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类\n\n- 响应式网格系统随着屏幕或视口（`viewport`）尺寸的增加，系统会自动分为最多`12`列。\n\n### 4 Bootstrap 网格系统（Grid System）的工作原理\n\n- （1）行必须放置在  `.container class`  内，以便获得适当的对齐（`alignment`）和内边距（`padding`）。\n- （2）使用行来创建列的水平组。\n- （3）内容应该放置在列内，且唯有列可以是行的直接子元素。\n- （4）预定义的网格类，比如  `.row`  和  `.col-xs-4`，可用于快速创建网格布局。`LESS`  混合类可用于更多语义布局。\n- （5）列通过内边距（`padding`）来创建列内容之间的间隙。该内边距是通过  `.rows`  上的外边距（`margin`）取负，表示第一列和最后一列的行偏移。\n- （6）网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个  `.col-xs-4`\n\n### 5 对于各类尺寸的设备，Bootstrap 设置的 class 前缀分别是什么\n\n- 超小设备手机（`<768px`）：`.col-xs-*`\n- 小型设备平板电脑（`>=768px`）：`.col-sm-*`\n- 中型设备台式电脑（`>=992px`）：`.col-md-*`\n- 大型设备台式电脑（`>=1200px`）：`.col-lg-*`\n\n### 6 Bootstrap 网格系统列与列之间的间隙宽度是多少\n\n> 间隙宽度为`30px`（一个列的每边分别是`15px`）\n\n### 7 如果需要在一个标题的旁边创建副标题，可以怎样操作\n\n> 在元素两旁添加`<small>`，或者添加`.small`的`class`\n\n### 8 用 Bootstrap，如何设置文字的对齐方式？\n\n- `class=\"text-center\"`  设置居中文本\n- `class=\"text-right\"`  设置向右对齐文本\n- `class=\"text-left\"`  设置向左对齐文本\n\n### 9 Bootstrap 如何设置响应式表格？\n\n> 增加`class=\"table-responsive\"`\n\n### 10 使用 Bootstrap 创建垂直表单的基本步骤？\n\n- （1）向父`<form>`元素添加`role=\"form\"`；\n- （2）把标签和控件放在一个带有`class=\"form-group\"`的`<div>`中，这是获取最佳间距所必需的；\n- （3）向所有的文本元素`<input>`、`<textarea>`、`<select>`添加`class=\"form-control\"`\n\n### 11 使用 Bootstrap 创建水平表单的基本步骤？\n\n- （1）向父`<form>`元素添加`class=\"form-horizontal\"`；\n- （2）把标签和控件放在一个带有`class=\"form-group\"`的`<div>`中；\n- （3）向标签添加`class=\"control-label\"`。\n\n### 12 使用 Bootstrap 如何创建表单控件的帮助文本？\n\n> 增加`class=\"help-block\"`的`span`标签或`p`标签。\n\n### 13 使用 Bootstrap 激活或禁用按钮要如何操作？\n\n- 激活按钮：给按钮增加`.active`的`class`\n- 禁用按钮：给按钮增加`disabled=\"disabled\"`的属性\n\n### 14 Bootstrap 有哪些关于的 class？\n\n- （1）`.img-rounded`  为图片添加圆角\n- （2）`.img-circle`  将图片变为圆形\n- （3）`.img-thumbnail`  缩略图功能\n- （4）`.img-responsive`  图片响应式 (将很好地扩展到父元素)\n\n### 15 Bootstrap 中有关元素浮动及清除浮动的 class？\n\n- （1）`class=\"pull-left\"`  元素浮动到左边\n- （2）`class=\"pull-right\"`  元素浮动到右边\n- （3）`class=\"clearfix\"`  清除浮动\n\n### 16 除了屏幕阅读器外，其他设备上隐藏元素的 class？\n\n> \\`class=\"sr-only\"\\`\\`\n\n### 17 Bootstrap 如何制作下拉菜单？\n\n- （1）将下拉菜单包裹在`class=\"dropdown\"`的`<div>`中；\n- （2）在触发下拉菜单的按钮中添加：`class=\"btn dropdown-toggle\" id=\"dropdownMenu1\" data-toggle=\"dropdown\"`\n- （3）在包裹下拉菜单的 ul 中添加：`class=\"dropdown-menu\" role=\"menu\" aria-labelledby=\"dropdownMenu1\"`\n- （4）在下拉菜单的列表项中添加：`role=\"presentation\"`。其中，下拉菜单的标题要添加`class=\"dropdown-header\"`，选项部分要添加`tabindex=\"-1\"`。\n\n### 18 Bootstrap 如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？\n\n- （1）用`class=\"btn-group\"`的`<div>`去包裹按钮组；`class=\"btn-group-vertical\"`可设置垂直按钮组。\n- （2）`btn-group`的优先级高于`btn-group-vertical`的优先级。\n\n### 19 Bootstrap 如何设置按钮的下拉菜单？\n\n> 在一个  `.btn-group`  中放置按钮和下拉菜单即可。\n\n### 20 Bootstrap 中的输入框组如何制作？\n\n- （1）把前缀或者后缀元素放在一个带有`class=\"input-group\"`中的`<div>`中\n- （2）在该`<div>`内，在`class=\"input-group-addon\"`的`<span>`里面放置额外的内容；\n- （3）把`<span>`放在`<input>`元素的前面或后面。\n\n### 21 Bootstrap 中的导航都有哪些？\n\n- （1）导航元素：有`class=\"nav nav-tabs\"`的标签页导航，还有`class=\"nav nav-pills\"`的胶囊式标签页导航；\n- （2）导航栏：`class=\"navbar navbar-default\" role=\"navigation\"`；\n- （3）面包屑导航：`class=\"breadcrumb\"`\n\n### 22 Bootstrap 中设置分页的 class？\n\n- 默认的分页：`class=\"pagination\"`\n- 默认的翻页：`class=\"pager\"`\n\n### 23 Bootstrap 中显示标签的 class？\n\n> `class=\"label\"`\n\n### 24 Bootstrap 中如何制作徽章？\n\n> `<span class=\"badge\">26</span>`\n\n### 25 Bootstrap 中超大屏幕的作用是什么？\n\n> 设置`class=\"jumbotron\"`可以制作超大屏幕，该组件可以增加标题的大小并增加更多的外边距\n\n## 六、微信小程序\n\n### 1 微信小程序有几个文件\n\n- `WXSS (WeiXin Style Sheets)`是一套样式语言，用于描述  `WXML`  的组件样式， `js`  逻辑处理，网络请求`json`小程序设置，如页面注册，页面标题及  `tabBar`。\n- `app.json`  必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的`window`  背景色，配置导航条样式，配置默认标题。\n- `app.js`  必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。\n- `app.wxss`  配置全局  `css`\n\n### 2 微信小程序怎样跟事件传值\n\n> 给  `HTML`  元素添加  `data-*`属性来传递我们需要的值，然后通过  `e.currentTarget.dataset`  或`onload`的`param`参数获取。但  `data -`  名称不能有大写字母和不可以存放对象\n\n### 3 小程序的 wxss 和 css 有哪些不一样的地方？\n\n- `wxss`的图片引入需使用外链地址\n- 没有  `Body`；样式可直接使用  `import`  导入\n\n### 4 小程序关联微信公众号如何确定用户的唯一性\n\n> 使用  `wx.getUserInfo`  方法  `withCredentials`  为  `true`  时 可获取  `encryptedData`，里面有  `union_id`。后端需要进行对称解密\n\n### 5 微信小程序与 vue 区别\n\n- 生命周期不一样，微信小程序生命周期比较简单\n- 数据绑定也不同，微信小程序数据绑定需要使用`{ {}}`，`vue`  直接`:`就可以\n- 显示与隐藏元素，`vue`中，使用  `v-if`  和  `v-show`  控制元素的显示和隐藏，小程序中，使用`wx-if`  和`hidden`  控制元素的显示和隐藏\n- 事件处理不同，小程序中，全用  `bindtap(bind+event)`，或者  `catchtap(catch+event)`  绑定事件,`vue：`使用  `v-on:event`  绑定事件，或者使用`@event`  绑定事件\n- 数据双向绑定也不也不一样在  `vue`中,只需要再表单元素上加上  `v-model`,然后再绑定  `data`中对应的一个值，当表单元素内容发生变化时，`data`中对应的值也会相应改变，这是  `vue`非常 nice 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个  `data`中声明的变量。\n\n## 七、webpack 相关\n\n### 1 打包体积 优化思路\n\n- 提取第三方库或通过引用外部文件的方式引入第三方库\n- 代码压缩插件`UglifyJsPlugin`\n- 服务器启用 gzip 压缩\n- 按需加载资源文件  `require.ensure`\n- 优化`devtool`中的`source-map`\n- 剥离`css`文件，单独打包\n- 去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致\n\n### 2 打包效率\n\n- 开发环境采用增量构建，启用热更新\n- 开发环境不做无意义的工作如提取`css`计算文件 hash 等\n- 配置`devtool`\n- 选择合适的`loader`\n- 个别`loader`开启`cache`  如`babel-loader`\n- 第三方库采用引入方式\n- 提取公共代码\n- 优化构建时的搜索路径 指明需要构建目录及不需要构建目录\n- 模块化引入需要的部分\n\n### 3 Loader\n\n编写一个 loader\n\n> `loader`就是一个`node`模块，它输出了一个函数。当某种资源需要用这个`loader`转换时，这个函数会被调用。并且，这个函数可以通过提供给它的`this`上下文访问`Loader API`。 `reverse-txt-loader`\n\n//  定义 module.exports = function(src) {\n  //src 是原文件内容（abcde），下面对内容进行处理，这里是反转\n  var result = src.split('').reverse().join('');\n  //返回 JavaScript 源码，必须是 String 或者 Buffer\n  return \\`module.exports = '${result}'\\`;}//使用{\n\ttest: /\\\\.txt$/,\nuse: \\[\n{\n'./path/reverse-txt-loader'\n}\n\\]},\n\n### 4 说一下 webpack 的一些 plugin，怎么使用 webpack 对项目进行优化\n\n构建优化\n\n- 减少编译体积  `ContextReplacementPugin`、`IgnorePlugin`、`babel-plugin-import`、`babel-plugin-transform-runtime`\n- 并行编译  `happypack`、`thread-loader`、`uglifyjsWebpackPlugin`开启并行\n- 缓存  `cache-loader`、`hard-source-webpack-plugin`、`uglifyjsWebpackPlugin`开启缓存、`babel-loader`开启缓存\n- 预编译  `dllWebpackPlugin && DllReferencePlugin`、`auto-dll-webapck-plugin`\n\n性能优化\n\n- 减少编译体积  `Tree-shaking`、`Scope Hositing`\n- `hash`缓存  `webpack-md5-plugin`\n- 拆包  `splitChunksPlugin`、`import()`、`require.ensure`\n","slug":"2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e7-ac-ac-e4-b8-89-e6-96-b9-e5-ba-93-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8","published":1,"updated":"2019-09-12T02:59:53.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269g6005bc8gsh0tedv4i","content":"<h2 id=\"四、jQuery\"><a href=\"#四、jQuery\" class=\"headerlink\" title=\"四、jQuery\"></a>四、jQuery</h2><h3 id=\"1-你觉得-jQuery-或-zepto-源码有哪些写的好的地方\"><a href=\"#1-你觉得-jQuery-或-zepto-源码有哪些写的好的地方\" class=\"headerlink\" title=\"1 你觉得 jQuery 或 zepto 源码有哪些写的好的地方\"></a>1 你觉得 jQuery 或 zepto 源码有哪些写的好的地方</h3><ul>\n<li>jquery 源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入 window 对象参数，可以使 window 对象作为局部变量使用，好处是当 jquery 中访问 window 对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问 window 对象。同样，传入 undefined 参数，可以缩短查找 undefined 时的作用域链</li>\n</ul>\n<p>(function( window, undefined ) {</p>\n<p>//用一个函数域包起来，就是所谓的沙箱</p>\n<p>//在这里边 var 定义的变量，属于这个函数域内的局部变量，避免污染全局</p>\n<p>//把当前沙箱需要的外部变量通过函数参数引入进来</p>\n<p>//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数</p>\n<p>window.jQuery = window.$ = jQuery;</p>\n<p>})( window );</p>\n<ul>\n<li>jquery 将一些原型属性和方法封装在了 jquery.prototype 中，为了缩短名称，又赋值给了 jquery.fn，这是很形象的写法</li>\n<li>有一些数组或对象的方法经常能使用到，jQuery 将其保存为局部变量以提高访问速度</li>\n<li>jquery 实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li>\n</ul>\n<h3 id=\"2-jQuery-的实现原理\"><a href=\"#2-jQuery-的实现原理\" class=\"headerlink\" title=\"2 jQuery 的实现原理\"></a>2 jQuery 的实现原理</h3><ul>\n<li><code>(function(window, undefined) &#123;&#125;)(window);</code></li>\n<li><code>jQuery</code>  利用  <code>JS</code>  函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题</li>\n<li><code>window.jQuery = window.$ = jQuery;</code></li>\n<li>在闭包当中将 jQuery 和 $ 绑定到 window 上，从而将 jQuery 和 $ 暴露为全局变量</li>\n</ul>\n<h3 id=\"3-jQuery-fn-的-init-方法返回的-this-指的是什么对象\"><a href=\"#3-jQuery-fn-的-init-方法返回的-this-指的是什么对象\" class=\"headerlink\" title=\"3 jQuery.fn  的  init  方法返回的  this  指的是什么对象\"></a>3 <code>jQuery.fn</code>  的  <code>init</code>  方法返回的  <code>this</code>  指的是什么对象</h3><ul>\n<li>jQuery.fn 的 init 方法 返回的 this 就是 jQuery 对象</li>\n<li>用户使用 jQuery() 或 $() 即可初始化 jQuery 对象，不需要动态的去调用 init 方法</li>\n</ul>\n<h3 id=\"4-jQuery-extend-与-jQuery-fn-extend-的区别\"><a href=\"#4-jQuery-extend-与-jQuery-fn-extend-的区别\" class=\"headerlink\" title=\"4 jQuery.extend 与 jQuery.fn.extend 的区别\"></a>4 jQuery.extend 与 jQuery.fn.extend 的区别</h3><ul>\n<li><code>$.fn.extend()</code>  和  <code>$.extend()</code>  是  <code>jQuery</code>  为扩展插件提拱了两个方法</li>\n<li><code>$.extend(object)</code>; // 为 jQuery 添加“静态方法”（工具方法）</li>\n</ul>\n<p>$.extend({　　min: function(a, b) { return a &lt; b ? a : b; },　　max: function(a, b) { return a &gt; b ? a : b; }});$.min(2,3); //  2$.max(4,5); //  5</p>\n<ul>\n<li>$.extend([true,] targetObject, object1[, object2]); // 对 targt 对象进行扩展</li>\n</ul>\n<p>var settings = {validate:false, limit:5};var options = {validate:true, name:”bar”};$.extend(settings, options);  //  注意：不支持第一个参数传  false// settings == {validate:true, limit:5, name:”bar”}</p>\n<ul>\n<li><code>$.fn.extend(json)</code>; // 为 jQuery 添加“成员函数”（实例方法）</li>\n</ul>\n<p>$.fn.extend({<br>   alertValue: function() {<br>      $(this).click(function(){<br>        alert($(this).val());<br>      });<br>   }});$(“email”).alertValue();</p>\n<h3 id=\"5-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝\"><a href=\"#5-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝\" class=\"headerlink\" title=\"5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝\"></a>5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝</h3><ul>\n<li>浅拷贝（只复制一份原始对象的引用） <code>var newObject = $.extend(&#123;&#125;, oldObject);</code></li>\n<li>深拷贝（对原始对象属性所引用的对象进行进行递归拷贝） <code>var newObject = $.extend(true, &#123;&#125;, oldObject);</code></li>\n</ul>\n<h3 id=\"6-jQuery-的队列是如何实现的\"><a href=\"#6-jQuery-的队列是如何实现的\" class=\"headerlink\" title=\"6 jQuery 的队列是如何实现的\"></a>6 jQuery 的队列是如何实现的</h3><ul>\n<li>jQuery 核心中有一组队列控制方法，由  <code>queue()/dequeue()/clearQueue()</code>  三个方法组成。</li>\n<li>主要应用于  <code>animate()</code>，<code>ajax</code>，其他要按时间顺序执行的事件中</li>\n</ul>\n<p>var func1 = function(){alert(‘事件 1’);}var func2 = function(){alert(‘事件 2’);}var func3 = function(){alert(‘事件 3’);}var func4 = function(){alert(‘事件 4’);}//  入栈队列事件$(‘box’).queue(“queue1”, func1);  // push func1 to queue1$(‘box’).queue(“queue1”, func2);  // push func2 to queue1//  替换队列事件$(‘box’).queue(“queue1”, []);  // delete queue1 with empty array$(‘box’).queue(“queue1”, [func3, func4]);  // replace queue1//  获取队列事件（返回一个函数数组）$(‘box’).queue(“queue1”);  // [func3(), func4()]// 出栈队列事件并执行$(‘box’).dequeue(“queue1”); // return func3 and do func3$(‘box’).dequeue(“queue1”); // return func4 and do func4// 清空整个队列$(‘box’).clearQueue(“queue1”); // delete queue1 with clearQueue</p>\n<h3 id=\"7-jQuery-中的-bind-live-delegate-on-的区别\"><a href=\"#7-jQuery-中的-bind-live-delegate-on-的区别\" class=\"headerlink\" title=\"7 jQuery 中的 bind(), live(), delegate(), on()的区别\"></a>7 jQuery 中的 bind(), live(), delegate(), on()的区别</h3><ul>\n<li><code>bind()</code>  直接绑定在目标元素上</li>\n<li><code>live()</code>  通过冒泡传播事件，默认<code>document</code>上，支持动态数据</li>\n<li><code>delegate()</code>  更精确的小范围使用事件代理，性能优于 live</li>\n<li><code>on()</code>  是最新的<code>1.9</code>版本整合了之前的三种方式的新事件绑定机制</li>\n</ul>\n<h3 id=\"8-是否知道自定义事件\"><a href=\"#8-是否知道自定义事件\" class=\"headerlink\" title=\"8 是否知道自定义事件\"></a>8 是否知道自定义事件</h3><ul>\n<li>事件即“发布/订阅”模式，自定义事件即“消息发布”，事件的监听即“订阅订阅”</li>\n<li>JS 原生支持自定义事件，示例：</li>\n</ul>\n<p>document.createEvent(type); //  创建事件<br>  event.initEvent(eventType, canBubble, prevent); //  初始化事件<br>  target.addEventListener(‘dataavailable’, handler, false); //  监听事件<br>  target.dispatchEvent(e);  //  触发事件</p>\n<ul>\n<li>jQuery 里的<code>fire</code>  函数用于调用<code>jQuery</code>自定义事件列表中的事件</li>\n</ul>\n<h3 id=\"9-jQuery-通过哪个方法和-Sizzle-选择器结合的\"><a href=\"#9-jQuery-通过哪个方法和-Sizzle-选择器结合的\" class=\"headerlink\" title=\"9 jQuery 通过哪个方法和 Sizzle 选择器结合的\"></a>9 jQuery 通过哪个方法和 Sizzle 选择器结合的</h3><ul>\n<li><code>Sizzle</code>  选择器采取  <code>Right To Left</code>  的匹配模式，先搜寻所有匹配标签，再判断它的父节点</li>\n<li><code>jQuery</code>  通过  <code>$(selecter).find(selecter);</code>  和  <code>Sizzle</code>  选择器结合</li>\n</ul>\n<h3 id=\"10-jQuery-中如何将数组转化为-JSON-字符串，然后再转化回来\"><a href=\"#10-jQuery-中如何将数组转化为-JSON-字符串，然后再转化回来\" class=\"headerlink\" title=\"10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来\"></a>10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来</h3><p>//  通过原生  JSON.stringify/JSON.parse  扩展  jQuery  实现<br> $.array2json = function(array) {<br>    return JSON.stringify(array);<br> }</p>\n<p>$.json2array = function(array) {<br>    // $.parseJSON(array); // 3.0  开始，已过时<br>    return JSON.parse(array);<br> }</p>\n<p>//  调用<br> var json = $.array2json([‘a’, ‘b’, ‘c’]);<br> var array = $.json2array(json);</p>\n<h3 id=\"11-jQuery-一个对象可以同时绑定多个事件，这是如何实现的\"><a href=\"#11-jQuery-一个对象可以同时绑定多个事件，这是如何实现的\" class=\"headerlink\" title=\"11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的\"></a>11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的</h3><p>$(“btn”).on(“mouseover mouseout”, func);</p>\n<p>$(“btn”).on({<br>      mouseover: func1,<br>      mouseout: func2,<br>      click: func3  });</p>\n<h3 id=\"12-针对-jQuery-的优化方法\"><a href=\"#12-针对-jQuery-的优化方法\" class=\"headerlink\" title=\"12 针对 jQuery 的优化方法\"></a>12 针对 jQuery 的优化方法</h3><ul>\n<li>缓存频繁操作<code>DOM</code>对象</li>\n<li>尽量使用<code>id</code>选择器代替<code>class</code>选择器</li>\n<li>总是从<code>id</code>选择器来继承</li>\n<li>尽量使用链式操作</li>\n<li>使用时间委托  <code>on</code>绑定事件</li>\n<li>采用<code>jQuery</code>的内部函数<code>data()</code>来存储数据</li>\n<li>使用最新版本的  <code>jQuery</code></li>\n</ul>\n<h3 id=\"13-jQuery-的-slideUp-动画，当鼠标快速连续触发-动画会滞后反复执行，该如何处理呢\"><a href=\"#13-jQuery-的-slideUp-动画，当鼠标快速连续触发-动画会滞后反复执行，该如何处理呢\" class=\"headerlink\" title=\"13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢\"></a>13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢</h3><ul>\n<li>在触发元素上的事件设置为延迟处理：使用  <code>JS</code>  原生  <code>setTimeout</code>  方法</li>\n<li>在触发元素的事件时预先停止所有的动画，再执行相应的动画事件：<code>$(&#39;.tab&#39;).stop().slideUp();</code></li>\n</ul>\n<h3 id=\"14-jQuery-UI-如何自定义组件\"><a href=\"#14-jQuery-UI-如何自定义组件\" class=\"headerlink\" title=\"14 jQuery UI 如何自定义组件\"></a>14 jQuery UI 如何自定义组件</h3><ul>\n<li>通过向  <code>$.widget()</code>  传递组件名称和一个原型对象来完成</li>\n<li><code>$.widget(&quot;ns.widgetName&quot;, [baseWidget], widgetPrototype);</code></li>\n</ul>\n<h3 id=\"15-jQuery-与-jQuery-UI、jQuery-Mobile-区别\"><a href=\"#15-jQuery-与-jQuery-UI、jQuery-Mobile-区别\" class=\"headerlink\" title=\"15 jQuery 与 jQuery UI、jQuery Mobile 区别\"></a>15 jQuery 与 jQuery UI、jQuery Mobile 区别</h3><ul>\n<li><code>jQuery</code>  是  <code>JS</code>  库，兼容各种 PC 浏览器，主要用作更方便地处理  <code>DOM</code>、事件、动画、<code>AJAX</code></li>\n<li><code>jQuery UI</code>  是建立在  <code>jQuery</code>  库上的一组用户界面交互、特效、小部件及主题</li>\n<li><code>jQuery Mobile</code>  以  <code>jQuery</code>  为基础，用于创建“移动 Web 应用”的框架</li>\n</ul>\n<h3 id=\"16-jQuery-和-Zepto-的区别？-各自的使用场景\"><a href=\"#16-jQuery-和-Zepto-的区别？-各自的使用场景\" class=\"headerlink\" title=\"16 jQuery 和 Zepto 的区别？ 各自的使用场景\"></a>16 jQuery 和 Zepto 的区别？ 各自的使用场景</h3><ul>\n<li><code>jQuery</code>  主要目标是<code>PC</code>的网页中，兼容全部主流浏览器。在移动设备方面，单独推出 `jQuery Mobile</li>\n<li><code>Zepto</code>从一开始就定<code>位移动设备，相对更轻量级。它的</code>API <code>基本兼容</code>jQuery`，但对 PC 浏览器兼容不理想</li>\n</ul>\n<h3 id=\"17-jQuery-对象的特点\"><a href=\"#17-jQuery-对象的特点\" class=\"headerlink\" title=\"17 jQuery 对象的特点\"></a>17 jQuery 对象的特点</h3><ul>\n<li>只有  <code>JQuery</code>对象才能使用  <code>JQuery</code>  方法</li>\n<li><code>JQuery</code>  对象是一个数组对象</li>\n</ul>\n<h2 id=\"五、Bootstrap\"><a href=\"#五、Bootstrap\" class=\"headerlink\" title=\"五、Bootstrap\"></a>五、Bootstrap</h2><h3 id=\"1-什么是-Bootstrap？以及为什么要使用-Bootstrap？\"><a href=\"#1-什么是-Bootstrap？以及为什么要使用-Bootstrap？\" class=\"headerlink\" title=\"1 什么是 Bootstrap？以及为什么要使用 Bootstrap？\"></a>1 什么是 Bootstrap？以及为什么要使用 Bootstrap？</h3><blockquote>\n<p><code>Bootstrap</code>  是一个用于快速开发  <code>Web</code>应用程序和网站的前端框架。<code>Bootstrap</code>是基于  <code>HTML</code>、<code>CSS</code>、<code>JAVASCRIPT</code>  的</p>\n</blockquote>\n<ul>\n<li><code>Bootstrap</code>具有移动设备优先、浏览器支持良好、容易上手、响应式设计等优点，所以<code>Bootstrap</code>被广泛应用</li>\n</ul>\n<h3 id=\"2-使用-Bootstrap-时，要声明的文档类型是什么？以及为什么要这样声明？\"><a href=\"#2-使用-Bootstrap-时，要声明的文档类型是什么？以及为什么要这样声明？\" class=\"headerlink\" title=\"2 使用 Bootstrap 时，要声明的文档类型是什么？以及为什么要这样声明？\"></a>2 使用 Bootstrap 时，要声明的文档类型是什么？以及为什么要这样声明？</h3><ul>\n<li>使用<code>Bootstrap</code>时，需要使用  <code>HTML5</code>  文档类型（<code>Doctype</code>）。<code>&lt;!DOCTYPE html&gt;</code></li>\n<li>因为<code>Bootstrap</code>使用了一些  <code>HTML5</code>  元素和  <code>CSS</code>  属性，如果在  <code>Bootstrap</code>创建的网页开头不使用  <code>HTML5</code>  的文档类型（<code>Doctype</code>），可能会面临一些浏览器显示不一致的问题，甚至可能面临一些特定情境下的不一致，以致于代码不能通过  <code>W3C</code>  标准的验证</li>\n</ul>\n<h3 id=\"3-什么是-Bootstrap-网格系统\"><a href=\"#3-什么是-Bootstrap-网格系统\" class=\"headerlink\" title=\"3 什么是 Bootstrap 网格系统\"></a>3 什么是 Bootstrap 网格系统</h3><blockquote>\n<p><code>Bootstrap</code>  包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到  <code>12</code>  列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类</p>\n</blockquote>\n<ul>\n<li>响应式网格系统随着屏幕或视口（<code>viewport</code>）尺寸的增加，系统会自动分为最多<code>12</code>列。</li>\n</ul>\n<h3 id=\"4-Bootstrap-网格系统（Grid-System）的工作原理\"><a href=\"#4-Bootstrap-网格系统（Grid-System）的工作原理\" class=\"headerlink\" title=\"4 Bootstrap 网格系统（Grid System）的工作原理\"></a>4 Bootstrap 网格系统（Grid System）的工作原理</h3><ul>\n<li>（1）行必须放置在  <code>.container class</code>  内，以便获得适当的对齐（<code>alignment</code>）和内边距（<code>padding</code>）。</li>\n<li>（2）使用行来创建列的水平组。</li>\n<li>（3）内容应该放置在列内，且唯有列可以是行的直接子元素。</li>\n<li>（4）预定义的网格类，比如  <code>.row</code>  和  <code>.col-xs-4</code>，可用于快速创建网格布局。<code>LESS</code>  混合类可用于更多语义布局。</li>\n<li>（5）列通过内边距（<code>padding</code>）来创建列内容之间的间隙。该内边距是通过  <code>.rows</code>  上的外边距（<code>margin</code>）取负，表示第一列和最后一列的行偏移。</li>\n<li>（6）网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个  <code>.col-xs-4</code></li>\n</ul>\n<h3 id=\"5-对于各类尺寸的设备，Bootstrap-设置的-class-前缀分别是什么\"><a href=\"#5-对于各类尺寸的设备，Bootstrap-设置的-class-前缀分别是什么\" class=\"headerlink\" title=\"5 对于各类尺寸的设备，Bootstrap 设置的 class 前缀分别是什么\"></a>5 对于各类尺寸的设备，Bootstrap 设置的 class 前缀分别是什么</h3><ul>\n<li>超小设备手机（<code>&lt;768px</code>）：<code>.col-xs-*</code></li>\n<li>小型设备平板电脑（<code>&gt;=768px</code>）：<code>.col-sm-*</code></li>\n<li>中型设备台式电脑（<code>&gt;=992px</code>）：<code>.col-md-*</code></li>\n<li>大型设备台式电脑（<code>&gt;=1200px</code>）：<code>.col-lg-*</code></li>\n</ul>\n<h3 id=\"6-Bootstrap-网格系统列与列之间的间隙宽度是多少\"><a href=\"#6-Bootstrap-网格系统列与列之间的间隙宽度是多少\" class=\"headerlink\" title=\"6 Bootstrap 网格系统列与列之间的间隙宽度是多少\"></a>6 Bootstrap 网格系统列与列之间的间隙宽度是多少</h3><blockquote>\n<p>间隙宽度为<code>30px</code>（一个列的每边分别是<code>15px</code>）</p>\n</blockquote>\n<h3 id=\"7-如果需要在一个标题的旁边创建副标题，可以怎样操作\"><a href=\"#7-如果需要在一个标题的旁边创建副标题，可以怎样操作\" class=\"headerlink\" title=\"7 如果需要在一个标题的旁边创建副标题，可以怎样操作\"></a>7 如果需要在一个标题的旁边创建副标题，可以怎样操作</h3><blockquote>\n<p>在元素两旁添加<code>&lt;small&gt;</code>，或者添加<code>.small</code>的<code>class</code></p>\n</blockquote>\n<h3 id=\"8-用-Bootstrap，如何设置文字的对齐方式？\"><a href=\"#8-用-Bootstrap，如何设置文字的对齐方式？\" class=\"headerlink\" title=\"8 用 Bootstrap，如何设置文字的对齐方式？\"></a>8 用 Bootstrap，如何设置文字的对齐方式？</h3><ul>\n<li><code>class=&quot;text-center&quot;</code>  设置居中文本</li>\n<li><code>class=&quot;text-right&quot;</code>  设置向右对齐文本</li>\n<li><code>class=&quot;text-left&quot;</code>  设置向左对齐文本</li>\n</ul>\n<h3 id=\"9-Bootstrap-如何设置响应式表格？\"><a href=\"#9-Bootstrap-如何设置响应式表格？\" class=\"headerlink\" title=\"9 Bootstrap 如何设置响应式表格？\"></a>9 Bootstrap 如何设置响应式表格？</h3><blockquote>\n<p>增加<code>class=&quot;table-responsive&quot;</code></p>\n</blockquote>\n<h3 id=\"10-使用-Bootstrap-创建垂直表单的基本步骤？\"><a href=\"#10-使用-Bootstrap-创建垂直表单的基本步骤？\" class=\"headerlink\" title=\"10 使用 Bootstrap 创建垂直表单的基本步骤？\"></a>10 使用 Bootstrap 创建垂直表单的基本步骤？</h3><ul>\n<li>（1）向父<code>&lt;form&gt;</code>元素添加<code>role=&quot;form&quot;</code>；</li>\n<li>（2）把标签和控件放在一个带有<code>class=&quot;form-group&quot;</code>的<code>&lt;div&gt;</code>中，这是获取最佳间距所必需的；</li>\n<li>（3）向所有的文本元素<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>添加<code>class=&quot;form-control&quot;</code></li>\n</ul>\n<h3 id=\"11-使用-Bootstrap-创建水平表单的基本步骤？\"><a href=\"#11-使用-Bootstrap-创建水平表单的基本步骤？\" class=\"headerlink\" title=\"11 使用 Bootstrap 创建水平表单的基本步骤？\"></a>11 使用 Bootstrap 创建水平表单的基本步骤？</h3><ul>\n<li>（1）向父<code>&lt;form&gt;</code>元素添加<code>class=&quot;form-horizontal&quot;</code>；</li>\n<li>（2）把标签和控件放在一个带有<code>class=&quot;form-group&quot;</code>的<code>&lt;div&gt;</code>中；</li>\n<li>（3）向标签添加<code>class=&quot;control-label&quot;</code>。</li>\n</ul>\n<h3 id=\"12-使用-Bootstrap-如何创建表单控件的帮助文本？\"><a href=\"#12-使用-Bootstrap-如何创建表单控件的帮助文本？\" class=\"headerlink\" title=\"12 使用 Bootstrap 如何创建表单控件的帮助文本？\"></a>12 使用 Bootstrap 如何创建表单控件的帮助文本？</h3><blockquote>\n<p>增加<code>class=&quot;help-block&quot;</code>的<code>span</code>标签或<code>p</code>标签。</p>\n</blockquote>\n<h3 id=\"13-使用-Bootstrap-激活或禁用按钮要如何操作？\"><a href=\"#13-使用-Bootstrap-激活或禁用按钮要如何操作？\" class=\"headerlink\" title=\"13 使用 Bootstrap 激活或禁用按钮要如何操作？\"></a>13 使用 Bootstrap 激活或禁用按钮要如何操作？</h3><ul>\n<li>激活按钮：给按钮增加<code>.active</code>的<code>class</code></li>\n<li>禁用按钮：给按钮增加<code>disabled=&quot;disabled&quot;</code>的属性</li>\n</ul>\n<h3 id=\"14-Bootstrap-有哪些关于的-class？\"><a href=\"#14-Bootstrap-有哪些关于的-class？\" class=\"headerlink\" title=\"14 Bootstrap 有哪些关于的 class？\"></a>14 Bootstrap 有哪些关于的 class？</h3><ul>\n<li>（1）<code>.img-rounded</code>  为图片添加圆角</li>\n<li>（2）<code>.img-circle</code>  将图片变为圆形</li>\n<li>（3）<code>.img-thumbnail</code>  缩略图功能</li>\n<li>（4）<code>.img-responsive</code>  图片响应式 (将很好地扩展到父元素)</li>\n</ul>\n<h3 id=\"15-Bootstrap-中有关元素浮动及清除浮动的-class？\"><a href=\"#15-Bootstrap-中有关元素浮动及清除浮动的-class？\" class=\"headerlink\" title=\"15 Bootstrap 中有关元素浮动及清除浮动的 class？\"></a>15 Bootstrap 中有关元素浮动及清除浮动的 class？</h3><ul>\n<li>（1）<code>class=&quot;pull-left&quot;</code>  元素浮动到左边</li>\n<li>（2）<code>class=&quot;pull-right&quot;</code>  元素浮动到右边</li>\n<li>（3）<code>class=&quot;clearfix&quot;</code>  清除浮动</li>\n</ul>\n<h3 id=\"16-除了屏幕阅读器外，其他设备上隐藏元素的-class？\"><a href=\"#16-除了屏幕阅读器外，其他设备上隐藏元素的-class？\" class=\"headerlink\" title=\"16 除了屏幕阅读器外，其他设备上隐藏元素的 class？\"></a>16 除了屏幕阅读器外，其他设备上隐藏元素的 class？</h3><blockquote>\n<p>`class=”sr-only”``</p>\n</blockquote>\n<h3 id=\"17-Bootstrap-如何制作下拉菜单？\"><a href=\"#17-Bootstrap-如何制作下拉菜单？\" class=\"headerlink\" title=\"17 Bootstrap 如何制作下拉菜单？\"></a>17 Bootstrap 如何制作下拉菜单？</h3><ul>\n<li>（1）将下拉菜单包裹在<code>class=&quot;dropdown&quot;</code>的<code>&lt;div&gt;</code>中；</li>\n<li>（2）在触发下拉菜单的按钮中添加：<code>class=&quot;btn dropdown-toggle&quot; id=&quot;dropdownMenu1&quot; data-toggle=&quot;dropdown&quot;</code></li>\n<li>（3）在包裹下拉菜单的 ul 中添加：<code>class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dropdownMenu1&quot;</code></li>\n<li>（4）在下拉菜单的列表项中添加：<code>role=&quot;presentation&quot;</code>。其中，下拉菜单的标题要添加<code>class=&quot;dropdown-header&quot;</code>，选项部分要添加<code>tabindex=&quot;-1&quot;</code>。</li>\n</ul>\n<h3 id=\"18-Bootstrap-如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？\"><a href=\"#18-Bootstrap-如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？\" class=\"headerlink\" title=\"18 Bootstrap 如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？\"></a>18 Bootstrap 如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？</h3><ul>\n<li>（1）用<code>class=&quot;btn-group&quot;</code>的<code>&lt;div&gt;</code>去包裹按钮组；<code>class=&quot;btn-group-vertical&quot;</code>可设置垂直按钮组。</li>\n<li>（2）<code>btn-group</code>的优先级高于<code>btn-group-vertical</code>的优先级。</li>\n</ul>\n<h3 id=\"19-Bootstrap-如何设置按钮的下拉菜单？\"><a href=\"#19-Bootstrap-如何设置按钮的下拉菜单？\" class=\"headerlink\" title=\"19 Bootstrap 如何设置按钮的下拉菜单？\"></a>19 Bootstrap 如何设置按钮的下拉菜单？</h3><blockquote>\n<p>在一个  <code>.btn-group</code>  中放置按钮和下拉菜单即可。</p>\n</blockquote>\n<h3 id=\"20-Bootstrap-中的输入框组如何制作？\"><a href=\"#20-Bootstrap-中的输入框组如何制作？\" class=\"headerlink\" title=\"20 Bootstrap 中的输入框组如何制作？\"></a>20 Bootstrap 中的输入框组如何制作？</h3><ul>\n<li>（1）把前缀或者后缀元素放在一个带有<code>class=&quot;input-group&quot;</code>中的<code>&lt;div&gt;</code>中</li>\n<li>（2）在该<code>&lt;div&gt;</code>内，在<code>class=&quot;input-group-addon&quot;</code>的<code>&lt;span&gt;</code>里面放置额外的内容；</li>\n<li>（3）把<code>&lt;span&gt;</code>放在<code>&lt;input&gt;</code>元素的前面或后面。</li>\n</ul>\n<h3 id=\"21-Bootstrap-中的导航都有哪些？\"><a href=\"#21-Bootstrap-中的导航都有哪些？\" class=\"headerlink\" title=\"21 Bootstrap 中的导航都有哪些？\"></a>21 Bootstrap 中的导航都有哪些？</h3><ul>\n<li>（1）导航元素：有<code>class=&quot;nav nav-tabs&quot;</code>的标签页导航，还有<code>class=&quot;nav nav-pills&quot;</code>的胶囊式标签页导航；</li>\n<li>（2）导航栏：<code>class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;</code>；</li>\n<li>（3）面包屑导航：<code>class=&quot;breadcrumb&quot;</code></li>\n</ul>\n<h3 id=\"22-Bootstrap-中设置分页的-class？\"><a href=\"#22-Bootstrap-中设置分页的-class？\" class=\"headerlink\" title=\"22 Bootstrap 中设置分页的 class？\"></a>22 Bootstrap 中设置分页的 class？</h3><ul>\n<li>默认的分页：<code>class=&quot;pagination&quot;</code></li>\n<li>默认的翻页：<code>class=&quot;pager&quot;</code></li>\n</ul>\n<h3 id=\"23-Bootstrap-中显示标签的-class？\"><a href=\"#23-Bootstrap-中显示标签的-class？\" class=\"headerlink\" title=\"23 Bootstrap 中显示标签的 class？\"></a>23 Bootstrap 中显示标签的 class？</h3><blockquote>\n<p><code>class=&quot;label&quot;</code></p>\n</blockquote>\n<h3 id=\"24-Bootstrap-中如何制作徽章？\"><a href=\"#24-Bootstrap-中如何制作徽章？\" class=\"headerlink\" title=\"24 Bootstrap 中如何制作徽章？\"></a>24 Bootstrap 中如何制作徽章？</h3><blockquote>\n<p><code>&lt;span class=&quot;badge&quot;&gt;26&lt;/span&gt;</code></p>\n</blockquote>\n<h3 id=\"25-Bootstrap-中超大屏幕的作用是什么？\"><a href=\"#25-Bootstrap-中超大屏幕的作用是什么？\" class=\"headerlink\" title=\"25 Bootstrap 中超大屏幕的作用是什么？\"></a>25 Bootstrap 中超大屏幕的作用是什么？</h3><blockquote>\n<p>设置<code>class=&quot;jumbotron&quot;</code>可以制作超大屏幕，该组件可以增加标题的大小并增加更多的外边距</p>\n</blockquote>\n<h2 id=\"六、微信小程序\"><a href=\"#六、微信小程序\" class=\"headerlink\" title=\"六、微信小程序\"></a>六、微信小程序</h2><h3 id=\"1-微信小程序有几个文件\"><a href=\"#1-微信小程序有几个文件\" class=\"headerlink\" title=\"1 微信小程序有几个文件\"></a>1 微信小程序有几个文件</h3><ul>\n<li><code>WXSS (WeiXin Style Sheets)</code>是一套样式语言，用于描述  <code>WXML</code>  的组件样式， <code>js</code>  逻辑处理，网络请求<code>json</code>小程序设置，如页面注册，页面标题及  <code>tabBar</code>。</li>\n<li><code>app.json</code>  必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的<code>window</code>  背景色，配置导航条样式，配置默认标题。</li>\n<li><code>app.js</code>  必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。</li>\n<li><code>app.wxss</code>  配置全局  <code>css</code></li>\n</ul>\n<h3 id=\"2-微信小程序怎样跟事件传值\"><a href=\"#2-微信小程序怎样跟事件传值\" class=\"headerlink\" title=\"2 微信小程序怎样跟事件传值\"></a>2 微信小程序怎样跟事件传值</h3><blockquote>\n<p>给  <code>HTML</code>  元素添加  <code>data-*</code>属性来传递我们需要的值，然后通过  <code>e.currentTarget.dataset</code>  或<code>onload</code>的<code>param</code>参数获取。但  <code>data -</code>  名称不能有大写字母和不可以存放对象</p>\n</blockquote>\n<h3 id=\"3-小程序的-wxss-和-css-有哪些不一样的地方？\"><a href=\"#3-小程序的-wxss-和-css-有哪些不一样的地方？\" class=\"headerlink\" title=\"3 小程序的 wxss 和 css 有哪些不一样的地方？\"></a>3 小程序的 wxss 和 css 有哪些不一样的地方？</h3><ul>\n<li><code>wxss</code>的图片引入需使用外链地址</li>\n<li>没有  <code>Body</code>；样式可直接使用  <code>import</code>  导入</li>\n</ul>\n<h3 id=\"4-小程序关联微信公众号如何确定用户的唯一性\"><a href=\"#4-小程序关联微信公众号如何确定用户的唯一性\" class=\"headerlink\" title=\"4 小程序关联微信公众号如何确定用户的唯一性\"></a>4 小程序关联微信公众号如何确定用户的唯一性</h3><blockquote>\n<p>使用  <code>wx.getUserInfo</code>  方法  <code>withCredentials</code>  为  <code>true</code>  时 可获取  <code>encryptedData</code>，里面有  <code>union_id</code>。后端需要进行对称解密</p>\n</blockquote>\n<h3 id=\"5-微信小程序与-vue-区别\"><a href=\"#5-微信小程序与-vue-区别\" class=\"headerlink\" title=\"5 微信小程序与 vue 区别\"></a>5 微信小程序与 vue 区别</h3><ul>\n<li>生命周期不一样，微信小程序生命周期比较简单</li>\n<li>数据绑定也不同，微信小程序数据绑定需要使用<code>&#123; &#123;&#125;&#125;</code>，<code>vue</code>  直接<code>:</code>就可以</li>\n<li>显示与隐藏元素，<code>vue</code>中，使用  <code>v-if</code>  和  <code>v-show</code>  控制元素的显示和隐藏，小程序中，使用<code>wx-if</code>  和<code>hidden</code>  控制元素的显示和隐藏</li>\n<li>事件处理不同，小程序中，全用  <code>bindtap(bind+event)</code>，或者  <code>catchtap(catch+event)</code>  绑定事件,<code>vue：</code>使用  <code>v-on:event</code>  绑定事件，或者使用<code>@event</code>  绑定事件</li>\n<li>数据双向绑定也不也不一样在  <code>vue</code>中,只需要再表单元素上加上  <code>v-model</code>,然后再绑定  <code>data</code>中对应的一个值，当表单元素内容发生变化时，<code>data</code>中对应的值也会相应改变，这是  <code>vue</code>非常 nice 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个  <code>data</code>中声明的变量。</li>\n</ul>\n<h2 id=\"七、webpack-相关\"><a href=\"#七、webpack-相关\" class=\"headerlink\" title=\"七、webpack 相关\"></a>七、webpack 相关</h2><h3 id=\"1-打包体积-优化思路\"><a href=\"#1-打包体积-优化思路\" class=\"headerlink\" title=\"1 打包体积 优化思路\"></a>1 打包体积 优化思路</h3><ul>\n<li>提取第三方库或通过引用外部文件的方式引入第三方库</li>\n<li>代码压缩插件<code>UglifyJsPlugin</code></li>\n<li>服务器启用 gzip 压缩</li>\n<li>按需加载资源文件  <code>require.ensure</code></li>\n<li>优化<code>devtool</code>中的<code>source-map</code></li>\n<li>剥离<code>css</code>文件，单独打包</li>\n<li>去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致</li>\n</ul>\n<h3 id=\"2-打包效率\"><a href=\"#2-打包效率\" class=\"headerlink\" title=\"2 打包效率\"></a>2 打包效率</h3><ul>\n<li>开发环境采用增量构建，启用热更新</li>\n<li>开发环境不做无意义的工作如提取<code>css</code>计算文件 hash 等</li>\n<li>配置<code>devtool</code></li>\n<li>选择合适的<code>loader</code></li>\n<li>个别<code>loader</code>开启<code>cache</code>  如<code>babel-loader</code></li>\n<li>第三方库采用引入方式</li>\n<li>提取公共代码</li>\n<li>优化构建时的搜索路径 指明需要构建目录及不需要构建目录</li>\n<li>模块化引入需要的部分</li>\n</ul>\n<h3 id=\"3-Loader\"><a href=\"#3-Loader\" class=\"headerlink\" title=\"3 Loader\"></a>3 Loader</h3><p>编写一个 loader</p>\n<blockquote>\n<p><code>loader</code>就是一个<code>node</code>模块，它输出了一个函数。当某种资源需要用这个<code>loader</code>转换时，这个函数会被调用。并且，这个函数可以通过提供给它的<code>this</code>上下文访问<code>Loader API</code>。 <code>reverse-txt-loader</code></p>\n</blockquote>\n<p>//  定义 module.exports = function(src) {<br>  //src 是原文件内容（abcde），下面对内容进行处理，这里是反转<br>  var result = src.split(‘’).reverse().join(‘’);<br>  //返回 JavaScript 源码，必须是 String 或者 Buffer<br>  return `module.exports = ‘${result}’`;}//使用{<br>    test: /\\.txt$/,<br>use: [<br>{<br>‘./path/reverse-txt-loader’<br>}<br>]},</p>\n<h3 id=\"4-说一下-webpack-的一些-plugin，怎么使用-webpack-对项目进行优化\"><a href=\"#4-说一下-webpack-的一些-plugin，怎么使用-webpack-对项目进行优化\" class=\"headerlink\" title=\"4 说一下 webpack 的一些 plugin，怎么使用 webpack 对项目进行优化\"></a>4 说一下 webpack 的一些 plugin，怎么使用 webpack 对项目进行优化</h3><p>构建优化</p>\n<ul>\n<li>减少编译体积  <code>ContextReplacementPugin</code>、<code>IgnorePlugin</code>、<code>babel-plugin-import</code>、<code>babel-plugin-transform-runtime</code></li>\n<li>并行编译  <code>happypack</code>、<code>thread-loader</code>、<code>uglifyjsWebpackPlugin</code>开启并行</li>\n<li>缓存  <code>cache-loader</code>、<code>hard-source-webpack-plugin</code>、<code>uglifyjsWebpackPlugin</code>开启缓存、<code>babel-loader</code>开启缓存</li>\n<li>预编译  <code>dllWebpackPlugin &amp;&amp; DllReferencePlugin</code>、<code>auto-dll-webapck-plugin</code></li>\n</ul>\n<p>性能优化</p>\n<ul>\n<li>减少编译体积  <code>Tree-shaking</code>、<code>Scope Hositing</code></li>\n<li><code>hash</code>缓存  <code>webpack-md5-plugin</code></li>\n<li>拆包  <code>splitChunksPlugin</code>、<code>import()</code>、<code>require.ensure</code></li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"四、jQuery\"><a href=\"#四、jQuery\" class=\"headerlink\" title=\"四、jQuery\"></a>四、jQuery</h2><h3 id=\"1-你觉得-jQuery-或-zepto-源码有哪些写的好的地方\"><a href=\"#1-你觉得-jQuery-或-zepto-源码有哪些写的好的地方\" class=\"headerlink\" title=\"1 你觉得 jQuery 或 zepto 源码有哪些写的好的地方\"></a>1 你觉得 jQuery 或 zepto 源码有哪些写的好的地方</h3><ul>\n<li>jquery 源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入 window 对象参数，可以使 window 对象作为局部变量使用，好处是当 jquery 中访问 window 对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问 window 对象。同样，传入 undefined 参数，可以缩短查找 undefined 时的作用域链</li>\n</ul>\n<p>(function( window, undefined ) {</p>\n<p>//用一个函数域包起来，就是所谓的沙箱</p>\n<p>//在这里边 var 定义的变量，属于这个函数域内的局部变量，避免污染全局</p>\n<p>//把当前沙箱需要的外部变量通过函数参数引入进来</p>\n<p>//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数</p>\n<p>window.jQuery = window.$ = jQuery;</p>\n<p>})( window );</p>\n<ul>\n<li>jquery 将一些原型属性和方法封装在了 jquery.prototype 中，为了缩短名称，又赋值给了 jquery.fn，这是很形象的写法</li>\n<li>有一些数组或对象的方法经常能使用到，jQuery 将其保存为局部变量以提高访问速度</li>\n<li>jquery 实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li>\n</ul>\n<h3 id=\"2-jQuery-的实现原理\"><a href=\"#2-jQuery-的实现原理\" class=\"headerlink\" title=\"2 jQuery 的实现原理\"></a>2 jQuery 的实现原理</h3><ul>\n<li><code>(function(window, undefined) &#123;&#125;)(window);</code></li>\n<li><code>jQuery</code>  利用  <code>JS</code>  函数作用域的特性，采用立即调用表达式包裹了自身，解决命名空间和变量污染问题</li>\n<li><code>window.jQuery = window.$ = jQuery;</code></li>\n<li>在闭包当中将 jQuery 和 $ 绑定到 window 上，从而将 jQuery 和 $ 暴露为全局变量</li>\n</ul>\n<h3 id=\"3-jQuery-fn-的-init-方法返回的-this-指的是什么对象\"><a href=\"#3-jQuery-fn-的-init-方法返回的-this-指的是什么对象\" class=\"headerlink\" title=\"3 jQuery.fn  的  init  方法返回的  this  指的是什么对象\"></a>3 <code>jQuery.fn</code>  的  <code>init</code>  方法返回的  <code>this</code>  指的是什么对象</h3><ul>\n<li>jQuery.fn 的 init 方法 返回的 this 就是 jQuery 对象</li>\n<li>用户使用 jQuery() 或 $() 即可初始化 jQuery 对象，不需要动态的去调用 init 方法</li>\n</ul>\n<h3 id=\"4-jQuery-extend-与-jQuery-fn-extend-的区别\"><a href=\"#4-jQuery-extend-与-jQuery-fn-extend-的区别\" class=\"headerlink\" title=\"4 jQuery.extend 与 jQuery.fn.extend 的区别\"></a>4 jQuery.extend 与 jQuery.fn.extend 的区别</h3><ul>\n<li><code>$.fn.extend()</code>  和  <code>$.extend()</code>  是  <code>jQuery</code>  为扩展插件提拱了两个方法</li>\n<li><code>$.extend(object)</code>; // 为 jQuery 添加“静态方法”（工具方法）</li>\n</ul>\n<p>$.extend({　　min: function(a, b) { return a &lt; b ? a : b; },　　max: function(a, b) { return a &gt; b ? a : b; }});$.min(2,3); //  2$.max(4,5); //  5</p>\n<ul>\n<li>$.extend([true,] targetObject, object1[, object2]); // 对 targt 对象进行扩展</li>\n</ul>\n<p>var settings = {validate:false, limit:5};var options = {validate:true, name:”bar”};$.extend(settings, options);  //  注意：不支持第一个参数传  false// settings == {validate:true, limit:5, name:”bar”}</p>\n<ul>\n<li><code>$.fn.extend(json)</code>; // 为 jQuery 添加“成员函数”（实例方法）</li>\n</ul>\n<p>$.fn.extend({<br>   alertValue: function() {<br>      $(this).click(function(){<br>        alert($(this).val());<br>      });<br>   }});$(“email”).alertValue();</p>\n<h3 id=\"5-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝\"><a href=\"#5-jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝\" class=\"headerlink\" title=\"5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝\"></a>5 jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝</h3><ul>\n<li>浅拷贝（只复制一份原始对象的引用） <code>var newObject = $.extend(&#123;&#125;, oldObject);</code></li>\n<li>深拷贝（对原始对象属性所引用的对象进行进行递归拷贝） <code>var newObject = $.extend(true, &#123;&#125;, oldObject);</code></li>\n</ul>\n<h3 id=\"6-jQuery-的队列是如何实现的\"><a href=\"#6-jQuery-的队列是如何实现的\" class=\"headerlink\" title=\"6 jQuery 的队列是如何实现的\"></a>6 jQuery 的队列是如何实现的</h3><ul>\n<li>jQuery 核心中有一组队列控制方法，由  <code>queue()/dequeue()/clearQueue()</code>  三个方法组成。</li>\n<li>主要应用于  <code>animate()</code>，<code>ajax</code>，其他要按时间顺序执行的事件中</li>\n</ul>\n<p>var func1 = function(){alert(‘事件 1’);}var func2 = function(){alert(‘事件 2’);}var func3 = function(){alert(‘事件 3’);}var func4 = function(){alert(‘事件 4’);}//  入栈队列事件$(‘box’).queue(“queue1”, func1);  // push func1 to queue1$(‘box’).queue(“queue1”, func2);  // push func2 to queue1//  替换队列事件$(‘box’).queue(“queue1”, []);  // delete queue1 with empty array$(‘box’).queue(“queue1”, [func3, func4]);  // replace queue1//  获取队列事件（返回一个函数数组）$(‘box’).queue(“queue1”);  // [func3(), func4()]// 出栈队列事件并执行$(‘box’).dequeue(“queue1”); // return func3 and do func3$(‘box’).dequeue(“queue1”); // return func4 and do func4// 清空整个队列$(‘box’).clearQueue(“queue1”); // delete queue1 with clearQueue</p>\n<h3 id=\"7-jQuery-中的-bind-live-delegate-on-的区别\"><a href=\"#7-jQuery-中的-bind-live-delegate-on-的区别\" class=\"headerlink\" title=\"7 jQuery 中的 bind(), live(), delegate(), on()的区别\"></a>7 jQuery 中的 bind(), live(), delegate(), on()的区别</h3><ul>\n<li><code>bind()</code>  直接绑定在目标元素上</li>\n<li><code>live()</code>  通过冒泡传播事件，默认<code>document</code>上，支持动态数据</li>\n<li><code>delegate()</code>  更精确的小范围使用事件代理，性能优于 live</li>\n<li><code>on()</code>  是最新的<code>1.9</code>版本整合了之前的三种方式的新事件绑定机制</li>\n</ul>\n<h3 id=\"8-是否知道自定义事件\"><a href=\"#8-是否知道自定义事件\" class=\"headerlink\" title=\"8 是否知道自定义事件\"></a>8 是否知道自定义事件</h3><ul>\n<li>事件即“发布/订阅”模式，自定义事件即“消息发布”，事件的监听即“订阅订阅”</li>\n<li>JS 原生支持自定义事件，示例：</li>\n</ul>\n<p>document.createEvent(type); //  创建事件<br>  event.initEvent(eventType, canBubble, prevent); //  初始化事件<br>  target.addEventListener(‘dataavailable’, handler, false); //  监听事件<br>  target.dispatchEvent(e);  //  触发事件</p>\n<ul>\n<li>jQuery 里的<code>fire</code>  函数用于调用<code>jQuery</code>自定义事件列表中的事件</li>\n</ul>\n<h3 id=\"9-jQuery-通过哪个方法和-Sizzle-选择器结合的\"><a href=\"#9-jQuery-通过哪个方法和-Sizzle-选择器结合的\" class=\"headerlink\" title=\"9 jQuery 通过哪个方法和 Sizzle 选择器结合的\"></a>9 jQuery 通过哪个方法和 Sizzle 选择器结合的</h3><ul>\n<li><code>Sizzle</code>  选择器采取  <code>Right To Left</code>  的匹配模式，先搜寻所有匹配标签，再判断它的父节点</li>\n<li><code>jQuery</code>  通过  <code>$(selecter).find(selecter);</code>  和  <code>Sizzle</code>  选择器结合</li>\n</ul>\n<h3 id=\"10-jQuery-中如何将数组转化为-JSON-字符串，然后再转化回来\"><a href=\"#10-jQuery-中如何将数组转化为-JSON-字符串，然后再转化回来\" class=\"headerlink\" title=\"10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来\"></a>10 jQuery 中如何将数组转化为 JSON 字符串，然后再转化回来</h3><p>//  通过原生  JSON.stringify/JSON.parse  扩展  jQuery  实现<br> $.array2json = function(array) {<br>    return JSON.stringify(array);<br> }</p>\n<p>$.json2array = function(array) {<br>    // $.parseJSON(array); // 3.0  开始，已过时<br>    return JSON.parse(array);<br> }</p>\n<p>//  调用<br> var json = $.array2json([‘a’, ‘b’, ‘c’]);<br> var array = $.json2array(json);</p>\n<h3 id=\"11-jQuery-一个对象可以同时绑定多个事件，这是如何实现的\"><a href=\"#11-jQuery-一个对象可以同时绑定多个事件，这是如何实现的\" class=\"headerlink\" title=\"11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的\"></a>11 jQuery 一个对象可以同时绑定多个事件，这是如何实现的</h3><p>$(“btn”).on(“mouseover mouseout”, func);</p>\n<p>$(“btn”).on({<br>      mouseover: func1,<br>      mouseout: func2,<br>      click: func3  });</p>\n<h3 id=\"12-针对-jQuery-的优化方法\"><a href=\"#12-针对-jQuery-的优化方法\" class=\"headerlink\" title=\"12 针对 jQuery 的优化方法\"></a>12 针对 jQuery 的优化方法</h3><ul>\n<li>缓存频繁操作<code>DOM</code>对象</li>\n<li>尽量使用<code>id</code>选择器代替<code>class</code>选择器</li>\n<li>总是从<code>id</code>选择器来继承</li>\n<li>尽量使用链式操作</li>\n<li>使用时间委托  <code>on</code>绑定事件</li>\n<li>采用<code>jQuery</code>的内部函数<code>data()</code>来存储数据</li>\n<li>使用最新版本的  <code>jQuery</code></li>\n</ul>\n<h3 id=\"13-jQuery-的-slideUp-动画，当鼠标快速连续触发-动画会滞后反复执行，该如何处理呢\"><a href=\"#13-jQuery-的-slideUp-动画，当鼠标快速连续触发-动画会滞后反复执行，该如何处理呢\" class=\"headerlink\" title=\"13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢\"></a>13 jQuery 的 slideUp 动画，当鼠标快速连续触发, 动画会滞后反复执行，该如何处理呢</h3><ul>\n<li>在触发元素上的事件设置为延迟处理：使用  <code>JS</code>  原生  <code>setTimeout</code>  方法</li>\n<li>在触发元素的事件时预先停止所有的动画，再执行相应的动画事件：<code>$(&#39;.tab&#39;).stop().slideUp();</code></li>\n</ul>\n<h3 id=\"14-jQuery-UI-如何自定义组件\"><a href=\"#14-jQuery-UI-如何自定义组件\" class=\"headerlink\" title=\"14 jQuery UI 如何自定义组件\"></a>14 jQuery UI 如何自定义组件</h3><ul>\n<li>通过向  <code>$.widget()</code>  传递组件名称和一个原型对象来完成</li>\n<li><code>$.widget(&quot;ns.widgetName&quot;, [baseWidget], widgetPrototype);</code></li>\n</ul>\n<h3 id=\"15-jQuery-与-jQuery-UI、jQuery-Mobile-区别\"><a href=\"#15-jQuery-与-jQuery-UI、jQuery-Mobile-区别\" class=\"headerlink\" title=\"15 jQuery 与 jQuery UI、jQuery Mobile 区别\"></a>15 jQuery 与 jQuery UI、jQuery Mobile 区别</h3><ul>\n<li><code>jQuery</code>  是  <code>JS</code>  库，兼容各种 PC 浏览器，主要用作更方便地处理  <code>DOM</code>、事件、动画、<code>AJAX</code></li>\n<li><code>jQuery UI</code>  是建立在  <code>jQuery</code>  库上的一组用户界面交互、特效、小部件及主题</li>\n<li><code>jQuery Mobile</code>  以  <code>jQuery</code>  为基础，用于创建“移动 Web 应用”的框架</li>\n</ul>\n<h3 id=\"16-jQuery-和-Zepto-的区别？-各自的使用场景\"><a href=\"#16-jQuery-和-Zepto-的区别？-各自的使用场景\" class=\"headerlink\" title=\"16 jQuery 和 Zepto 的区别？ 各自的使用场景\"></a>16 jQuery 和 Zepto 的区别？ 各自的使用场景</h3><ul>\n<li><code>jQuery</code>  主要目标是<code>PC</code>的网页中，兼容全部主流浏览器。在移动设备方面，单独推出 `jQuery Mobile</li>\n<li><code>Zepto</code>从一开始就定<code>位移动设备，相对更轻量级。它的</code>API <code>基本兼容</code>jQuery`，但对 PC 浏览器兼容不理想</li>\n</ul>\n<h3 id=\"17-jQuery-对象的特点\"><a href=\"#17-jQuery-对象的特点\" class=\"headerlink\" title=\"17 jQuery 对象的特点\"></a>17 jQuery 对象的特点</h3><ul>\n<li>只有  <code>JQuery</code>对象才能使用  <code>JQuery</code>  方法</li>\n<li><code>JQuery</code>  对象是一个数组对象</li>\n</ul>\n<h2 id=\"五、Bootstrap\"><a href=\"#五、Bootstrap\" class=\"headerlink\" title=\"五、Bootstrap\"></a>五、Bootstrap</h2><h3 id=\"1-什么是-Bootstrap？以及为什么要使用-Bootstrap？\"><a href=\"#1-什么是-Bootstrap？以及为什么要使用-Bootstrap？\" class=\"headerlink\" title=\"1 什么是 Bootstrap？以及为什么要使用 Bootstrap？\"></a>1 什么是 Bootstrap？以及为什么要使用 Bootstrap？</h3><blockquote>\n<p><code>Bootstrap</code>  是一个用于快速开发  <code>Web</code>应用程序和网站的前端框架。<code>Bootstrap</code>是基于  <code>HTML</code>、<code>CSS</code>、<code>JAVASCRIPT</code>  的</p>\n</blockquote>\n<ul>\n<li><code>Bootstrap</code>具有移动设备优先、浏览器支持良好、容易上手、响应式设计等优点，所以<code>Bootstrap</code>被广泛应用</li>\n</ul>\n<h3 id=\"2-使用-Bootstrap-时，要声明的文档类型是什么？以及为什么要这样声明？\"><a href=\"#2-使用-Bootstrap-时，要声明的文档类型是什么？以及为什么要这样声明？\" class=\"headerlink\" title=\"2 使用 Bootstrap 时，要声明的文档类型是什么？以及为什么要这样声明？\"></a>2 使用 Bootstrap 时，要声明的文档类型是什么？以及为什么要这样声明？</h3><ul>\n<li>使用<code>Bootstrap</code>时，需要使用  <code>HTML5</code>  文档类型（<code>Doctype</code>）。<code>&lt;!DOCTYPE html&gt;</code></li>\n<li>因为<code>Bootstrap</code>使用了一些  <code>HTML5</code>  元素和  <code>CSS</code>  属性，如果在  <code>Bootstrap</code>创建的网页开头不使用  <code>HTML5</code>  的文档类型（<code>Doctype</code>），可能会面临一些浏览器显示不一致的问题，甚至可能面临一些特定情境下的不一致，以致于代码不能通过  <code>W3C</code>  标准的验证</li>\n</ul>\n<h3 id=\"3-什么是-Bootstrap-网格系统\"><a href=\"#3-什么是-Bootstrap-网格系统\" class=\"headerlink\" title=\"3 什么是 Bootstrap 网格系统\"></a>3 什么是 Bootstrap 网格系统</h3><blockquote>\n<p><code>Bootstrap</code>  包含了一个响应式的、移动设备优先的、不固定的网格系统，可以随着设备或视口大小的增加而适当地扩展到  <code>12</code>  列。它包含了用于简单的布局选项的预定义类，也包含了用于生成更多语义布局的功能强大的混合类</p>\n</blockquote>\n<ul>\n<li>响应式网格系统随着屏幕或视口（<code>viewport</code>）尺寸的增加，系统会自动分为最多<code>12</code>列。</li>\n</ul>\n<h3 id=\"4-Bootstrap-网格系统（Grid-System）的工作原理\"><a href=\"#4-Bootstrap-网格系统（Grid-System）的工作原理\" class=\"headerlink\" title=\"4 Bootstrap 网格系统（Grid System）的工作原理\"></a>4 Bootstrap 网格系统（Grid System）的工作原理</h3><ul>\n<li>（1）行必须放置在  <code>.container class</code>  内，以便获得适当的对齐（<code>alignment</code>）和内边距（<code>padding</code>）。</li>\n<li>（2）使用行来创建列的水平组。</li>\n<li>（3）内容应该放置在列内，且唯有列可以是行的直接子元素。</li>\n<li>（4）预定义的网格类，比如  <code>.row</code>  和  <code>.col-xs-4</code>，可用于快速创建网格布局。<code>LESS</code>  混合类可用于更多语义布局。</li>\n<li>（5）列通过内边距（<code>padding</code>）来创建列内容之间的间隙。该内边距是通过  <code>.rows</code>  上的外边距（<code>margin</code>）取负，表示第一列和最后一列的行偏移。</li>\n<li>（6）网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个  <code>.col-xs-4</code></li>\n</ul>\n<h3 id=\"5-对于各类尺寸的设备，Bootstrap-设置的-class-前缀分别是什么\"><a href=\"#5-对于各类尺寸的设备，Bootstrap-设置的-class-前缀分别是什么\" class=\"headerlink\" title=\"5 对于各类尺寸的设备，Bootstrap 设置的 class 前缀分别是什么\"></a>5 对于各类尺寸的设备，Bootstrap 设置的 class 前缀分别是什么</h3><ul>\n<li>超小设备手机（<code>&lt;768px</code>）：<code>.col-xs-*</code></li>\n<li>小型设备平板电脑（<code>&gt;=768px</code>）：<code>.col-sm-*</code></li>\n<li>中型设备台式电脑（<code>&gt;=992px</code>）：<code>.col-md-*</code></li>\n<li>大型设备台式电脑（<code>&gt;=1200px</code>）：<code>.col-lg-*</code></li>\n</ul>\n<h3 id=\"6-Bootstrap-网格系统列与列之间的间隙宽度是多少\"><a href=\"#6-Bootstrap-网格系统列与列之间的间隙宽度是多少\" class=\"headerlink\" title=\"6 Bootstrap 网格系统列与列之间的间隙宽度是多少\"></a>6 Bootstrap 网格系统列与列之间的间隙宽度是多少</h3><blockquote>\n<p>间隙宽度为<code>30px</code>（一个列的每边分别是<code>15px</code>）</p>\n</blockquote>\n<h3 id=\"7-如果需要在一个标题的旁边创建副标题，可以怎样操作\"><a href=\"#7-如果需要在一个标题的旁边创建副标题，可以怎样操作\" class=\"headerlink\" title=\"7 如果需要在一个标题的旁边创建副标题，可以怎样操作\"></a>7 如果需要在一个标题的旁边创建副标题，可以怎样操作</h3><blockquote>\n<p>在元素两旁添加<code>&lt;small&gt;</code>，或者添加<code>.small</code>的<code>class</code></p>\n</blockquote>\n<h3 id=\"8-用-Bootstrap，如何设置文字的对齐方式？\"><a href=\"#8-用-Bootstrap，如何设置文字的对齐方式？\" class=\"headerlink\" title=\"8 用 Bootstrap，如何设置文字的对齐方式？\"></a>8 用 Bootstrap，如何设置文字的对齐方式？</h3><ul>\n<li><code>class=&quot;text-center&quot;</code>  设置居中文本</li>\n<li><code>class=&quot;text-right&quot;</code>  设置向右对齐文本</li>\n<li><code>class=&quot;text-left&quot;</code>  设置向左对齐文本</li>\n</ul>\n<h3 id=\"9-Bootstrap-如何设置响应式表格？\"><a href=\"#9-Bootstrap-如何设置响应式表格？\" class=\"headerlink\" title=\"9 Bootstrap 如何设置响应式表格？\"></a>9 Bootstrap 如何设置响应式表格？</h3><blockquote>\n<p>增加<code>class=&quot;table-responsive&quot;</code></p>\n</blockquote>\n<h3 id=\"10-使用-Bootstrap-创建垂直表单的基本步骤？\"><a href=\"#10-使用-Bootstrap-创建垂直表单的基本步骤？\" class=\"headerlink\" title=\"10 使用 Bootstrap 创建垂直表单的基本步骤？\"></a>10 使用 Bootstrap 创建垂直表单的基本步骤？</h3><ul>\n<li>（1）向父<code>&lt;form&gt;</code>元素添加<code>role=&quot;form&quot;</code>；</li>\n<li>（2）把标签和控件放在一个带有<code>class=&quot;form-group&quot;</code>的<code>&lt;div&gt;</code>中，这是获取最佳间距所必需的；</li>\n<li>（3）向所有的文本元素<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>添加<code>class=&quot;form-control&quot;</code></li>\n</ul>\n<h3 id=\"11-使用-Bootstrap-创建水平表单的基本步骤？\"><a href=\"#11-使用-Bootstrap-创建水平表单的基本步骤？\" class=\"headerlink\" title=\"11 使用 Bootstrap 创建水平表单的基本步骤？\"></a>11 使用 Bootstrap 创建水平表单的基本步骤？</h3><ul>\n<li>（1）向父<code>&lt;form&gt;</code>元素添加<code>class=&quot;form-horizontal&quot;</code>；</li>\n<li>（2）把标签和控件放在一个带有<code>class=&quot;form-group&quot;</code>的<code>&lt;div&gt;</code>中；</li>\n<li>（3）向标签添加<code>class=&quot;control-label&quot;</code>。</li>\n</ul>\n<h3 id=\"12-使用-Bootstrap-如何创建表单控件的帮助文本？\"><a href=\"#12-使用-Bootstrap-如何创建表单控件的帮助文本？\" class=\"headerlink\" title=\"12 使用 Bootstrap 如何创建表单控件的帮助文本？\"></a>12 使用 Bootstrap 如何创建表单控件的帮助文本？</h3><blockquote>\n<p>增加<code>class=&quot;help-block&quot;</code>的<code>span</code>标签或<code>p</code>标签。</p>\n</blockquote>\n<h3 id=\"13-使用-Bootstrap-激活或禁用按钮要如何操作？\"><a href=\"#13-使用-Bootstrap-激活或禁用按钮要如何操作？\" class=\"headerlink\" title=\"13 使用 Bootstrap 激活或禁用按钮要如何操作？\"></a>13 使用 Bootstrap 激活或禁用按钮要如何操作？</h3><ul>\n<li>激活按钮：给按钮增加<code>.active</code>的<code>class</code></li>\n<li>禁用按钮：给按钮增加<code>disabled=&quot;disabled&quot;</code>的属性</li>\n</ul>\n<h3 id=\"14-Bootstrap-有哪些关于的-class？\"><a href=\"#14-Bootstrap-有哪些关于的-class？\" class=\"headerlink\" title=\"14 Bootstrap 有哪些关于的 class？\"></a>14 Bootstrap 有哪些关于的 class？</h3><ul>\n<li>（1）<code>.img-rounded</code>  为图片添加圆角</li>\n<li>（2）<code>.img-circle</code>  将图片变为圆形</li>\n<li>（3）<code>.img-thumbnail</code>  缩略图功能</li>\n<li>（4）<code>.img-responsive</code>  图片响应式 (将很好地扩展到父元素)</li>\n</ul>\n<h3 id=\"15-Bootstrap-中有关元素浮动及清除浮动的-class？\"><a href=\"#15-Bootstrap-中有关元素浮动及清除浮动的-class？\" class=\"headerlink\" title=\"15 Bootstrap 中有关元素浮动及清除浮动的 class？\"></a>15 Bootstrap 中有关元素浮动及清除浮动的 class？</h3><ul>\n<li>（1）<code>class=&quot;pull-left&quot;</code>  元素浮动到左边</li>\n<li>（2）<code>class=&quot;pull-right&quot;</code>  元素浮动到右边</li>\n<li>（3）<code>class=&quot;clearfix&quot;</code>  清除浮动</li>\n</ul>\n<h3 id=\"16-除了屏幕阅读器外，其他设备上隐藏元素的-class？\"><a href=\"#16-除了屏幕阅读器外，其他设备上隐藏元素的-class？\" class=\"headerlink\" title=\"16 除了屏幕阅读器外，其他设备上隐藏元素的 class？\"></a>16 除了屏幕阅读器外，其他设备上隐藏元素的 class？</h3><blockquote>\n<p>`class=”sr-only”``</p>\n</blockquote>\n<h3 id=\"17-Bootstrap-如何制作下拉菜单？\"><a href=\"#17-Bootstrap-如何制作下拉菜单？\" class=\"headerlink\" title=\"17 Bootstrap 如何制作下拉菜单？\"></a>17 Bootstrap 如何制作下拉菜单？</h3><ul>\n<li>（1）将下拉菜单包裹在<code>class=&quot;dropdown&quot;</code>的<code>&lt;div&gt;</code>中；</li>\n<li>（2）在触发下拉菜单的按钮中添加：<code>class=&quot;btn dropdown-toggle&quot; id=&quot;dropdownMenu1&quot; data-toggle=&quot;dropdown&quot;</code></li>\n<li>（3）在包裹下拉菜单的 ul 中添加：<code>class=&quot;dropdown-menu&quot; role=&quot;menu&quot; aria-labelledby=&quot;dropdownMenu1&quot;</code></li>\n<li>（4）在下拉菜单的列表项中添加：<code>role=&quot;presentation&quot;</code>。其中，下拉菜单的标题要添加<code>class=&quot;dropdown-header&quot;</code>，选项部分要添加<code>tabindex=&quot;-1&quot;</code>。</li>\n</ul>\n<h3 id=\"18-Bootstrap-如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？\"><a href=\"#18-Bootstrap-如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？\" class=\"headerlink\" title=\"18 Bootstrap 如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？\"></a>18 Bootstrap 如何制作按钮组？以及水平按钮组和垂直按钮组的优先级？</h3><ul>\n<li>（1）用<code>class=&quot;btn-group&quot;</code>的<code>&lt;div&gt;</code>去包裹按钮组；<code>class=&quot;btn-group-vertical&quot;</code>可设置垂直按钮组。</li>\n<li>（2）<code>btn-group</code>的优先级高于<code>btn-group-vertical</code>的优先级。</li>\n</ul>\n<h3 id=\"19-Bootstrap-如何设置按钮的下拉菜单？\"><a href=\"#19-Bootstrap-如何设置按钮的下拉菜单？\" class=\"headerlink\" title=\"19 Bootstrap 如何设置按钮的下拉菜单？\"></a>19 Bootstrap 如何设置按钮的下拉菜单？</h3><blockquote>\n<p>在一个  <code>.btn-group</code>  中放置按钮和下拉菜单即可。</p>\n</blockquote>\n<h3 id=\"20-Bootstrap-中的输入框组如何制作？\"><a href=\"#20-Bootstrap-中的输入框组如何制作？\" class=\"headerlink\" title=\"20 Bootstrap 中的输入框组如何制作？\"></a>20 Bootstrap 中的输入框组如何制作？</h3><ul>\n<li>（1）把前缀或者后缀元素放在一个带有<code>class=&quot;input-group&quot;</code>中的<code>&lt;div&gt;</code>中</li>\n<li>（2）在该<code>&lt;div&gt;</code>内，在<code>class=&quot;input-group-addon&quot;</code>的<code>&lt;span&gt;</code>里面放置额外的内容；</li>\n<li>（3）把<code>&lt;span&gt;</code>放在<code>&lt;input&gt;</code>元素的前面或后面。</li>\n</ul>\n<h3 id=\"21-Bootstrap-中的导航都有哪些？\"><a href=\"#21-Bootstrap-中的导航都有哪些？\" class=\"headerlink\" title=\"21 Bootstrap 中的导航都有哪些？\"></a>21 Bootstrap 中的导航都有哪些？</h3><ul>\n<li>（1）导航元素：有<code>class=&quot;nav nav-tabs&quot;</code>的标签页导航，还有<code>class=&quot;nav nav-pills&quot;</code>的胶囊式标签页导航；</li>\n<li>（2）导航栏：<code>class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;</code>；</li>\n<li>（3）面包屑导航：<code>class=&quot;breadcrumb&quot;</code></li>\n</ul>\n<h3 id=\"22-Bootstrap-中设置分页的-class？\"><a href=\"#22-Bootstrap-中设置分页的-class？\" class=\"headerlink\" title=\"22 Bootstrap 中设置分页的 class？\"></a>22 Bootstrap 中设置分页的 class？</h3><ul>\n<li>默认的分页：<code>class=&quot;pagination&quot;</code></li>\n<li>默认的翻页：<code>class=&quot;pager&quot;</code></li>\n</ul>\n<h3 id=\"23-Bootstrap-中显示标签的-class？\"><a href=\"#23-Bootstrap-中显示标签的-class？\" class=\"headerlink\" title=\"23 Bootstrap 中显示标签的 class？\"></a>23 Bootstrap 中显示标签的 class？</h3><blockquote>\n<p><code>class=&quot;label&quot;</code></p>\n</blockquote>\n<h3 id=\"24-Bootstrap-中如何制作徽章？\"><a href=\"#24-Bootstrap-中如何制作徽章？\" class=\"headerlink\" title=\"24 Bootstrap 中如何制作徽章？\"></a>24 Bootstrap 中如何制作徽章？</h3><blockquote>\n<p><code>&lt;span class=&quot;badge&quot;&gt;26&lt;/span&gt;</code></p>\n</blockquote>\n<h3 id=\"25-Bootstrap-中超大屏幕的作用是什么？\"><a href=\"#25-Bootstrap-中超大屏幕的作用是什么？\" class=\"headerlink\" title=\"25 Bootstrap 中超大屏幕的作用是什么？\"></a>25 Bootstrap 中超大屏幕的作用是什么？</h3><blockquote>\n<p>设置<code>class=&quot;jumbotron&quot;</code>可以制作超大屏幕，该组件可以增加标题的大小并增加更多的外边距</p>\n</blockquote>\n<h2 id=\"六、微信小程序\"><a href=\"#六、微信小程序\" class=\"headerlink\" title=\"六、微信小程序\"></a>六、微信小程序</h2><h3 id=\"1-微信小程序有几个文件\"><a href=\"#1-微信小程序有几个文件\" class=\"headerlink\" title=\"1 微信小程序有几个文件\"></a>1 微信小程序有几个文件</h3><ul>\n<li><code>WXSS (WeiXin Style Sheets)</code>是一套样式语言，用于描述  <code>WXML</code>  的组件样式， <code>js</code>  逻辑处理，网络请求<code>json</code>小程序设置，如页面注册，页面标题及  <code>tabBar</code>。</li>\n<li><code>app.json</code>  必须要有这个文件，如果没有这个文件，项目无法运行，因为微信框架把这个作为配置文件入口，整个小程序的全局配置。包括页面注册，网络设置，以及小程序的<code>window</code>  背景色，配置导航条样式，配置默认标题。</li>\n<li><code>app.js</code>  必须要有这个文件，没有也是会报错！但是这个文件创建一下就行 什么都不需要写以后我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。</li>\n<li><code>app.wxss</code>  配置全局  <code>css</code></li>\n</ul>\n<h3 id=\"2-微信小程序怎样跟事件传值\"><a href=\"#2-微信小程序怎样跟事件传值\" class=\"headerlink\" title=\"2 微信小程序怎样跟事件传值\"></a>2 微信小程序怎样跟事件传值</h3><blockquote>\n<p>给  <code>HTML</code>  元素添加  <code>data-*</code>属性来传递我们需要的值，然后通过  <code>e.currentTarget.dataset</code>  或<code>onload</code>的<code>param</code>参数获取。但  <code>data -</code>  名称不能有大写字母和不可以存放对象</p>\n</blockquote>\n<h3 id=\"3-小程序的-wxss-和-css-有哪些不一样的地方？\"><a href=\"#3-小程序的-wxss-和-css-有哪些不一样的地方？\" class=\"headerlink\" title=\"3 小程序的 wxss 和 css 有哪些不一样的地方？\"></a>3 小程序的 wxss 和 css 有哪些不一样的地方？</h3><ul>\n<li><code>wxss</code>的图片引入需使用外链地址</li>\n<li>没有  <code>Body</code>；样式可直接使用  <code>import</code>  导入</li>\n</ul>\n<h3 id=\"4-小程序关联微信公众号如何确定用户的唯一性\"><a href=\"#4-小程序关联微信公众号如何确定用户的唯一性\" class=\"headerlink\" title=\"4 小程序关联微信公众号如何确定用户的唯一性\"></a>4 小程序关联微信公众号如何确定用户的唯一性</h3><blockquote>\n<p>使用  <code>wx.getUserInfo</code>  方法  <code>withCredentials</code>  为  <code>true</code>  时 可获取  <code>encryptedData</code>，里面有  <code>union_id</code>。后端需要进行对称解密</p>\n</blockquote>\n<h3 id=\"5-微信小程序与-vue-区别\"><a href=\"#5-微信小程序与-vue-区别\" class=\"headerlink\" title=\"5 微信小程序与 vue 区别\"></a>5 微信小程序与 vue 区别</h3><ul>\n<li>生命周期不一样，微信小程序生命周期比较简单</li>\n<li>数据绑定也不同，微信小程序数据绑定需要使用<code>&#123; &#123;&#125;&#125;</code>，<code>vue</code>  直接<code>:</code>就可以</li>\n<li>显示与隐藏元素，<code>vue</code>中，使用  <code>v-if</code>  和  <code>v-show</code>  控制元素的显示和隐藏，小程序中，使用<code>wx-if</code>  和<code>hidden</code>  控制元素的显示和隐藏</li>\n<li>事件处理不同，小程序中，全用  <code>bindtap(bind+event)</code>，或者  <code>catchtap(catch+event)</code>  绑定事件,<code>vue：</code>使用  <code>v-on:event</code>  绑定事件，或者使用<code>@event</code>  绑定事件</li>\n<li>数据双向绑定也不也不一样在  <code>vue</code>中,只需要再表单元素上加上  <code>v-model</code>,然后再绑定  <code>data</code>中对应的一个值，当表单元素内容发生变化时，<code>data</code>中对应的值也会相应改变，这是  <code>vue</code>非常 nice 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个  <code>data</code>中声明的变量。</li>\n</ul>\n<h2 id=\"七、webpack-相关\"><a href=\"#七、webpack-相关\" class=\"headerlink\" title=\"七、webpack 相关\"></a>七、webpack 相关</h2><h3 id=\"1-打包体积-优化思路\"><a href=\"#1-打包体积-优化思路\" class=\"headerlink\" title=\"1 打包体积 优化思路\"></a>1 打包体积 优化思路</h3><ul>\n<li>提取第三方库或通过引用外部文件的方式引入第三方库</li>\n<li>代码压缩插件<code>UglifyJsPlugin</code></li>\n<li>服务器启用 gzip 压缩</li>\n<li>按需加载资源文件  <code>require.ensure</code></li>\n<li>优化<code>devtool</code>中的<code>source-map</code></li>\n<li>剥离<code>css</code>文件，单独打包</li>\n<li>去除不必要插件，通常就是开发环境与生产环境用同一套配置文件导致</li>\n</ul>\n<h3 id=\"2-打包效率\"><a href=\"#2-打包效率\" class=\"headerlink\" title=\"2 打包效率\"></a>2 打包效率</h3><ul>\n<li>开发环境采用增量构建，启用热更新</li>\n<li>开发环境不做无意义的工作如提取<code>css</code>计算文件 hash 等</li>\n<li>配置<code>devtool</code></li>\n<li>选择合适的<code>loader</code></li>\n<li>个别<code>loader</code>开启<code>cache</code>  如<code>babel-loader</code></li>\n<li>第三方库采用引入方式</li>\n<li>提取公共代码</li>\n<li>优化构建时的搜索路径 指明需要构建目录及不需要构建目录</li>\n<li>模块化引入需要的部分</li>\n</ul>\n<h3 id=\"3-Loader\"><a href=\"#3-Loader\" class=\"headerlink\" title=\"3 Loader\"></a>3 Loader</h3><p>编写一个 loader</p>\n<blockquote>\n<p><code>loader</code>就是一个<code>node</code>模块，它输出了一个函数。当某种资源需要用这个<code>loader</code>转换时，这个函数会被调用。并且，这个函数可以通过提供给它的<code>this</code>上下文访问<code>Loader API</code>。 <code>reverse-txt-loader</code></p>\n</blockquote>\n<p>//  定义 module.exports = function(src) {<br>  //src 是原文件内容（abcde），下面对内容进行处理，这里是反转<br>  var result = src.split(‘’).reverse().join(‘’);<br>  //返回 JavaScript 源码，必须是 String 或者 Buffer<br>  return `module.exports = ‘${result}’`;}//使用{<br>    test: /\\.txt$/,<br>use: [<br>{<br>‘./path/reverse-txt-loader’<br>}<br>]},</p>\n<h3 id=\"4-说一下-webpack-的一些-plugin，怎么使用-webpack-对项目进行优化\"><a href=\"#4-说一下-webpack-的一些-plugin，怎么使用-webpack-对项目进行优化\" class=\"headerlink\" title=\"4 说一下 webpack 的一些 plugin，怎么使用 webpack 对项目进行优化\"></a>4 说一下 webpack 的一些 plugin，怎么使用 webpack 对项目进行优化</h3><p>构建优化</p>\n<ul>\n<li>减少编译体积  <code>ContextReplacementPugin</code>、<code>IgnorePlugin</code>、<code>babel-plugin-import</code>、<code>babel-plugin-transform-runtime</code></li>\n<li>并行编译  <code>happypack</code>、<code>thread-loader</code>、<code>uglifyjsWebpackPlugin</code>开启并行</li>\n<li>缓存  <code>cache-loader</code>、<code>hard-source-webpack-plugin</code>、<code>uglifyjsWebpackPlugin</code>开启缓存、<code>babel-loader</code>开启缓存</li>\n<li>预编译  <code>dllWebpackPlugin &amp;&amp; DllReferencePlugin</code>、<code>auto-dll-webapck-plugin</code></li>\n</ul>\n<p>性能优化</p>\n<ul>\n<li>减少编译体积  <code>Tree-shaking</code>、<code>Scope Hositing</code></li>\n<li><code>hash</code>缓存  <code>webpack-md5-plugin</code></li>\n<li>拆包  <code>splitChunksPlugin</code>、<code>import()</code>、<code>require.ensure</code></li>\n</ul>\n"},{"title":"2019最新前端知识梳理(CSS部分)-面试宝典","url":"160.html","id":"160","date":"2019-06-22T09:21:07.000Z","_content":"\n## 二、CSS 部分\n\n### 1 css sprite 是什么,有什么优缺点\n\n- 概念：将多个小图片拼接到一个图片中。通过`background-position`和元素尺寸调节需要显示的背景图案。\n- 优点：\n  - 减少`HTTP`请求数，极大地提高页面加载速度\n  - 增加图片信息重复度，提高压缩比，减少图片大小\n  - 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现\n- 缺点：\n  - 图片合并麻烦\n  - 维护麻烦，修改一个图片可能需要从新布局整个图片，样式\n\n### 2 `display: none;`与`visibility: hidden;`的区别\n\n- 联系：它们都能让元素不可见\n- 区别：\n  - `display:none`;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；`visibility: hidden`;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见\n  - `display: none`;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示`；visibility: hidden;`是继承属性，子孙节点消失由于继承了`hidden`，通过设置`visibility: visible;`可以让子孙节点显式\n  - 修改常规流中元素的`display`通常会造成文档重排。修改`visibility`属性只会造成本元素的重绘。\n  - 读屏器不会读取`display: none`;元素内容；会读取`visibility: hidden;`元素内容\n\n### 3 `link`与`@import`的区别\n\n1.  `link`是`HTML`方式， `@import`是 CSS 方式\n2.  `link`最大限度支持并行下载，`@import`过多嵌套导致串行下载，出现`FOUC`(文档样式短暂失效)\n3.  `link`可以通过`rel=\"alternate stylesheet\"`指定候选样式\n4.  浏览器对`link`支持早于`@import`，可以使用`@import`对老浏览器隐藏样式\n5.  `@import`必须在样式规则之前，可以在 css 文件中引用其他文件\n6.  总体来说：`link`优于`@import`\n\n### 4 什么是 FOUC?如何避免\n\n- `Flash Of Unstyled Content`：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。\n- 解决方法：把样式表放到文档的`<head>`\n\n### 5 如何创建块级格式化上下文(block formatting context),BFC 有什么用\n\n- 创建规则：\n  - 根元素\n  - 浮动元素（`float`不取值为`none`）\n  - 绝对定位元素（`position`取值为`absolute`或`fixed`）\n  - `display`取值为`inline-block`、`table-cell`、`table-caption`、`flex`、`inline-flex`之一的元素\n  - `overflow`不取值为`visible`的元素\n- 作用：\n  - 可以包含浮动元素\n  - 不被浮动元素覆盖\n  - 阻止父子元素的`margin`折叠\n\n### 6 display、float、position 的关系\n\n- 如果`display`取值为`none`，那么`position`和`float`都不起作用，这种情况下元素不产生框\n- 否则，如果`position`取值为`absolute`或者`fixed`，框就是绝对定位的，`float`的计算值为`none`，`display`根据下面的表格进行调整。\n- 否则，如果`float`不是`none`，框是浮动的，`display`根据下表进行调整\n- 否则，如果元素是根元素，`display`根据下表进行调整\n- 其他情况下`display`的值为指定值\n- 总结起来：绝对定位、浮动、根元素都需要调整`display`\n\n### 7 清除浮动的几种方式，各自的优缺点\n\n- 父级`div`定义`height`\n- 结尾处加空`div`标签`clear:both`\n- 父级`div`定义伪类`:after`和`zoom`\n- 父级`div`定义`overflow:hidden`\n- 父级`div`也浮动，需要定义宽度\n- 结尾处加`br`标签`clear:both`\n- 比较好的是第 3 种方式，好多网站都这么用\n\n### 8 为什么要初始化 CSS 样式?\n\n- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对`CSS`初始化往往会出现浏览器之间的页面显示差异。\n- 当然，初始化样式会对`SEO`有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化\n\n### 9 css3 有哪些新特性\n\n- 新增各种`css`选择器\n- 圆角  `border-radius`\n- 多列布局\n- 阴影和反射\n- 文字特效`text-shadow`\n- 线性渐变\n- 旋转`transform`\n\nCSS3 新增伪类有那些？\n\n- `p:first-of-type`  选择属于其父元素的首个`<p>`元素的每个`<p>`  元素。\n- `p:last-of-type`  选择属于其父元素的最后  `<p>`  元素的每个`<p>`  元素。\n- `p:only-of-type`  选择属于其父元素唯一的  `<p>`元素的每个  `<p>`  元素。\n- `p:only-child`  选择属于其父元素的唯一子元素的每个  `<p>`  元素。\n- `p:nth-child(2)`  选择属于其父元素的第二个子元素的每个  `<p>`  元素。\n- `:after`  在元素之前添加内容,也可以用来做清除浮动。\n- `:before`  在元素之后添加内容。\n- `:enabled`  已启用的表单元素。\n- `:disabled`  已禁用的表单元素。\n- `:checked`  单选框或复选框被选中。\n\n### 10 display 有哪些值？说明他们的作用\n\n- `block`  转换成块状元素。\n- `inline`  转换成行内元素。\n- `none`  设置元素不可见。\n- `inline-block`  象行内元素一样显示，但其内容象块类型元素一样显示。\n- `list-item`  象块类型元素一样显示，并添加样式列表标记。\n- `table`  此元素会作为块级表格来显示\n- `inherit`  规定应该从父元素继承  `display`  属性的值\n\n### 11 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？\n\n- 有两种， `IE`盒子模型、`W3C`盒子模型；\n- 盒模型： 内容(content)、填充(`padding`)、边界(`margin`)、 边框(`border`)；\n- 区 别： `IE`的 c`ontent`部分把  `border`  和  `padding`计算了进去;\n\n### 12 CSS 优先级算法如何计算？\n\n- 优先级就近原则，同权重情况下样式定义最近者为准\n- 载入样式以最后载入的定位为准\n- 优先级为: `!important > id > class > tag`; `!important`  比 内联优先级高\n\n### 13 对 BFC 规范的理解？\n\n- 它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用\n\n### 14 谈谈浮动和清除浮动\n\n- 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上\n\n### 15 position 的值， relative 和 absolute 定位原点是\n\n- `absolute`：生成绝对定位的元素，相对于  `static`  定位以外的第一个父元素进行定位\n- `fixed`：生成绝对定位的元素，相对于浏览器窗口进行定位\n- `relative`：生成相对定位的元素，相对于其正常位置进行定位\n- `static`  默认值。没有定位，元素出现在正常的流中\n- `inherit`  规定从父元素继承  `position`  属性的值\n\n### 16 display:inline-block 什么时候不会显示间隙？(携程)\n\n- 移除空格\n- 使用`margin`负值\n- 使用`font-size:0`\n- `letter-spacing`\n- `word-spacing`\n\n### 17 PNG\\\\GIF\\\\JPG 的区别及如何选\n\n- `GIF`\n  - `8`位像素，`256`色\n  - 无损压缩\n  - 支持简单动画\n  - 支持`boolean`透明\n  - 适合简单动画\n- `JPEG`\n  - 颜色限于`256`\n  - 有损压缩\n  - 可控制压缩质量\n  - 不支持透明\n  - 适合照片\n- `PNG`\n  - 有`PNG8`和`truecolor PNG`\n  - `PNG8`类似`GIF`颜色上限为`256`，文件小，支持`alpha`透明度，无动画\n  - 适合图标、背景、按钮\n\n### 18 行内元素 float:left 后是否变为块级元素？\n\n> 行内元素设置成浮动之后变得更加像是`inline-block`（行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是`100%`），这时候给行内元素设置`padding-top`和`padding-bottom`或者`width`、`height`都是有效果的\n\n### 19 在网页中的应该使用奇数还是偶数的字体？为什么呢？\n\n- 偶数字号相对更容易和 web 设计的其他部分构成比例关系\n\n### 20 ::before 和 :after 中双冒号和单冒号 有什么区别？解释一下这 2 个伪元素的作用\n\n- 单冒号(`:`)用于`CSS3`伪类，双冒号(`::`)用于`CSS3`伪元素\n- 用于区分伪类和伪元素\n\n### 21 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）\n\n- 多数显示器默认频率是`60Hz`，即`1`秒刷新`60`次，所以理论上最小间隔为`1/60*1000ms ＝ 16.7ms`\n\n### 22 CSS 合并方法\n\n- 避免使用`@import`引入多个`css`文件，可以使用`CSS`工具将`CSS`合并为一个`CSS`文件，例如使用`Sass\\Compass`等\n\n### 23 CSS 不同选择器的权重(CSS 层叠的规则)\n\n- `！important`规则最重要，大于其它规则\n- 行内样式规则，加`1000`\n- 对于选择器中给定的各个`ID`属性值，加`100`\n- 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加`10`\n- 对于选择其中给定的各个元素标签选择器，加 1\n- 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则\n\n### 24 列出你所知道可以改变页面布局的属性\n\n- `position`、`display`、`float`、`width`、`height`、`margin`、`padding`、`top`、`left`、`right`、`\n\n### 25 CSS 在性能优化方面的实践\n\n- `css`压缩与合并、`Gzip`压缩\n- `css`文件放在`head`里、不要用`@import`\n- 尽量用缩写、避免用滤镜、合理使用选择器\n\n### 26 CSS3 动画（简单动画的实现，如旋转等）\n\n- 依靠`CSS3`中提出的三个属性：`transition`、`transform`、`animation`\n- `transition`：定义了元素在变化过程中是怎么样的，包含`transition-property`、`transition-duration`、`transition-timing-function`、`transition-delay`。\n- `transform`：定义元素的变化结果，包含`rotate`、`scale`、`skew`、`translate`。\n- `animation`：动画定义了动作的每一帧（`@keyframes`）有什么效果，包括`animation-name`，`animation-duration`、`animation-timing-function`、`animation-delay`、`animation-iteration-count`、`animation-direction`\n\n### 27 base64 的原理及优缺点\n\n- 优点可以加密，减少了`HTTTP`请求\n- 缺点是需要消耗`CPU`进行编解码\n\n### 28 几种常见的 CSS 布局\n\n#### 流体布局\n\n    .left {\n    \tfloat: left;\n    \twidth: 100px;\n    \theight: 200px;\n    \tbackground: red;\n    }\n    .right {\n    \tfloat: right;\n    \twidth: 200px;\n    \theight: 200px;\n    \tbackground: blue;\n    }\n    .main {\n    \tmargin-left: 120px;\n    \tmargin-right: 220px;\n    \theight: 200px;\n    \tbackground: green;\n    }\n\n<div class=\"container\">\n    <div class=\"left\"></div>\n    <div class=\"right\"></div>\n    <div class=\"main\"></div></div>\n\n#### 圣杯布局\n\n.container {\n    margin-left: 120px;\n    margin-right: 220px;}.main {\n    float: left;\n    width: 100%;\n    height:300px;\n    background: green;}.left {\n    position: relative;\n    left: -120px;\n    float: left;\n    height: 300px;\n    width: 100px;\n    margin-left: -100%;\n    background: red;}.right {\n    position: relative;\n    right: -220px;\n    float: right;\n    height: 300px;\n    width: 200px;\n    margin-left: -200px;\n    background: blue;}\n\n<div class=\"container\">\n\t<div class=\"main\"></div>\n\t<div class=\"left\"></div>\n\t<div class=\"right\"></div></div>\n\n#### 双飞翼布局\n\n.content {\n    float: left;\n    width: 100%;}.main {\n    height: 200px;\n    margin-left: 110px;\n    margin-right: 220px;\n    background: green;}.main::after {\n    content: '';\n    display: block;\n    font-size:0;\n    height: 0;\n    zoom: 1;\n    clear: both;}.left {\n    float:left;\n    height: 200px;\n    width: 100px;\n    margin-left: -100%;\n    background: red;}.right {\n    float: right;\n    height: 200px;\n    width: 200px;\n    margin-left: -200px;\n    background: blue;}\n\n<div class=\"content\">\n    <div class=\"main\"></div></div><div class=\"left\"></div><div class=\"right\"></div>\n\n### 29 stylus/sass/less 区别\n\n- 均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性\n- `Scss`和`LESS`语法较为严谨，`LESS`要求一定要使用大括号“{}”，`Scss`和`Stylus`可以通过缩进表示层次与嵌套关系\n- `Scss`无全局变量的概念，`LESS`和`Stylus`有类似于其它语言的作用域概念\n- `Sass`是基于`Ruby`语言的，而`LESS`和`Stylus`可以基于`NodeJS` `NPM`下载相应库后进行编译；\n\n### 30 postcss 的作用\n\n- 可以直观的理解为：它就是一个平台。为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大\n- `PostCSS`  提供了一个解析器，它能够将  `CSS`  解析成抽象语法树\n- 通过在  `PostCSS`  这个平台上，我们能够开发一些插件，来处理我们的`CSS`，比如热门的：`autoprefixer`\n- `postcss`可以对 sass 处理过后的`css`再处理 最常见的就是`autoprefixer`\n\n### 31 css 样式（选择器）的优先级\n\n- 计算权重确定\n- `!important`\n- 内联样式\n- 后写的优先级高\n\n### 32 自定义字体的使用场景\n\n- 宣传/品牌/`banner`等固定文案\n- 字体图标\n\n### 33 如何美化 CheckBox\n\n- `<label>`  属性  `for`  和  `id`\n- 隐藏原生的  `<input>`\n- `:checked + <label>`\n\n### 34 伪类和伪元素的区别\n\n- 伪类表状态\n- 伪元素是真的有元素\n- 前者单冒号，后者双冒号\n\n### 35 `base64`的使用\n\n- 用于减少  `HTTP`  请求\n- 适用于小图片\n- `base64`的体积约为原图的`4/3`\n\n### 36 自适应布局\n\n思路：\n\n- 左侧浮动或者绝对定位，然后右侧`margin`撑开\n- 使用`<div>`包含，然后靠负`margin`形成`bfc`\n- 使用`flex`\n\n### 37 请用 CSS 写一个简单的幻灯片效果页面\n\n> 知道是要用`CSS3`。使用`animation`动画实现一个简单的幻灯片效果\n\n/\\*\\*css\\*\\*/.ani{\n  width:480px;\n  height:320px;\n  margin:50px auto;\n  overflow: hidden;\n  box-shadow:0 0 5px rgba(0,0,0,1);\n  background-size: cover;\n  background-position: center;\n  -webkit-animation-name: \"loops\";\n  -webkit-animation-duration: 20s;\n  -webkit-animation-iteration-count: infinite;}@-webkit-keyframes \"loops\" {\n    0% {\n        background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg) no-repeat;             \n    }\n    25% {\n        background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat;\n    }\n    50% {\n        background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg) no-repeat;\n    }\n    75% {\n        background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg) no-repeat;\n    }\n    100% {\n        background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg) no-repeat;\n    }}\n\n### 38 什么是外边距重叠？重叠的结果是什么？\n\n> 外边距重叠就是 margin-collapse\n\n- 在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。\n\n折叠结果遵循下列计算规则：\n\n- 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。\n- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。\n- 两个外边距一正一负时，折叠结果是两者的相加的和。\n\n### 39 rgba()和 opacity 的透明效果有什么不同？\n\n- `rgba()`和`opacity`都能实现透明效果，但最大的不同是`opacity`作用于元素，以及元素内的所有内容的透明度，\n- 而`rgba()`只作用于元素的颜色或其背景色。（设置`rgba`透明的元素的子元素不会继承透明效果！）\n\n### 40 css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？\n\n- 垂直方向：`line-height`\n- 水平方向：`letter-spacing`\n\n### 41 如何垂直居中一个浮动元素？\n\n/**方法一：已知元素的高宽**/#div1{\n  background-color:#6699FF;\n  width:200px;\n  height:200px;\n  position: absolute;        //父元素需要相对定位   top: 50%;\n  left: 50%;\n  margin-top:-100px ;   //二分之一的 height，width  margin-left: -100px;}/**方法二:**/#div1{\n  width: 200px;\n  height: 200px;\n  background-color: #6699FF;\n  margin:auto;\n  position: absolute;        //父元素需要相对定位   left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;}\n\n如何垂直居中一个`<img>`?（用更简便的方法。）\n\n#container     /**<img>的容器设置如下**/{\n    display:table-cell;\n    text-align:center;\n    vertical-align:middle;}\n\n### 42 px 和 em 的区别\n\n- `px`和`em`都是长度单位，区别是，`px`的值是固定的，指定是多少就是多少，计算比较容易。`em`得值不是固定的，并且`em`会继承父级元素的字体大小。\n- 浏览器的默认字体高都是`16px`。所以未经调整的浏览器都符合: `1em=16px`。那么`12px=0.75em`, `10px=0.625em`。\n\n### 43 Sass、LESS 是什么？大家为什么要使用他们？\n\n- 他们是`CSS`预处理器。他是`CSS`上的一种抽象层。他们是一种特殊的语法/语言编译成`CSS`。\n- 例如 Less 是一种动态样式语言. 将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. `LESS`  既可以在客户端上运行 (支持`IE 6+`, `Webkit`, `Firefox`)，也可一在服务端运行 (借助  `Node.js`)\n\n为什么要使用它们？\n\n- 结构清晰，便于扩展。\n- 可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对\\- 浏览器语法差异的重复处理，减少无意义的机械劳动。\n- 可以轻松实现多重继承。\n- 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只- 是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译\n\n### 44 知道 css 有个 content 属性吗？有什么作用？有什么应用？\n\n> css 的`content`属性专门应用在  `before/after`伪元素上，用于来插入生成内容。最常见的应用是利用伪类清除浮动。\n\n/**一种常见利用伪类清除浮动的代码**/.clearfix:after {\n    content:\".\";       //这里利用到了 content 属性     display:block;\n    height:0;\n    visibility:hidden;\n    clear:both; \n }.clearfix {\n    \\*zoom:1;}\n\n### 45 水平居中的方法\n\n- 元素为行内元素，设置父元素`text-align:center`\n- 如果元素宽度固定，可以设置左右`margin`为`auto`;\n- 如果元素为绝对定位，设置父元素`position`为`relative`，元素设`left:0;right:0;margin:auto;`\n- 使用`flex-box`布局，指定`justify-content`属性为 center\n- `display`设置为`tabel-ceil`\n\n### 46 垂直居中的方法\n\n- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`\n- 使用`flex`布局，设置为`align-item：center`\n- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`\n- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值\n- 文本垂直居中设置`line-height`为`height`值\n\n### 47 如何使用 CSS 实现硬件加速？\n\n> 硬件加速是指通过创建独立的复合图层，让 GPU 来渲染这个图层，从而提高性能，\n\n- 一般触发硬件加速的`CSS`属性有`transform`、`opacity`、`filter`，为了避免 2D 动画在 开始和结束的时候的`repaint`操作，一般使用`tranform:translateZ(0)`\n\n### 48 重绘和回流（重排）是什么，如何避免？\n\n- DOM 的变化影响到了元素的几何属性（宽高）,浏览器重新计算元素的几何属性，其他元素的几何\n- 属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排，浏览器将受到影响的部分\n- 重新绘制到屏幕上的过程称为重绘。引起重排的原因有\n  - 添加或者删除可见的 DOM 元素，\n  - 元素位置、尺寸、内容改变，\n  - 浏览器页面初始化，\n  - 浏览器窗口尺寸改变，重排一定重绘，重绘不一定重排，\n\n减少重绘和重排的方法：\n\n- 不在布局信息改变时做`DOM`查询\n- 使用`cssText`或者`className`一次性改变属性\n- 使用`fragment`\n- 对于多次重排的元素，如动画，使用绝对定位脱离文档流，让他的改变不影响到其他元素\n\n### 49 说一说 css3 的 animation\n\n- css3 的`animation`是 css3 新增的动画属性，这个 css3 动画的每一帧是通过`@keyframes`来声明的，`keyframes`声明了动画的名称，通过`from`、`to`或者是百分比来定义\n- 每一帧动画元素的状态，通过`animation-name`来引用这个动画，同时 css3 动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式，\n- 这些相关的动画子属性有：`animation-name`定义动画名、`animation-duration`定义动画播放的时长、`animation-delay`定义动画延迟播放的时间、`animation-direction`定义 动画的播放方向、`animation-iteration-count`定义播放次数、`animation-fill-mode`定义动画播放之后的状态、`animation-play-state`定义播放状态，如暂停运行等、`animation-timing-function`\n- 定义播放的方式，如恒速播放、艰涩播放等。\n\n### 50 左边宽度固定，右边自适应\n\n> 左侧固定宽度，右侧自适应宽度的两列布局实现\n\nhtml 结构\n\n<div class=\"outer\">\n    <div class=\"left\">固定宽度</div>\n    <div class=\"right\">自适应宽度</div></div>\n\n> 在外层`div`（类名为`outer`）的`div`中，有两个子`div`，类名分别为`left`和`right`，其中`left`为固定宽度，而`right`为自适应宽度\n\n方法 1：左侧 div 设置成浮动：float: left，右侧 div 宽度会自拉升适应\n\n.outer {\n    width: 100%;\n    height: 500px;\n    background-color: yellow;}.left {\n    width: 200px;\n    height: 200px;\n    background-color: red;\n    float: left;}.right {\n    height: 200px;\n    background-color: blue;}\n\n方法 2：对右侧:div 进行绝对定位，然后再设置 right=0，即可以实现宽度自适应\n\n> 绝对定位元素的第一个高级特性就是其具有自动伸缩的功能，当我们将  `width`设置为  `auto`  的时候（或者不设置，默认为  `auto` ），绝对定位元素会根据其  `left`  和  `right`  自动伸缩其大小\n\n.outer {\n    width: 100%;\n    height: 500px;\n    background-color: yellow;\n    position: relative;}.left {\n    width: 200px;\n    height: 200px;\n    background-color: red;}.right {\n    height: 200px;\n    background-color: blue;\n    position: absolute;\n    left: 200px;\n    top:0;          \n    right: 0;}\n\n方法 3：将左侧 div 进行绝对定位，然后右侧 div 设置 margin-left: 200px\n\n.outer {\n    width: 100%;\n    height: 500px;\n    background-color: yellow;\n    position: relative;}.left {\n    width: 200px;\n    height: 200px;\n    background-color: red;\n    position: absolute;}.right {\n    height: 200px;\n    background-color: blue;\n    margin-left: 200px;}\n\n方法 4：使用 flex 布局\n\n.outer {\n    width: 100%;\n    height: 500px;\n    background-color: yellow;\n    display: flex;\n    flex-direction: row;}.left {\n    width: 200px;\n    height: 200px;\n    background-color: red;}.right {\n    height: 200px;\n    background-color: blue;\n    flex: 1;}\n\n### [#](http://blog.poetries.top/FE-Interview-Questions/base/#_51-%E4%B8%A4%E7%A7%8D%E4%BB%A5%E4%B8%8A%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%B7%B2%E7%9F%A5%E6%88%96%E8%80%85%E6%9C%AA%E7%9F%A5%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD)51 两种以上方式实现已知或者未知宽度的垂直水平居中\n\n/** 1 **/.wraper {\n  position: relative;\n  .box {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 100px;\n    height: 100px;\n    margin: -50px 0 0 -50px;\n  }}/** 2 **/.wraper {\n  position: relative;\n  .box {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n  }}/** 3 **/.wraper {\n  .box {\n    display: flex;\n    justify-content:center;\n    align-items: center;\n    height: 100px;\n  }}/** 4 **/.wraper {\n  display: table;\n  .box {\n    display: table-cell;\n    vertical-align: middle;\n  }}\n\n### 52 如何实现小于 12px 的字体效果\n\n> `transform:scale()`这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个`display:inline-block`;\n\ntransform: scale(0.7);\n\n`css`的属性，可以缩放大小\n","source":"_posts/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86css-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8.md","raw":"---\ntitle: 2019最新前端知识梳理(CSS部分)-面试宝典\ntags:\n  - CSS\n  - 面试题\nurl: 160.html\nid: 160\ncategories:\n  - 大前端\n  - 面试题类\ndate: 2019-06-22 17:21:07\n---\n\n## 二、CSS 部分\n\n### 1 css sprite 是什么,有什么优缺点\n\n- 概念：将多个小图片拼接到一个图片中。通过`background-position`和元素尺寸调节需要显示的背景图案。\n- 优点：\n  - 减少`HTTP`请求数，极大地提高页面加载速度\n  - 增加图片信息重复度，提高压缩比，减少图片大小\n  - 更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现\n- 缺点：\n  - 图片合并麻烦\n  - 维护麻烦，修改一个图片可能需要从新布局整个图片，样式\n\n### 2 `display: none;`与`visibility: hidden;`的区别\n\n- 联系：它们都能让元素不可见\n- 区别：\n  - `display:none`;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；`visibility: hidden`;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见\n  - `display: none`;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示`；visibility: hidden;`是继承属性，子孙节点消失由于继承了`hidden`，通过设置`visibility: visible;`可以让子孙节点显式\n  - 修改常规流中元素的`display`通常会造成文档重排。修改`visibility`属性只会造成本元素的重绘。\n  - 读屏器不会读取`display: none`;元素内容；会读取`visibility: hidden;`元素内容\n\n### 3 `link`与`@import`的区别\n\n1.  `link`是`HTML`方式， `@import`是 CSS 方式\n2.  `link`最大限度支持并行下载，`@import`过多嵌套导致串行下载，出现`FOUC`(文档样式短暂失效)\n3.  `link`可以通过`rel=\"alternate stylesheet\"`指定候选样式\n4.  浏览器对`link`支持早于`@import`，可以使用`@import`对老浏览器隐藏样式\n5.  `@import`必须在样式规则之前，可以在 css 文件中引用其他文件\n6.  总体来说：`link`优于`@import`\n\n### 4 什么是 FOUC?如何避免\n\n- `Flash Of Unstyled Content`：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。\n- 解决方法：把样式表放到文档的`<head>`\n\n### 5 如何创建块级格式化上下文(block formatting context),BFC 有什么用\n\n- 创建规则：\n  - 根元素\n  - 浮动元素（`float`不取值为`none`）\n  - 绝对定位元素（`position`取值为`absolute`或`fixed`）\n  - `display`取值为`inline-block`、`table-cell`、`table-caption`、`flex`、`inline-flex`之一的元素\n  - `overflow`不取值为`visible`的元素\n- 作用：\n  - 可以包含浮动元素\n  - 不被浮动元素覆盖\n  - 阻止父子元素的`margin`折叠\n\n### 6 display、float、position 的关系\n\n- 如果`display`取值为`none`，那么`position`和`float`都不起作用，这种情况下元素不产生框\n- 否则，如果`position`取值为`absolute`或者`fixed`，框就是绝对定位的，`float`的计算值为`none`，`display`根据下面的表格进行调整。\n- 否则，如果`float`不是`none`，框是浮动的，`display`根据下表进行调整\n- 否则，如果元素是根元素，`display`根据下表进行调整\n- 其他情况下`display`的值为指定值\n- 总结起来：绝对定位、浮动、根元素都需要调整`display`\n\n### 7 清除浮动的几种方式，各自的优缺点\n\n- 父级`div`定义`height`\n- 结尾处加空`div`标签`clear:both`\n- 父级`div`定义伪类`:after`和`zoom`\n- 父级`div`定义`overflow:hidden`\n- 父级`div`也浮动，需要定义宽度\n- 结尾处加`br`标签`clear:both`\n- 比较好的是第 3 种方式，好多网站都这么用\n\n### 8 为什么要初始化 CSS 样式?\n\n- 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对`CSS`初始化往往会出现浏览器之间的页面显示差异。\n- 当然，初始化样式会对`SEO`有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化\n\n### 9 css3 有哪些新特性\n\n- 新增各种`css`选择器\n- 圆角  `border-radius`\n- 多列布局\n- 阴影和反射\n- 文字特效`text-shadow`\n- 线性渐变\n- 旋转`transform`\n\nCSS3 新增伪类有那些？\n\n- `p:first-of-type`  选择属于其父元素的首个`<p>`元素的每个`<p>`  元素。\n- `p:last-of-type`  选择属于其父元素的最后  `<p>`  元素的每个`<p>`  元素。\n- `p:only-of-type`  选择属于其父元素唯一的  `<p>`元素的每个  `<p>`  元素。\n- `p:only-child`  选择属于其父元素的唯一子元素的每个  `<p>`  元素。\n- `p:nth-child(2)`  选择属于其父元素的第二个子元素的每个  `<p>`  元素。\n- `:after`  在元素之前添加内容,也可以用来做清除浮动。\n- `:before`  在元素之后添加内容。\n- `:enabled`  已启用的表单元素。\n- `:disabled`  已禁用的表单元素。\n- `:checked`  单选框或复选框被选中。\n\n### 10 display 有哪些值？说明他们的作用\n\n- `block`  转换成块状元素。\n- `inline`  转换成行内元素。\n- `none`  设置元素不可见。\n- `inline-block`  象行内元素一样显示，但其内容象块类型元素一样显示。\n- `list-item`  象块类型元素一样显示，并添加样式列表标记。\n- `table`  此元素会作为块级表格来显示\n- `inherit`  规定应该从父元素继承  `display`  属性的值\n\n### 11 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？\n\n- 有两种， `IE`盒子模型、`W3C`盒子模型；\n- 盒模型： 内容(content)、填充(`padding`)、边界(`margin`)、 边框(`border`)；\n- 区 别： `IE`的 c`ontent`部分把  `border`  和  `padding`计算了进去;\n\n### 12 CSS 优先级算法如何计算？\n\n- 优先级就近原则，同权重情况下样式定义最近者为准\n- 载入样式以最后载入的定位为准\n- 优先级为: `!important > id > class > tag`; `!important`  比 内联优先级高\n\n### 13 对 BFC 规范的理解？\n\n- 它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用\n\n### 14 谈谈浮动和清除浮动\n\n- 浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上\n\n### 15 position 的值， relative 和 absolute 定位原点是\n\n- `absolute`：生成绝对定位的元素，相对于  `static`  定位以外的第一个父元素进行定位\n- `fixed`：生成绝对定位的元素，相对于浏览器窗口进行定位\n- `relative`：生成相对定位的元素，相对于其正常位置进行定位\n- `static`  默认值。没有定位，元素出现在正常的流中\n- `inherit`  规定从父元素继承  `position`  属性的值\n\n### 16 display:inline-block 什么时候不会显示间隙？(携程)\n\n- 移除空格\n- 使用`margin`负值\n- 使用`font-size:0`\n- `letter-spacing`\n- `word-spacing`\n\n### 17 PNG\\\\GIF\\\\JPG 的区别及如何选\n\n- `GIF`\n  - `8`位像素，`256`色\n  - 无损压缩\n  - 支持简单动画\n  - 支持`boolean`透明\n  - 适合简单动画\n- `JPEG`\n  - 颜色限于`256`\n  - 有损压缩\n  - 可控制压缩质量\n  - 不支持透明\n  - 适合照片\n- `PNG`\n  - 有`PNG8`和`truecolor PNG`\n  - `PNG8`类似`GIF`颜色上限为`256`，文件小，支持`alpha`透明度，无动画\n  - 适合图标、背景、按钮\n\n### 18 行内元素 float:left 后是否变为块级元素？\n\n> 行内元素设置成浮动之后变得更加像是`inline-block`（行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是`100%`），这时候给行内元素设置`padding-top`和`padding-bottom`或者`width`、`height`都是有效果的\n\n### 19 在网页中的应该使用奇数还是偶数的字体？为什么呢？\n\n- 偶数字号相对更容易和 web 设计的其他部分构成比例关系\n\n### 20 ::before 和 :after 中双冒号和单冒号 有什么区别？解释一下这 2 个伪元素的作用\n\n- 单冒号(`:`)用于`CSS3`伪类，双冒号(`::`)用于`CSS3`伪元素\n- 用于区分伪类和伪元素\n\n### 21 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）\n\n- 多数显示器默认频率是`60Hz`，即`1`秒刷新`60`次，所以理论上最小间隔为`1/60*1000ms ＝ 16.7ms`\n\n### 22 CSS 合并方法\n\n- 避免使用`@import`引入多个`css`文件，可以使用`CSS`工具将`CSS`合并为一个`CSS`文件，例如使用`Sass\\Compass`等\n\n### 23 CSS 不同选择器的权重(CSS 层叠的规则)\n\n- `！important`规则最重要，大于其它规则\n- 行内样式规则，加`1000`\n- 对于选择器中给定的各个`ID`属性值，加`100`\n- 对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加`10`\n- 对于选择其中给定的各个元素标签选择器，加 1\n- 如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则\n\n### 24 列出你所知道可以改变页面布局的属性\n\n- `position`、`display`、`float`、`width`、`height`、`margin`、`padding`、`top`、`left`、`right`、`\n\n### 25 CSS 在性能优化方面的实践\n\n- `css`压缩与合并、`Gzip`压缩\n- `css`文件放在`head`里、不要用`@import`\n- 尽量用缩写、避免用滤镜、合理使用选择器\n\n### 26 CSS3 动画（简单动画的实现，如旋转等）\n\n- 依靠`CSS3`中提出的三个属性：`transition`、`transform`、`animation`\n- `transition`：定义了元素在变化过程中是怎么样的，包含`transition-property`、`transition-duration`、`transition-timing-function`、`transition-delay`。\n- `transform`：定义元素的变化结果，包含`rotate`、`scale`、`skew`、`translate`。\n- `animation`：动画定义了动作的每一帧（`@keyframes`）有什么效果，包括`animation-name`，`animation-duration`、`animation-timing-function`、`animation-delay`、`animation-iteration-count`、`animation-direction`\n\n### 27 base64 的原理及优缺点\n\n- 优点可以加密，减少了`HTTTP`请求\n- 缺点是需要消耗`CPU`进行编解码\n\n### 28 几种常见的 CSS 布局\n\n#### 流体布局\n\n    .left {\n    \tfloat: left;\n    \twidth: 100px;\n    \theight: 200px;\n    \tbackground: red;\n    }\n    .right {\n    \tfloat: right;\n    \twidth: 200px;\n    \theight: 200px;\n    \tbackground: blue;\n    }\n    .main {\n    \tmargin-left: 120px;\n    \tmargin-right: 220px;\n    \theight: 200px;\n    \tbackground: green;\n    }\n\n<div class=\"container\">\n    <div class=\"left\"></div>\n    <div class=\"right\"></div>\n    <div class=\"main\"></div></div>\n\n#### 圣杯布局\n\n.container {\n    margin-left: 120px;\n    margin-right: 220px;}.main {\n    float: left;\n    width: 100%;\n    height:300px;\n    background: green;}.left {\n    position: relative;\n    left: -120px;\n    float: left;\n    height: 300px;\n    width: 100px;\n    margin-left: -100%;\n    background: red;}.right {\n    position: relative;\n    right: -220px;\n    float: right;\n    height: 300px;\n    width: 200px;\n    margin-left: -200px;\n    background: blue;}\n\n<div class=\"container\">\n\t<div class=\"main\"></div>\n\t<div class=\"left\"></div>\n\t<div class=\"right\"></div></div>\n\n#### 双飞翼布局\n\n.content {\n    float: left;\n    width: 100%;}.main {\n    height: 200px;\n    margin-left: 110px;\n    margin-right: 220px;\n    background: green;}.main::after {\n    content: '';\n    display: block;\n    font-size:0;\n    height: 0;\n    zoom: 1;\n    clear: both;}.left {\n    float:left;\n    height: 200px;\n    width: 100px;\n    margin-left: -100%;\n    background: red;}.right {\n    float: right;\n    height: 200px;\n    width: 200px;\n    margin-left: -200px;\n    background: blue;}\n\n<div class=\"content\">\n    <div class=\"main\"></div></div><div class=\"left\"></div><div class=\"right\"></div>\n\n### 29 stylus/sass/less 区别\n\n- 均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性\n- `Scss`和`LESS`语法较为严谨，`LESS`要求一定要使用大括号“{}”，`Scss`和`Stylus`可以通过缩进表示层次与嵌套关系\n- `Scss`无全局变量的概念，`LESS`和`Stylus`有类似于其它语言的作用域概念\n- `Sass`是基于`Ruby`语言的，而`LESS`和`Stylus`可以基于`NodeJS` `NPM`下载相应库后进行编译；\n\n### 30 postcss 的作用\n\n- 可以直观的理解为：它就是一个平台。为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大\n- `PostCSS`  提供了一个解析器，它能够将  `CSS`  解析成抽象语法树\n- 通过在  `PostCSS`  这个平台上，我们能够开发一些插件，来处理我们的`CSS`，比如热门的：`autoprefixer`\n- `postcss`可以对 sass 处理过后的`css`再处理 最常见的就是`autoprefixer`\n\n### 31 css 样式（选择器）的优先级\n\n- 计算权重确定\n- `!important`\n- 内联样式\n- 后写的优先级高\n\n### 32 自定义字体的使用场景\n\n- 宣传/品牌/`banner`等固定文案\n- 字体图标\n\n### 33 如何美化 CheckBox\n\n- `<label>`  属性  `for`  和  `id`\n- 隐藏原生的  `<input>`\n- `:checked + <label>`\n\n### 34 伪类和伪元素的区别\n\n- 伪类表状态\n- 伪元素是真的有元素\n- 前者单冒号，后者双冒号\n\n### 35 `base64`的使用\n\n- 用于减少  `HTTP`  请求\n- 适用于小图片\n- `base64`的体积约为原图的`4/3`\n\n### 36 自适应布局\n\n思路：\n\n- 左侧浮动或者绝对定位，然后右侧`margin`撑开\n- 使用`<div>`包含，然后靠负`margin`形成`bfc`\n- 使用`flex`\n\n### 37 请用 CSS 写一个简单的幻灯片效果页面\n\n> 知道是要用`CSS3`。使用`animation`动画实现一个简单的幻灯片效果\n\n/\\*\\*css\\*\\*/.ani{\n  width:480px;\n  height:320px;\n  margin:50px auto;\n  overflow: hidden;\n  box-shadow:0 0 5px rgba(0,0,0,1);\n  background-size: cover;\n  background-position: center;\n  -webkit-animation-name: \"loops\";\n  -webkit-animation-duration: 20s;\n  -webkit-animation-iteration-count: infinite;}@-webkit-keyframes \"loops\" {\n    0% {\n        background:url(http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg) no-repeat;             \n    }\n    25% {\n        background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg) no-repeat;\n    }\n    50% {\n        background:url(http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg) no-repeat;\n    }\n    75% {\n        background:url(http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg) no-repeat;\n    }\n    100% {\n        background:url(http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg) no-repeat;\n    }}\n\n### 38 什么是外边距重叠？重叠的结果是什么？\n\n> 外边距重叠就是 margin-collapse\n\n- 在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。\n\n折叠结果遵循下列计算规则：\n\n- 两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。\n- 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。\n- 两个外边距一正一负时，折叠结果是两者的相加的和。\n\n### 39 rgba()和 opacity 的透明效果有什么不同？\n\n- `rgba()`和`opacity`都能实现透明效果，但最大的不同是`opacity`作用于元素，以及元素内的所有内容的透明度，\n- 而`rgba()`只作用于元素的颜色或其背景色。（设置`rgba`透明的元素的子元素不会继承透明效果！）\n\n### 40 css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？\n\n- 垂直方向：`line-height`\n- 水平方向：`letter-spacing`\n\n### 41 如何垂直居中一个浮动元素？\n\n/**方法一：已知元素的高宽**/#div1{\n  background-color:#6699FF;\n  width:200px;\n  height:200px;\n  position: absolute;        //父元素需要相对定位   top: 50%;\n  left: 50%;\n  margin-top:-100px ;   //二分之一的 height，width  margin-left: -100px;}/**方法二:**/#div1{\n  width: 200px;\n  height: 200px;\n  background-color: #6699FF;\n  margin:auto;\n  position: absolute;        //父元素需要相对定位   left: 0;\n  top: 0;\n  right: 0;\n  bottom: 0;}\n\n如何垂直居中一个`<img>`?（用更简便的方法。）\n\n#container     /**<img>的容器设置如下**/{\n    display:table-cell;\n    text-align:center;\n    vertical-align:middle;}\n\n### 42 px 和 em 的区别\n\n- `px`和`em`都是长度单位，区别是，`px`的值是固定的，指定是多少就是多少，计算比较容易。`em`得值不是固定的，并且`em`会继承父级元素的字体大小。\n- 浏览器的默认字体高都是`16px`。所以未经调整的浏览器都符合: `1em=16px`。那么`12px=0.75em`, `10px=0.625em`。\n\n### 43 Sass、LESS 是什么？大家为什么要使用他们？\n\n- 他们是`CSS`预处理器。他是`CSS`上的一种抽象层。他们是一种特殊的语法/语言编译成`CSS`。\n- 例如 Less 是一种动态样式语言. 将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. `LESS`  既可以在客户端上运行 (支持`IE 6+`, `Webkit`, `Firefox`)，也可一在服务端运行 (借助  `Node.js`)\n\n为什么要使用它们？\n\n- 结构清晰，便于扩展。\n- 可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对\\- 浏览器语法差异的重复处理，减少无意义的机械劳动。\n- 可以轻松实现多重继承。\n- 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只- 是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译\n\n### 44 知道 css 有个 content 属性吗？有什么作用？有什么应用？\n\n> css 的`content`属性专门应用在  `before/after`伪元素上，用于来插入生成内容。最常见的应用是利用伪类清除浮动。\n\n/**一种常见利用伪类清除浮动的代码**/.clearfix:after {\n    content:\".\";       //这里利用到了 content 属性     display:block;\n    height:0;\n    visibility:hidden;\n    clear:both; \n }.clearfix {\n    \\*zoom:1;}\n\n### 45 水平居中的方法\n\n- 元素为行内元素，设置父元素`text-align:center`\n- 如果元素宽度固定，可以设置左右`margin`为`auto`;\n- 如果元素为绝对定位，设置父元素`position`为`relative`，元素设`left:0;right:0;margin:auto;`\n- 使用`flex-box`布局，指定`justify-content`属性为 center\n- `display`设置为`tabel-ceil`\n\n### 46 垂直居中的方法\n\n- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`\n- 使用`flex`布局，设置为`align-item：center`\n- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`\n- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值\n- 文本垂直居中设置`line-height`为`height`值\n\n### 47 如何使用 CSS 实现硬件加速？\n\n> 硬件加速是指通过创建独立的复合图层，让 GPU 来渲染这个图层，从而提高性能，\n\n- 一般触发硬件加速的`CSS`属性有`transform`、`opacity`、`filter`，为了避免 2D 动画在 开始和结束的时候的`repaint`操作，一般使用`tranform:translateZ(0)`\n\n### 48 重绘和回流（重排）是什么，如何避免？\n\n- DOM 的变化影响到了元素的几何属性（宽高）,浏览器重新计算元素的几何属性，其他元素的几何\n- 属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排，浏览器将受到影响的部分\n- 重新绘制到屏幕上的过程称为重绘。引起重排的原因有\n  - 添加或者删除可见的 DOM 元素，\n  - 元素位置、尺寸、内容改变，\n  - 浏览器页面初始化，\n  - 浏览器窗口尺寸改变，重排一定重绘，重绘不一定重排，\n\n减少重绘和重排的方法：\n\n- 不在布局信息改变时做`DOM`查询\n- 使用`cssText`或者`className`一次性改变属性\n- 使用`fragment`\n- 对于多次重排的元素，如动画，使用绝对定位脱离文档流，让他的改变不影响到其他元素\n\n### 49 说一说 css3 的 animation\n\n- css3 的`animation`是 css3 新增的动画属性，这个 css3 动画的每一帧是通过`@keyframes`来声明的，`keyframes`声明了动画的名称，通过`from`、`to`或者是百分比来定义\n- 每一帧动画元素的状态，通过`animation-name`来引用这个动画，同时 css3 动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式，\n- 这些相关的动画子属性有：`animation-name`定义动画名、`animation-duration`定义动画播放的时长、`animation-delay`定义动画延迟播放的时间、`animation-direction`定义 动画的播放方向、`animation-iteration-count`定义播放次数、`animation-fill-mode`定义动画播放之后的状态、`animation-play-state`定义播放状态，如暂停运行等、`animation-timing-function`\n- 定义播放的方式，如恒速播放、艰涩播放等。\n\n### 50 左边宽度固定，右边自适应\n\n> 左侧固定宽度，右侧自适应宽度的两列布局实现\n\nhtml 结构\n\n<div class=\"outer\">\n    <div class=\"left\">固定宽度</div>\n    <div class=\"right\">自适应宽度</div></div>\n\n> 在外层`div`（类名为`outer`）的`div`中，有两个子`div`，类名分别为`left`和`right`，其中`left`为固定宽度，而`right`为自适应宽度\n\n方法 1：左侧 div 设置成浮动：float: left，右侧 div 宽度会自拉升适应\n\n.outer {\n    width: 100%;\n    height: 500px;\n    background-color: yellow;}.left {\n    width: 200px;\n    height: 200px;\n    background-color: red;\n    float: left;}.right {\n    height: 200px;\n    background-color: blue;}\n\n方法 2：对右侧:div 进行绝对定位，然后再设置 right=0，即可以实现宽度自适应\n\n> 绝对定位元素的第一个高级特性就是其具有自动伸缩的功能，当我们将  `width`设置为  `auto`  的时候（或者不设置，默认为  `auto` ），绝对定位元素会根据其  `left`  和  `right`  自动伸缩其大小\n\n.outer {\n    width: 100%;\n    height: 500px;\n    background-color: yellow;\n    position: relative;}.left {\n    width: 200px;\n    height: 200px;\n    background-color: red;}.right {\n    height: 200px;\n    background-color: blue;\n    position: absolute;\n    left: 200px;\n    top:0;          \n    right: 0;}\n\n方法 3：将左侧 div 进行绝对定位，然后右侧 div 设置 margin-left: 200px\n\n.outer {\n    width: 100%;\n    height: 500px;\n    background-color: yellow;\n    position: relative;}.left {\n    width: 200px;\n    height: 200px;\n    background-color: red;\n    position: absolute;}.right {\n    height: 200px;\n    background-color: blue;\n    margin-left: 200px;}\n\n方法 4：使用 flex 布局\n\n.outer {\n    width: 100%;\n    height: 500px;\n    background-color: yellow;\n    display: flex;\n    flex-direction: row;}.left {\n    width: 200px;\n    height: 200px;\n    background-color: red;}.right {\n    height: 200px;\n    background-color: blue;\n    flex: 1;}\n\n### [#](http://blog.poetries.top/FE-Interview-Questions/base/#_51-%E4%B8%A4%E7%A7%8D%E4%BB%A5%E4%B8%8A%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%B7%B2%E7%9F%A5%E6%88%96%E8%80%85%E6%9C%AA%E7%9F%A5%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD)51 两种以上方式实现已知或者未知宽度的垂直水平居中\n\n/** 1 **/.wraper {\n  position: relative;\n  .box {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 100px;\n    height: 100px;\n    margin: -50px 0 0 -50px;\n  }}/** 2 **/.wraper {\n  position: relative;\n  .box {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n  }}/** 3 **/.wraper {\n  .box {\n    display: flex;\n    justify-content:center;\n    align-items: center;\n    height: 100px;\n  }}/** 4 **/.wraper {\n  display: table;\n  .box {\n    display: table-cell;\n    vertical-align: middle;\n  }}\n\n### 52 如何实现小于 12px 的字体效果\n\n> `transform:scale()`这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个`display:inline-block`;\n\ntransform: scale(0.7);\n\n`css`的属性，可以缩放大小\n","slug":"2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86css-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8","published":1,"updated":"2019-09-12T02:59:59.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269gd005dc8gsa3dgbo70","content":"<h2 id=\"二、CSS-部分\"><a href=\"#二、CSS-部分\" class=\"headerlink\" title=\"二、CSS 部分\"></a>二、CSS 部分</h2><h3 id=\"1-css-sprite-是什么-有什么优缺点\"><a href=\"#1-css-sprite-是什么-有什么优缺点\" class=\"headerlink\" title=\"1 css sprite 是什么,有什么优缺点\"></a>1 css sprite 是什么,有什么优缺点</h3><ul>\n<li>概念：将多个小图片拼接到一个图片中。通过<code>background-position</code>和元素尺寸调节需要显示的背景图案。</li>\n<li>优点：<ul>\n<li>减少<code>HTTP</code>请求数，极大地提高页面加载速度</li>\n<li>增加图片信息重复度，提高压缩比，减少图片大小</li>\n<li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>图片合并麻烦</li>\n<li>维护麻烦，修改一个图片可能需要从新布局整个图片，样式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-display-none-与visibility-hidden-的区别\"><a href=\"#2-display-none-与visibility-hidden-的区别\" class=\"headerlink\" title=\"2 display: none;与visibility: hidden;的区别\"></a>2 <code>display: none;</code>与<code>visibility: hidden;</code>的区别</h3><ul>\n<li>联系：它们都能让元素不可见</li>\n<li>区别：<ul>\n<li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden</code>;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li>\n<li><code>display: none</code>;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示<code>；visibility: hidden;</code>是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible;</code>可以让子孙节点显式</li>\n<li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘。</li>\n<li>读屏器不会读取<code>display: none</code>;元素内容；会读取<code>visibility: hidden;</code>元素内容</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-link与-import的区别\"><a href=\"#3-link与-import的区别\" class=\"headerlink\" title=\"3 link与@import的区别\"></a>3 <code>link</code>与<code>@import</code>的区别</h3><ol>\n<li> <code>link</code>是<code>HTML</code>方式， <code>@import</code>是 CSS 方式</li>\n<li> <code>link</code>最大限度支持并行下载，<code>@import</code>过多嵌套导致串行下载，出现<code>FOUC</code>(文档样式短暂失效)</li>\n<li> <code>link</code>可以通过<code>rel=&quot;alternate stylesheet&quot;</code>指定候选样式</li>\n<li> 浏览器对<code>link</code>支持早于<code>@import</code>，可以使用<code>@import</code>对老浏览器隐藏样式</li>\n<li> <code>@import</code>必须在样式规则之前，可以在 css 文件中引用其他文件</li>\n<li> 总体来说：<code>link</code>优于<code>@import</code></li>\n</ol>\n<h3 id=\"4-什么是-FOUC-如何避免\"><a href=\"#4-什么是-FOUC-如何避免\" class=\"headerlink\" title=\"4 什么是 FOUC?如何避免\"></a>4 什么是 FOUC?如何避免</h3><ul>\n<li><code>Flash Of Unstyled Content</code>：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。</li>\n<li>解决方法：把样式表放到文档的<code>&lt;head&gt;</code></li>\n</ul>\n<h3 id=\"5-如何创建块级格式化上下文-block-formatting-context-BFC-有什么用\"><a href=\"#5-如何创建块级格式化上下文-block-formatting-context-BFC-有什么用\" class=\"headerlink\" title=\"5 如何创建块级格式化上下文(block formatting context),BFC 有什么用\"></a>5 如何创建块级格式化上下文(block formatting context),BFC 有什么用</h3><ul>\n<li>创建规则：<ul>\n<li>根元素</li>\n<li>浮动元素（<code>float</code>不取值为<code>none</code>）</li>\n<li>绝对定位元素（<code>position</code>取值为<code>absolute</code>或<code>fixed</code>）</li>\n<li><code>display</code>取值为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>、<code>inline-flex</code>之一的元素</li>\n<li><code>overflow</code>不取值为<code>visible</code>的元素</li>\n</ul>\n</li>\n<li>作用：<ul>\n<li>可以包含浮动元素</li>\n<li>不被浮动元素覆盖</li>\n<li>阻止父子元素的<code>margin</code>折叠</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-display、float、position-的关系\"><a href=\"#6-display、float、position-的关系\" class=\"headerlink\" title=\"6 display、float、position 的关系\"></a>6 display、float、position 的关系</h3><ul>\n<li>如果<code>display</code>取值为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，这种情况下元素不产生框</li>\n<li>否则，如果<code>position</code>取值为<code>absolute</code>或者<code>fixed</code>，框就是绝对定位的，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整。</li>\n<li>否则，如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整</li>\n<li>否则，如果元素是根元素，<code>display</code>根据下表进行调整</li>\n<li>其他情况下<code>display</code>的值为指定值</li>\n<li>总结起来：绝对定位、浮动、根元素都需要调整<code>display</code></li>\n</ul>\n<h3 id=\"7-清除浮动的几种方式，各自的优缺点\"><a href=\"#7-清除浮动的几种方式，各自的优缺点\" class=\"headerlink\" title=\"7 清除浮动的几种方式，各自的优缺点\"></a>7 清除浮动的几种方式，各自的优缺点</h3><ul>\n<li>父级<code>div</code>定义<code>height</code></li>\n<li>结尾处加空<code>div</code>标签<code>clear:both</code></li>\n<li>父级<code>div</code>定义伪类<code>:after</code>和<code>zoom</code></li>\n<li>父级<code>div</code>定义<code>overflow:hidden</code></li>\n<li>父级<code>div</code>也浮动，需要定义宽度</li>\n<li>结尾处加<code>br</code>标签<code>clear:both</code></li>\n<li>比较好的是第 3 种方式，好多网站都这么用</li>\n</ul>\n<h3 id=\"8-为什么要初始化-CSS-样式\"><a href=\"#8-为什么要初始化-CSS-样式\" class=\"headerlink\" title=\"8 为什么要初始化 CSS 样式?\"></a>8 为什么要初始化 CSS 样式?</h3><ul>\n<li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对<code>CSS</code>初始化往往会出现浏览器之间的页面显示差异。</li>\n<li>当然，初始化样式会对<code>SEO</code>有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化</li>\n</ul>\n<h3 id=\"9-css3-有哪些新特性\"><a href=\"#9-css3-有哪些新特性\" class=\"headerlink\" title=\"9 css3 有哪些新特性\"></a>9 css3 有哪些新特性</h3><ul>\n<li>新增各种<code>css</code>选择器</li>\n<li>圆角  <code>border-radius</code></li>\n<li>多列布局</li>\n<li>阴影和反射</li>\n<li>文字特效<code>text-shadow</code></li>\n<li>线性渐变</li>\n<li>旋转<code>transform</code></li>\n</ul>\n<p>CSS3 新增伪类有那些？</p>\n<ul>\n<li><code>p:first-of-type</code>  选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>  元素。</li>\n<li><code>p:last-of-type</code>  选择属于其父元素的最后  <code>&lt;p&gt;</code>  元素的每个<code>&lt;p&gt;</code>  元素。</li>\n<li><code>p:only-of-type</code>  选择属于其父元素唯一的  <code>&lt;p&gt;</code>元素的每个  <code>&lt;p&gt;</code>  元素。</li>\n<li><code>p:only-child</code>  选择属于其父元素的唯一子元素的每个  <code>&lt;p&gt;</code>  元素。</li>\n<li><code>p:nth-child(2)</code>  选择属于其父元素的第二个子元素的每个  <code>&lt;p&gt;</code>  元素。</li>\n<li><code>:after</code>  在元素之前添加内容,也可以用来做清除浮动。</li>\n<li><code>:before</code>  在元素之后添加内容。</li>\n<li><code>:enabled</code>  已启用的表单元素。</li>\n<li><code>:disabled</code>  已禁用的表单元素。</li>\n<li><code>:checked</code>  单选框或复选框被选中。</li>\n</ul>\n<h3 id=\"10-display-有哪些值？说明他们的作用\"><a href=\"#10-display-有哪些值？说明他们的作用\" class=\"headerlink\" title=\"10 display 有哪些值？说明他们的作用\"></a>10 display 有哪些值？说明他们的作用</h3><ul>\n<li><code>block</code>  转换成块状元素。</li>\n<li><code>inline</code>  转换成行内元素。</li>\n<li><code>none</code>  设置元素不可见。</li>\n<li><code>inline-block</code>  象行内元素一样显示，但其内容象块类型元素一样显示。</li>\n<li><code>list-item</code>  象块类型元素一样显示，并添加样式列表标记。</li>\n<li><code>table</code>  此元素会作为块级表格来显示</li>\n<li><code>inherit</code>  规定应该从父元素继承  <code>display</code>  属性的值</li>\n</ul>\n<h3 id=\"11-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？\"><a href=\"#11-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？\" class=\"headerlink\" title=\"11 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？\"></a>11 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h3><ul>\n<li>有两种， <code>IE</code>盒子模型、<code>W3C</code>盒子模型；</li>\n<li>盒模型： 内容(content)、填充(<code>padding</code>)、边界(<code>margin</code>)、 边框(<code>border</code>)；</li>\n<li>区 别： <code>IE</code>的 c<code>ontent</code>部分把  <code>border</code>  和  <code>padding</code>计算了进去;</li>\n</ul>\n<h3 id=\"12-CSS-优先级算法如何计算？\"><a href=\"#12-CSS-优先级算法如何计算？\" class=\"headerlink\" title=\"12 CSS 优先级算法如何计算？\"></a>12 CSS 优先级算法如何计算？</h3><ul>\n<li>优先级就近原则，同权重情况下样式定义最近者为准</li>\n<li>载入样式以最后载入的定位为准</li>\n<li>优先级为: <code>!important &gt; id &gt; class &gt; tag</code>; <code>!important</code>  比 内联优先级高</li>\n</ul>\n<h3 id=\"13-对-BFC-规范的理解？\"><a href=\"#13-对-BFC-规范的理解？\" class=\"headerlink\" title=\"13 对 BFC 规范的理解？\"></a>13 对 BFC 规范的理解？</h3><ul>\n<li>它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用</li>\n</ul>\n<h3 id=\"14-谈谈浮动和清除浮动\"><a href=\"#14-谈谈浮动和清除浮动\" class=\"headerlink\" title=\"14 谈谈浮动和清除浮动\"></a>14 谈谈浮动和清除浮动</h3><ul>\n<li>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上</li>\n</ul>\n<h3 id=\"15-position-的值，-relative-和-absolute-定位原点是\"><a href=\"#15-position-的值，-relative-和-absolute-定位原点是\" class=\"headerlink\" title=\"15 position 的值， relative 和 absolute 定位原点是\"></a>15 position 的值， relative 和 absolute 定位原点是</h3><ul>\n<li><code>absolute</code>：生成绝对定位的元素，相对于  <code>static</code>  定位以外的第一个父元素进行定位</li>\n<li><code>fixed</code>：生成绝对定位的元素，相对于浏览器窗口进行定位</li>\n<li><code>relative</code>：生成相对定位的元素，相对于其正常位置进行定位</li>\n<li><code>static</code>  默认值。没有定位，元素出现在正常的流中</li>\n<li><code>inherit</code>  规定从父元素继承  <code>position</code>  属性的值</li>\n</ul>\n<h3 id=\"16-display-inline-block-什么时候不会显示间隙？-携程\"><a href=\"#16-display-inline-block-什么时候不会显示间隙？-携程\" class=\"headerlink\" title=\"16 display:inline-block 什么时候不会显示间隙？(携程)\"></a>16 display:inline-block 什么时候不会显示间隙？(携程)</h3><ul>\n<li>移除空格</li>\n<li>使用<code>margin</code>负值</li>\n<li>使用<code>font-size:0</code></li>\n<li><code>letter-spacing</code></li>\n<li><code>word-spacing</code></li>\n</ul>\n<h3 id=\"17-PNG-GIF-JPG-的区别及如何选\"><a href=\"#17-PNG-GIF-JPG-的区别及如何选\" class=\"headerlink\" title=\"17 PNG\\GIF\\JPG 的区别及如何选\"></a>17 PNG\\GIF\\JPG 的区别及如何选</h3><ul>\n<li><code>GIF</code><ul>\n<li><code>8</code>位像素，<code>256</code>色</li>\n<li>无损压缩</li>\n<li>支持简单动画</li>\n<li>支持<code>boolean</code>透明</li>\n<li>适合简单动画</li>\n</ul>\n</li>\n<li><code>JPEG</code><ul>\n<li>颜色限于<code>256</code></li>\n<li>有损压缩</li>\n<li>可控制压缩质量</li>\n<li>不支持透明</li>\n<li>适合照片</li>\n</ul>\n</li>\n<li><code>PNG</code><ul>\n<li>有<code>PNG8</code>和<code>truecolor PNG</code></li>\n<li><code>PNG8</code>类似<code>GIF</code>颜色上限为<code>256</code>，文件小，支持<code>alpha</code>透明度，无动画</li>\n<li>适合图标、背景、按钮</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"18-行内元素-float-left-后是否变为块级元素？\"><a href=\"#18-行内元素-float-left-后是否变为块级元素？\" class=\"headerlink\" title=\"18 行内元素 float:left 后是否变为块级元素？\"></a>18 行内元素 float:left 后是否变为块级元素？</h3><blockquote>\n<p>行内元素设置成浮动之后变得更加像是<code>inline-block</code>（行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是<code>100%</code>），这时候给行内元素设置<code>padding-top</code>和<code>padding-bottom</code>或者<code>width</code>、<code>height</code>都是有效果的</p>\n</blockquote>\n<h3 id=\"19-在网页中的应该使用奇数还是偶数的字体？为什么呢？\"><a href=\"#19-在网页中的应该使用奇数还是偶数的字体？为什么呢？\" class=\"headerlink\" title=\"19 在网页中的应该使用奇数还是偶数的字体？为什么呢？\"></a>19 在网页中的应该使用奇数还是偶数的字体？为什么呢？</h3><ul>\n<li>偶数字号相对更容易和 web 设计的其他部分构成比例关系</li>\n</ul>\n<h3 id=\"20-before-和-after-中双冒号和单冒号-有什么区别？解释一下这-2-个伪元素的作用\"><a href=\"#20-before-和-after-中双冒号和单冒号-有什么区别？解释一下这-2-个伪元素的作用\" class=\"headerlink\" title=\"20 ::before 和 :after 中双冒号和单冒号 有什么区别？解释一下这 2 个伪元素的作用\"></a>20 ::before 和 :after 中双冒号和单冒号 有什么区别？解释一下这 2 个伪元素的作用</h3><ul>\n<li>单冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素</li>\n<li>用于区分伪类和伪元素</li>\n</ul>\n<h3 id=\"21-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）\"><a href=\"#21-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）\" class=\"headerlink\" title=\"21 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）\"></a>21 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h3><ul>\n<li>多数显示器默认频率是<code>60Hz</code>，即<code>1</code>秒刷新<code>60</code>次，所以理论上最小间隔为<code>1/60*1000ms ＝ 16.7ms</code></li>\n</ul>\n<h3 id=\"22-CSS-合并方法\"><a href=\"#22-CSS-合并方法\" class=\"headerlink\" title=\"22 CSS 合并方法\"></a>22 CSS 合并方法</h3><ul>\n<li>避免使用<code>@import</code>引入多个<code>css</code>文件，可以使用<code>CSS</code>工具将<code>CSS</code>合并为一个<code>CSS</code>文件，例如使用<code>Sass\\Compass</code>等</li>\n</ul>\n<h3 id=\"23-CSS-不同选择器的权重-CSS-层叠的规则\"><a href=\"#23-CSS-不同选择器的权重-CSS-层叠的规则\" class=\"headerlink\" title=\"23 CSS 不同选择器的权重(CSS 层叠的规则)\"></a>23 CSS 不同选择器的权重(CSS 层叠的规则)</h3><ul>\n<li><code>！important</code>规则最重要，大于其它规则</li>\n<li>行内样式规则，加<code>1000</code></li>\n<li>对于选择器中给定的各个<code>ID</code>属性值，加<code>100</code></li>\n<li>对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加<code>10</code></li>\n<li>对于选择其中给定的各个元素标签选择器，加 1</li>\n<li>如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则</li>\n</ul>\n<h3 id=\"24-列出你所知道可以改变页面布局的属性\"><a href=\"#24-列出你所知道可以改变页面布局的属性\" class=\"headerlink\" title=\"24 列出你所知道可以改变页面布局的属性\"></a>24 列出你所知道可以改变页面布局的属性</h3><ul>\n<li><code>position</code>、<code>display</code>、<code>float</code>、<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>top</code>、<code>left</code>、<code>right</code>、`</li>\n</ul>\n<h3 id=\"25-CSS-在性能优化方面的实践\"><a href=\"#25-CSS-在性能优化方面的实践\" class=\"headerlink\" title=\"25 CSS 在性能优化方面的实践\"></a>25 CSS 在性能优化方面的实践</h3><ul>\n<li><code>css</code>压缩与合并、<code>Gzip</code>压缩</li>\n<li><code>css</code>文件放在<code>head</code>里、不要用<code>@import</code></li>\n<li>尽量用缩写、避免用滤镜、合理使用选择器</li>\n</ul>\n<h3 id=\"26-CSS3-动画（简单动画的实现，如旋转等）\"><a href=\"#26-CSS3-动画（简单动画的实现，如旋转等）\" class=\"headerlink\" title=\"26 CSS3 动画（简单动画的实现，如旋转等）\"></a>26 CSS3 动画（简单动画的实现，如旋转等）</h3><ul>\n<li>依靠<code>CSS3</code>中提出的三个属性：<code>transition</code>、<code>transform</code>、<code>animation</code></li>\n<li><code>transition</code>：定义了元素在变化过程中是怎么样的，包含<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>、<code>transition-delay</code>。</li>\n<li><code>transform</code>：定义元素的变化结果，包含<code>rotate</code>、<code>scale</code>、<code>skew</code>、<code>translate</code>。</li>\n<li><code>animation</code>：动画定义了动作的每一帧（<code>@keyframes</code>）有什么效果，包括<code>animation-name</code>，<code>animation-duration</code>、<code>animation-timing-function</code>、<code>animation-delay</code>、<code>animation-iteration-count</code>、<code>animation-direction</code></li>\n</ul>\n<h3 id=\"27-base64-的原理及优缺点\"><a href=\"#27-base64-的原理及优缺点\" class=\"headerlink\" title=\"27 base64 的原理及优缺点\"></a>27 base64 的原理及优缺点</h3><ul>\n<li>优点可以加密，减少了<code>HTTTP</code>请求</li>\n<li>缺点是需要消耗<code>CPU</code>进行编解码</li>\n</ul>\n<h3 id=\"28-几种常见的-CSS-布局\"><a href=\"#28-几种常见的-CSS-布局\" class=\"headerlink\" title=\"28 几种常见的 CSS 布局\"></a>28 几种常见的 CSS 布局</h3><h4 id=\"流体布局\"><a href=\"#流体布局\" class=\"headerlink\" title=\"流体布局\"></a>流体布局</h4><pre><code>.left &#123;\n    float: left;\n    width: 100px;\n    height: 200px;\n    background: red;\n&#125;\n.right &#123;\n    float: right;\n    width: 200px;\n    height: 200px;\n    background: blue;\n&#125;\n.main &#123;\n    margin-left: 120px;\n    margin-right: 220px;\n    height: 200px;\n    background: green;\n&#125;\n</code></pre>\n<p><div class=\"container\"><br>    <div class=\"left\"></div><br>    <div class=\"right\"></div><br>    <div class=\"main\"></div></div></p>\n<h4 id=\"圣杯布局\"><a href=\"#圣杯布局\" class=\"headerlink\" title=\"圣杯布局\"></a>圣杯布局</h4><p>.container {<br>    margin-left: 120px;<br>    margin-right: 220px;}.main {<br>    float: left;<br>    width: 100%;<br>    height:300px;<br>    background: green;}.left {<br>    position: relative;<br>    left: -120px;<br>    float: left;<br>    height: 300px;<br>    width: 100px;<br>    margin-left: -100%;<br>    background: red;}.right {<br>    position: relative;<br>    right: -220px;<br>    float: right;<br>    height: 300px;<br>    width: 200px;<br>    margin-left: -200px;<br>    background: blue;}</p>\n<p><div class=\"container\"><br>    <div class=\"main\"></div><br>    <div class=\"left\"></div><br>    <div class=\"right\"></div></div></p>\n<h4 id=\"双飞翼布局\"><a href=\"#双飞翼布局\" class=\"headerlink\" title=\"双飞翼布局\"></a>双飞翼布局</h4><p>.content {<br>    float: left;<br>    width: 100%;}.main {<br>    height: 200px;<br>    margin-left: 110px;<br>    margin-right: 220px;<br>    background: green;}.main::after {<br>    content: ‘’;<br>    display: block;<br>    font-size:0;<br>    height: 0;<br>    zoom: 1;<br>    clear: both;}.left {<br>    float:left;<br>    height: 200px;<br>    width: 100px;<br>    margin-left: -100%;<br>    background: red;}.right {<br>    float: right;<br>    height: 200px;<br>    width: 200px;<br>    margin-left: -200px;<br>    background: blue;}</p>\n<p><div class=\"content\"><br>    <div class=\"main\"></div></div><div class=\"left\"></div><div class=\"right\"></div></p>\n<h3 id=\"29-stylus-sass-less-区别\"><a href=\"#29-stylus-sass-less-区别\" class=\"headerlink\" title=\"29 stylus/sass/less 区别\"></a>29 stylus/sass/less 区别</h3><ul>\n<li>均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性</li>\n<li><code>Scss</code>和<code>LESS</code>语法较为严谨，<code>LESS</code>要求一定要使用大括号“{}”，<code>Scss</code>和<code>Stylus</code>可以通过缩进表示层次与嵌套关系</li>\n<li><code>Scss</code>无全局变量的概念，<code>LESS</code>和<code>Stylus</code>有类似于其它语言的作用域概念</li>\n<li><code>Sass</code>是基于<code>Ruby</code>语言的，而<code>LESS</code>和<code>Stylus</code>可以基于<code>NodeJS</code> <code>NPM</code>下载相应库后进行编译；</li>\n</ul>\n<h3 id=\"30-postcss-的作用\"><a href=\"#30-postcss-的作用\" class=\"headerlink\" title=\"30 postcss 的作用\"></a>30 postcss 的作用</h3><ul>\n<li>可以直观的理解为：它就是一个平台。为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大</li>\n<li><code>PostCSS</code>  提供了一个解析器，它能够将  <code>CSS</code>  解析成抽象语法树</li>\n<li>通过在  <code>PostCSS</code>  这个平台上，我们能够开发一些插件，来处理我们的<code>CSS</code>，比如热门的：<code>autoprefixer</code></li>\n<li><code>postcss</code>可以对 sass 处理过后的<code>css</code>再处理 最常见的就是<code>autoprefixer</code></li>\n</ul>\n<h3 id=\"31-css-样式（选择器）的优先级\"><a href=\"#31-css-样式（选择器）的优先级\" class=\"headerlink\" title=\"31 css 样式（选择器）的优先级\"></a>31 css 样式（选择器）的优先级</h3><ul>\n<li>计算权重确定</li>\n<li><code>!important</code></li>\n<li>内联样式</li>\n<li>后写的优先级高</li>\n</ul>\n<h3 id=\"32-自定义字体的使用场景\"><a href=\"#32-自定义字体的使用场景\" class=\"headerlink\" title=\"32 自定义字体的使用场景\"></a>32 自定义字体的使用场景</h3><ul>\n<li>宣传/品牌/<code>banner</code>等固定文案</li>\n<li>字体图标</li>\n</ul>\n<h3 id=\"33-如何美化-CheckBox\"><a href=\"#33-如何美化-CheckBox\" class=\"headerlink\" title=\"33 如何美化 CheckBox\"></a>33 如何美化 CheckBox</h3><ul>\n<li><code>&lt;label&gt;</code>  属性  <code>for</code>  和  <code>id</code></li>\n<li>隐藏原生的  <code>&lt;input&gt;</code></li>\n<li><code>:checked + &lt;label&gt;</code></li>\n</ul>\n<h3 id=\"34-伪类和伪元素的区别\"><a href=\"#34-伪类和伪元素的区别\" class=\"headerlink\" title=\"34 伪类和伪元素的区别\"></a>34 伪类和伪元素的区别</h3><ul>\n<li>伪类表状态</li>\n<li>伪元素是真的有元素</li>\n<li>前者单冒号，后者双冒号</li>\n</ul>\n<h3 id=\"35-base64的使用\"><a href=\"#35-base64的使用\" class=\"headerlink\" title=\"35 base64的使用\"></a>35 <code>base64</code>的使用</h3><ul>\n<li>用于减少  <code>HTTP</code>  请求</li>\n<li>适用于小图片</li>\n<li><code>base64</code>的体积约为原图的<code>4/3</code></li>\n</ul>\n<h3 id=\"36-自适应布局\"><a href=\"#36-自适应布局\" class=\"headerlink\" title=\"36 自适应布局\"></a>36 自适应布局</h3><p>思路：</p>\n<ul>\n<li>左侧浮动或者绝对定位，然后右侧<code>margin</code>撑开</li>\n<li>使用<code>&lt;div&gt;</code>包含，然后靠负<code>margin</code>形成<code>bfc</code></li>\n<li>使用<code>flex</code></li>\n</ul>\n<h3 id=\"37-请用-CSS-写一个简单的幻灯片效果页面\"><a href=\"#37-请用-CSS-写一个简单的幻灯片效果页面\" class=\"headerlink\" title=\"37 请用 CSS 写一个简单的幻灯片效果页面\"></a>37 请用 CSS 写一个简单的幻灯片效果页面</h3><blockquote>\n<p>知道是要用<code>CSS3</code>。使用<code>animation</code>动画实现一个简单的幻灯片效果</p>\n</blockquote>\n<p>/**css**/.ani{<br>  width:480px;<br>  height:320px;<br>  margin:50px auto;<br>  overflow: hidden;<br>  box-shadow:0 0 5px rgba(0,0,0,1);<br>  background-size: cover;<br>  background-position: center;<br>  -webkit-animation-name: “loops”;<br>  -webkit-animation-duration: 20s;<br>  -webkit-animation-iteration-count: infinite;}@-webkit-keyframes “loops” {<br>    0% {<br>        background:url(<a href=\"http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg\">http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg</a>) no-repeat;             <br>    }<br>    25% {<br>        background:url(<a href=\"http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg\">http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg</a>) no-repeat;<br>    }<br>    50% {<br>        background:url(<a href=\"http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg\">http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg</a>) no-repeat;<br>    }<br>    75% {<br>        background:url(<a href=\"http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg\">http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg</a>) no-repeat;<br>    }<br>    100% {<br>        background:url(<a href=\"http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg\">http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg</a>) no-repeat;<br>    }}</p>\n<h3 id=\"38-什么是外边距重叠？重叠的结果是什么？\"><a href=\"#38-什么是外边距重叠？重叠的结果是什么？\" class=\"headerlink\" title=\"38 什么是外边距重叠？重叠的结果是什么？\"></a>38 什么是外边距重叠？重叠的结果是什么？</h3><blockquote>\n<p>外边距重叠就是 margin-collapse</p>\n</blockquote>\n<ul>\n<li>在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</li>\n</ul>\n<p>折叠结果遵循下列计算规则：</p>\n<ul>\n<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>\n<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>\n<li>两个外边距一正一负时，折叠结果是两者的相加的和。</li>\n</ul>\n<h3 id=\"39-rgba-和-opacity-的透明效果有什么不同？\"><a href=\"#39-rgba-和-opacity-的透明效果有什么不同？\" class=\"headerlink\" title=\"39 rgba()和 opacity 的透明效果有什么不同？\"></a>39 rgba()和 opacity 的透明效果有什么不同？</h3><ul>\n<li><code>rgba()</code>和<code>opacity</code>都能实现透明效果，但最大的不同是<code>opacity</code>作用于元素，以及元素内的所有内容的透明度，</li>\n<li>而<code>rgba()</code>只作用于元素的颜色或其背景色。（设置<code>rgba</code>透明的元素的子元素不会继承透明效果！）</li>\n</ul>\n<h3 id=\"40-css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？\"><a href=\"#40-css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？\" class=\"headerlink\" title=\"40 css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？\"></a>40 css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h3><ul>\n<li>垂直方向：<code>line-height</code></li>\n<li>水平方向：<code>letter-spacing</code></li>\n</ul>\n<h3 id=\"41-如何垂直居中一个浮动元素？\"><a href=\"#41-如何垂直居中一个浮动元素？\" class=\"headerlink\" title=\"41 如何垂直居中一个浮动元素？\"></a>41 如何垂直居中一个浮动元素？</h3><p>/<strong>方法一：已知元素的高宽</strong>/#div1{<br>  background-color:#6699FF;<br>  width:200px;<br>  height:200px;<br>  position: absolute;        //父元素需要相对定位   top: 50%;<br>  left: 50%;<br>  margin-top:-100px ;   //二分之一的 height，width  margin-left: -100px;}/<strong>方法二:</strong>/#div1{<br>  width: 200px;<br>  height: 200px;<br>  background-color: #6699FF;<br>  margin:auto;<br>  position: absolute;        //父元素需要相对定位   left: 0;<br>  top: 0;<br>  right: 0;<br>  bottom: 0;}</p>\n<p>如何垂直居中一个<code>&lt;img&gt;</code>?（用更简便的方法。）</p>\n<p>#container     /<strong><img>的容器设置如下</strong>/{<br>    display:table-cell;<br>    text-align:center;<br>    vertical-align:middle;}</p>\n<h3 id=\"42-px-和-em-的区别\"><a href=\"#42-px-和-em-的区别\" class=\"headerlink\" title=\"42 px 和 em 的区别\"></a>42 px 和 em 的区别</h3><ul>\n<li><code>px</code>和<code>em</code>都是长度单位，区别是，<code>px</code>的值是固定的，指定是多少就是多少，计算比较容易。<code>em</code>得值不是固定的，并且<code>em</code>会继承父级元素的字体大小。</li>\n<li>浏览器的默认字体高都是<code>16px</code>。所以未经调整的浏览器都符合: <code>1em=16px</code>。那么<code>12px=0.75em</code>, <code>10px=0.625em</code>。</li>\n</ul>\n<h3 id=\"43-Sass、LESS-是什么？大家为什么要使用他们？\"><a href=\"#43-Sass、LESS-是什么？大家为什么要使用他们？\" class=\"headerlink\" title=\"43 Sass、LESS 是什么？大家为什么要使用他们？\"></a>43 Sass、LESS 是什么？大家为什么要使用他们？</h3><ul>\n<li>他们是<code>CSS</code>预处理器。他是<code>CSS</code>上的一种抽象层。他们是一种特殊的语法/语言编译成<code>CSS</code>。</li>\n<li>例如 Less 是一种动态样式语言. 将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. <code>LESS</code>  既可以在客户端上运行 (支持<code>IE 6+</code>, <code>Webkit</code>, <code>Firefox</code>)，也可一在服务端运行 (借助  <code>Node.js</code>)</li>\n</ul>\n<p>为什么要使用它们？</p>\n<ul>\n<li>结构清晰，便于扩展。</li>\n<li>可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对- 浏览器语法差异的重复处理，减少无意义的机械劳动。</li>\n<li>可以轻松实现多重继承。</li>\n<li>完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只- 是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译</li>\n</ul>\n<h3 id=\"44-知道-css-有个-content-属性吗？有什么作用？有什么应用？\"><a href=\"#44-知道-css-有个-content-属性吗？有什么作用？有什么应用？\" class=\"headerlink\" title=\"44 知道 css 有个 content 属性吗？有什么作用？有什么应用？\"></a>44 知道 css 有个 content 属性吗？有什么作用？有什么应用？</h3><blockquote>\n<p>css 的<code>content</code>属性专门应用在  <code>before/after</code>伪元素上，用于来插入生成内容。最常见的应用是利用伪类清除浮动。</p>\n</blockquote>\n<p>/<strong>一种常见利用伪类清除浮动的代码</strong>/.clearfix:after {<br>    content:”.”;       //这里利用到了 content 属性     display:block;<br>    height:0;<br>    visibility:hidden;<br>    clear:both; <br> }.clearfix {<br>    *zoom:1;}</p>\n<h3 id=\"45-水平居中的方法\"><a href=\"#45-水平居中的方法\" class=\"headerlink\" title=\"45 水平居中的方法\"></a>45 水平居中的方法</h3><ul>\n<li>元素为行内元素，设置父元素<code>text-align:center</code></li>\n<li>如果元素宽度固定，可以设置左右<code>margin</code>为<code>auto</code>;</li>\n<li>如果元素为绝对定位，设置父元素<code>position</code>为<code>relative</code>，元素设<code>left:0;right:0;margin:auto;</code></li>\n<li>使用<code>flex-box</code>布局，指定<code>justify-content</code>属性为 center</li>\n<li><code>display</code>设置为<code>tabel-ceil</code></li>\n</ul>\n<h3 id=\"46-垂直居中的方法\"><a href=\"#46-垂直居中的方法\" class=\"headerlink\" title=\"46 垂直居中的方法\"></a>46 垂直居中的方法</h3><ul>\n<li>将显示方式设置为表格，<code>display:table-cell</code>,同时设置<code>vertial-align：middle</code></li>\n<li>使用<code>flex</code>布局，设置为<code>align-item：center</code></li>\n<li>绝对定位中设置<code>bottom:0,top:0</code>,并设置<code>margin:auto</code></li>\n<li>绝对定位中固定高度时设置<code>top:50%，margin-top</code>值为高度一半的负值</li>\n<li>文本垂直居中设置<code>line-height</code>为<code>height</code>值</li>\n</ul>\n<h3 id=\"47-如何使用-CSS-实现硬件加速？\"><a href=\"#47-如何使用-CSS-实现硬件加速？\" class=\"headerlink\" title=\"47 如何使用 CSS 实现硬件加速？\"></a>47 如何使用 CSS 实现硬件加速？</h3><blockquote>\n<p>硬件加速是指通过创建独立的复合图层，让 GPU 来渲染这个图层，从而提高性能，</p>\n</blockquote>\n<ul>\n<li>一般触发硬件加速的<code>CSS</code>属性有<code>transform</code>、<code>opacity</code>、<code>filter</code>，为了避免 2D 动画在 开始和结束的时候的<code>repaint</code>操作，一般使用<code>tranform:translateZ(0)</code></li>\n</ul>\n<h3 id=\"48-重绘和回流（重排）是什么，如何避免？\"><a href=\"#48-重绘和回流（重排）是什么，如何避免？\" class=\"headerlink\" title=\"48 重绘和回流（重排）是什么，如何避免？\"></a>48 重绘和回流（重排）是什么，如何避免？</h3><ul>\n<li>DOM 的变化影响到了元素的几何属性（宽高）,浏览器重新计算元素的几何属性，其他元素的几何</li>\n<li>属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排，浏览器将受到影响的部分</li>\n<li>重新绘制到屏幕上的过程称为重绘。引起重排的原因有<ul>\n<li>添加或者删除可见的 DOM 元素，</li>\n<li>元素位置、尺寸、内容改变，</li>\n<li>浏览器页面初始化，</li>\n<li>浏览器窗口尺寸改变，重排一定重绘，重绘不一定重排，</li>\n</ul>\n</li>\n</ul>\n<p>减少重绘和重排的方法：</p>\n<ul>\n<li>不在布局信息改变时做<code>DOM</code>查询</li>\n<li>使用<code>cssText</code>或者<code>className</code>一次性改变属性</li>\n<li>使用<code>fragment</code></li>\n<li>对于多次重排的元素，如动画，使用绝对定位脱离文档流，让他的改变不影响到其他元素</li>\n</ul>\n<h3 id=\"49-说一说-css3-的-animation\"><a href=\"#49-说一说-css3-的-animation\" class=\"headerlink\" title=\"49 说一说 css3 的 animation\"></a>49 说一说 css3 的 animation</h3><ul>\n<li>css3 的<code>animation</code>是 css3 新增的动画属性，这个 css3 动画的每一帧是通过<code>@keyframes</code>来声明的，<code>keyframes</code>声明了动画的名称，通过<code>from</code>、<code>to</code>或者是百分比来定义</li>\n<li>每一帧动画元素的状态，通过<code>animation-name</code>来引用这个动画，同时 css3 动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式，</li>\n<li>这些相关的动画子属性有：<code>animation-name</code>定义动画名、<code>animation-duration</code>定义动画播放的时长、<code>animation-delay</code>定义动画延迟播放的时间、<code>animation-direction</code>定义 动画的播放方向、<code>animation-iteration-count</code>定义播放次数、<code>animation-fill-mode</code>定义动画播放之后的状态、<code>animation-play-state</code>定义播放状态，如暂停运行等、<code>animation-timing-function</code></li>\n<li>定义播放的方式，如恒速播放、艰涩播放等。</li>\n</ul>\n<h3 id=\"50-左边宽度固定，右边自适应\"><a href=\"#50-左边宽度固定，右边自适应\" class=\"headerlink\" title=\"50 左边宽度固定，右边自适应\"></a>50 左边宽度固定，右边自适应</h3><blockquote>\n<p>左侧固定宽度，右侧自适应宽度的两列布局实现</p>\n</blockquote>\n<p>html 结构</p>\n<p><div class=\"outer\"><br>    <div class=\"left\">固定宽度</div><br>    <div class=\"right\">自适应宽度</div></div></p>\n<blockquote>\n<p>在外层<code>div</code>（类名为<code>outer</code>）的<code>div</code>中，有两个子<code>div</code>，类名分别为<code>left</code>和<code>right</code>，其中<code>left</code>为固定宽度，而<code>right</code>为自适应宽度</p>\n</blockquote>\n<p>方法 1：左侧 div 设置成浮动：float: left，右侧 div 宽度会自拉升适应</p>\n<p>.outer {<br>    width: 100%;<br>    height: 500px;<br>    background-color: yellow;}.left {<br>    width: 200px;<br>    height: 200px;<br>    background-color: red;<br>    float: left;}.right {<br>    height: 200px;<br>    background-color: blue;}</p>\n<p>方法 2：对右侧:div 进行绝对定位，然后再设置 right=0，即可以实现宽度自适应</p>\n<blockquote>\n<p>绝对定位元素的第一个高级特性就是其具有自动伸缩的功能，当我们将  <code>width</code>设置为  <code>auto</code>  的时候（或者不设置，默认为  <code>auto</code> ），绝对定位元素会根据其  <code>left</code>  和  <code>right</code>  自动伸缩其大小</p>\n</blockquote>\n<p>.outer {<br>    width: 100%;<br>    height: 500px;<br>    background-color: yellow;<br>    position: relative;}.left {<br>    width: 200px;<br>    height: 200px;<br>    background-color: red;}.right {<br>    height: 200px;<br>    background-color: blue;<br>    position: absolute;<br>    left: 200px;<br>    top:0;          <br>    right: 0;}</p>\n<p>方法 3：将左侧 div 进行绝对定位，然后右侧 div 设置 margin-left: 200px</p>\n<p>.outer {<br>    width: 100%;<br>    height: 500px;<br>    background-color: yellow;<br>    position: relative;}.left {<br>    width: 200px;<br>    height: 200px;<br>    background-color: red;<br>    position: absolute;}.right {<br>    height: 200px;<br>    background-color: blue;<br>    margin-left: 200px;}</p>\n<p>方法 4：使用 flex 布局</p>\n<p>.outer {<br>    width: 100%;<br>    height: 500px;<br>    background-color: yellow;<br>    display: flex;<br>    flex-direction: row;}.left {<br>    width: 200px;<br>    height: 200px;<br>    background-color: red;}.right {<br>    height: 200px;<br>    background-color: blue;<br>    flex: 1;}</p>\n<h3 id=\"51-两种以上方式实现已知或者未知宽度的垂直水平居中\"><a href=\"#51-两种以上方式实现已知或者未知宽度的垂直水平居中\" class=\"headerlink\" title=\"#51 两种以上方式实现已知或者未知宽度的垂直水平居中\"></a><a href=\"http://blog.poetries.top/FE-Interview-Questions/base/#_51-%E4%B8%A4%E7%A7%8D%E4%BB%A5%E4%B8%8A%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%B7%B2%E7%9F%A5%E6%88%96%E8%80%85%E6%9C%AA%E7%9F%A5%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD\">#</a>51 两种以上方式实现已知或者未知宽度的垂直水平居中</h3><p>/** 1 <strong>/.wraper {<br>  position: relative;<br>  .box {<br>    position: absolute;<br>    top: 50%;<br>    left: 50%;<br>    width: 100px;<br>    height: 100px;<br>    margin: -50px 0 0 -50px;<br>  }}/</strong> 2 <strong>/.wraper {<br>  position: relative;<br>  .box {<br>    position: absolute;<br>    top: 50%;<br>    left: 50%;<br>    transform: translate(-50%, -50%);<br>  }}/</strong> 3 <strong>/.wraper {<br>  .box {<br>    display: flex;<br>    justify-content:center;<br>    align-items: center;<br>    height: 100px;<br>  }}/</strong> 4 **/.wraper {<br>  display: table;<br>  .box {<br>    display: table-cell;<br>    vertical-align: middle;<br>  }}</p>\n<h3 id=\"52-如何实现小于-12px-的字体效果\"><a href=\"#52-如何实现小于-12px-的字体效果\" class=\"headerlink\" title=\"52 如何实现小于 12px 的字体效果\"></a>52 如何实现小于 12px 的字体效果</h3><blockquote>\n<p><code>transform:scale()</code>这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个<code>display:inline-block</code>;</p>\n</blockquote>\n<p>transform: scale(0.7);</p>\n<p><code>css</code>的属性，可以缩放大小</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"二、CSS-部分\"><a href=\"#二、CSS-部分\" class=\"headerlink\" title=\"二、CSS 部分\"></a>二、CSS 部分</h2><h3 id=\"1-css-sprite-是什么-有什么优缺点\"><a href=\"#1-css-sprite-是什么-有什么优缺点\" class=\"headerlink\" title=\"1 css sprite 是什么,有什么优缺点\"></a>1 css sprite 是什么,有什么优缺点</h3><ul>\n<li>概念：将多个小图片拼接到一个图片中。通过<code>background-position</code>和元素尺寸调节需要显示的背景图案。</li>\n<li>优点：<ul>\n<li>减少<code>HTTP</code>请求数，极大地提高页面加载速度</li>\n<li>增加图片信息重复度，提高压缩比，减少图片大小</li>\n<li>更换风格方便，只需在一张或几张图片上修改颜色或样式即可实现</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>图片合并麻烦</li>\n<li>维护麻烦，修改一个图片可能需要从新布局整个图片，样式</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-display-none-与visibility-hidden-的区别\"><a href=\"#2-display-none-与visibility-hidden-的区别\" class=\"headerlink\" title=\"2 display: none;与visibility: hidden;的区别\"></a>2 <code>display: none;</code>与<code>visibility: hidden;</code>的区别</h3><ul>\n<li>联系：它们都能让元素不可见</li>\n<li>区别：<ul>\n<li><code>display:none</code>;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；<code>visibility: hidden</code>;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见</li>\n<li><code>display: none</code>;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示<code>；visibility: hidden;</code>是继承属性，子孙节点消失由于继承了<code>hidden</code>，通过设置<code>visibility: visible;</code>可以让子孙节点显式</li>\n<li>修改常规流中元素的<code>display</code>通常会造成文档重排。修改<code>visibility</code>属性只会造成本元素的重绘。</li>\n<li>读屏器不会读取<code>display: none</code>;元素内容；会读取<code>visibility: hidden;</code>元素内容</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-link与-import的区别\"><a href=\"#3-link与-import的区别\" class=\"headerlink\" title=\"3 link与@import的区别\"></a>3 <code>link</code>与<code>@import</code>的区别</h3><ol>\n<li> <code>link</code>是<code>HTML</code>方式， <code>@import</code>是 CSS 方式</li>\n<li> <code>link</code>最大限度支持并行下载，<code>@import</code>过多嵌套导致串行下载，出现<code>FOUC</code>(文档样式短暂失效)</li>\n<li> <code>link</code>可以通过<code>rel=&quot;alternate stylesheet&quot;</code>指定候选样式</li>\n<li> 浏览器对<code>link</code>支持早于<code>@import</code>，可以使用<code>@import</code>对老浏览器隐藏样式</li>\n<li> <code>@import</code>必须在样式规则之前，可以在 css 文件中引用其他文件</li>\n<li> 总体来说：<code>link</code>优于<code>@import</code></li>\n</ol>\n<h3 id=\"4-什么是-FOUC-如何避免\"><a href=\"#4-什么是-FOUC-如何避免\" class=\"headerlink\" title=\"4 什么是 FOUC?如何避免\"></a>4 什么是 FOUC?如何避免</h3><ul>\n<li><code>Flash Of Unstyled Content</code>：用户定义样式表加载之前浏览器使用默认样式显示文档，用户样式加载渲染之后再从新显示文档，造成页面闪烁。</li>\n<li>解决方法：把样式表放到文档的<code>&lt;head&gt;</code></li>\n</ul>\n<h3 id=\"5-如何创建块级格式化上下文-block-formatting-context-BFC-有什么用\"><a href=\"#5-如何创建块级格式化上下文-block-formatting-context-BFC-有什么用\" class=\"headerlink\" title=\"5 如何创建块级格式化上下文(block formatting context),BFC 有什么用\"></a>5 如何创建块级格式化上下文(block formatting context),BFC 有什么用</h3><ul>\n<li>创建规则：<ul>\n<li>根元素</li>\n<li>浮动元素（<code>float</code>不取值为<code>none</code>）</li>\n<li>绝对定位元素（<code>position</code>取值为<code>absolute</code>或<code>fixed</code>）</li>\n<li><code>display</code>取值为<code>inline-block</code>、<code>table-cell</code>、<code>table-caption</code>、<code>flex</code>、<code>inline-flex</code>之一的元素</li>\n<li><code>overflow</code>不取值为<code>visible</code>的元素</li>\n</ul>\n</li>\n<li>作用：<ul>\n<li>可以包含浮动元素</li>\n<li>不被浮动元素覆盖</li>\n<li>阻止父子元素的<code>margin</code>折叠</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-display、float、position-的关系\"><a href=\"#6-display、float、position-的关系\" class=\"headerlink\" title=\"6 display、float、position 的关系\"></a>6 display、float、position 的关系</h3><ul>\n<li>如果<code>display</code>取值为<code>none</code>，那么<code>position</code>和<code>float</code>都不起作用，这种情况下元素不产生框</li>\n<li>否则，如果<code>position</code>取值为<code>absolute</code>或者<code>fixed</code>，框就是绝对定位的，<code>float</code>的计算值为<code>none</code>，<code>display</code>根据下面的表格进行调整。</li>\n<li>否则，如果<code>float</code>不是<code>none</code>，框是浮动的，<code>display</code>根据下表进行调整</li>\n<li>否则，如果元素是根元素，<code>display</code>根据下表进行调整</li>\n<li>其他情况下<code>display</code>的值为指定值</li>\n<li>总结起来：绝对定位、浮动、根元素都需要调整<code>display</code></li>\n</ul>\n<h3 id=\"7-清除浮动的几种方式，各自的优缺点\"><a href=\"#7-清除浮动的几种方式，各自的优缺点\" class=\"headerlink\" title=\"7 清除浮动的几种方式，各自的优缺点\"></a>7 清除浮动的几种方式，各自的优缺点</h3><ul>\n<li>父级<code>div</code>定义<code>height</code></li>\n<li>结尾处加空<code>div</code>标签<code>clear:both</code></li>\n<li>父级<code>div</code>定义伪类<code>:after</code>和<code>zoom</code></li>\n<li>父级<code>div</code>定义<code>overflow:hidden</code></li>\n<li>父级<code>div</code>也浮动，需要定义宽度</li>\n<li>结尾处加<code>br</code>标签<code>clear:both</code></li>\n<li>比较好的是第 3 种方式，好多网站都这么用</li>\n</ul>\n<h3 id=\"8-为什么要初始化-CSS-样式\"><a href=\"#8-为什么要初始化-CSS-样式\" class=\"headerlink\" title=\"8 为什么要初始化 CSS 样式?\"></a>8 为什么要初始化 CSS 样式?</h3><ul>\n<li>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对<code>CSS</code>初始化往往会出现浏览器之间的页面显示差异。</li>\n<li>当然，初始化样式会对<code>SEO</code>有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化</li>\n</ul>\n<h3 id=\"9-css3-有哪些新特性\"><a href=\"#9-css3-有哪些新特性\" class=\"headerlink\" title=\"9 css3 有哪些新特性\"></a>9 css3 有哪些新特性</h3><ul>\n<li>新增各种<code>css</code>选择器</li>\n<li>圆角  <code>border-radius</code></li>\n<li>多列布局</li>\n<li>阴影和反射</li>\n<li>文字特效<code>text-shadow</code></li>\n<li>线性渐变</li>\n<li>旋转<code>transform</code></li>\n</ul>\n<p>CSS3 新增伪类有那些？</p>\n<ul>\n<li><code>p:first-of-type</code>  选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code>  元素。</li>\n<li><code>p:last-of-type</code>  选择属于其父元素的最后  <code>&lt;p&gt;</code>  元素的每个<code>&lt;p&gt;</code>  元素。</li>\n<li><code>p:only-of-type</code>  选择属于其父元素唯一的  <code>&lt;p&gt;</code>元素的每个  <code>&lt;p&gt;</code>  元素。</li>\n<li><code>p:only-child</code>  选择属于其父元素的唯一子元素的每个  <code>&lt;p&gt;</code>  元素。</li>\n<li><code>p:nth-child(2)</code>  选择属于其父元素的第二个子元素的每个  <code>&lt;p&gt;</code>  元素。</li>\n<li><code>:after</code>  在元素之前添加内容,也可以用来做清除浮动。</li>\n<li><code>:before</code>  在元素之后添加内容。</li>\n<li><code>:enabled</code>  已启用的表单元素。</li>\n<li><code>:disabled</code>  已禁用的表单元素。</li>\n<li><code>:checked</code>  单选框或复选框被选中。</li>\n</ul>\n<h3 id=\"10-display-有哪些值？说明他们的作用\"><a href=\"#10-display-有哪些值？说明他们的作用\" class=\"headerlink\" title=\"10 display 有哪些值？说明他们的作用\"></a>10 display 有哪些值？说明他们的作用</h3><ul>\n<li><code>block</code>  转换成块状元素。</li>\n<li><code>inline</code>  转换成行内元素。</li>\n<li><code>none</code>  设置元素不可见。</li>\n<li><code>inline-block</code>  象行内元素一样显示，但其内容象块类型元素一样显示。</li>\n<li><code>list-item</code>  象块类型元素一样显示，并添加样式列表标记。</li>\n<li><code>table</code>  此元素会作为块级表格来显示</li>\n<li><code>inherit</code>  规定应该从父元素继承  <code>display</code>  属性的值</li>\n</ul>\n<h3 id=\"11-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？\"><a href=\"#11-介绍一下标准的-CSS-的盒子模型？低版本-IE-的盒子模型有什么不同的？\" class=\"headerlink\" title=\"11 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？\"></a>11 介绍一下标准的 CSS 的盒子模型？低版本 IE 的盒子模型有什么不同的？</h3><ul>\n<li>有两种， <code>IE</code>盒子模型、<code>W3C</code>盒子模型；</li>\n<li>盒模型： 内容(content)、填充(<code>padding</code>)、边界(<code>margin</code>)、 边框(<code>border</code>)；</li>\n<li>区 别： <code>IE</code>的 c<code>ontent</code>部分把  <code>border</code>  和  <code>padding</code>计算了进去;</li>\n</ul>\n<h3 id=\"12-CSS-优先级算法如何计算？\"><a href=\"#12-CSS-优先级算法如何计算？\" class=\"headerlink\" title=\"12 CSS 优先级算法如何计算？\"></a>12 CSS 优先级算法如何计算？</h3><ul>\n<li>优先级就近原则，同权重情况下样式定义最近者为准</li>\n<li>载入样式以最后载入的定位为准</li>\n<li>优先级为: <code>!important &gt; id &gt; class &gt; tag</code>; <code>!important</code>  比 内联优先级高</li>\n</ul>\n<h3 id=\"13-对-BFC-规范的理解？\"><a href=\"#13-对-BFC-规范的理解？\" class=\"headerlink\" title=\"13 对 BFC 规范的理解？\"></a>13 对 BFC 规范的理解？</h3><ul>\n<li>它决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用</li>\n</ul>\n<h3 id=\"14-谈谈浮动和清除浮动\"><a href=\"#14-谈谈浮动和清除浮动\" class=\"headerlink\" title=\"14 谈谈浮动和清除浮动\"></a>14 谈谈浮动和清除浮动</h3><ul>\n<li>浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上</li>\n</ul>\n<h3 id=\"15-position-的值，-relative-和-absolute-定位原点是\"><a href=\"#15-position-的值，-relative-和-absolute-定位原点是\" class=\"headerlink\" title=\"15 position 的值， relative 和 absolute 定位原点是\"></a>15 position 的值， relative 和 absolute 定位原点是</h3><ul>\n<li><code>absolute</code>：生成绝对定位的元素，相对于  <code>static</code>  定位以外的第一个父元素进行定位</li>\n<li><code>fixed</code>：生成绝对定位的元素，相对于浏览器窗口进行定位</li>\n<li><code>relative</code>：生成相对定位的元素，相对于其正常位置进行定位</li>\n<li><code>static</code>  默认值。没有定位，元素出现在正常的流中</li>\n<li><code>inherit</code>  规定从父元素继承  <code>position</code>  属性的值</li>\n</ul>\n<h3 id=\"16-display-inline-block-什么时候不会显示间隙？-携程\"><a href=\"#16-display-inline-block-什么时候不会显示间隙？-携程\" class=\"headerlink\" title=\"16 display:inline-block 什么时候不会显示间隙？(携程)\"></a>16 display:inline-block 什么时候不会显示间隙？(携程)</h3><ul>\n<li>移除空格</li>\n<li>使用<code>margin</code>负值</li>\n<li>使用<code>font-size:0</code></li>\n<li><code>letter-spacing</code></li>\n<li><code>word-spacing</code></li>\n</ul>\n<h3 id=\"17-PNG-GIF-JPG-的区别及如何选\"><a href=\"#17-PNG-GIF-JPG-的区别及如何选\" class=\"headerlink\" title=\"17 PNG\\GIF\\JPG 的区别及如何选\"></a>17 PNG\\GIF\\JPG 的区别及如何选</h3><ul>\n<li><code>GIF</code><ul>\n<li><code>8</code>位像素，<code>256</code>色</li>\n<li>无损压缩</li>\n<li>支持简单动画</li>\n<li>支持<code>boolean</code>透明</li>\n<li>适合简单动画</li>\n</ul>\n</li>\n<li><code>JPEG</code><ul>\n<li>颜色限于<code>256</code></li>\n<li>有损压缩</li>\n<li>可控制压缩质量</li>\n<li>不支持透明</li>\n<li>适合照片</li>\n</ul>\n</li>\n<li><code>PNG</code><ul>\n<li>有<code>PNG8</code>和<code>truecolor PNG</code></li>\n<li><code>PNG8</code>类似<code>GIF</code>颜色上限为<code>256</code>，文件小，支持<code>alpha</code>透明度，无动画</li>\n<li>适合图标、背景、按钮</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"18-行内元素-float-left-后是否变为块级元素？\"><a href=\"#18-行内元素-float-left-后是否变为块级元素？\" class=\"headerlink\" title=\"18 行内元素 float:left 后是否变为块级元素？\"></a>18 行内元素 float:left 后是否变为块级元素？</h3><blockquote>\n<p>行内元素设置成浮动之后变得更加像是<code>inline-block</code>（行内块级元素，设置成这个属性的元素会同时拥有行内和块级的特性，最明显的不同是它的默认宽度不是<code>100%</code>），这时候给行内元素设置<code>padding-top</code>和<code>padding-bottom</code>或者<code>width</code>、<code>height</code>都是有效果的</p>\n</blockquote>\n<h3 id=\"19-在网页中的应该使用奇数还是偶数的字体？为什么呢？\"><a href=\"#19-在网页中的应该使用奇数还是偶数的字体？为什么呢？\" class=\"headerlink\" title=\"19 在网页中的应该使用奇数还是偶数的字体？为什么呢？\"></a>19 在网页中的应该使用奇数还是偶数的字体？为什么呢？</h3><ul>\n<li>偶数字号相对更容易和 web 设计的其他部分构成比例关系</li>\n</ul>\n<h3 id=\"20-before-和-after-中双冒号和单冒号-有什么区别？解释一下这-2-个伪元素的作用\"><a href=\"#20-before-和-after-中双冒号和单冒号-有什么区别？解释一下这-2-个伪元素的作用\" class=\"headerlink\" title=\"20 ::before 和 :after 中双冒号和单冒号 有什么区别？解释一下这 2 个伪元素的作用\"></a>20 ::before 和 :after 中双冒号和单冒号 有什么区别？解释一下这 2 个伪元素的作用</h3><ul>\n<li>单冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素</li>\n<li>用于区分伪类和伪元素</li>\n</ul>\n<h3 id=\"21-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）\"><a href=\"#21-如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）\" class=\"headerlink\" title=\"21 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）\"></a>21 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里）</h3><ul>\n<li>多数显示器默认频率是<code>60Hz</code>，即<code>1</code>秒刷新<code>60</code>次，所以理论上最小间隔为<code>1/60*1000ms ＝ 16.7ms</code></li>\n</ul>\n<h3 id=\"22-CSS-合并方法\"><a href=\"#22-CSS-合并方法\" class=\"headerlink\" title=\"22 CSS 合并方法\"></a>22 CSS 合并方法</h3><ul>\n<li>避免使用<code>@import</code>引入多个<code>css</code>文件，可以使用<code>CSS</code>工具将<code>CSS</code>合并为一个<code>CSS</code>文件，例如使用<code>Sass\\Compass</code>等</li>\n</ul>\n<h3 id=\"23-CSS-不同选择器的权重-CSS-层叠的规则\"><a href=\"#23-CSS-不同选择器的权重-CSS-层叠的规则\" class=\"headerlink\" title=\"23 CSS 不同选择器的权重(CSS 层叠的规则)\"></a>23 CSS 不同选择器的权重(CSS 层叠的规则)</h3><ul>\n<li><code>！important</code>规则最重要，大于其它规则</li>\n<li>行内样式规则，加<code>1000</code></li>\n<li>对于选择器中给定的各个<code>ID</code>属性值，加<code>100</code></li>\n<li>对于选择器中给定的各个类属性、属性选择器或者伪类选择器，加<code>10</code></li>\n<li>对于选择其中给定的各个元素标签选择器，加 1</li>\n<li>如果权值一样，则按照样式规则的先后顺序来应用，顺序靠后的覆盖靠前的规则</li>\n</ul>\n<h3 id=\"24-列出你所知道可以改变页面布局的属性\"><a href=\"#24-列出你所知道可以改变页面布局的属性\" class=\"headerlink\" title=\"24 列出你所知道可以改变页面布局的属性\"></a>24 列出你所知道可以改变页面布局的属性</h3><ul>\n<li><code>position</code>、<code>display</code>、<code>float</code>、<code>width</code>、<code>height</code>、<code>margin</code>、<code>padding</code>、<code>top</code>、<code>left</code>、<code>right</code>、`</li>\n</ul>\n<h3 id=\"25-CSS-在性能优化方面的实践\"><a href=\"#25-CSS-在性能优化方面的实践\" class=\"headerlink\" title=\"25 CSS 在性能优化方面的实践\"></a>25 CSS 在性能优化方面的实践</h3><ul>\n<li><code>css</code>压缩与合并、<code>Gzip</code>压缩</li>\n<li><code>css</code>文件放在<code>head</code>里、不要用<code>@import</code></li>\n<li>尽量用缩写、避免用滤镜、合理使用选择器</li>\n</ul>\n<h3 id=\"26-CSS3-动画（简单动画的实现，如旋转等）\"><a href=\"#26-CSS3-动画（简单动画的实现，如旋转等）\" class=\"headerlink\" title=\"26 CSS3 动画（简单动画的实现，如旋转等）\"></a>26 CSS3 动画（简单动画的实现，如旋转等）</h3><ul>\n<li>依靠<code>CSS3</code>中提出的三个属性：<code>transition</code>、<code>transform</code>、<code>animation</code></li>\n<li><code>transition</code>：定义了元素在变化过程中是怎么样的，包含<code>transition-property</code>、<code>transition-duration</code>、<code>transition-timing-function</code>、<code>transition-delay</code>。</li>\n<li><code>transform</code>：定义元素的变化结果，包含<code>rotate</code>、<code>scale</code>、<code>skew</code>、<code>translate</code>。</li>\n<li><code>animation</code>：动画定义了动作的每一帧（<code>@keyframes</code>）有什么效果，包括<code>animation-name</code>，<code>animation-duration</code>、<code>animation-timing-function</code>、<code>animation-delay</code>、<code>animation-iteration-count</code>、<code>animation-direction</code></li>\n</ul>\n<h3 id=\"27-base64-的原理及优缺点\"><a href=\"#27-base64-的原理及优缺点\" class=\"headerlink\" title=\"27 base64 的原理及优缺点\"></a>27 base64 的原理及优缺点</h3><ul>\n<li>优点可以加密，减少了<code>HTTTP</code>请求</li>\n<li>缺点是需要消耗<code>CPU</code>进行编解码</li>\n</ul>\n<h3 id=\"28-几种常见的-CSS-布局\"><a href=\"#28-几种常见的-CSS-布局\" class=\"headerlink\" title=\"28 几种常见的 CSS 布局\"></a>28 几种常见的 CSS 布局</h3><h4 id=\"流体布局\"><a href=\"#流体布局\" class=\"headerlink\" title=\"流体布局\"></a>流体布局</h4><pre><code>.left &#123;\n    float: left;\n    width: 100px;\n    height: 200px;\n    background: red;\n&#125;\n.right &#123;\n    float: right;\n    width: 200px;\n    height: 200px;\n    background: blue;\n&#125;\n.main &#123;\n    margin-left: 120px;\n    margin-right: 220px;\n    height: 200px;\n    background: green;\n&#125;\n</code></pre>\n<p><div class=\"container\"><br>    <div class=\"left\"></div><br>    <div class=\"right\"></div><br>    <div class=\"main\"></div></div></p>\n<h4 id=\"圣杯布局\"><a href=\"#圣杯布局\" class=\"headerlink\" title=\"圣杯布局\"></a>圣杯布局</h4><p>.container {<br>    margin-left: 120px;<br>    margin-right: 220px;}.main {<br>    float: left;<br>    width: 100%;<br>    height:300px;<br>    background: green;}.left {<br>    position: relative;<br>    left: -120px;<br>    float: left;<br>    height: 300px;<br>    width: 100px;<br>    margin-left: -100%;<br>    background: red;}.right {<br>    position: relative;<br>    right: -220px;<br>    float: right;<br>    height: 300px;<br>    width: 200px;<br>    margin-left: -200px;<br>    background: blue;}</p>\n<p><div class=\"container\"><br>    <div class=\"main\"></div><br>    <div class=\"left\"></div><br>    <div class=\"right\"></div></div></p>\n<h4 id=\"双飞翼布局\"><a href=\"#双飞翼布局\" class=\"headerlink\" title=\"双飞翼布局\"></a>双飞翼布局</h4><p>.content {<br>    float: left;<br>    width: 100%;}.main {<br>    height: 200px;<br>    margin-left: 110px;<br>    margin-right: 220px;<br>    background: green;}.main::after {<br>    content: ‘’;<br>    display: block;<br>    font-size:0;<br>    height: 0;<br>    zoom: 1;<br>    clear: both;}.left {<br>    float:left;<br>    height: 200px;<br>    width: 100px;<br>    margin-left: -100%;<br>    background: red;}.right {<br>    float: right;<br>    height: 200px;<br>    width: 200px;<br>    margin-left: -200px;<br>    background: blue;}</p>\n<p><div class=\"content\"><br>    <div class=\"main\"></div></div><div class=\"left\"></div><div class=\"right\"></div></p>\n<h3 id=\"29-stylus-sass-less-区别\"><a href=\"#29-stylus-sass-less-区别\" class=\"headerlink\" title=\"29 stylus/sass/less 区别\"></a>29 stylus/sass/less 区别</h3><ul>\n<li>均具有“变量”、“混合”、“嵌套”、“继承”、“颜色混合”五大基本特性</li>\n<li><code>Scss</code>和<code>LESS</code>语法较为严谨，<code>LESS</code>要求一定要使用大括号“{}”，<code>Scss</code>和<code>Stylus</code>可以通过缩进表示层次与嵌套关系</li>\n<li><code>Scss</code>无全局变量的概念，<code>LESS</code>和<code>Stylus</code>有类似于其它语言的作用域概念</li>\n<li><code>Sass</code>是基于<code>Ruby</code>语言的，而<code>LESS</code>和<code>Stylus</code>可以基于<code>NodeJS</code> <code>NPM</code>下载相应库后进行编译；</li>\n</ul>\n<h3 id=\"30-postcss-的作用\"><a href=\"#30-postcss-的作用\" class=\"headerlink\" title=\"30 postcss 的作用\"></a>30 postcss 的作用</h3><ul>\n<li>可以直观的理解为：它就是一个平台。为什么说它是一个平台呢？因为我们直接用它，感觉不能干什么事情，但是如果让一些插件在它上面跑，那么将会很强大</li>\n<li><code>PostCSS</code>  提供了一个解析器，它能够将  <code>CSS</code>  解析成抽象语法树</li>\n<li>通过在  <code>PostCSS</code>  这个平台上，我们能够开发一些插件，来处理我们的<code>CSS</code>，比如热门的：<code>autoprefixer</code></li>\n<li><code>postcss</code>可以对 sass 处理过后的<code>css</code>再处理 最常见的就是<code>autoprefixer</code></li>\n</ul>\n<h3 id=\"31-css-样式（选择器）的优先级\"><a href=\"#31-css-样式（选择器）的优先级\" class=\"headerlink\" title=\"31 css 样式（选择器）的优先级\"></a>31 css 样式（选择器）的优先级</h3><ul>\n<li>计算权重确定</li>\n<li><code>!important</code></li>\n<li>内联样式</li>\n<li>后写的优先级高</li>\n</ul>\n<h3 id=\"32-自定义字体的使用场景\"><a href=\"#32-自定义字体的使用场景\" class=\"headerlink\" title=\"32 自定义字体的使用场景\"></a>32 自定义字体的使用场景</h3><ul>\n<li>宣传/品牌/<code>banner</code>等固定文案</li>\n<li>字体图标</li>\n</ul>\n<h3 id=\"33-如何美化-CheckBox\"><a href=\"#33-如何美化-CheckBox\" class=\"headerlink\" title=\"33 如何美化 CheckBox\"></a>33 如何美化 CheckBox</h3><ul>\n<li><code>&lt;label&gt;</code>  属性  <code>for</code>  和  <code>id</code></li>\n<li>隐藏原生的  <code>&lt;input&gt;</code></li>\n<li><code>:checked + &lt;label&gt;</code></li>\n</ul>\n<h3 id=\"34-伪类和伪元素的区别\"><a href=\"#34-伪类和伪元素的区别\" class=\"headerlink\" title=\"34 伪类和伪元素的区别\"></a>34 伪类和伪元素的区别</h3><ul>\n<li>伪类表状态</li>\n<li>伪元素是真的有元素</li>\n<li>前者单冒号，后者双冒号</li>\n</ul>\n<h3 id=\"35-base64的使用\"><a href=\"#35-base64的使用\" class=\"headerlink\" title=\"35 base64的使用\"></a>35 <code>base64</code>的使用</h3><ul>\n<li>用于减少  <code>HTTP</code>  请求</li>\n<li>适用于小图片</li>\n<li><code>base64</code>的体积约为原图的<code>4/3</code></li>\n</ul>\n<h3 id=\"36-自适应布局\"><a href=\"#36-自适应布局\" class=\"headerlink\" title=\"36 自适应布局\"></a>36 自适应布局</h3><p>思路：</p>\n<ul>\n<li>左侧浮动或者绝对定位，然后右侧<code>margin</code>撑开</li>\n<li>使用<code>&lt;div&gt;</code>包含，然后靠负<code>margin</code>形成<code>bfc</code></li>\n<li>使用<code>flex</code></li>\n</ul>\n<h3 id=\"37-请用-CSS-写一个简单的幻灯片效果页面\"><a href=\"#37-请用-CSS-写一个简单的幻灯片效果页面\" class=\"headerlink\" title=\"37 请用 CSS 写一个简单的幻灯片效果页面\"></a>37 请用 CSS 写一个简单的幻灯片效果页面</h3><blockquote>\n<p>知道是要用<code>CSS3</code>。使用<code>animation</code>动画实现一个简单的幻灯片效果</p>\n</blockquote>\n<p>/**css**/.ani{<br>  width:480px;<br>  height:320px;<br>  margin:50px auto;<br>  overflow: hidden;<br>  box-shadow:0 0 5px rgba(0,0,0,1);<br>  background-size: cover;<br>  background-position: center;<br>  -webkit-animation-name: “loops”;<br>  -webkit-animation-duration: 20s;<br>  -webkit-animation-iteration-count: infinite;}@-webkit-keyframes “loops” {<br>    0% {<br>        background:url(<a href=\"http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg\">http://d.hiphotos.baidu.com/image/w%3D400/sign=c01e6adca964034f0fcdc3069fc27980/e824b899a9014c08e5e38ca4087b02087af4f4d3.jpg</a>) no-repeat;             <br>    }<br>    25% {<br>        background:url(<a href=\"http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg\">http://b.hiphotos.baidu.com/image/w%3D400/sign=edee1572e9f81a4c2632edc9e72b6029/30adcbef76094b364d72bceba1cc7cd98c109dd0.jpg</a>) no-repeat;<br>    }<br>    50% {<br>        background:url(<a href=\"http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg\">http://b.hiphotos.baidu.com/image/w%3D400/sign=937dace2552c11dfded1be2353266255/d8f9d72a6059252d258e7605369b033b5bb5b912.jpg</a>) no-repeat;<br>    }<br>    75% {<br>        background:url(<a href=\"http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg\">http://g.hiphotos.baidu.com/image/w%3D400/sign=7d37500b8544ebf86d71653fe9f9d736/0df431adcbef76095d61f0972cdda3cc7cd99e4b.jpg</a>) no-repeat;<br>    }<br>    100% {<br>        background:url(<a href=\"http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg\">http://c.hiphotos.baidu.com/image/w%3D400/sign=cfb239ceb0fb43161a1f7b7a10a54642/3b87e950352ac65ce2e73f76f9f2b21192138ad1.jpg</a>) no-repeat;<br>    }}</p>\n<h3 id=\"38-什么是外边距重叠？重叠的结果是什么？\"><a href=\"#38-什么是外边距重叠？重叠的结果是什么？\" class=\"headerlink\" title=\"38 什么是外边距重叠？重叠的结果是什么？\"></a>38 什么是外边距重叠？重叠的结果是什么？</h3><blockquote>\n<p>外边距重叠就是 margin-collapse</p>\n</blockquote>\n<ul>\n<li>在 CSS 当中，相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。这种合并外边距的方式被称为折叠，并且因而所结合成的外边距称为折叠外边距。</li>\n</ul>\n<p>折叠结果遵循下列计算规则：</p>\n<ul>\n<li>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。</li>\n<li>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。</li>\n<li>两个外边距一正一负时，折叠结果是两者的相加的和。</li>\n</ul>\n<h3 id=\"39-rgba-和-opacity-的透明效果有什么不同？\"><a href=\"#39-rgba-和-opacity-的透明效果有什么不同？\" class=\"headerlink\" title=\"39 rgba()和 opacity 的透明效果有什么不同？\"></a>39 rgba()和 opacity 的透明效果有什么不同？</h3><ul>\n<li><code>rgba()</code>和<code>opacity</code>都能实现透明效果，但最大的不同是<code>opacity</code>作用于元素，以及元素内的所有内容的透明度，</li>\n<li>而<code>rgba()</code>只作用于元素的颜色或其背景色。（设置<code>rgba</code>透明的元素的子元素不会继承透明效果！）</li>\n</ul>\n<h3 id=\"40-css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？\"><a href=\"#40-css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？\" class=\"headerlink\" title=\"40 css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？\"></a>40 css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h3><ul>\n<li>垂直方向：<code>line-height</code></li>\n<li>水平方向：<code>letter-spacing</code></li>\n</ul>\n<h3 id=\"41-如何垂直居中一个浮动元素？\"><a href=\"#41-如何垂直居中一个浮动元素？\" class=\"headerlink\" title=\"41 如何垂直居中一个浮动元素？\"></a>41 如何垂直居中一个浮动元素？</h3><p>/<strong>方法一：已知元素的高宽</strong>/#div1{<br>  background-color:#6699FF;<br>  width:200px;<br>  height:200px;<br>  position: absolute;        //父元素需要相对定位   top: 50%;<br>  left: 50%;<br>  margin-top:-100px ;   //二分之一的 height，width  margin-left: -100px;}/<strong>方法二:</strong>/#div1{<br>  width: 200px;<br>  height: 200px;<br>  background-color: #6699FF;<br>  margin:auto;<br>  position: absolute;        //父元素需要相对定位   left: 0;<br>  top: 0;<br>  right: 0;<br>  bottom: 0;}</p>\n<p>如何垂直居中一个<code>&lt;img&gt;</code>?（用更简便的方法。）</p>\n<p>#container     /<strong><img>的容器设置如下</strong>/{<br>    display:table-cell;<br>    text-align:center;<br>    vertical-align:middle;}</p>\n<h3 id=\"42-px-和-em-的区别\"><a href=\"#42-px-和-em-的区别\" class=\"headerlink\" title=\"42 px 和 em 的区别\"></a>42 px 和 em 的区别</h3><ul>\n<li><code>px</code>和<code>em</code>都是长度单位，区别是，<code>px</code>的值是固定的，指定是多少就是多少，计算比较容易。<code>em</code>得值不是固定的，并且<code>em</code>会继承父级元素的字体大小。</li>\n<li>浏览器的默认字体高都是<code>16px</code>。所以未经调整的浏览器都符合: <code>1em=16px</code>。那么<code>12px=0.75em</code>, <code>10px=0.625em</code>。</li>\n</ul>\n<h3 id=\"43-Sass、LESS-是什么？大家为什么要使用他们？\"><a href=\"#43-Sass、LESS-是什么？大家为什么要使用他们？\" class=\"headerlink\" title=\"43 Sass、LESS 是什么？大家为什么要使用他们？\"></a>43 Sass、LESS 是什么？大家为什么要使用他们？</h3><ul>\n<li>他们是<code>CSS</code>预处理器。他是<code>CSS</code>上的一种抽象层。他们是一种特殊的语法/语言编译成<code>CSS</code>。</li>\n<li>例如 Less 是一种动态样式语言. 将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数. <code>LESS</code>  既可以在客户端上运行 (支持<code>IE 6+</code>, <code>Webkit</code>, <code>Firefox</code>)，也可一在服务端运行 (借助  <code>Node.js</code>)</li>\n</ul>\n<p>为什么要使用它们？</p>\n<ul>\n<li>结构清晰，便于扩展。</li>\n<li>可以方便地屏蔽浏览器私有语法差异。这个不用多说，封装对- 浏览器语法差异的重复处理，减少无意义的机械劳动。</li>\n<li>可以轻松实现多重继承。</li>\n<li>完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只- 是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译</li>\n</ul>\n<h3 id=\"44-知道-css-有个-content-属性吗？有什么作用？有什么应用？\"><a href=\"#44-知道-css-有个-content-属性吗？有什么作用？有什么应用？\" class=\"headerlink\" title=\"44 知道 css 有个 content 属性吗？有什么作用？有什么应用？\"></a>44 知道 css 有个 content 属性吗？有什么作用？有什么应用？</h3><blockquote>\n<p>css 的<code>content</code>属性专门应用在  <code>before/after</code>伪元素上，用于来插入生成内容。最常见的应用是利用伪类清除浮动。</p>\n</blockquote>\n<p>/<strong>一种常见利用伪类清除浮动的代码</strong>/.clearfix:after {<br>    content:”.”;       //这里利用到了 content 属性     display:block;<br>    height:0;<br>    visibility:hidden;<br>    clear:both; <br> }.clearfix {<br>    *zoom:1;}</p>\n<h3 id=\"45-水平居中的方法\"><a href=\"#45-水平居中的方法\" class=\"headerlink\" title=\"45 水平居中的方法\"></a>45 水平居中的方法</h3><ul>\n<li>元素为行内元素，设置父元素<code>text-align:center</code></li>\n<li>如果元素宽度固定，可以设置左右<code>margin</code>为<code>auto</code>;</li>\n<li>如果元素为绝对定位，设置父元素<code>position</code>为<code>relative</code>，元素设<code>left:0;right:0;margin:auto;</code></li>\n<li>使用<code>flex-box</code>布局，指定<code>justify-content</code>属性为 center</li>\n<li><code>display</code>设置为<code>tabel-ceil</code></li>\n</ul>\n<h3 id=\"46-垂直居中的方法\"><a href=\"#46-垂直居中的方法\" class=\"headerlink\" title=\"46 垂直居中的方法\"></a>46 垂直居中的方法</h3><ul>\n<li>将显示方式设置为表格，<code>display:table-cell</code>,同时设置<code>vertial-align：middle</code></li>\n<li>使用<code>flex</code>布局，设置为<code>align-item：center</code></li>\n<li>绝对定位中设置<code>bottom:0,top:0</code>,并设置<code>margin:auto</code></li>\n<li>绝对定位中固定高度时设置<code>top:50%，margin-top</code>值为高度一半的负值</li>\n<li>文本垂直居中设置<code>line-height</code>为<code>height</code>值</li>\n</ul>\n<h3 id=\"47-如何使用-CSS-实现硬件加速？\"><a href=\"#47-如何使用-CSS-实现硬件加速？\" class=\"headerlink\" title=\"47 如何使用 CSS 实现硬件加速？\"></a>47 如何使用 CSS 实现硬件加速？</h3><blockquote>\n<p>硬件加速是指通过创建独立的复合图层，让 GPU 来渲染这个图层，从而提高性能，</p>\n</blockquote>\n<ul>\n<li>一般触发硬件加速的<code>CSS</code>属性有<code>transform</code>、<code>opacity</code>、<code>filter</code>，为了避免 2D 动画在 开始和结束的时候的<code>repaint</code>操作，一般使用<code>tranform:translateZ(0)</code></li>\n</ul>\n<h3 id=\"48-重绘和回流（重排）是什么，如何避免？\"><a href=\"#48-重绘和回流（重排）是什么，如何避免？\" class=\"headerlink\" title=\"48 重绘和回流（重排）是什么，如何避免？\"></a>48 重绘和回流（重排）是什么，如何避免？</h3><ul>\n<li>DOM 的变化影响到了元素的几何属性（宽高）,浏览器重新计算元素的几何属性，其他元素的几何</li>\n<li>属性和位置也会受到影响，浏览器需要重新构造渲染树，这个过程称为重排，浏览器将受到影响的部分</li>\n<li>重新绘制到屏幕上的过程称为重绘。引起重排的原因有<ul>\n<li>添加或者删除可见的 DOM 元素，</li>\n<li>元素位置、尺寸、内容改变，</li>\n<li>浏览器页面初始化，</li>\n<li>浏览器窗口尺寸改变，重排一定重绘，重绘不一定重排，</li>\n</ul>\n</li>\n</ul>\n<p>减少重绘和重排的方法：</p>\n<ul>\n<li>不在布局信息改变时做<code>DOM</code>查询</li>\n<li>使用<code>cssText</code>或者<code>className</code>一次性改变属性</li>\n<li>使用<code>fragment</code></li>\n<li>对于多次重排的元素，如动画，使用绝对定位脱离文档流，让他的改变不影响到其他元素</li>\n</ul>\n<h3 id=\"49-说一说-css3-的-animation\"><a href=\"#49-说一说-css3-的-animation\" class=\"headerlink\" title=\"49 说一说 css3 的 animation\"></a>49 说一说 css3 的 animation</h3><ul>\n<li>css3 的<code>animation</code>是 css3 新增的动画属性，这个 css3 动画的每一帧是通过<code>@keyframes</code>来声明的，<code>keyframes</code>声明了动画的名称，通过<code>from</code>、<code>to</code>或者是百分比来定义</li>\n<li>每一帧动画元素的状态，通过<code>animation-name</code>来引用这个动画，同时 css3 动画也可以定义动画运行的时长、动画开始时间、动画播放方向、动画循环次数、动画播放的方式，</li>\n<li>这些相关的动画子属性有：<code>animation-name</code>定义动画名、<code>animation-duration</code>定义动画播放的时长、<code>animation-delay</code>定义动画延迟播放的时间、<code>animation-direction</code>定义 动画的播放方向、<code>animation-iteration-count</code>定义播放次数、<code>animation-fill-mode</code>定义动画播放之后的状态、<code>animation-play-state</code>定义播放状态，如暂停运行等、<code>animation-timing-function</code></li>\n<li>定义播放的方式，如恒速播放、艰涩播放等。</li>\n</ul>\n<h3 id=\"50-左边宽度固定，右边自适应\"><a href=\"#50-左边宽度固定，右边自适应\" class=\"headerlink\" title=\"50 左边宽度固定，右边自适应\"></a>50 左边宽度固定，右边自适应</h3><blockquote>\n<p>左侧固定宽度，右侧自适应宽度的两列布局实现</p>\n</blockquote>\n<p>html 结构</p>\n<p><div class=\"outer\"><br>    <div class=\"left\">固定宽度</div><br>    <div class=\"right\">自适应宽度</div></div></p>\n<blockquote>\n<p>在外层<code>div</code>（类名为<code>outer</code>）的<code>div</code>中，有两个子<code>div</code>，类名分别为<code>left</code>和<code>right</code>，其中<code>left</code>为固定宽度，而<code>right</code>为自适应宽度</p>\n</blockquote>\n<p>方法 1：左侧 div 设置成浮动：float: left，右侧 div 宽度会自拉升适应</p>\n<p>.outer {<br>    width: 100%;<br>    height: 500px;<br>    background-color: yellow;}.left {<br>    width: 200px;<br>    height: 200px;<br>    background-color: red;<br>    float: left;}.right {<br>    height: 200px;<br>    background-color: blue;}</p>\n<p>方法 2：对右侧:div 进行绝对定位，然后再设置 right=0，即可以实现宽度自适应</p>\n<blockquote>\n<p>绝对定位元素的第一个高级特性就是其具有自动伸缩的功能，当我们将  <code>width</code>设置为  <code>auto</code>  的时候（或者不设置，默认为  <code>auto</code> ），绝对定位元素会根据其  <code>left</code>  和  <code>right</code>  自动伸缩其大小</p>\n</blockquote>\n<p>.outer {<br>    width: 100%;<br>    height: 500px;<br>    background-color: yellow;<br>    position: relative;}.left {<br>    width: 200px;<br>    height: 200px;<br>    background-color: red;}.right {<br>    height: 200px;<br>    background-color: blue;<br>    position: absolute;<br>    left: 200px;<br>    top:0;          <br>    right: 0;}</p>\n<p>方法 3：将左侧 div 进行绝对定位，然后右侧 div 设置 margin-left: 200px</p>\n<p>.outer {<br>    width: 100%;<br>    height: 500px;<br>    background-color: yellow;<br>    position: relative;}.left {<br>    width: 200px;<br>    height: 200px;<br>    background-color: red;<br>    position: absolute;}.right {<br>    height: 200px;<br>    background-color: blue;<br>    margin-left: 200px;}</p>\n<p>方法 4：使用 flex 布局</p>\n<p>.outer {<br>    width: 100%;<br>    height: 500px;<br>    background-color: yellow;<br>    display: flex;<br>    flex-direction: row;}.left {<br>    width: 200px;<br>    height: 200px;<br>    background-color: red;}.right {<br>    height: 200px;<br>    background-color: blue;<br>    flex: 1;}</p>\n<h3 id=\"51-两种以上方式实现已知或者未知宽度的垂直水平居中\"><a href=\"#51-两种以上方式实现已知或者未知宽度的垂直水平居中\" class=\"headerlink\" title=\"#51 两种以上方式实现已知或者未知宽度的垂直水平居中\"></a><a href=\"http://blog.poetries.top/FE-Interview-Questions/base/#_51-%E4%B8%A4%E7%A7%8D%E4%BB%A5%E4%B8%8A%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%B7%B2%E7%9F%A5%E6%88%96%E8%80%85%E6%9C%AA%E7%9F%A5%E5%AE%BD%E5%BA%A6%E7%9A%84%E5%9E%82%E7%9B%B4%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD\">#</a>51 两种以上方式实现已知或者未知宽度的垂直水平居中</h3><p>/** 1 <strong>/.wraper {<br>  position: relative;<br>  .box {<br>    position: absolute;<br>    top: 50%;<br>    left: 50%;<br>    width: 100px;<br>    height: 100px;<br>    margin: -50px 0 0 -50px;<br>  }}/</strong> 2 <strong>/.wraper {<br>  position: relative;<br>  .box {<br>    position: absolute;<br>    top: 50%;<br>    left: 50%;<br>    transform: translate(-50%, -50%);<br>  }}/</strong> 3 <strong>/.wraper {<br>  .box {<br>    display: flex;<br>    justify-content:center;<br>    align-items: center;<br>    height: 100px;<br>  }}/</strong> 4 **/.wraper {<br>  display: table;<br>  .box {<br>    display: table-cell;<br>    vertical-align: middle;<br>  }}</p>\n<h3 id=\"52-如何实现小于-12px-的字体效果\"><a href=\"#52-如何实现小于-12px-的字体效果\" class=\"headerlink\" title=\"52 如何实现小于 12px 的字体效果\"></a>52 如何实现小于 12px 的字体效果</h3><blockquote>\n<p><code>transform:scale()</code>这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个<code>display:inline-block</code>;</p>\n</blockquote>\n<p>transform: scale(0.7);</p>\n<p><code>css</code>的属性，可以缩放大小</p>\n"},{"title":"大型项目前端架构详谈","url":"177.html","id":"177","date":"2019-06-24T12:07:33.000Z","_content":"\n目录：\n\n*   1、综合\n*   1.1、使用场景\n*   1.2、核心思想\n*   1.3、切入角度\n*   1.4、其他\n*   2、基础层设计\n*   2.1、自建Gitlab\n*   2.2、版本管理\n*   2.3、自动编译发布Jenkins\n*   2.4、纯前端版本发布\n*   2.5、统一脚手架\n*   2.6、Node中间层\n*   2.7、埋点系统\n*   2.8、监控和报警系统\n*   2.9、安全管理\n*   2.10、Eslint\n*   2.11、灰度发布\n*   2.12、前后端分离\n*   2.13、Mock\n*   2.14、定期备份\n*   3、应用层设计\n*   3.1、多页和单页\n*   3.2、以应用为单位划分前端项目\n*   3.3、基础组件库的建设\n*   3.4、技术栈统一\n*   3.5、浏览器兼容\n*   3.6、内容平_台建设\n*   3.7、权限管理平_台\n*   3.8、登录系统设计（单点登录）\n*   3.9、CDN\n*   3.10、负载均衡\n*   3.11、多端共用一套接口\n*   4、总结\n\n1、综合\n----\n\n我在2年之前，写过一篇中小型项目的前端架构浅谈。随着能力的上升，以及在阿里巴巴工作的经验，是时候写一篇大型项目的前端架构分析了。 本篇文章不会更多侧重于具体技术实现，而是尝试从更高角度出发，分析为什么要这么做，这些设计能解决什么问题，成本和收益如何。 由于作者能力有限，可能会有所缺漏或者部分错误，欢迎读者指出。\n\n### 1.1、适用场景：\n\n本篇文章，适用于单个/多个大型项目、拥有超过10个以上的前端开发的场景。 前端项目的规模不同，成本收益比也会有所差别。通常来说，人员越多、项目复杂度越高，那么收益/成本的比值越大。 对于人数较少、项目简单的开发团队，可能有部分措施不适用，因此应该根据具体情况来选用。\n\n### 1.2、核心思想：\n\n【1】解决问题：前端架构的设计，应是用于解决已存在或者未来可能发生的技术问题，增加项目的可管理性、稳定性、可扩展性。 【2】人效比：对于需要额外开发工作量的事务（本文中存在一些需要一定开发量的内容），我们在决定是否去做的时候，应该考虑到两个要素：第一个是花费的人力成本，第二个是未来可能节约的时间和金钱、避免的项目风险与资损、提高对业务的支撑能力以带来在业务上可衡量的更高的价值、以及其他价值。 【3】定性和定量：架构里设计的内容，一定要有是可衡量的意义的，最好是可以定量的——即可以衡量带来的收益或减少的成本，至少是可以定性的——即虽然无法用数字阐述收益，但我们可以明确这个是有意义的，例如增加安全性降低风险。 【4】数据敏感：专门写这一条强调数据作为依据的重要性。当我们需要说服其他部门/上级管理者，以推动我们设计的内容时，只有数据——特别是跟钱有关的数据，才是最有说服力的证明。 由于篇幅所限，本文很难直接给出定量的值，因此建议架构设计者，先确保项目中设计使用2.7里的埋点系统，根据埋点系统获取的数据，对项目效果进行定量分析，并以此写成PPT和其他部门/上级管理者进行协调。\n\n### 1.3、切入角度：\n\n分为基础层和应用层。 基础层偏基础设施建设，与业务相关性较低。 应用层更贴近用户，用于解决某一个问题。 部分两个都沾边的，根据经验划分到其中一个。\n\n### 1.4、其他\n\n由于已经谈到架构层级，因此很多内容，并不仅仅只属于前端领域，有很多内容是复合领域（前端、后端、运维、测试），因此需要负责架构的人，技术栈足够全面，对未来发展有足够的前瞻性。 文章的内容结构为：【项目】—>【解决的问题和带来的好处】—>【项目的实际意义】\n\n2、基础层设计\n-------\n\n### 2.1、自建Gitlab\n\n这个是基础的基础了。本不应该提的，不过考虑到我最近面试的几家公司，有的公司（人数并不少）并没有使用Gitlab，因此专门提一下，并且使用这个的难度非常低。 强烈建议使用Gitlab进行版本管理，自建Gitlab难度并不大，方便管理，包括代码管理、权限管理、提交日志查询，以及联动一些第三方插件。 意义： 公司代码是公司的重要资产，使用自建Gitlab可以有效保护公司资产。\n\n### 2.2、版本管理\n\n版本管理的几个关键点：\n\n*   发布后分支锁死，不可再更改：指当例如0.0.1版本成功发布后，不可再更改0.0.1分支上的代码，否则可能会导致版本管理混乱。\n*   全自动流程发布；指应避免开发者提交后，手动编译打包等操作，换句话说，开发人员发布后，将自动发布到预发布/生产环境。开发人员不和相关环境直接接触。实现这个需要参考下面的2.3。\n*   多版本并存；指当例如发布0.0.2版本后，0.0.1版本的代码应仍保存在线上（例如CDN），这样当出现线上bug时，方便快速回滚到上一个版本。\n\n意义： 提高项目的可控性。\n\n### 2.3、自动编译发布Jenkins\n\n这个工具用于在代码发布后，执行一系列流程，例如自动编译打包合并，然后再从Gitlab发布到CDN或者静态资源服务器。 使用这个工具，可以让一般研发人员不关心代码传到Gitlab后会发生什么事情，只需要专心于开发就可以了。 意义： 让研发人员专心于研发，和环境、运维等事情脱钩。\n\n### 2.4、纯前端版本发布\n\n纯前端版本发布分为两步：\n\n*   前端发布到生产环境——此时可以通过外网链接加正确的版本号访问到新版本的代码，但页面上的资源还是旧版本；\n*   前端通过配置工具（或者是直接更新html文件），将html中引入的资源，改为新版本。\n\n解决的问题是：当前端需要发布新版本时，可以不依赖于后端（根据实际情况，也可以不依赖于运维）。毕竟有很多需求并不需要后端介入，单纯改个前端版本后就要后端发布一次，显然是一件非常麻烦的事情。 这个需要专门的工具，用于配置版本发布，我最近就在写这个。 意义： 提高发布效率，降低发布带来的人员时间损耗（这些都是钱），也可以在前端版本回滚的时候，速度更快。 文章链接： [juejin.im/post/5d0714…](https://juejin.im/post/5d071428f265da1baa1e73ab)\n\n### 2.5、统一脚手架\n\n适用场景：有比较多独立中小项目。好处：\n\n*   可以减少开发人员配置脚手架带来的时间损耗（特殊功能可以fork脚手架后再自行定制）；\n*   统一项目结构，方便管理，也降低项目交接时带来的需要熟悉项目的时间；\n*   方便统一技术栈，可以预先引入固定的组件库；\n\n意义： 提高开发人员在多个项目之间的快速切换能力，提高项目可维护性，统一公司技术栈，避免因为环境不同导致奇怪的问题。\n\n### 2.6、Node中间层\n\n适用场景：需要SEO且前端使用React、vue，或前端介入后端逻辑，直接读取后端服务或者数据库的情况。\n\n*   SEO：仁者见仁智者见智，虽然很多公司已经不做了，但通常认为，还是有一定意义的（特别是需要搜索引擎引流的时候），因此React或者Vue的同构是必须的。并且同构还可以降低首页白屏时间；\n*   前端读取后端服务/数据库：好处是提高前端的开发效率和对业务的支持能力，缺点是可能导致P0级故障。\n\n意义： 让前端可以侵入后端领域，质的提升对业务的支持能力。\n\n### 2.7、埋点系统\n\n强烈推荐前端做自己的埋点系统。这个不同于后端的日志系统。 前端埋点系统的好处：\n\n*   记录每个页面的访问量（日周月年的UV、PV）；\n*   记录每个功能的使用量；\n*   捕捉报错情况；\n*   图表化显示，方便给其他部门展示；\n\n埋点系统是前端高度介入业务，把握业务发展情况的一把利剑，通过这个系统，我们可以比后端更深刻的把握用户的习惯，以及给产品经理、运营等人员提供准确的数据依据。当有了数据后，前端人员就可以针对性的优化功能、布局、页面交互逻辑、用户使用流程。 埋点系统应和业务解耦，开发人员使用时注册，然后在项目中引入。然后在埋点系统里查看相关数据（例如以小时、日、周、月、年为周期查看）\\[原创水印-作者：零零水(王冬)，微信：qq20004604\\]。 意义： 数据是money，数据是公司的生命线，数据是最好的武器。\n\n### 2.8、监控和报警系统\n\n监控和报警系统应基于埋点系统而建立，在如以下场景时\\[原创水印-作者：零零水(王冬)，微信：qq20004604\\]触发：\n\n*   当访问量有比较大的变化（比如日PV/UV只有之前20%以下）时，自动触发报警，发送邮件到相关人员邮箱；\n*   比如报错量大幅度上升（比如200%或更高），则触发报警；\n*   当一段时间内没有任何访问量（不符合之前的情况），则触发报警；\n*   每过一段时间，自动汇总访问者/报错触发者的相关信息（例如系统、浏览器版本等）；\n\n建设这个系统的好处在于，提前发现一些不容易发现的bug（需要埋点做的比较扎实）。有一些线上bug，因为用户环境特殊，导致无法被开发人员和测试人员发现。但其中一部分bug又因为不涉及资金，并不会导致资损（因此也不会被后端的监控系统所发现），这样的bug非常容易影响项目里某个链路的正常使用。 意义： 提高项目的稳定性，提高对业务的把控能力。降低bug数，降低资损的可能性，提前发现某些功能的bug（在工单到来之前）。\n\n### 2.9、安全管理\n\n前端的安全管理，通常要依赖于后端，至于只跟单纯有关系的例如dom.innerHTML= 'xxx '这种太基础，就不提了。 安全管理的很难从架构设计上完全避免，但还是有一定解决方案的，常见安全问题如下：\n\n*   XSS注入：对用户输入的内容，需要转码（大部分时候要server端来处理，偶尔也需要前端处理），禁止使用eval函数；\n*   https：这个显然是必须的，好处非常多；\n*   CSRF：要求server端加入CSRF的处理方法（至少在关键页面加入）；\n\n意义： 减少安全漏洞，避免用户受到损失，避免遭遇恶意攻击，增加系统的稳定性和安全性。\n\n### 2.10、Eslint\n\nEslint的好处很多，强烈推荐使用：\n\n*   降低低级bug（例如拼写问题）出现的概率；\n*   增加代码的可维护性，可阅读性；\n*   硬性统一代码风格，团队协作起来时更轻松；\n\n总的来说，eslint推荐直接配置到脚手架之中，对我们提高代码的可维护性的帮助会很大。可以考虑在上传到gitlab时，硬性要求eslint校验，通过的才允许上传。 意义： 提高代码的可维护性，降低团队协作的成本。\n\n### 2.11、灰度发布\n\n灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1~5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量极大的页面。 好处有以下几点：\n\n*   生产环境比开发环境复杂，灰度发布时可以在生产环境小范围尝试观察新版本是否可以正常运行，即使出问题，也可以控制损失。\n*   对于大版本更新，可以先灰度一部分，观察埋点效果和用户反馈（即所谓的抢先试用版）。假如效果并不好，那么回滚到老版本也可以及时止损；\n*   当我们需要验证某些想法或问题的时候，可以先灰度一部分，快速验证效果如何，然后查漏补缺或者针对性优化；\n\n灰度发布通常分为多个阶段：【1】1%；【2】5~10%；【3】30~50%；【4】全量推送（100%）。灰度发布一定要允许配置某些IP/账号访问时，可以直接访问到灰度版本。 意义： 降低风险，提高发布灵活度。\n\n### 2.12、前后端分离\n\n这个并不是指常见的前后端分离，而是指在分配前后端管控的领域。 中小项目常见的情况是后端只提供接口和让某个url指向某个html，前端负责html、css、js等静态资源。 但大型项目并不建议这么做，建议前端负责除html以外的静态资源，而html交给后端处理，理由有很多：\n\n*   后端进行渲染，方便统一插入一些代码和资源，例如埋点js，监控js，国际化文本资源，页面标识符等。这些通常是后端通过调用某些服务直接写入的；\n*   当页面需要统一的头尾时（参考淘宝里我的淘宝页面），前端不应该关注这些跟当前页面无关的东西；\n*   某些东西，如果通过html来管理，那么耦合度太高了，违背了解耦和分离的原则；\n*   前端版本发布在后端引入某种功能模块后，可以从单独的页面控制前端发布内容，比更新html更方便，也利于灰度发布；\n\n意义： 更规范的进行页面管理，降低页面和功能的耦合度，减少复杂页面的环境配置时间。\n\n### 2.13、Mock\n\nMock也是常见前端系统之一，用于解决在后端接口未好时，生成返回的数据。 我个人不太建议开发一个专门的系统来Mock，更好的Mock手法是直接嵌入到脚手架之中。思路如下：\n\n*   当在开发环境下，访问链接通常是localhost:8000/index.html，此时加入后缀 ?debug=true；\n*   封装好的异步请求在发现当前链接有以上标志时，认为是测试环境，访问/userinfo 时，不去读取线上的数据（因为也读取不到），去本地环境读取 src/test_ajax/userinfo.json，并将内容返回给用户；\n*   异步请求正常拿到数据，在页面中显示\\[原创水印-作者：零零水(王冬)，微信：qq20004604\\]；\n*   当线上接口可以获取到数据后，从network里找到返回的数据，放入/ src/test_ajax/userinfo.json中，此时再次本地调试的话，相当于使用的是线上的真实数据。\n\n这种处理，可以降低mock的复杂度，随时更改mock时返回的数据，比单独开发一个mock系统性价比更高。 意义： 在前后端并行开发时，降低沟通交流成本，方便开发完毕后直接对接。\n\n### 2.14、定期备份\n\n备份是常被忽略的一件事情，但当我们遇见毁灭性场景时，缺少备份带来的损失是非常大的，常见场景：\n\n*   服务器损坏，导致存在该服务器上的内容全部完蛋；\n*   触发某致命bug或者错误操作（例如rm -f），导致文件和数据全部消失；\n*   数据库出现错误操作或出现问题，导致用户数据、公司资产遭受严重损失；\n\n总的来说，没人想遇见这样的场景，但我们必须考虑这种极端情况的发生，因此需要从架构层面解决这个问题。常见方法是定期备份、多机备份、容灾系统建设等。 意义： 避免在遭遇极端场景时，给公司带来不可估量的损失。\n\n3、应用层设计\n-------\n\n### 3.1、多页和单页\n\n除了特殊场景，通常推荐使用多页架构。理由如下：\n\n*   多页项目，页面和页面之间是独立的，不存在交互，因此当一个页面需要单独重构时，不会影响其他页面，对于有长期历史的项目来说，可维护性、可重构性要高很多；\n*   多页项目的缺点是不同页面切换时，会有一个白屏时间，但通常来说，这个时间并不长，大部分现有大公司的线上网页，都是这样的，因此认为是可以接受的；\n*   多页项目可以单次只更新一个页面的版本，而单页项目如果其中一个功能模块要更新（特别是公共组件更新），很容易让所有页面都需要更新版本；\n*   多页项目的版本控制更简单，如果需要页面拆分，调整部分页面的使用流程，难度也会更低；\n*   灰度发布更友好；\n\n之前面试的一家，采用了单页的形式，之前因为种种原因，同时采用了ng和react。由于项目历史也比较久（3年以上），结果导致目前继续维护更新的难度很大，即使想部分重构，也很麻烦。 意义： 降低长期项目迭代维护的难度，\n\n### 3.2、以应用为单位划分前端项目\n\n在项目比较大的时候，将所有页面的前端文件放入到同一个代码仓库里，我之前参与过一家企业的前端项目开发，发现其就是这么做的。根据使用经验来看\\[原创水印-作者：零零水(王冬)，微信：qq20004604\\]，存在很多问题：\n\n*   会极大的增加代码的维护难度；\n*   项目会变得很丑陋；\n*   不方便权限管理，容易造成页面误更改或代码泄密；\n*   任何人都有权利改任何他能看到的页面（在合并代码的时候，管理人员并不能确定他本次修改的页面是否是需求里他应该改的页面）；\n*   发布成本高，即使改一个页面，也需要发布所有资源；\n\n因此，我们应该避免这种现象的发生，个人推荐以应用为单位进行开发、发布。所谓应用即指一个业务涉及到的前后端代码，好处很多：\n\n*   方便进行管理，当某个业务有需求变更时，可以只给研发人员该业务前端应用的developer权限；\n*   在需要发布某业务时，只需要发布该业务的所属应用即可；\n\n意义： 规范项目，增加代码的安全性，降低项目维护成本。\n\n### 3.3、基础组件库的建设\n\n这个蛮基础的，对于组件库的建设，不建议研发人员较少时去做这件事情，专职前端开发人数少于10人时，建议使用比较靠谱的第三方UI库，例如Antd，这样性价比更高。 设计基础组件库的前提，是要求统一技术栈，这样才能最大化基础组件库的效益。组件库建议以使用以下参考标准：\n\n*   使用ts；\n*   可扩展性强；\n*   适用程度高；\n*   文档清楚详细；\n*   版本隔离，小版本优化加功能，大改需要大版本更新；\n*   和UI协调统一，要求UI交互参与进来；\n\n总的来说，建设起来后，利大于弊，但是需要专人维护，因此还是有一定成本的。 意义： 统一不同/相同产品线之间的风格，给用户更好的体验，减少单次开发中写UI组件时浪费的时间和人力，提高开发效率。\n\n### 3.4、技术栈统一\n\n前端有三大主流框架，还有兼容性最强jQuery，以及各种第三方库，UI框架。因此项目需求如果复杂一些，很容易形成一个大杂烩。因此前端的技术栈必须统一，具体来说，建议实现以下举措：\n\n*   三大框架选型其一，团队水平一般推荐Vue、水平较好推荐React，对外项目选React或者ng；\n*   需要兼容IE8或更老版本时，建议使用jQuery；\n*   组件库自建或者统一选择一个固定的第三方；\n*   一些特殊第三方库统一使用一个版本，例如需要使用地图时，固定使用高德或百度或腾讯地图；\n*   基础设施建设应避免重复造轮子，所有团队尽量共用，并有专门的前端平_台负责统一这些东西，对于特殊需求，可以新建，但应当有说服力；\n\n总的来说，技术栈统一的好处很多，可以有效提高开发效率，降低重复造轮子产生的成本。 意义： 方便招人，简化团队成员培养成本，以及提高项目的可持续性。\n\n### 3.5、浏览器兼容\n\n常见的问题是IE6、7、8，以及部分小众浏览器（PC和手机）产生的奇怪问题。因此应该考虑统一解决方案，避免bug的重复产生。常见解决方案有：\n\n*   配置postcss，让某些css增加兼容性前缀；\n*   写一个wepback的loader，处理某些特殊场景；\n*   规范团队代码，使用更稳定的写法（例如移动端避免使用fixed进行布局）；\n*   对常见问题、疑难问题，总结解决方案并团队共享；\n*   建议或引导用户使用高版本浏览器（比如chrome）；\n\n意义： 避免浏览器环境产生的bug，以及排查此类bug所浪费的大量时间。\n\n### 3.6、内容平_台建设\n\n为了提高公司内部的沟通效率，总结经验，以及保密原因。应建设一个内部论坛+博客站点。其具备的好处如下：\n\n*   可以记录公司的历史；\n*   研发同学之间分享经验；\n*   总结转载一些外界比较精品的文章，提高大家的眼界；\n*   增加公司内部同学的交流，有利于公司的团队和文化建设；\n*   对某些技术问题可以进行讨论，减少因没有达成共识带来的沟通损耗；\n\n众所周知，大型互联网公司通常都有这样一个内部论坛和博客站点。其降低了公司的沟通和交流成本，也增加了公司的技术积累。 意义： 博客增强技术积累，论坛增强公司内部沟通能力。\n\n### 3.7、权限管理平_台\n\n当公司内部人员较多时，应有一个专门的平_台，来管理、规范用户的权限以及可访问内容\\[原创水印-作者：零零水(王冬)，微信：qq20004604\\]。权限管理平_台有几个特点：\n\n*   必然和Server端天然高耦合度，因此需要有专门的控制模块负责处理权限问题（负责Server端开发处理，或者前端通过中间层例如Node层介入处理）；\n*   自动化流程控制，即用户创建、申请、审批、离职自动删除，都应该是由系统推进并提醒相关人士，必要时应能触发报警；\n*   权限应有时效性，减少永久性权限的产生；\n*   审批流程应清晰可见，每一阶段流程应具体明确；\n*   应与公司流程紧密结合，并且提高可修改性，方便公司后期进行流程优化；\n\n意义： 使得公司内部流程正规化、信息化。\n\n### 3.8、登录系统设计（单点登录）\n\n当公司内部业务线比较复杂但相互之间的耦合度比较高时，我们应该考虑设计添加单点登录系统。具体来说，用户在一处登录，即可以在任何页面访问，登出时，也同样在任何页面都失去登录状态。SSO的好处很多：\n\n*   增强用户体验；\n*   打通了不同业务系统之间的用户数据；\n*   方便统一管理用户；\n*   有利于引流；\n*   降低开发系统的成本（不需要每个业务都开发一次登录系统和用户状态控制）；\n\n总的来说，大中型web应用，SSO可以带来很多好处，缺点却很少。 意义： 用户体验增强，打通不同业务之间的间隔，降低开发成本和用户管理成本。\n\n### 3.9、CDN\n\n前端资源的加载速度是衡量用户体验的重要指标之一。而现实中，因为种种因素，用户在加载页面资源时，会受到很多限制。因此上CDN是非常有意义的，好处如下：\n\n*   用户来自不同地区，加入CDN可以使用户访问资源时，访问离自己比较近的CDN服务器，降低访问延迟；\n*   降低服务器带宽使用成本；\n*   支持视频、静态资源、大文件、小文件、直播等多种业务场景；\n*   消除跨运营商造成的网络速度较慢的问题；\n*   降低DDOS攻击造成的对网站的影响；\n\nCDN是一种比较成熟的技术，各大云平_台都有提供CDN服务，价格也不贵，因此CDN的性价比很高。 意义： 增加用户访问速度，降低网络延迟，带宽优化，减少服务器负载，增强对攻击的抵抗能力。\n\n### 3.10、负载均衡\n\n目前来看，负载均衡通常使用Nginx比较多，以前也有使用Apache。当遇见大型项目的时候，负载均衡和分布式几乎是必须的。负载均衡有以下好处：\n\n*   降低单台server的压力，提高业务承载能力；\n*   方便应对峰值流量，扩容方便（如举办某些活动时）；\n*   增强业务的可用性、扩展性、稳定性；\n\n负载均衡已经是蛮常见的技术了，好处不用多说，很容易理解。 意义： 增强业务的可用性、扩展性、稳定性，可以支持更多用户的访问。\n\n### 3.11、多端共用一套接口\n\n目前常见场景是一个业务，同时有PC页面和H5页面，由于业务是一样的，因此应避免同一个业务有多套接口分别适用于PC和H5端。因此解决方案如下：\n\n*   后端提供的接口，应该同时包含PC和H5的数据（即单独对一个存在亢余数据）；\n*   接口应当稳定，即当业务变更时，应尽量采取追加数据的形式；\n*   只有在单独一端需要特殊业务流程时，设计单端独有接口；\n\n多端共用接口，是减少开发工作量，并且提高业务可维护性的重要解决方案。 意义： 降低开发工作量，增强可维护性。","source":"_posts/e5-a4-a7-e5-9e-8b-e9-a1-b9-e7-9b-ae-e5-89-8d-e7-ab-af-e6-9e-b6-e6-9e-84-e8-af-a6-e8-b0-88.md","raw":"---\ntitle: 大型项目前端架构详谈\ntags:\n  - 前端架构\n  - 大型前端发布架构\nurl: 177.html\nid: 177\ncategories:\n  - 大前端\ndate: 2019-06-24 20:07:33\n---\n\n目录：\n\n*   1、综合\n*   1.1、使用场景\n*   1.2、核心思想\n*   1.3、切入角度\n*   1.4、其他\n*   2、基础层设计\n*   2.1、自建Gitlab\n*   2.2、版本管理\n*   2.3、自动编译发布Jenkins\n*   2.4、纯前端版本发布\n*   2.5、统一脚手架\n*   2.6、Node中间层\n*   2.7、埋点系统\n*   2.8、监控和报警系统\n*   2.9、安全管理\n*   2.10、Eslint\n*   2.11、灰度发布\n*   2.12、前后端分离\n*   2.13、Mock\n*   2.14、定期备份\n*   3、应用层设计\n*   3.1、多页和单页\n*   3.2、以应用为单位划分前端项目\n*   3.3、基础组件库的建设\n*   3.4、技术栈统一\n*   3.5、浏览器兼容\n*   3.6、内容平_台建设\n*   3.7、权限管理平_台\n*   3.8、登录系统设计（单点登录）\n*   3.9、CDN\n*   3.10、负载均衡\n*   3.11、多端共用一套接口\n*   4、总结\n\n1、综合\n----\n\n我在2年之前，写过一篇中小型项目的前端架构浅谈。随着能力的上升，以及在阿里巴巴工作的经验，是时候写一篇大型项目的前端架构分析了。 本篇文章不会更多侧重于具体技术实现，而是尝试从更高角度出发，分析为什么要这么做，这些设计能解决什么问题，成本和收益如何。 由于作者能力有限，可能会有所缺漏或者部分错误，欢迎读者指出。\n\n### 1.1、适用场景：\n\n本篇文章，适用于单个/多个大型项目、拥有超过10个以上的前端开发的场景。 前端项目的规模不同，成本收益比也会有所差别。通常来说，人员越多、项目复杂度越高，那么收益/成本的比值越大。 对于人数较少、项目简单的开发团队，可能有部分措施不适用，因此应该根据具体情况来选用。\n\n### 1.2、核心思想：\n\n【1】解决问题：前端架构的设计，应是用于解决已存在或者未来可能发生的技术问题，增加项目的可管理性、稳定性、可扩展性。 【2】人效比：对于需要额外开发工作量的事务（本文中存在一些需要一定开发量的内容），我们在决定是否去做的时候，应该考虑到两个要素：第一个是花费的人力成本，第二个是未来可能节约的时间和金钱、避免的项目风险与资损、提高对业务的支撑能力以带来在业务上可衡量的更高的价值、以及其他价值。 【3】定性和定量：架构里设计的内容，一定要有是可衡量的意义的，最好是可以定量的——即可以衡量带来的收益或减少的成本，至少是可以定性的——即虽然无法用数字阐述收益，但我们可以明确这个是有意义的，例如增加安全性降低风险。 【4】数据敏感：专门写这一条强调数据作为依据的重要性。当我们需要说服其他部门/上级管理者，以推动我们设计的内容时，只有数据——特别是跟钱有关的数据，才是最有说服力的证明。 由于篇幅所限，本文很难直接给出定量的值，因此建议架构设计者，先确保项目中设计使用2.7里的埋点系统，根据埋点系统获取的数据，对项目效果进行定量分析，并以此写成PPT和其他部门/上级管理者进行协调。\n\n### 1.3、切入角度：\n\n分为基础层和应用层。 基础层偏基础设施建设，与业务相关性较低。 应用层更贴近用户，用于解决某一个问题。 部分两个都沾边的，根据经验划分到其中一个。\n\n### 1.4、其他\n\n由于已经谈到架构层级，因此很多内容，并不仅仅只属于前端领域，有很多内容是复合领域（前端、后端、运维、测试），因此需要负责架构的人，技术栈足够全面，对未来发展有足够的前瞻性。 文章的内容结构为：【项目】—>【解决的问题和带来的好处】—>【项目的实际意义】\n\n2、基础层设计\n-------\n\n### 2.1、自建Gitlab\n\n这个是基础的基础了。本不应该提的，不过考虑到我最近面试的几家公司，有的公司（人数并不少）并没有使用Gitlab，因此专门提一下，并且使用这个的难度非常低。 强烈建议使用Gitlab进行版本管理，自建Gitlab难度并不大，方便管理，包括代码管理、权限管理、提交日志查询，以及联动一些第三方插件。 意义： 公司代码是公司的重要资产，使用自建Gitlab可以有效保护公司资产。\n\n### 2.2、版本管理\n\n版本管理的几个关键点：\n\n*   发布后分支锁死，不可再更改：指当例如0.0.1版本成功发布后，不可再更改0.0.1分支上的代码，否则可能会导致版本管理混乱。\n*   全自动流程发布；指应避免开发者提交后，手动编译打包等操作，换句话说，开发人员发布后，将自动发布到预发布/生产环境。开发人员不和相关环境直接接触。实现这个需要参考下面的2.3。\n*   多版本并存；指当例如发布0.0.2版本后，0.0.1版本的代码应仍保存在线上（例如CDN），这样当出现线上bug时，方便快速回滚到上一个版本。\n\n意义： 提高项目的可控性。\n\n### 2.3、自动编译发布Jenkins\n\n这个工具用于在代码发布后，执行一系列流程，例如自动编译打包合并，然后再从Gitlab发布到CDN或者静态资源服务器。 使用这个工具，可以让一般研发人员不关心代码传到Gitlab后会发生什么事情，只需要专心于开发就可以了。 意义： 让研发人员专心于研发，和环境、运维等事情脱钩。\n\n### 2.4、纯前端版本发布\n\n纯前端版本发布分为两步：\n\n*   前端发布到生产环境——此时可以通过外网链接加正确的版本号访问到新版本的代码，但页面上的资源还是旧版本；\n*   前端通过配置工具（或者是直接更新html文件），将html中引入的资源，改为新版本。\n\n解决的问题是：当前端需要发布新版本时，可以不依赖于后端（根据实际情况，也可以不依赖于运维）。毕竟有很多需求并不需要后端介入，单纯改个前端版本后就要后端发布一次，显然是一件非常麻烦的事情。 这个需要专门的工具，用于配置版本发布，我最近就在写这个。 意义： 提高发布效率，降低发布带来的人员时间损耗（这些都是钱），也可以在前端版本回滚的时候，速度更快。 文章链接： [juejin.im/post/5d0714…](https://juejin.im/post/5d071428f265da1baa1e73ab)\n\n### 2.5、统一脚手架\n\n适用场景：有比较多独立中小项目。好处：\n\n*   可以减少开发人员配置脚手架带来的时间损耗（特殊功能可以fork脚手架后再自行定制）；\n*   统一项目结构，方便管理，也降低项目交接时带来的需要熟悉项目的时间；\n*   方便统一技术栈，可以预先引入固定的组件库；\n\n意义： 提高开发人员在多个项目之间的快速切换能力，提高项目可维护性，统一公司技术栈，避免因为环境不同导致奇怪的问题。\n\n### 2.6、Node中间层\n\n适用场景：需要SEO且前端使用React、vue，或前端介入后端逻辑，直接读取后端服务或者数据库的情况。\n\n*   SEO：仁者见仁智者见智，虽然很多公司已经不做了，但通常认为，还是有一定意义的（特别是需要搜索引擎引流的时候），因此React或者Vue的同构是必须的。并且同构还可以降低首页白屏时间；\n*   前端读取后端服务/数据库：好处是提高前端的开发效率和对业务的支持能力，缺点是可能导致P0级故障。\n\n意义： 让前端可以侵入后端领域，质的提升对业务的支持能力。\n\n### 2.7、埋点系统\n\n强烈推荐前端做自己的埋点系统。这个不同于后端的日志系统。 前端埋点系统的好处：\n\n*   记录每个页面的访问量（日周月年的UV、PV）；\n*   记录每个功能的使用量；\n*   捕捉报错情况；\n*   图表化显示，方便给其他部门展示；\n\n埋点系统是前端高度介入业务，把握业务发展情况的一把利剑，通过这个系统，我们可以比后端更深刻的把握用户的习惯，以及给产品经理、运营等人员提供准确的数据依据。当有了数据后，前端人员就可以针对性的优化功能、布局、页面交互逻辑、用户使用流程。 埋点系统应和业务解耦，开发人员使用时注册，然后在项目中引入。然后在埋点系统里查看相关数据（例如以小时、日、周、月、年为周期查看）\\[原创水印-作者：零零水(王冬)，微信：qq20004604\\]。 意义： 数据是money，数据是公司的生命线，数据是最好的武器。\n\n### 2.8、监控和报警系统\n\n监控和报警系统应基于埋点系统而建立，在如以下场景时\\[原创水印-作者：零零水(王冬)，微信：qq20004604\\]触发：\n\n*   当访问量有比较大的变化（比如日PV/UV只有之前20%以下）时，自动触发报警，发送邮件到相关人员邮箱；\n*   比如报错量大幅度上升（比如200%或更高），则触发报警；\n*   当一段时间内没有任何访问量（不符合之前的情况），则触发报警；\n*   每过一段时间，自动汇总访问者/报错触发者的相关信息（例如系统、浏览器版本等）；\n\n建设这个系统的好处在于，提前发现一些不容易发现的bug（需要埋点做的比较扎实）。有一些线上bug，因为用户环境特殊，导致无法被开发人员和测试人员发现。但其中一部分bug又因为不涉及资金，并不会导致资损（因此也不会被后端的监控系统所发现），这样的bug非常容易影响项目里某个链路的正常使用。 意义： 提高项目的稳定性，提高对业务的把控能力。降低bug数，降低资损的可能性，提前发现某些功能的bug（在工单到来之前）。\n\n### 2.9、安全管理\n\n前端的安全管理，通常要依赖于后端，至于只跟单纯有关系的例如dom.innerHTML= 'xxx '这种太基础，就不提了。 安全管理的很难从架构设计上完全避免，但还是有一定解决方案的，常见安全问题如下：\n\n*   XSS注入：对用户输入的内容，需要转码（大部分时候要server端来处理，偶尔也需要前端处理），禁止使用eval函数；\n*   https：这个显然是必须的，好处非常多；\n*   CSRF：要求server端加入CSRF的处理方法（至少在关键页面加入）；\n\n意义： 减少安全漏洞，避免用户受到损失，避免遭遇恶意攻击，增加系统的稳定性和安全性。\n\n### 2.10、Eslint\n\nEslint的好处很多，强烈推荐使用：\n\n*   降低低级bug（例如拼写问题）出现的概率；\n*   增加代码的可维护性，可阅读性；\n*   硬性统一代码风格，团队协作起来时更轻松；\n\n总的来说，eslint推荐直接配置到脚手架之中，对我们提高代码的可维护性的帮助会很大。可以考虑在上传到gitlab时，硬性要求eslint校验，通过的才允许上传。 意义： 提高代码的可维护性，降低团队协作的成本。\n\n### 2.11、灰度发布\n\n灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1~5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量极大的页面。 好处有以下几点：\n\n*   生产环境比开发环境复杂，灰度发布时可以在生产环境小范围尝试观察新版本是否可以正常运行，即使出问题，也可以控制损失。\n*   对于大版本更新，可以先灰度一部分，观察埋点效果和用户反馈（即所谓的抢先试用版）。假如效果并不好，那么回滚到老版本也可以及时止损；\n*   当我们需要验证某些想法或问题的时候，可以先灰度一部分，快速验证效果如何，然后查漏补缺或者针对性优化；\n\n灰度发布通常分为多个阶段：【1】1%；【2】5~10%；【3】30~50%；【4】全量推送（100%）。灰度发布一定要允许配置某些IP/账号访问时，可以直接访问到灰度版本。 意义： 降低风险，提高发布灵活度。\n\n### 2.12、前后端分离\n\n这个并不是指常见的前后端分离，而是指在分配前后端管控的领域。 中小项目常见的情况是后端只提供接口和让某个url指向某个html，前端负责html、css、js等静态资源。 但大型项目并不建议这么做，建议前端负责除html以外的静态资源，而html交给后端处理，理由有很多：\n\n*   后端进行渲染，方便统一插入一些代码和资源，例如埋点js，监控js，国际化文本资源，页面标识符等。这些通常是后端通过调用某些服务直接写入的；\n*   当页面需要统一的头尾时（参考淘宝里我的淘宝页面），前端不应该关注这些跟当前页面无关的东西；\n*   某些东西，如果通过html来管理，那么耦合度太高了，违背了解耦和分离的原则；\n*   前端版本发布在后端引入某种功能模块后，可以从单独的页面控制前端发布内容，比更新html更方便，也利于灰度发布；\n\n意义： 更规范的进行页面管理，降低页面和功能的耦合度，减少复杂页面的环境配置时间。\n\n### 2.13、Mock\n\nMock也是常见前端系统之一，用于解决在后端接口未好时，生成返回的数据。 我个人不太建议开发一个专门的系统来Mock，更好的Mock手法是直接嵌入到脚手架之中。思路如下：\n\n*   当在开发环境下，访问链接通常是localhost:8000/index.html，此时加入后缀 ?debug=true；\n*   封装好的异步请求在发现当前链接有以上标志时，认为是测试环境，访问/userinfo 时，不去读取线上的数据（因为也读取不到），去本地环境读取 src/test_ajax/userinfo.json，并将内容返回给用户；\n*   异步请求正常拿到数据，在页面中显示\\[原创水印-作者：零零水(王冬)，微信：qq20004604\\]；\n*   当线上接口可以获取到数据后，从network里找到返回的数据，放入/ src/test_ajax/userinfo.json中，此时再次本地调试的话，相当于使用的是线上的真实数据。\n\n这种处理，可以降低mock的复杂度，随时更改mock时返回的数据，比单独开发一个mock系统性价比更高。 意义： 在前后端并行开发时，降低沟通交流成本，方便开发完毕后直接对接。\n\n### 2.14、定期备份\n\n备份是常被忽略的一件事情，但当我们遇见毁灭性场景时，缺少备份带来的损失是非常大的，常见场景：\n\n*   服务器损坏，导致存在该服务器上的内容全部完蛋；\n*   触发某致命bug或者错误操作（例如rm -f），导致文件和数据全部消失；\n*   数据库出现错误操作或出现问题，导致用户数据、公司资产遭受严重损失；\n\n总的来说，没人想遇见这样的场景，但我们必须考虑这种极端情况的发生，因此需要从架构层面解决这个问题。常见方法是定期备份、多机备份、容灾系统建设等。 意义： 避免在遭遇极端场景时，给公司带来不可估量的损失。\n\n3、应用层设计\n-------\n\n### 3.1、多页和单页\n\n除了特殊场景，通常推荐使用多页架构。理由如下：\n\n*   多页项目，页面和页面之间是独立的，不存在交互，因此当一个页面需要单独重构时，不会影响其他页面，对于有长期历史的项目来说，可维护性、可重构性要高很多；\n*   多页项目的缺点是不同页面切换时，会有一个白屏时间，但通常来说，这个时间并不长，大部分现有大公司的线上网页，都是这样的，因此认为是可以接受的；\n*   多页项目可以单次只更新一个页面的版本，而单页项目如果其中一个功能模块要更新（特别是公共组件更新），很容易让所有页面都需要更新版本；\n*   多页项目的版本控制更简单，如果需要页面拆分，调整部分页面的使用流程，难度也会更低；\n*   灰度发布更友好；\n\n之前面试的一家，采用了单页的形式，之前因为种种原因，同时采用了ng和react。由于项目历史也比较久（3年以上），结果导致目前继续维护更新的难度很大，即使想部分重构，也很麻烦。 意义： 降低长期项目迭代维护的难度，\n\n### 3.2、以应用为单位划分前端项目\n\n在项目比较大的时候，将所有页面的前端文件放入到同一个代码仓库里，我之前参与过一家企业的前端项目开发，发现其就是这么做的。根据使用经验来看\\[原创水印-作者：零零水(王冬)，微信：qq20004604\\]，存在很多问题：\n\n*   会极大的增加代码的维护难度；\n*   项目会变得很丑陋；\n*   不方便权限管理，容易造成页面误更改或代码泄密；\n*   任何人都有权利改任何他能看到的页面（在合并代码的时候，管理人员并不能确定他本次修改的页面是否是需求里他应该改的页面）；\n*   发布成本高，即使改一个页面，也需要发布所有资源；\n\n因此，我们应该避免这种现象的发生，个人推荐以应用为单位进行开发、发布。所谓应用即指一个业务涉及到的前后端代码，好处很多：\n\n*   方便进行管理，当某个业务有需求变更时，可以只给研发人员该业务前端应用的developer权限；\n*   在需要发布某业务时，只需要发布该业务的所属应用即可；\n\n意义： 规范项目，增加代码的安全性，降低项目维护成本。\n\n### 3.3、基础组件库的建设\n\n这个蛮基础的，对于组件库的建设，不建议研发人员较少时去做这件事情，专职前端开发人数少于10人时，建议使用比较靠谱的第三方UI库，例如Antd，这样性价比更高。 设计基础组件库的前提，是要求统一技术栈，这样才能最大化基础组件库的效益。组件库建议以使用以下参考标准：\n\n*   使用ts；\n*   可扩展性强；\n*   适用程度高；\n*   文档清楚详细；\n*   版本隔离，小版本优化加功能，大改需要大版本更新；\n*   和UI协调统一，要求UI交互参与进来；\n\n总的来说，建设起来后，利大于弊，但是需要专人维护，因此还是有一定成本的。 意义： 统一不同/相同产品线之间的风格，给用户更好的体验，减少单次开发中写UI组件时浪费的时间和人力，提高开发效率。\n\n### 3.4、技术栈统一\n\n前端有三大主流框架，还有兼容性最强jQuery，以及各种第三方库，UI框架。因此项目需求如果复杂一些，很容易形成一个大杂烩。因此前端的技术栈必须统一，具体来说，建议实现以下举措：\n\n*   三大框架选型其一，团队水平一般推荐Vue、水平较好推荐React，对外项目选React或者ng；\n*   需要兼容IE8或更老版本时，建议使用jQuery；\n*   组件库自建或者统一选择一个固定的第三方；\n*   一些特殊第三方库统一使用一个版本，例如需要使用地图时，固定使用高德或百度或腾讯地图；\n*   基础设施建设应避免重复造轮子，所有团队尽量共用，并有专门的前端平_台负责统一这些东西，对于特殊需求，可以新建，但应当有说服力；\n\n总的来说，技术栈统一的好处很多，可以有效提高开发效率，降低重复造轮子产生的成本。 意义： 方便招人，简化团队成员培养成本，以及提高项目的可持续性。\n\n### 3.5、浏览器兼容\n\n常见的问题是IE6、7、8，以及部分小众浏览器（PC和手机）产生的奇怪问题。因此应该考虑统一解决方案，避免bug的重复产生。常见解决方案有：\n\n*   配置postcss，让某些css增加兼容性前缀；\n*   写一个wepback的loader，处理某些特殊场景；\n*   规范团队代码，使用更稳定的写法（例如移动端避免使用fixed进行布局）；\n*   对常见问题、疑难问题，总结解决方案并团队共享；\n*   建议或引导用户使用高版本浏览器（比如chrome）；\n\n意义： 避免浏览器环境产生的bug，以及排查此类bug所浪费的大量时间。\n\n### 3.6、内容平_台建设\n\n为了提高公司内部的沟通效率，总结经验，以及保密原因。应建设一个内部论坛+博客站点。其具备的好处如下：\n\n*   可以记录公司的历史；\n*   研发同学之间分享经验；\n*   总结转载一些外界比较精品的文章，提高大家的眼界；\n*   增加公司内部同学的交流，有利于公司的团队和文化建设；\n*   对某些技术问题可以进行讨论，减少因没有达成共识带来的沟通损耗；\n\n众所周知，大型互联网公司通常都有这样一个内部论坛和博客站点。其降低了公司的沟通和交流成本，也增加了公司的技术积累。 意义： 博客增强技术积累，论坛增强公司内部沟通能力。\n\n### 3.7、权限管理平_台\n\n当公司内部人员较多时，应有一个专门的平_台，来管理、规范用户的权限以及可访问内容\\[原创水印-作者：零零水(王冬)，微信：qq20004604\\]。权限管理平_台有几个特点：\n\n*   必然和Server端天然高耦合度，因此需要有专门的控制模块负责处理权限问题（负责Server端开发处理，或者前端通过中间层例如Node层介入处理）；\n*   自动化流程控制，即用户创建、申请、审批、离职自动删除，都应该是由系统推进并提醒相关人士，必要时应能触发报警；\n*   权限应有时效性，减少永久性权限的产生；\n*   审批流程应清晰可见，每一阶段流程应具体明确；\n*   应与公司流程紧密结合，并且提高可修改性，方便公司后期进行流程优化；\n\n意义： 使得公司内部流程正规化、信息化。\n\n### 3.8、登录系统设计（单点登录）\n\n当公司内部业务线比较复杂但相互之间的耦合度比较高时，我们应该考虑设计添加单点登录系统。具体来说，用户在一处登录，即可以在任何页面访问，登出时，也同样在任何页面都失去登录状态。SSO的好处很多：\n\n*   增强用户体验；\n*   打通了不同业务系统之间的用户数据；\n*   方便统一管理用户；\n*   有利于引流；\n*   降低开发系统的成本（不需要每个业务都开发一次登录系统和用户状态控制）；\n\n总的来说，大中型web应用，SSO可以带来很多好处，缺点却很少。 意义： 用户体验增强，打通不同业务之间的间隔，降低开发成本和用户管理成本。\n\n### 3.9、CDN\n\n前端资源的加载速度是衡量用户体验的重要指标之一。而现实中，因为种种因素，用户在加载页面资源时，会受到很多限制。因此上CDN是非常有意义的，好处如下：\n\n*   用户来自不同地区，加入CDN可以使用户访问资源时，访问离自己比较近的CDN服务器，降低访问延迟；\n*   降低服务器带宽使用成本；\n*   支持视频、静态资源、大文件、小文件、直播等多种业务场景；\n*   消除跨运营商造成的网络速度较慢的问题；\n*   降低DDOS攻击造成的对网站的影响；\n\nCDN是一种比较成熟的技术，各大云平_台都有提供CDN服务，价格也不贵，因此CDN的性价比很高。 意义： 增加用户访问速度，降低网络延迟，带宽优化，减少服务器负载，增强对攻击的抵抗能力。\n\n### 3.10、负载均衡\n\n目前来看，负载均衡通常使用Nginx比较多，以前也有使用Apache。当遇见大型项目的时候，负载均衡和分布式几乎是必须的。负载均衡有以下好处：\n\n*   降低单台server的压力，提高业务承载能力；\n*   方便应对峰值流量，扩容方便（如举办某些活动时）；\n*   增强业务的可用性、扩展性、稳定性；\n\n负载均衡已经是蛮常见的技术了，好处不用多说，很容易理解。 意义： 增强业务的可用性、扩展性、稳定性，可以支持更多用户的访问。\n\n### 3.11、多端共用一套接口\n\n目前常见场景是一个业务，同时有PC页面和H5页面，由于业务是一样的，因此应避免同一个业务有多套接口分别适用于PC和H5端。因此解决方案如下：\n\n*   后端提供的接口，应该同时包含PC和H5的数据（即单独对一个存在亢余数据）；\n*   接口应当稳定，即当业务变更时，应尽量采取追加数据的形式；\n*   只有在单独一端需要特殊业务流程时，设计单端独有接口；\n\n多端共用接口，是减少开发工作量，并且提高业务可维护性的重要解决方案。 意义： 降低开发工作量，增强可维护性。","slug":"e5-a4-a7-e5-9e-8b-e9-a1-b9-e7-9b-ae-e5-89-8d-e7-ab-af-e6-9e-b6-e6-9e-84-e8-af-a6-e8-b0-88","published":1,"updated":"2019-09-10T07:46:08.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269ge005fc8gs7panb3a2","content":"<p>目录：</p>\n<ul>\n<li>  1、综合</li>\n<li>  1.1、使用场景</li>\n<li>  1.2、核心思想</li>\n<li>  1.3、切入角度</li>\n<li>  1.4、其他</li>\n<li>  2、基础层设计</li>\n<li>  2.1、自建Gitlab</li>\n<li>  2.2、版本管理</li>\n<li>  2.3、自动编译发布Jenkins</li>\n<li>  2.4、纯前端版本发布</li>\n<li>  2.5、统一脚手架</li>\n<li>  2.6、Node中间层</li>\n<li>  2.7、埋点系统</li>\n<li>  2.8、监控和报警系统</li>\n<li>  2.9、安全管理</li>\n<li>  2.10、Eslint</li>\n<li>  2.11、灰度发布</li>\n<li>  2.12、前后端分离</li>\n<li>  2.13、Mock</li>\n<li>  2.14、定期备份</li>\n<li>  3、应用层设计</li>\n<li>  3.1、多页和单页</li>\n<li>  3.2、以应用为单位划分前端项目</li>\n<li>  3.3、基础组件库的建设</li>\n<li>  3.4、技术栈统一</li>\n<li>  3.5、浏览器兼容</li>\n<li>  3.6、内容平_台建设</li>\n<li>  3.7、权限管理平_台</li>\n<li>  3.8、登录系统设计（单点登录）</li>\n<li>  3.9、CDN</li>\n<li>  3.10、负载均衡</li>\n<li>  3.11、多端共用一套接口</li>\n<li>  4、总结</li>\n</ul>\n<h2 id=\"1、综合\"><a href=\"#1、综合\" class=\"headerlink\" title=\"1、综合\"></a>1、综合</h2><p>我在2年之前，写过一篇中小型项目的前端架构浅谈。随着能力的上升，以及在阿里巴巴工作的经验，是时候写一篇大型项目的前端架构分析了。 本篇文章不会更多侧重于具体技术实现，而是尝试从更高角度出发，分析为什么要这么做，这些设计能解决什么问题，成本和收益如何。 由于作者能力有限，可能会有所缺漏或者部分错误，欢迎读者指出。</p>\n<h3 id=\"1-1、适用场景：\"><a href=\"#1-1、适用场景：\" class=\"headerlink\" title=\"1.1、适用场景：\"></a>1.1、适用场景：</h3><p>本篇文章，适用于单个/多个大型项目、拥有超过10个以上的前端开发的场景。 前端项目的规模不同，成本收益比也会有所差别。通常来说，人员越多、项目复杂度越高，那么收益/成本的比值越大。 对于人数较少、项目简单的开发团队，可能有部分措施不适用，因此应该根据具体情况来选用。</p>\n<h3 id=\"1-2、核心思想：\"><a href=\"#1-2、核心思想：\" class=\"headerlink\" title=\"1.2、核心思想：\"></a>1.2、核心思想：</h3><p>【1】解决问题：前端架构的设计，应是用于解决已存在或者未来可能发生的技术问题，增加项目的可管理性、稳定性、可扩展性。 【2】人效比：对于需要额外开发工作量的事务（本文中存在一些需要一定开发量的内容），我们在决定是否去做的时候，应该考虑到两个要素：第一个是花费的人力成本，第二个是未来可能节约的时间和金钱、避免的项目风险与资损、提高对业务的支撑能力以带来在业务上可衡量的更高的价值、以及其他价值。 【3】定性和定量：架构里设计的内容，一定要有是可衡量的意义的，最好是可以定量的——即可以衡量带来的收益或减少的成本，至少是可以定性的——即虽然无法用数字阐述收益，但我们可以明确这个是有意义的，例如增加安全性降低风险。 【4】数据敏感：专门写这一条强调数据作为依据的重要性。当我们需要说服其他部门/上级管理者，以推动我们设计的内容时，只有数据——特别是跟钱有关的数据，才是最有说服力的证明。 由于篇幅所限，本文很难直接给出定量的值，因此建议架构设计者，先确保项目中设计使用2.7里的埋点系统，根据埋点系统获取的数据，对项目效果进行定量分析，并以此写成PPT和其他部门/上级管理者进行协调。</p>\n<h3 id=\"1-3、切入角度：\"><a href=\"#1-3、切入角度：\" class=\"headerlink\" title=\"1.3、切入角度：\"></a>1.3、切入角度：</h3><p>分为基础层和应用层。 基础层偏基础设施建设，与业务相关性较低。 应用层更贴近用户，用于解决某一个问题。 部分两个都沾边的，根据经验划分到其中一个。</p>\n<h3 id=\"1-4、其他\"><a href=\"#1-4、其他\" class=\"headerlink\" title=\"1.4、其他\"></a>1.4、其他</h3><p>由于已经谈到架构层级，因此很多内容，并不仅仅只属于前端领域，有很多内容是复合领域（前端、后端、运维、测试），因此需要负责架构的人，技术栈足够全面，对未来发展有足够的前瞻性。 文章的内容结构为：【项目】—&gt;【解决的问题和带来的好处】—&gt;【项目的实际意义】</p>\n<h2 id=\"2、基础层设计\"><a href=\"#2、基础层设计\" class=\"headerlink\" title=\"2、基础层设计\"></a>2、基础层设计</h2><h3 id=\"2-1、自建Gitlab\"><a href=\"#2-1、自建Gitlab\" class=\"headerlink\" title=\"2.1、自建Gitlab\"></a>2.1、自建Gitlab</h3><p>这个是基础的基础了。本不应该提的，不过考虑到我最近面试的几家公司，有的公司（人数并不少）并没有使用Gitlab，因此专门提一下，并且使用这个的难度非常低。 强烈建议使用Gitlab进行版本管理，自建Gitlab难度并不大，方便管理，包括代码管理、权限管理、提交日志查询，以及联动一些第三方插件。 意义： 公司代码是公司的重要资产，使用自建Gitlab可以有效保护公司资产。</p>\n<h3 id=\"2-2、版本管理\"><a href=\"#2-2、版本管理\" class=\"headerlink\" title=\"2.2、版本管理\"></a>2.2、版本管理</h3><p>版本管理的几个关键点：</p>\n<ul>\n<li>  发布后分支锁死，不可再更改：指当例如0.0.1版本成功发布后，不可再更改0.0.1分支上的代码，否则可能会导致版本管理混乱。</li>\n<li>  全自动流程发布；指应避免开发者提交后，手动编译打包等操作，换句话说，开发人员发布后，将自动发布到预发布/生产环境。开发人员不和相关环境直接接触。实现这个需要参考下面的2.3。</li>\n<li>  多版本并存；指当例如发布0.0.2版本后，0.0.1版本的代码应仍保存在线上（例如CDN），这样当出现线上bug时，方便快速回滚到上一个版本。</li>\n</ul>\n<p>意义： 提高项目的可控性。</p>\n<h3 id=\"2-3、自动编译发布Jenkins\"><a href=\"#2-3、自动编译发布Jenkins\" class=\"headerlink\" title=\"2.3、自动编译发布Jenkins\"></a>2.3、自动编译发布Jenkins</h3><p>这个工具用于在代码发布后，执行一系列流程，例如自动编译打包合并，然后再从Gitlab发布到CDN或者静态资源服务器。 使用这个工具，可以让一般研发人员不关心代码传到Gitlab后会发生什么事情，只需要专心于开发就可以了。 意义： 让研发人员专心于研发，和环境、运维等事情脱钩。</p>\n<h3 id=\"2-4、纯前端版本发布\"><a href=\"#2-4、纯前端版本发布\" class=\"headerlink\" title=\"2.4、纯前端版本发布\"></a>2.4、纯前端版本发布</h3><p>纯前端版本发布分为两步：</p>\n<ul>\n<li>  前端发布到生产环境——此时可以通过外网链接加正确的版本号访问到新版本的代码，但页面上的资源还是旧版本；</li>\n<li>  前端通过配置工具（或者是直接更新html文件），将html中引入的资源，改为新版本。</li>\n</ul>\n<p>解决的问题是：当前端需要发布新版本时，可以不依赖于后端（根据实际情况，也可以不依赖于运维）。毕竟有很多需求并不需要后端介入，单纯改个前端版本后就要后端发布一次，显然是一件非常麻烦的事情。 这个需要专门的工具，用于配置版本发布，我最近就在写这个。 意义： 提高发布效率，降低发布带来的人员时间损耗（这些都是钱），也可以在前端版本回滚的时候，速度更快。 文章链接： <a href=\"https://juejin.im/post/5d071428f265da1baa1e73ab\">juejin.im/post/5d0714…</a></p>\n<h3 id=\"2-5、统一脚手架\"><a href=\"#2-5、统一脚手架\" class=\"headerlink\" title=\"2.5、统一脚手架\"></a>2.5、统一脚手架</h3><p>适用场景：有比较多独立中小项目。好处：</p>\n<ul>\n<li>  可以减少开发人员配置脚手架带来的时间损耗（特殊功能可以fork脚手架后再自行定制）；</li>\n<li>  统一项目结构，方便管理，也降低项目交接时带来的需要熟悉项目的时间；</li>\n<li>  方便统一技术栈，可以预先引入固定的组件库；</li>\n</ul>\n<p>意义： 提高开发人员在多个项目之间的快速切换能力，提高项目可维护性，统一公司技术栈，避免因为环境不同导致奇怪的问题。</p>\n<h3 id=\"2-6、Node中间层\"><a href=\"#2-6、Node中间层\" class=\"headerlink\" title=\"2.6、Node中间层\"></a>2.6、Node中间层</h3><p>适用场景：需要SEO且前端使用React、vue，或前端介入后端逻辑，直接读取后端服务或者数据库的情况。</p>\n<ul>\n<li>  SEO：仁者见仁智者见智，虽然很多公司已经不做了，但通常认为，还是有一定意义的（特别是需要搜索引擎引流的时候），因此React或者Vue的同构是必须的。并且同构还可以降低首页白屏时间；</li>\n<li>  前端读取后端服务/数据库：好处是提高前端的开发效率和对业务的支持能力，缺点是可能导致P0级故障。</li>\n</ul>\n<p>意义： 让前端可以侵入后端领域，质的提升对业务的支持能力。</p>\n<h3 id=\"2-7、埋点系统\"><a href=\"#2-7、埋点系统\" class=\"headerlink\" title=\"2.7、埋点系统\"></a>2.7、埋点系统</h3><p>强烈推荐前端做自己的埋点系统。这个不同于后端的日志系统。 前端埋点系统的好处：</p>\n<ul>\n<li>  记录每个页面的访问量（日周月年的UV、PV）；</li>\n<li>  记录每个功能的使用量；</li>\n<li>  捕捉报错情况；</li>\n<li>  图表化显示，方便给其他部门展示；</li>\n</ul>\n<p>埋点系统是前端高度介入业务，把握业务发展情况的一把利剑，通过这个系统，我们可以比后端更深刻的把握用户的习惯，以及给产品经理、运营等人员提供准确的数据依据。当有了数据后，前端人员就可以针对性的优化功能、布局、页面交互逻辑、用户使用流程。 埋点系统应和业务解耦，开发人员使用时注册，然后在项目中引入。然后在埋点系统里查看相关数据（例如以小时、日、周、月、年为周期查看）[原创水印-作者：零零水(王冬)，微信：qq20004604]。 意义： 数据是money，数据是公司的生命线，数据是最好的武器。</p>\n<h3 id=\"2-8、监控和报警系统\"><a href=\"#2-8、监控和报警系统\" class=\"headerlink\" title=\"2.8、监控和报警系统\"></a>2.8、监控和报警系统</h3><p>监控和报警系统应基于埋点系统而建立，在如以下场景时[原创水印-作者：零零水(王冬)，微信：qq20004604]触发：</p>\n<ul>\n<li>  当访问量有比较大的变化（比如日PV/UV只有之前20%以下）时，自动触发报警，发送邮件到相关人员邮箱；</li>\n<li>  比如报错量大幅度上升（比如200%或更高），则触发报警；</li>\n<li>  当一段时间内没有任何访问量（不符合之前的情况），则触发报警；</li>\n<li>  每过一段时间，自动汇总访问者/报错触发者的相关信息（例如系统、浏览器版本等）；</li>\n</ul>\n<p>建设这个系统的好处在于，提前发现一些不容易发现的bug（需要埋点做的比较扎实）。有一些线上bug，因为用户环境特殊，导致无法被开发人员和测试人员发现。但其中一部分bug又因为不涉及资金，并不会导致资损（因此也不会被后端的监控系统所发现），这样的bug非常容易影响项目里某个链路的正常使用。 意义： 提高项目的稳定性，提高对业务的把控能力。降低bug数，降低资损的可能性，提前发现某些功能的bug（在工单到来之前）。</p>\n<h3 id=\"2-9、安全管理\"><a href=\"#2-9、安全管理\" class=\"headerlink\" title=\"2.9、安全管理\"></a>2.9、安全管理</h3><p>前端的安全管理，通常要依赖于后端，至于只跟单纯有关系的例如dom.innerHTML= ‘xxx ‘这种太基础，就不提了。 安全管理的很难从架构设计上完全避免，但还是有一定解决方案的，常见安全问题如下：</p>\n<ul>\n<li>  XSS注入：对用户输入的内容，需要转码（大部分时候要server端来处理，偶尔也需要前端处理），禁止使用eval函数；</li>\n<li>  https：这个显然是必须的，好处非常多；</li>\n<li>  CSRF：要求server端加入CSRF的处理方法（至少在关键页面加入）；</li>\n</ul>\n<p>意义： 减少安全漏洞，避免用户受到损失，避免遭遇恶意攻击，增加系统的稳定性和安全性。</p>\n<h3 id=\"2-10、Eslint\"><a href=\"#2-10、Eslint\" class=\"headerlink\" title=\"2.10、Eslint\"></a>2.10、Eslint</h3><p>Eslint的好处很多，强烈推荐使用：</p>\n<ul>\n<li>  降低低级bug（例如拼写问题）出现的概率；</li>\n<li>  增加代码的可维护性，可阅读性；</li>\n<li>  硬性统一代码风格，团队协作起来时更轻松；</li>\n</ul>\n<p>总的来说，eslint推荐直接配置到脚手架之中，对我们提高代码的可维护性的帮助会很大。可以考虑在上传到gitlab时，硬性要求eslint校验，通过的才允许上传。 意义： 提高代码的可维护性，降低团队协作的成本。</p>\n<h3 id=\"2-11、灰度发布\"><a href=\"#2-11、灰度发布\" class=\"headerlink\" title=\"2.11、灰度发布\"></a>2.11、灰度发布</h3><p>灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1~5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量极大的页面。 好处有以下几点：</p>\n<ul>\n<li>  生产环境比开发环境复杂，灰度发布时可以在生产环境小范围尝试观察新版本是否可以正常运行，即使出问题，也可以控制损失。</li>\n<li>  对于大版本更新，可以先灰度一部分，观察埋点效果和用户反馈（即所谓的抢先试用版）。假如效果并不好，那么回滚到老版本也可以及时止损；</li>\n<li>  当我们需要验证某些想法或问题的时候，可以先灰度一部分，快速验证效果如何，然后查漏补缺或者针对性优化；</li>\n</ul>\n<p>灰度发布通常分为多个阶段：【1】1%；【2】5<del>10%；【3】30</del>50%；【4】全量推送（100%）。灰度发布一定要允许配置某些IP/账号访问时，可以直接访问到灰度版本。 意义： 降低风险，提高发布灵活度。</p>\n<h3 id=\"2-12、前后端分离\"><a href=\"#2-12、前后端分离\" class=\"headerlink\" title=\"2.12、前后端分离\"></a>2.12、前后端分离</h3><p>这个并不是指常见的前后端分离，而是指在分配前后端管控的领域。 中小项目常见的情况是后端只提供接口和让某个url指向某个html，前端负责html、css、js等静态资源。 但大型项目并不建议这么做，建议前端负责除html以外的静态资源，而html交给后端处理，理由有很多：</p>\n<ul>\n<li>  后端进行渲染，方便统一插入一些代码和资源，例如埋点js，监控js，国际化文本资源，页面标识符等。这些通常是后端通过调用某些服务直接写入的；</li>\n<li>  当页面需要统一的头尾时（参考淘宝里我的淘宝页面），前端不应该关注这些跟当前页面无关的东西；</li>\n<li>  某些东西，如果通过html来管理，那么耦合度太高了，违背了解耦和分离的原则；</li>\n<li>  前端版本发布在后端引入某种功能模块后，可以从单独的页面控制前端发布内容，比更新html更方便，也利于灰度发布；</li>\n</ul>\n<p>意义： 更规范的进行页面管理，降低页面和功能的耦合度，减少复杂页面的环境配置时间。</p>\n<h3 id=\"2-13、Mock\"><a href=\"#2-13、Mock\" class=\"headerlink\" title=\"2.13、Mock\"></a>2.13、Mock</h3><p>Mock也是常见前端系统之一，用于解决在后端接口未好时，生成返回的数据。 我个人不太建议开发一个专门的系统来Mock，更好的Mock手法是直接嵌入到脚手架之中。思路如下：</p>\n<ul>\n<li>  当在开发环境下，访问链接通常是localhost:8000/index.html，此时加入后缀 ?debug=true；</li>\n<li>  封装好的异步请求在发现当前链接有以上标志时，认为是测试环境，访问/userinfo 时，不去读取线上的数据（因为也读取不到），去本地环境读取 src/test_ajax/userinfo.json，并将内容返回给用户；</li>\n<li>  异步请求正常拿到数据，在页面中显示[原创水印-作者：零零水(王冬)，微信：qq20004604]；</li>\n<li>  当线上接口可以获取到数据后，从network里找到返回的数据，放入/ src/test_ajax/userinfo.json中，此时再次本地调试的话，相当于使用的是线上的真实数据。</li>\n</ul>\n<p>这种处理，可以降低mock的复杂度，随时更改mock时返回的数据，比单独开发一个mock系统性价比更高。 意义： 在前后端并行开发时，降低沟通交流成本，方便开发完毕后直接对接。</p>\n<h3 id=\"2-14、定期备份\"><a href=\"#2-14、定期备份\" class=\"headerlink\" title=\"2.14、定期备份\"></a>2.14、定期备份</h3><p>备份是常被忽略的一件事情，但当我们遇见毁灭性场景时，缺少备份带来的损失是非常大的，常见场景：</p>\n<ul>\n<li>  服务器损坏，导致存在该服务器上的内容全部完蛋；</li>\n<li>  触发某致命bug或者错误操作（例如rm -f），导致文件和数据全部消失；</li>\n<li>  数据库出现错误操作或出现问题，导致用户数据、公司资产遭受严重损失；</li>\n</ul>\n<p>总的来说，没人想遇见这样的场景，但我们必须考虑这种极端情况的发生，因此需要从架构层面解决这个问题。常见方法是定期备份、多机备份、容灾系统建设等。 意义： 避免在遭遇极端场景时，给公司带来不可估量的损失。</p>\n<h2 id=\"3、应用层设计\"><a href=\"#3、应用层设计\" class=\"headerlink\" title=\"3、应用层设计\"></a>3、应用层设计</h2><h3 id=\"3-1、多页和单页\"><a href=\"#3-1、多页和单页\" class=\"headerlink\" title=\"3.1、多页和单页\"></a>3.1、多页和单页</h3><p>除了特殊场景，通常推荐使用多页架构。理由如下：</p>\n<ul>\n<li>  多页项目，页面和页面之间是独立的，不存在交互，因此当一个页面需要单独重构时，不会影响其他页面，对于有长期历史的项目来说，可维护性、可重构性要高很多；</li>\n<li>  多页项目的缺点是不同页面切换时，会有一个白屏时间，但通常来说，这个时间并不长，大部分现有大公司的线上网页，都是这样的，因此认为是可以接受的；</li>\n<li>  多页项目可以单次只更新一个页面的版本，而单页项目如果其中一个功能模块要更新（特别是公共组件更新），很容易让所有页面都需要更新版本；</li>\n<li>  多页项目的版本控制更简单，如果需要页面拆分，调整部分页面的使用流程，难度也会更低；</li>\n<li>  灰度发布更友好；</li>\n</ul>\n<p>之前面试的一家，采用了单页的形式，之前因为种种原因，同时采用了ng和react。由于项目历史也比较久（3年以上），结果导致目前继续维护更新的难度很大，即使想部分重构，也很麻烦。 意义： 降低长期项目迭代维护的难度，</p>\n<h3 id=\"3-2、以应用为单位划分前端项目\"><a href=\"#3-2、以应用为单位划分前端项目\" class=\"headerlink\" title=\"3.2、以应用为单位划分前端项目\"></a>3.2、以应用为单位划分前端项目</h3><p>在项目比较大的时候，将所有页面的前端文件放入到同一个代码仓库里，我之前参与过一家企业的前端项目开发，发现其就是这么做的。根据使用经验来看[原创水印-作者：零零水(王冬)，微信：qq20004604]，存在很多问题：</p>\n<ul>\n<li>  会极大的增加代码的维护难度；</li>\n<li>  项目会变得很丑陋；</li>\n<li>  不方便权限管理，容易造成页面误更改或代码泄密；</li>\n<li>  任何人都有权利改任何他能看到的页面（在合并代码的时候，管理人员并不能确定他本次修改的页面是否是需求里他应该改的页面）；</li>\n<li>  发布成本高，即使改一个页面，也需要发布所有资源；</li>\n</ul>\n<p>因此，我们应该避免这种现象的发生，个人推荐以应用为单位进行开发、发布。所谓应用即指一个业务涉及到的前后端代码，好处很多：</p>\n<ul>\n<li>  方便进行管理，当某个业务有需求变更时，可以只给研发人员该业务前端应用的developer权限；</li>\n<li>  在需要发布某业务时，只需要发布该业务的所属应用即可；</li>\n</ul>\n<p>意义： 规范项目，增加代码的安全性，降低项目维护成本。</p>\n<h3 id=\"3-3、基础组件库的建设\"><a href=\"#3-3、基础组件库的建设\" class=\"headerlink\" title=\"3.3、基础组件库的建设\"></a>3.3、基础组件库的建设</h3><p>这个蛮基础的，对于组件库的建设，不建议研发人员较少时去做这件事情，专职前端开发人数少于10人时，建议使用比较靠谱的第三方UI库，例如Antd，这样性价比更高。 设计基础组件库的前提，是要求统一技术栈，这样才能最大化基础组件库的效益。组件库建议以使用以下参考标准：</p>\n<ul>\n<li>  使用ts；</li>\n<li>  可扩展性强；</li>\n<li>  适用程度高；</li>\n<li>  文档清楚详细；</li>\n<li>  版本隔离，小版本优化加功能，大改需要大版本更新；</li>\n<li>  和UI协调统一，要求UI交互参与进来；</li>\n</ul>\n<p>总的来说，建设起来后，利大于弊，但是需要专人维护，因此还是有一定成本的。 意义： 统一不同/相同产品线之间的风格，给用户更好的体验，减少单次开发中写UI组件时浪费的时间和人力，提高开发效率。</p>\n<h3 id=\"3-4、技术栈统一\"><a href=\"#3-4、技术栈统一\" class=\"headerlink\" title=\"3.4、技术栈统一\"></a>3.4、技术栈统一</h3><p>前端有三大主流框架，还有兼容性最强jQuery，以及各种第三方库，UI框架。因此项目需求如果复杂一些，很容易形成一个大杂烩。因此前端的技术栈必须统一，具体来说，建议实现以下举措：</p>\n<ul>\n<li>  三大框架选型其一，团队水平一般推荐Vue、水平较好推荐React，对外项目选React或者ng；</li>\n<li>  需要兼容IE8或更老版本时，建议使用jQuery；</li>\n<li>  组件库自建或者统一选择一个固定的第三方；</li>\n<li>  一些特殊第三方库统一使用一个版本，例如需要使用地图时，固定使用高德或百度或腾讯地图；</li>\n<li>  基础设施建设应避免重复造轮子，所有团队尽量共用，并有专门的前端平_台负责统一这些东西，对于特殊需求，可以新建，但应当有说服力；</li>\n</ul>\n<p>总的来说，技术栈统一的好处很多，可以有效提高开发效率，降低重复造轮子产生的成本。 意义： 方便招人，简化团队成员培养成本，以及提高项目的可持续性。</p>\n<h3 id=\"3-5、浏览器兼容\"><a href=\"#3-5、浏览器兼容\" class=\"headerlink\" title=\"3.5、浏览器兼容\"></a>3.5、浏览器兼容</h3><p>常见的问题是IE6、7、8，以及部分小众浏览器（PC和手机）产生的奇怪问题。因此应该考虑统一解决方案，避免bug的重复产生。常见解决方案有：</p>\n<ul>\n<li>  配置postcss，让某些css增加兼容性前缀；</li>\n<li>  写一个wepback的loader，处理某些特殊场景；</li>\n<li>  规范团队代码，使用更稳定的写法（例如移动端避免使用fixed进行布局）；</li>\n<li>  对常见问题、疑难问题，总结解决方案并团队共享；</li>\n<li>  建议或引导用户使用高版本浏览器（比如chrome）；</li>\n</ul>\n<p>意义： 避免浏览器环境产生的bug，以及排查此类bug所浪费的大量时间。</p>\n<h3 id=\"3-6、内容平-台建设\"><a href=\"#3-6、内容平-台建设\" class=\"headerlink\" title=\"3.6、内容平_台建设\"></a>3.6、内容平_台建设</h3><p>为了提高公司内部的沟通效率，总结经验，以及保密原因。应建设一个内部论坛+博客站点。其具备的好处如下：</p>\n<ul>\n<li>  可以记录公司的历史；</li>\n<li>  研发同学之间分享经验；</li>\n<li>  总结转载一些外界比较精品的文章，提高大家的眼界；</li>\n<li>  增加公司内部同学的交流，有利于公司的团队和文化建设；</li>\n<li>  对某些技术问题可以进行讨论，减少因没有达成共识带来的沟通损耗；</li>\n</ul>\n<p>众所周知，大型互联网公司通常都有这样一个内部论坛和博客站点。其降低了公司的沟通和交流成本，也增加了公司的技术积累。 意义： 博客增强技术积累，论坛增强公司内部沟通能力。</p>\n<h3 id=\"3-7、权限管理平-台\"><a href=\"#3-7、权限管理平-台\" class=\"headerlink\" title=\"3.7、权限管理平_台\"></a>3.7、权限管理平_台</h3><p>当公司内部人员较多时，应有一个专门的平_台，来管理、规范用户的权限以及可访问内容[原创水印-作者：零零水(王冬)，微信：qq20004604]。权限管理平_台有几个特点：</p>\n<ul>\n<li>  必然和Server端天然高耦合度，因此需要有专门的控制模块负责处理权限问题（负责Server端开发处理，或者前端通过中间层例如Node层介入处理）；</li>\n<li>  自动化流程控制，即用户创建、申请、审批、离职自动删除，都应该是由系统推进并提醒相关人士，必要时应能触发报警；</li>\n<li>  权限应有时效性，减少永久性权限的产生；</li>\n<li>  审批流程应清晰可见，每一阶段流程应具体明确；</li>\n<li>  应与公司流程紧密结合，并且提高可修改性，方便公司后期进行流程优化；</li>\n</ul>\n<p>意义： 使得公司内部流程正规化、信息化。</p>\n<h3 id=\"3-8、登录系统设计（单点登录）\"><a href=\"#3-8、登录系统设计（单点登录）\" class=\"headerlink\" title=\"3.8、登录系统设计（单点登录）\"></a>3.8、登录系统设计（单点登录）</h3><p>当公司内部业务线比较复杂但相互之间的耦合度比较高时，我们应该考虑设计添加单点登录系统。具体来说，用户在一处登录，即可以在任何页面访问，登出时，也同样在任何页面都失去登录状态。SSO的好处很多：</p>\n<ul>\n<li>  增强用户体验；</li>\n<li>  打通了不同业务系统之间的用户数据；</li>\n<li>  方便统一管理用户；</li>\n<li>  有利于引流；</li>\n<li>  降低开发系统的成本（不需要每个业务都开发一次登录系统和用户状态控制）；</li>\n</ul>\n<p>总的来说，大中型web应用，SSO可以带来很多好处，缺点却很少。 意义： 用户体验增强，打通不同业务之间的间隔，降低开发成本和用户管理成本。</p>\n<h3 id=\"3-9、CDN\"><a href=\"#3-9、CDN\" class=\"headerlink\" title=\"3.9、CDN\"></a>3.9、CDN</h3><p>前端资源的加载速度是衡量用户体验的重要指标之一。而现实中，因为种种因素，用户在加载页面资源时，会受到很多限制。因此上CDN是非常有意义的，好处如下：</p>\n<ul>\n<li>  用户来自不同地区，加入CDN可以使用户访问资源时，访问离自己比较近的CDN服务器，降低访问延迟；</li>\n<li>  降低服务器带宽使用成本；</li>\n<li>  支持视频、静态资源、大文件、小文件、直播等多种业务场景；</li>\n<li>  消除跨运营商造成的网络速度较慢的问题；</li>\n<li>  降低DDOS攻击造成的对网站的影响；</li>\n</ul>\n<p>CDN是一种比较成熟的技术，各大云平_台都有提供CDN服务，价格也不贵，因此CDN的性价比很高。 意义： 增加用户访问速度，降低网络延迟，带宽优化，减少服务器负载，增强对攻击的抵抗能力。</p>\n<h3 id=\"3-10、负载均衡\"><a href=\"#3-10、负载均衡\" class=\"headerlink\" title=\"3.10、负载均衡\"></a>3.10、负载均衡</h3><p>目前来看，负载均衡通常使用Nginx比较多，以前也有使用Apache。当遇见大型项目的时候，负载均衡和分布式几乎是必须的。负载均衡有以下好处：</p>\n<ul>\n<li>  降低单台server的压力，提高业务承载能力；</li>\n<li>  方便应对峰值流量，扩容方便（如举办某些活动时）；</li>\n<li>  增强业务的可用性、扩展性、稳定性；</li>\n</ul>\n<p>负载均衡已经是蛮常见的技术了，好处不用多说，很容易理解。 意义： 增强业务的可用性、扩展性、稳定性，可以支持更多用户的访问。</p>\n<h3 id=\"3-11、多端共用一套接口\"><a href=\"#3-11、多端共用一套接口\" class=\"headerlink\" title=\"3.11、多端共用一套接口\"></a>3.11、多端共用一套接口</h3><p>目前常见场景是一个业务，同时有PC页面和H5页面，由于业务是一样的，因此应避免同一个业务有多套接口分别适用于PC和H5端。因此解决方案如下：</p>\n<ul>\n<li>  后端提供的接口，应该同时包含PC和H5的数据（即单独对一个存在亢余数据）；</li>\n<li>  接口应当稳定，即当业务变更时，应尽量采取追加数据的形式；</li>\n<li>  只有在单独一端需要特殊业务流程时，设计单端独有接口；</li>\n</ul>\n<p>多端共用接口，是减少开发工作量，并且提高业务可维护性的重要解决方案。 意义： 降低开发工作量，增强可维护性。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>目录：</p>\n<ul>\n<li>  1、综合</li>\n<li>  1.1、使用场景</li>\n<li>  1.2、核心思想</li>\n<li>  1.3、切入角度</li>\n<li>  1.4、其他</li>\n<li>  2、基础层设计</li>\n<li>  2.1、自建Gitlab</li>\n<li>  2.2、版本管理</li>\n<li>  2.3、自动编译发布Jenkins</li>\n<li>  2.4、纯前端版本发布</li>\n<li>  2.5、统一脚手架</li>\n<li>  2.6、Node中间层</li>\n<li>  2.7、埋点系统</li>\n<li>  2.8、监控和报警系统</li>\n<li>  2.9、安全管理</li>\n<li>  2.10、Eslint</li>\n<li>  2.11、灰度发布</li>\n<li>  2.12、前后端分离</li>\n<li>  2.13、Mock</li>\n<li>  2.14、定期备份</li>\n<li>  3、应用层设计</li>\n<li>  3.1、多页和单页</li>\n<li>  3.2、以应用为单位划分前端项目</li>\n<li>  3.3、基础组件库的建设</li>\n<li>  3.4、技术栈统一</li>\n<li>  3.5、浏览器兼容</li>\n<li>  3.6、内容平_台建设</li>\n<li>  3.7、权限管理平_台</li>\n<li>  3.8、登录系统设计（单点登录）</li>\n<li>  3.9、CDN</li>\n<li>  3.10、负载均衡</li>\n<li>  3.11、多端共用一套接口</li>\n<li>  4、总结</li>\n</ul>\n<h2 id=\"1、综合\"><a href=\"#1、综合\" class=\"headerlink\" title=\"1、综合\"></a>1、综合</h2><p>我在2年之前，写过一篇中小型项目的前端架构浅谈。随着能力的上升，以及在阿里巴巴工作的经验，是时候写一篇大型项目的前端架构分析了。 本篇文章不会更多侧重于具体技术实现，而是尝试从更高角度出发，分析为什么要这么做，这些设计能解决什么问题，成本和收益如何。 由于作者能力有限，可能会有所缺漏或者部分错误，欢迎读者指出。</p>\n<h3 id=\"1-1、适用场景：\"><a href=\"#1-1、适用场景：\" class=\"headerlink\" title=\"1.1、适用场景：\"></a>1.1、适用场景：</h3><p>本篇文章，适用于单个/多个大型项目、拥有超过10个以上的前端开发的场景。 前端项目的规模不同，成本收益比也会有所差别。通常来说，人员越多、项目复杂度越高，那么收益/成本的比值越大。 对于人数较少、项目简单的开发团队，可能有部分措施不适用，因此应该根据具体情况来选用。</p>\n<h3 id=\"1-2、核心思想：\"><a href=\"#1-2、核心思想：\" class=\"headerlink\" title=\"1.2、核心思想：\"></a>1.2、核心思想：</h3><p>【1】解决问题：前端架构的设计，应是用于解决已存在或者未来可能发生的技术问题，增加项目的可管理性、稳定性、可扩展性。 【2】人效比：对于需要额外开发工作量的事务（本文中存在一些需要一定开发量的内容），我们在决定是否去做的时候，应该考虑到两个要素：第一个是花费的人力成本，第二个是未来可能节约的时间和金钱、避免的项目风险与资损、提高对业务的支撑能力以带来在业务上可衡量的更高的价值、以及其他价值。 【3】定性和定量：架构里设计的内容，一定要有是可衡量的意义的，最好是可以定量的——即可以衡量带来的收益或减少的成本，至少是可以定性的——即虽然无法用数字阐述收益，但我们可以明确这个是有意义的，例如增加安全性降低风险。 【4】数据敏感：专门写这一条强调数据作为依据的重要性。当我们需要说服其他部门/上级管理者，以推动我们设计的内容时，只有数据——特别是跟钱有关的数据，才是最有说服力的证明。 由于篇幅所限，本文很难直接给出定量的值，因此建议架构设计者，先确保项目中设计使用2.7里的埋点系统，根据埋点系统获取的数据，对项目效果进行定量分析，并以此写成PPT和其他部门/上级管理者进行协调。</p>\n<h3 id=\"1-3、切入角度：\"><a href=\"#1-3、切入角度：\" class=\"headerlink\" title=\"1.3、切入角度：\"></a>1.3、切入角度：</h3><p>分为基础层和应用层。 基础层偏基础设施建设，与业务相关性较低。 应用层更贴近用户，用于解决某一个问题。 部分两个都沾边的，根据经验划分到其中一个。</p>\n<h3 id=\"1-4、其他\"><a href=\"#1-4、其他\" class=\"headerlink\" title=\"1.4、其他\"></a>1.4、其他</h3><p>由于已经谈到架构层级，因此很多内容，并不仅仅只属于前端领域，有很多内容是复合领域（前端、后端、运维、测试），因此需要负责架构的人，技术栈足够全面，对未来发展有足够的前瞻性。 文章的内容结构为：【项目】—&gt;【解决的问题和带来的好处】—&gt;【项目的实际意义】</p>\n<h2 id=\"2、基础层设计\"><a href=\"#2、基础层设计\" class=\"headerlink\" title=\"2、基础层设计\"></a>2、基础层设计</h2><h3 id=\"2-1、自建Gitlab\"><a href=\"#2-1、自建Gitlab\" class=\"headerlink\" title=\"2.1、自建Gitlab\"></a>2.1、自建Gitlab</h3><p>这个是基础的基础了。本不应该提的，不过考虑到我最近面试的几家公司，有的公司（人数并不少）并没有使用Gitlab，因此专门提一下，并且使用这个的难度非常低。 强烈建议使用Gitlab进行版本管理，自建Gitlab难度并不大，方便管理，包括代码管理、权限管理、提交日志查询，以及联动一些第三方插件。 意义： 公司代码是公司的重要资产，使用自建Gitlab可以有效保护公司资产。</p>\n<h3 id=\"2-2、版本管理\"><a href=\"#2-2、版本管理\" class=\"headerlink\" title=\"2.2、版本管理\"></a>2.2、版本管理</h3><p>版本管理的几个关键点：</p>\n<ul>\n<li>  发布后分支锁死，不可再更改：指当例如0.0.1版本成功发布后，不可再更改0.0.1分支上的代码，否则可能会导致版本管理混乱。</li>\n<li>  全自动流程发布；指应避免开发者提交后，手动编译打包等操作，换句话说，开发人员发布后，将自动发布到预发布/生产环境。开发人员不和相关环境直接接触。实现这个需要参考下面的2.3。</li>\n<li>  多版本并存；指当例如发布0.0.2版本后，0.0.1版本的代码应仍保存在线上（例如CDN），这样当出现线上bug时，方便快速回滚到上一个版本。</li>\n</ul>\n<p>意义： 提高项目的可控性。</p>\n<h3 id=\"2-3、自动编译发布Jenkins\"><a href=\"#2-3、自动编译发布Jenkins\" class=\"headerlink\" title=\"2.3、自动编译发布Jenkins\"></a>2.3、自动编译发布Jenkins</h3><p>这个工具用于在代码发布后，执行一系列流程，例如自动编译打包合并，然后再从Gitlab发布到CDN或者静态资源服务器。 使用这个工具，可以让一般研发人员不关心代码传到Gitlab后会发生什么事情，只需要专心于开发就可以了。 意义： 让研发人员专心于研发，和环境、运维等事情脱钩。</p>\n<h3 id=\"2-4、纯前端版本发布\"><a href=\"#2-4、纯前端版本发布\" class=\"headerlink\" title=\"2.4、纯前端版本发布\"></a>2.4、纯前端版本发布</h3><p>纯前端版本发布分为两步：</p>\n<ul>\n<li>  前端发布到生产环境——此时可以通过外网链接加正确的版本号访问到新版本的代码，但页面上的资源还是旧版本；</li>\n<li>  前端通过配置工具（或者是直接更新html文件），将html中引入的资源，改为新版本。</li>\n</ul>\n<p>解决的问题是：当前端需要发布新版本时，可以不依赖于后端（根据实际情况，也可以不依赖于运维）。毕竟有很多需求并不需要后端介入，单纯改个前端版本后就要后端发布一次，显然是一件非常麻烦的事情。 这个需要专门的工具，用于配置版本发布，我最近就在写这个。 意义： 提高发布效率，降低发布带来的人员时间损耗（这些都是钱），也可以在前端版本回滚的时候，速度更快。 文章链接： <a href=\"https://juejin.im/post/5d071428f265da1baa1e73ab\">juejin.im/post/5d0714…</a></p>\n<h3 id=\"2-5、统一脚手架\"><a href=\"#2-5、统一脚手架\" class=\"headerlink\" title=\"2.5、统一脚手架\"></a>2.5、统一脚手架</h3><p>适用场景：有比较多独立中小项目。好处：</p>\n<ul>\n<li>  可以减少开发人员配置脚手架带来的时间损耗（特殊功能可以fork脚手架后再自行定制）；</li>\n<li>  统一项目结构，方便管理，也降低项目交接时带来的需要熟悉项目的时间；</li>\n<li>  方便统一技术栈，可以预先引入固定的组件库；</li>\n</ul>\n<p>意义： 提高开发人员在多个项目之间的快速切换能力，提高项目可维护性，统一公司技术栈，避免因为环境不同导致奇怪的问题。</p>\n<h3 id=\"2-6、Node中间层\"><a href=\"#2-6、Node中间层\" class=\"headerlink\" title=\"2.6、Node中间层\"></a>2.6、Node中间层</h3><p>适用场景：需要SEO且前端使用React、vue，或前端介入后端逻辑，直接读取后端服务或者数据库的情况。</p>\n<ul>\n<li>  SEO：仁者见仁智者见智，虽然很多公司已经不做了，但通常认为，还是有一定意义的（特别是需要搜索引擎引流的时候），因此React或者Vue的同构是必须的。并且同构还可以降低首页白屏时间；</li>\n<li>  前端读取后端服务/数据库：好处是提高前端的开发效率和对业务的支持能力，缺点是可能导致P0级故障。</li>\n</ul>\n<p>意义： 让前端可以侵入后端领域，质的提升对业务的支持能力。</p>\n<h3 id=\"2-7、埋点系统\"><a href=\"#2-7、埋点系统\" class=\"headerlink\" title=\"2.7、埋点系统\"></a>2.7、埋点系统</h3><p>强烈推荐前端做自己的埋点系统。这个不同于后端的日志系统。 前端埋点系统的好处：</p>\n<ul>\n<li>  记录每个页面的访问量（日周月年的UV、PV）；</li>\n<li>  记录每个功能的使用量；</li>\n<li>  捕捉报错情况；</li>\n<li>  图表化显示，方便给其他部门展示；</li>\n</ul>\n<p>埋点系统是前端高度介入业务，把握业务发展情况的一把利剑，通过这个系统，我们可以比后端更深刻的把握用户的习惯，以及给产品经理、运营等人员提供准确的数据依据。当有了数据后，前端人员就可以针对性的优化功能、布局、页面交互逻辑、用户使用流程。 埋点系统应和业务解耦，开发人员使用时注册，然后在项目中引入。然后在埋点系统里查看相关数据（例如以小时、日、周、月、年为周期查看）[原创水印-作者：零零水(王冬)，微信：qq20004604]。 意义： 数据是money，数据是公司的生命线，数据是最好的武器。</p>\n<h3 id=\"2-8、监控和报警系统\"><a href=\"#2-8、监控和报警系统\" class=\"headerlink\" title=\"2.8、监控和报警系统\"></a>2.8、监控和报警系统</h3><p>监控和报警系统应基于埋点系统而建立，在如以下场景时[原创水印-作者：零零水(王冬)，微信：qq20004604]触发：</p>\n<ul>\n<li>  当访问量有比较大的变化（比如日PV/UV只有之前20%以下）时，自动触发报警，发送邮件到相关人员邮箱；</li>\n<li>  比如报错量大幅度上升（比如200%或更高），则触发报警；</li>\n<li>  当一段时间内没有任何访问量（不符合之前的情况），则触发报警；</li>\n<li>  每过一段时间，自动汇总访问者/报错触发者的相关信息（例如系统、浏览器版本等）；</li>\n</ul>\n<p>建设这个系统的好处在于，提前发现一些不容易发现的bug（需要埋点做的比较扎实）。有一些线上bug，因为用户环境特殊，导致无法被开发人员和测试人员发现。但其中一部分bug又因为不涉及资金，并不会导致资损（因此也不会被后端的监控系统所发现），这样的bug非常容易影响项目里某个链路的正常使用。 意义： 提高项目的稳定性，提高对业务的把控能力。降低bug数，降低资损的可能性，提前发现某些功能的bug（在工单到来之前）。</p>\n<h3 id=\"2-9、安全管理\"><a href=\"#2-9、安全管理\" class=\"headerlink\" title=\"2.9、安全管理\"></a>2.9、安全管理</h3><p>前端的安全管理，通常要依赖于后端，至于只跟单纯有关系的例如dom.innerHTML= ‘xxx ‘这种太基础，就不提了。 安全管理的很难从架构设计上完全避免，但还是有一定解决方案的，常见安全问题如下：</p>\n<ul>\n<li>  XSS注入：对用户输入的内容，需要转码（大部分时候要server端来处理，偶尔也需要前端处理），禁止使用eval函数；</li>\n<li>  https：这个显然是必须的，好处非常多；</li>\n<li>  CSRF：要求server端加入CSRF的处理方法（至少在关键页面加入）；</li>\n</ul>\n<p>意义： 减少安全漏洞，避免用户受到损失，避免遭遇恶意攻击，增加系统的稳定性和安全性。</p>\n<h3 id=\"2-10、Eslint\"><a href=\"#2-10、Eslint\" class=\"headerlink\" title=\"2.10、Eslint\"></a>2.10、Eslint</h3><p>Eslint的好处很多，强烈推荐使用：</p>\n<ul>\n<li>  降低低级bug（例如拼写问题）出现的概率；</li>\n<li>  增加代码的可维护性，可阅读性；</li>\n<li>  硬性统一代码风格，团队协作起来时更轻松；</li>\n</ul>\n<p>总的来说，eslint推荐直接配置到脚手架之中，对我们提高代码的可维护性的帮助会很大。可以考虑在上传到gitlab时，硬性要求eslint校验，通过的才允许上传。 意义： 提高代码的可维护性，降低团队协作的成本。</p>\n<h3 id=\"2-11、灰度发布\"><a href=\"#2-11、灰度发布\" class=\"headerlink\" title=\"2.11、灰度发布\"></a>2.11、灰度发布</h3><p>灰度发布是大型项目在发布时的常见方法，指在发布版本时，初始情况下，只允许小比例（比如1~5%比例的用户使用），若出现问题时，可以快速回滚使用老版本，适用于主链路和访问量极大的页面。 好处有以下几点：</p>\n<ul>\n<li>  生产环境比开发环境复杂，灰度发布时可以在生产环境小范围尝试观察新版本是否可以正常运行，即使出问题，也可以控制损失。</li>\n<li>  对于大版本更新，可以先灰度一部分，观察埋点效果和用户反馈（即所谓的抢先试用版）。假如效果并不好，那么回滚到老版本也可以及时止损；</li>\n<li>  当我们需要验证某些想法或问题的时候，可以先灰度一部分，快速验证效果如何，然后查漏补缺或者针对性优化；</li>\n</ul>\n<p>灰度发布通常分为多个阶段：【1】1%；【2】5<del>10%；【3】30</del>50%；【4】全量推送（100%）。灰度发布一定要允许配置某些IP/账号访问时，可以直接访问到灰度版本。 意义： 降低风险，提高发布灵活度。</p>\n<h3 id=\"2-12、前后端分离\"><a href=\"#2-12、前后端分离\" class=\"headerlink\" title=\"2.12、前后端分离\"></a>2.12、前后端分离</h3><p>这个并不是指常见的前后端分离，而是指在分配前后端管控的领域。 中小项目常见的情况是后端只提供接口和让某个url指向某个html，前端负责html、css、js等静态资源。 但大型项目并不建议这么做，建议前端负责除html以外的静态资源，而html交给后端处理，理由有很多：</p>\n<ul>\n<li>  后端进行渲染，方便统一插入一些代码和资源，例如埋点js，监控js，国际化文本资源，页面标识符等。这些通常是后端通过调用某些服务直接写入的；</li>\n<li>  当页面需要统一的头尾时（参考淘宝里我的淘宝页面），前端不应该关注这些跟当前页面无关的东西；</li>\n<li>  某些东西，如果通过html来管理，那么耦合度太高了，违背了解耦和分离的原则；</li>\n<li>  前端版本发布在后端引入某种功能模块后，可以从单独的页面控制前端发布内容，比更新html更方便，也利于灰度发布；</li>\n</ul>\n<p>意义： 更规范的进行页面管理，降低页面和功能的耦合度，减少复杂页面的环境配置时间。</p>\n<h3 id=\"2-13、Mock\"><a href=\"#2-13、Mock\" class=\"headerlink\" title=\"2.13、Mock\"></a>2.13、Mock</h3><p>Mock也是常见前端系统之一，用于解决在后端接口未好时，生成返回的数据。 我个人不太建议开发一个专门的系统来Mock，更好的Mock手法是直接嵌入到脚手架之中。思路如下：</p>\n<ul>\n<li>  当在开发环境下，访问链接通常是localhost:8000/index.html，此时加入后缀 ?debug=true；</li>\n<li>  封装好的异步请求在发现当前链接有以上标志时，认为是测试环境，访问/userinfo 时，不去读取线上的数据（因为也读取不到），去本地环境读取 src/test_ajax/userinfo.json，并将内容返回给用户；</li>\n<li>  异步请求正常拿到数据，在页面中显示[原创水印-作者：零零水(王冬)，微信：qq20004604]；</li>\n<li>  当线上接口可以获取到数据后，从network里找到返回的数据，放入/ src/test_ajax/userinfo.json中，此时再次本地调试的话，相当于使用的是线上的真实数据。</li>\n</ul>\n<p>这种处理，可以降低mock的复杂度，随时更改mock时返回的数据，比单独开发一个mock系统性价比更高。 意义： 在前后端并行开发时，降低沟通交流成本，方便开发完毕后直接对接。</p>\n<h3 id=\"2-14、定期备份\"><a href=\"#2-14、定期备份\" class=\"headerlink\" title=\"2.14、定期备份\"></a>2.14、定期备份</h3><p>备份是常被忽略的一件事情，但当我们遇见毁灭性场景时，缺少备份带来的损失是非常大的，常见场景：</p>\n<ul>\n<li>  服务器损坏，导致存在该服务器上的内容全部完蛋；</li>\n<li>  触发某致命bug或者错误操作（例如rm -f），导致文件和数据全部消失；</li>\n<li>  数据库出现错误操作或出现问题，导致用户数据、公司资产遭受严重损失；</li>\n</ul>\n<p>总的来说，没人想遇见这样的场景，但我们必须考虑这种极端情况的发生，因此需要从架构层面解决这个问题。常见方法是定期备份、多机备份、容灾系统建设等。 意义： 避免在遭遇极端场景时，给公司带来不可估量的损失。</p>\n<h2 id=\"3、应用层设计\"><a href=\"#3、应用层设计\" class=\"headerlink\" title=\"3、应用层设计\"></a>3、应用层设计</h2><h3 id=\"3-1、多页和单页\"><a href=\"#3-1、多页和单页\" class=\"headerlink\" title=\"3.1、多页和单页\"></a>3.1、多页和单页</h3><p>除了特殊场景，通常推荐使用多页架构。理由如下：</p>\n<ul>\n<li>  多页项目，页面和页面之间是独立的，不存在交互，因此当一个页面需要单独重构时，不会影响其他页面，对于有长期历史的项目来说，可维护性、可重构性要高很多；</li>\n<li>  多页项目的缺点是不同页面切换时，会有一个白屏时间，但通常来说，这个时间并不长，大部分现有大公司的线上网页，都是这样的，因此认为是可以接受的；</li>\n<li>  多页项目可以单次只更新一个页面的版本，而单页项目如果其中一个功能模块要更新（特别是公共组件更新），很容易让所有页面都需要更新版本；</li>\n<li>  多页项目的版本控制更简单，如果需要页面拆分，调整部分页面的使用流程，难度也会更低；</li>\n<li>  灰度发布更友好；</li>\n</ul>\n<p>之前面试的一家，采用了单页的形式，之前因为种种原因，同时采用了ng和react。由于项目历史也比较久（3年以上），结果导致目前继续维护更新的难度很大，即使想部分重构，也很麻烦。 意义： 降低长期项目迭代维护的难度，</p>\n<h3 id=\"3-2、以应用为单位划分前端项目\"><a href=\"#3-2、以应用为单位划分前端项目\" class=\"headerlink\" title=\"3.2、以应用为单位划分前端项目\"></a>3.2、以应用为单位划分前端项目</h3><p>在项目比较大的时候，将所有页面的前端文件放入到同一个代码仓库里，我之前参与过一家企业的前端项目开发，发现其就是这么做的。根据使用经验来看[原创水印-作者：零零水(王冬)，微信：qq20004604]，存在很多问题：</p>\n<ul>\n<li>  会极大的增加代码的维护难度；</li>\n<li>  项目会变得很丑陋；</li>\n<li>  不方便权限管理，容易造成页面误更改或代码泄密；</li>\n<li>  任何人都有权利改任何他能看到的页面（在合并代码的时候，管理人员并不能确定他本次修改的页面是否是需求里他应该改的页面）；</li>\n<li>  发布成本高，即使改一个页面，也需要发布所有资源；</li>\n</ul>\n<p>因此，我们应该避免这种现象的发生，个人推荐以应用为单位进行开发、发布。所谓应用即指一个业务涉及到的前后端代码，好处很多：</p>\n<ul>\n<li>  方便进行管理，当某个业务有需求变更时，可以只给研发人员该业务前端应用的developer权限；</li>\n<li>  在需要发布某业务时，只需要发布该业务的所属应用即可；</li>\n</ul>\n<p>意义： 规范项目，增加代码的安全性，降低项目维护成本。</p>\n<h3 id=\"3-3、基础组件库的建设\"><a href=\"#3-3、基础组件库的建设\" class=\"headerlink\" title=\"3.3、基础组件库的建设\"></a>3.3、基础组件库的建设</h3><p>这个蛮基础的，对于组件库的建设，不建议研发人员较少时去做这件事情，专职前端开发人数少于10人时，建议使用比较靠谱的第三方UI库，例如Antd，这样性价比更高。 设计基础组件库的前提，是要求统一技术栈，这样才能最大化基础组件库的效益。组件库建议以使用以下参考标准：</p>\n<ul>\n<li>  使用ts；</li>\n<li>  可扩展性强；</li>\n<li>  适用程度高；</li>\n<li>  文档清楚详细；</li>\n<li>  版本隔离，小版本优化加功能，大改需要大版本更新；</li>\n<li>  和UI协调统一，要求UI交互参与进来；</li>\n</ul>\n<p>总的来说，建设起来后，利大于弊，但是需要专人维护，因此还是有一定成本的。 意义： 统一不同/相同产品线之间的风格，给用户更好的体验，减少单次开发中写UI组件时浪费的时间和人力，提高开发效率。</p>\n<h3 id=\"3-4、技术栈统一\"><a href=\"#3-4、技术栈统一\" class=\"headerlink\" title=\"3.4、技术栈统一\"></a>3.4、技术栈统一</h3><p>前端有三大主流框架，还有兼容性最强jQuery，以及各种第三方库，UI框架。因此项目需求如果复杂一些，很容易形成一个大杂烩。因此前端的技术栈必须统一，具体来说，建议实现以下举措：</p>\n<ul>\n<li>  三大框架选型其一，团队水平一般推荐Vue、水平较好推荐React，对外项目选React或者ng；</li>\n<li>  需要兼容IE8或更老版本时，建议使用jQuery；</li>\n<li>  组件库自建或者统一选择一个固定的第三方；</li>\n<li>  一些特殊第三方库统一使用一个版本，例如需要使用地图时，固定使用高德或百度或腾讯地图；</li>\n<li>  基础设施建设应避免重复造轮子，所有团队尽量共用，并有专门的前端平_台负责统一这些东西，对于特殊需求，可以新建，但应当有说服力；</li>\n</ul>\n<p>总的来说，技术栈统一的好处很多，可以有效提高开发效率，降低重复造轮子产生的成本。 意义： 方便招人，简化团队成员培养成本，以及提高项目的可持续性。</p>\n<h3 id=\"3-5、浏览器兼容\"><a href=\"#3-5、浏览器兼容\" class=\"headerlink\" title=\"3.5、浏览器兼容\"></a>3.5、浏览器兼容</h3><p>常见的问题是IE6、7、8，以及部分小众浏览器（PC和手机）产生的奇怪问题。因此应该考虑统一解决方案，避免bug的重复产生。常见解决方案有：</p>\n<ul>\n<li>  配置postcss，让某些css增加兼容性前缀；</li>\n<li>  写一个wepback的loader，处理某些特殊场景；</li>\n<li>  规范团队代码，使用更稳定的写法（例如移动端避免使用fixed进行布局）；</li>\n<li>  对常见问题、疑难问题，总结解决方案并团队共享；</li>\n<li>  建议或引导用户使用高版本浏览器（比如chrome）；</li>\n</ul>\n<p>意义： 避免浏览器环境产生的bug，以及排查此类bug所浪费的大量时间。</p>\n<h3 id=\"3-6、内容平-台建设\"><a href=\"#3-6、内容平-台建设\" class=\"headerlink\" title=\"3.6、内容平_台建设\"></a>3.6、内容平_台建设</h3><p>为了提高公司内部的沟通效率，总结经验，以及保密原因。应建设一个内部论坛+博客站点。其具备的好处如下：</p>\n<ul>\n<li>  可以记录公司的历史；</li>\n<li>  研发同学之间分享经验；</li>\n<li>  总结转载一些外界比较精品的文章，提高大家的眼界；</li>\n<li>  增加公司内部同学的交流，有利于公司的团队和文化建设；</li>\n<li>  对某些技术问题可以进行讨论，减少因没有达成共识带来的沟通损耗；</li>\n</ul>\n<p>众所周知，大型互联网公司通常都有这样一个内部论坛和博客站点。其降低了公司的沟通和交流成本，也增加了公司的技术积累。 意义： 博客增强技术积累，论坛增强公司内部沟通能力。</p>\n<h3 id=\"3-7、权限管理平-台\"><a href=\"#3-7、权限管理平-台\" class=\"headerlink\" title=\"3.7、权限管理平_台\"></a>3.7、权限管理平_台</h3><p>当公司内部人员较多时，应有一个专门的平_台，来管理、规范用户的权限以及可访问内容[原创水印-作者：零零水(王冬)，微信：qq20004604]。权限管理平_台有几个特点：</p>\n<ul>\n<li>  必然和Server端天然高耦合度，因此需要有专门的控制模块负责处理权限问题（负责Server端开发处理，或者前端通过中间层例如Node层介入处理）；</li>\n<li>  自动化流程控制，即用户创建、申请、审批、离职自动删除，都应该是由系统推进并提醒相关人士，必要时应能触发报警；</li>\n<li>  权限应有时效性，减少永久性权限的产生；</li>\n<li>  审批流程应清晰可见，每一阶段流程应具体明确；</li>\n<li>  应与公司流程紧密结合，并且提高可修改性，方便公司后期进行流程优化；</li>\n</ul>\n<p>意义： 使得公司内部流程正规化、信息化。</p>\n<h3 id=\"3-8、登录系统设计（单点登录）\"><a href=\"#3-8、登录系统设计（单点登录）\" class=\"headerlink\" title=\"3.8、登录系统设计（单点登录）\"></a>3.8、登录系统设计（单点登录）</h3><p>当公司内部业务线比较复杂但相互之间的耦合度比较高时，我们应该考虑设计添加单点登录系统。具体来说，用户在一处登录，即可以在任何页面访问，登出时，也同样在任何页面都失去登录状态。SSO的好处很多：</p>\n<ul>\n<li>  增强用户体验；</li>\n<li>  打通了不同业务系统之间的用户数据；</li>\n<li>  方便统一管理用户；</li>\n<li>  有利于引流；</li>\n<li>  降低开发系统的成本（不需要每个业务都开发一次登录系统和用户状态控制）；</li>\n</ul>\n<p>总的来说，大中型web应用，SSO可以带来很多好处，缺点却很少。 意义： 用户体验增强，打通不同业务之间的间隔，降低开发成本和用户管理成本。</p>\n<h3 id=\"3-9、CDN\"><a href=\"#3-9、CDN\" class=\"headerlink\" title=\"3.9、CDN\"></a>3.9、CDN</h3><p>前端资源的加载速度是衡量用户体验的重要指标之一。而现实中，因为种种因素，用户在加载页面资源时，会受到很多限制。因此上CDN是非常有意义的，好处如下：</p>\n<ul>\n<li>  用户来自不同地区，加入CDN可以使用户访问资源时，访问离自己比较近的CDN服务器，降低访问延迟；</li>\n<li>  降低服务器带宽使用成本；</li>\n<li>  支持视频、静态资源、大文件、小文件、直播等多种业务场景；</li>\n<li>  消除跨运营商造成的网络速度较慢的问题；</li>\n<li>  降低DDOS攻击造成的对网站的影响；</li>\n</ul>\n<p>CDN是一种比较成熟的技术，各大云平_台都有提供CDN服务，价格也不贵，因此CDN的性价比很高。 意义： 增加用户访问速度，降低网络延迟，带宽优化，减少服务器负载，增强对攻击的抵抗能力。</p>\n<h3 id=\"3-10、负载均衡\"><a href=\"#3-10、负载均衡\" class=\"headerlink\" title=\"3.10、负载均衡\"></a>3.10、负载均衡</h3><p>目前来看，负载均衡通常使用Nginx比较多，以前也有使用Apache。当遇见大型项目的时候，负载均衡和分布式几乎是必须的。负载均衡有以下好处：</p>\n<ul>\n<li>  降低单台server的压力，提高业务承载能力；</li>\n<li>  方便应对峰值流量，扩容方便（如举办某些活动时）；</li>\n<li>  增强业务的可用性、扩展性、稳定性；</li>\n</ul>\n<p>负载均衡已经是蛮常见的技术了，好处不用多说，很容易理解。 意义： 增强业务的可用性、扩展性、稳定性，可以支持更多用户的访问。</p>\n<h3 id=\"3-11、多端共用一套接口\"><a href=\"#3-11、多端共用一套接口\" class=\"headerlink\" title=\"3.11、多端共用一套接口\"></a>3.11、多端共用一套接口</h3><p>目前常见场景是一个业务，同时有PC页面和H5页面，由于业务是一样的，因此应避免同一个业务有多套接口分别适用于PC和H5端。因此解决方案如下：</p>\n<ul>\n<li>  后端提供的接口，应该同时包含PC和H5的数据（即单独对一个存在亢余数据）；</li>\n<li>  接口应当稳定，即当业务变更时，应尽量采取追加数据的形式；</li>\n<li>  只有在单独一端需要特殊业务流程时，设计单端独有接口；</li>\n</ul>\n<p>多端共用接口，是减少开发工作量，并且提高业务可维护性的重要解决方案。 意义： 降低开发工作量，增强可维护性。</p>\n"},{"title":"iOS 13 不只有深色模式，这 15+ 个新功能同样值得关注","url":"121.html","id":"121","date":"2019-06-22T08:24:12.000Z","_content":"\n按照惯例，苹果于北京时间 6 月 4 日凌晨的  WWDC  上发布了各个平台的新一代操作系统。相比去年专注于性能和稳定性的  iOS 12，今年的  iOS 13 有了大幅改动，带来了众多系统新特性，以及原生应用也得到了大幅改进。\n\n## 系统外观：姗姗来迟的深色模式\n\n自  iPhone X  发布以来，iOS  的深色模式就成了许多媒体每年 WWDC 预测的保留部分。在两年之后，苹果终于在  iOS 13  中将深色模式带到了  iPhone  上。 刷上 iOS 13 并在设置中开启深色模式后，我发现 iPhone  的锁屏页面、主屏幕、通知中心小组件页面以及原生应用的背景都会相应变为深色。此外，iOS 13  还提供了一组与  macOS Mojave  类似的壁纸，可以随深色模式的开关而变化。 ![](https://cdn.sspai.com/2019/06/05/e36e932d31bbc29f8719a6c2be3b011e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在「设置-显示与亮度」中更改深色模式的设置。除了手动更改外，还可以选择根据日出与日落时间进行自动更改，或是自定义深色模式的时间段。 ![](https://cdn.sspai.com/2019/06/05/b27f9c73ee0fa614673edf33dd1fb5da.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 除了在设置中开启 / 关闭深色模式，你也可以在控制中心长按亮度选项，借助弹出的选项来更加方便地切换系统外观。 ![](https://cdn.sspai.com/2019/06/05/53ba31313a1d0197881399279fcdffce.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 虽然苹果在系统界面和内置应用上下了不少功夫，但要实现全方位的一致外观，还离不开第三方  App  的支持。iOS 13  也为开发者提供了新的  API，使第三方应用也能更容易地适配深色模式。 除了深色模式，iOS 13  还对整体的设计语言进行了微调，向 iOS 12.3 中的钱包  app  的风格靠拢。例如，备忘录等应用新增了卡片式的视图；许多应用右上角也新增了「...」的选项按钮。\n\n## 摄影：除了拍，后期修图和管理也很重要\n\n苹果除了在 iPhone 上会通过硬件提升拍照的能力，还通过系统软件来提升拍照的体验，其中就包括了照片和相机应用的大幅优化。\n\n### 照片：全新的浏览视图，增强的编辑功能\n\n照片应用在原本的「所有照片」之外，又新增了「年度」、「月」和「日」三个维度。不同维度间的过渡动画颇为流畅，并会自动播放实况照片和视频。相比「所有照片」平铺式的显示方式，新的显示模式进一步优化了浏览体验，帮助使用者更好地重温回忆。 ![](https://cdn.sspai.com/2019/06/05/c4aac8818d925e2619d0a5f872f259d8.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 借助机器学习技术，照片应用会隐藏重复照片、屏幕截图、白板照片等干扰，并自动选取一张最佳照片进行放大展示。如果你正在按年份浏览，照片会尽量选取往年的今日照片进行展示；按照月份浏览时，照片还会根据照片展示的事件对图片进行分类，并显示事件的名称、位置等信息。 尤其值得一提的是，当应用检测到生日照片时，还会对照片中的人物进行识别，并与通讯录中的生日信息进行对照，从而在标题中显示寿星的名字。 在浏览照片拥有了更合理的方式之外，iOS 13  还增强了编辑图片和视频的功能。现在，包括自动增强在内，你可以通过滑动来调节色温、色调、对比度、噪点消除等  16  项参数，并可以实时预览效果。在添加滤镜时，应用同样允许你调节滤镜强度，并实时展示滤镜效果。 ![](https://cdn.sspai.com/2019/06/05/8c032a40196a81b875153b9a9e7a4fd1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 此外，原本的旋转和裁剪页面还加入了矫正畸变的功能。 ![](https://cdn.sspai.com/2019/06/05/a23cf5693b4d1c867e799151112652b0.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 值得一提的是，以上功能同样适用于视频编辑。总的来看，更新后的照片  app  已经足以满足一定的后期需求。美中不足的是，原生照片  app  缺失了局部编辑功能，因而依然无法替代泼辣修图等更为专业的修图应用。\n\n### 相机：人像光效更进一步\n\niOS 13  进一步提升了最新一代  iPhone  的人像模式效果。你可以调节不同光效的光源距离，从而实现更为理想的成像效果。 此外，人像模式还新增了名为「High-Key Mono」的光效模式，帮你拍摄出对比强烈、风格独特的人像。不过遗憾的是，本次相机的更新仅适用于  iPhone Xs、iPhone Xs Max  和  iPhone XR  机型。 ![](https://cdn.sspai.com/20190605112924.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)样张来源：苹果官网\n\n## 原生应用：全新的设计，更多的功能\n\n这次 iOS 13 更新苹果继续在自家的应用上发力，为提醒事项、备忘录、地图、Safari、文件等应用都带来新设计和更加强大的功能。\n\n### 提醒事项：更实用的筛选功能\n\niOS 13  带来了全新的提醒事项  App。新设计的主页可以帮你更清楚地浏览任务。你还可以在创建列表时自定义使用的图标和颜色。 ![](https://cdn.sspai.com/2019/06/05/441526a0d270c679bdb52118e49875c3.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 此外，创建提醒也更为容易。除了会在键盘上方提供可能的触发方式，提醒事项还会通过自然语义识别功能进一步协助你创建提醒。当你在信息  App  中聊天时，Siri  将会根据对话内容，为你创建建议的任务；当你在提醒事项  App  中输入任务时，Siri  可以根据你的输入提供建议的提醒时间。 ![](https://cdn.sspai.com/2019/06/05/199cec47e8b4b85ac04961d8c4320464.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 创建提醒事项后，你还可以在详情中进一步编辑，如添加子事件，添加图片和链接作为附件等。 ![](https://cdn.sspai.com/2019/06/05/a4146b6c817d0eba30e549953648f992.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 提醒事项还提供了新的触发方式。现在，除了设置在某一时间提醒、到达某一地点提醒，你还可以选择让提醒事项在你与选定的联系人发送短信时进行提醒。\n\n### 备忘录：查看、编辑、分享更为便捷\n\n借助备忘录的列表页面新增的选项，备忘录可以将笔记以缩略图的形式呈现。相比之前的列表，新的视图更方便你查找带有图片和  Apple Pencil  标注的笔记。 ![](https://cdn.sspai.com/2019/06/05/4c484570b95cd920d846e305d4bd9546.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 除此之外，备忘录的搜索功能也得到了提升。新增的搜索建议功能可以帮你按照不同的类别进行检索。当你输入关键词后，备忘录可以在包括笔记中添加的图片、扫描的文档等在内的位置查找关键词。 iOS  13  还为备忘录带来了多层级的文件夹系统。你可以新建一个文件夹，然后点击右上角的「...」将其移动到另一个文件夹之下。 不仅如此，备忘录还完善了其协作功能。你可以将笔记甚至整个文件夹共享给其他用户来进行协作，并可以控制协作者之间的权限。\n\n### Safari  浏览器：新增下载管理器\n\nSafari  浏览器的空白标签页也在  iOS  13  中发生了变化。「经常访问的网页」变为了与「个人收藏」平级的项目。如果你并不需要，可以在设置中将其关闭。 尽管苹果只在  iPadOS  中提及了  Safari  浏览器的下载管理器，但实际上  iOS 13  也为  Safari  浏览器加入了这一功能。你可以在「设置-Safari 浏览器-下载项」中更改下载文件的默认存放位置。值得一提的是，下载过程中并不需要保持  Safari  浏览器在前台。 除此之外，Safari  浏览器还允许你针对每个网页设定不同的显示和隐私选项。点击智能搜索栏左侧的图标，即可调整字体大小，并选择是否开启阅读模式。在「网页设置」中，你还可以进一步更改该网页的权限。在打开阅读模式后，你还可以进一步调整背景色和字体。 ![](https://cdn.sspai.com/2019/06/05/0f3d263b39fa807faa32613a28114629.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 值得一提的是，「请求桌面网站」选项同样出现在了  iOS  的  Safari  浏览器上。尽管  iPhone  的屏幕并不适合桌面网站，但这一功能可以绕开知乎等网站强制要求打开  App  才能进一步阅读的障碍。 除了上文所述之外，Safari  浏览器还有以下更新：\n\n- 上传图片时，可以更改图片尺寸；\n- 当你搜索的关键词与已经打开的标签页相关时，建议栏可以让你直接跳转到该标签页；\n- Safari  浏览器会在你用弱密码注册账号时进行警告；\n- 通过  iCloud  同步的  Safari  浏览器浏览记录和打开的标签页会被端到端加密。\n\n总的来说，本次更新为  Safari  浏览器带来了不少实用的功能，已经可以在一定程度上实现  iCab  等  [进阶型浏览器](https://sspai.com/post/45385)  的功能。\n\n### 文件：朝访达迈出的又一步\n\niOS 13  也进一步增强了文件  App  的功能。首先，你可以与其他用户共享  iCloud Drive  中的文件夹，从而进行远程协作。要为文件夹添加协作用户，只需选中文件夹后，在分享页面选择「Add People」即可。 ![](https://cdn.sspai.com/20190605114631.PNG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 此外，苹果还更新了长按文件后弹出的操作页面，并新增了数个功能：\n\n- 压缩与解压缩。相应的操作不再需要绕道捷径；\n\n![](https://cdn.sspai.com/20190605115913.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 快速查看。通过这个功能可以直接在文件应用中浏览文件，而无需跳转到第三方应用；\n\n![](https://cdn.sspai.com/20190605120006.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 不仅如此，iOS 13  还将备忘录中的扫描文档功能带到了文件  App  中。点击应用首页的「...」，选择「扫描文稿」即可。扫描后的文档可以直接分享，或是存储到文件  App  中。虽然这一原生功能并没有类似  Scanner Pro  等应用的  Workflow  选项，但扫描并保存文档的流程要比第三方  App  便捷不少。 ![](https://cdn.sspai.com/2019/06/05/fa1d40139fbdb9d8cfaa2bcd887e6348.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 文件  App  的搜索还增加了关键词过滤的功能。你可以在输入文件的格式后，点击搜索建议的提示对搜索结果进行过滤，从而更快地找到所需的文件。 ![](https://cdn.sspai.com/2019/06/05/1f2eec4b8701529e1ea3b59550fe00fc.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 值得一提的是，iOS 13  的文件  App  同样支持  iPadOS  中外接  USB  设备和连接服务器的功能。不过，目前苹果官网在售的相应配件只有一款  [闪电转  USB  相机转换器](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=2ahUKEwj7hJTvjNHiAhXCv54KHbpNBJAQFjAAegQIAxAB&url=https%3A%2F%2Fwww.apple.com%2Fcn%2Fshop%2Fproduct%2FMD821FE%2FA&usg=AOvVaw3fZJyQjb-7Ntv-9EH1M_qA) ，其是否能支持连接  U  盘等设备还有待测试。\n\n### 地图：更详尽，更智能\n\n得益于苹果的测绘工作，新版本的地图精细度有了极大的提升。 ![](https://cdn.sspai.com/2019/06/05/5a69fd932bb7c00b38c2c45b83bfeeab.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)新旧地图精细度对比 除此之外，新版地图还加入了类似  Google Maps  的街景功能，从而方便用户获取更为准确的道路和地址等信息。苹果计划于未来两年内将这一改进应用至更多国家和地区。不过鉴于国内对测绘的管理，这一新特性能否应用至国内尚未可知。 ![](https://cdn.sspai.com/2019/06/05/7f3325db8463a605d60eca3cb940ae9d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)街景功能 此外，地图还对收藏位置的显示进行了优化。现在，你可以对不同的地点进行分类，设定家庭、工作等多个预设地址，并将这些地点和预计到达时间分享出去。 ![](https://cdn.sspai.com/2019/06/05/517793b447958b54ebfc813f9ee2c7b6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 新版地图的导航功能也得到了提高。增强的  Siri  导航功能会用类似「下个红绿灯左转」的指示代替过去的「500 米后左转」指令，并在导航快要结束前，引导你前往目的地的入口处。 除了上述的内容外，新版地图还可以实时更新你的航班信息，自动获取公交线路的时刻表，并额外为开发者提供了新的  API  接口  。\n\n### 健康：个性化与新增功能\n\niOS 13  的健康应用也获得了全新的界面。通过机器学习，健康应用会将一天中最重要的健康信息呈现给你，并将其   与之前一周的情况进行对比，激励你更加重视个人健康。当然，你也可以选择将部分数据加入收藏，从而使其始终在应用顶部显示。你也可以在「搜索」标签页中查看所有健康数据。 ![](https://cdn.sspai.com/2019/06/05/0c195e5d6b3e9feff46f0ff8cd4e2a96.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 健康应用还同时新增了数个模块，包括：\n\n- 月经周期记录。在「搜索」标签页中点击「周期跟踪」，即可根据提示进行设置。应用会根据记录数据对排卵期等进行预测和提醒。\n- 噪音检测。如果你有  Apple Watch  与  iPhone  配对，Apple Watch  将会对你的周围环境噪声进行监控，并为你提供其对听力的损害情况。此外，这一模块还会收集你使用的耳机音量，帮你判断是否需要将其调小。\n- 口腔健康。你可以在「搜索」标签页的「Other Data-刷牙」中手动记录每日的刷牙时长，或是通过带有相应功能的牙刷自动记录。\n- 教育模块，以短文的形式出现在主页面底部，为你普及健康知识。\n\n### 查找：找朋友找设备合二为一\n\niOS 13  将查找我的朋友和查找我的设备进行了合并，组成了新的「查找」应用。不过更引人关注的则是应用在查找离线设备上的进步。当其他人的  iPhone  检测到周围你的离线设备的蓝牙信号后，iOS  会自动将这一信息发送至云端，从而帮你定位丢失的设备。整个过程通过端到端加密来保证隐私安全，并且不会额外占用  iPhone  的数据流量。 ![](https://cdn.sspai.com/20190605120543.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n### Siri  和捷径：更自然的声音、自动化的触发机制\n\n相比此前  Siri  将多段语音拼合在一起的发音方式， iOS 13 采用了 TTS  模型，利用深度学习技术直接生成完整的句子，从而使  Siri  的声音听起来更为自然。此外，你还可以通过  Siri  来收听无线电广播、播客和有声书等内容。 iOS 13  也为捷径带来了新的重要功能：自动化。你可以设置通过时间、闹钟、体能训练、位置、打开应用、设备状态、NFC  贴纸等方式，自动触发相应的捷径。 这一新模块的加入，又进一步增加了捷径的玩法和实用性。例如，你可以令捷径在早晨闹钟结束后，自动为你播报今天的天气等信息。相比之下，Launch Center Pro  的订阅吸引力又小了不少。美中不足的是，目前捷径创建自动化时，其触发的动作无法设定为已经存在的捷径，制作起来略为繁琐。 ![](https://cdn.sspai.com/2019/06/05/7ee0cf871836f266ce82f222dee95e57.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n## 系统功能：更好玩，更安全\n\n### 拟我表情（Memoji）与动话表情（Animoji）：在线化妆，还能做贴纸\n\niOS 13  为拟我表情带来了大量的可调节特性，如眼线、眼影、耳饰等。在发布会上，苹果还特意请来了  Youtube  网红  Patrick Starrr  和  Desi Perkins  进行了  [演示](https://www.youtube.com/watch?v=3x7_w9Oz8lQ) 。 ![](https://cdn.sspai.com/2019/06/05/715b8d5e6207a23986e1a7c0ed1ebd64.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)新增的人物细节 动话表情也得到了更新，新增了老鼠、章鱼和奶牛三款形象。此外，制作完毕的  Memoji  和动画表情还会被自动转化为一套贴纸，可以和  Emoji  一起在表情键盘中使用，不再仅局限于信息 App 中。 ![](https://cdn.sspai.com/2019/06/05/a6b07dec1f3ef8110f6b8074d8475bc0.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)3 款新增动话表情 值得一提的是，尽管动话表情需要  iPhone X  及更新机型才能使用，Memoji  贴纸和动话表情贴纸可以在所有搭载  A9  及更新处理器的机型上使用。\n\n### 新的文本编辑和浏览手势\n\niOS 13  还带来了数个新的手势功能，更好地利用多点触控屏的优势来编辑和浏览文本：\n\n- iOS 13 可以让你直接拖动并移动光标，不再需要长按；\n- 长按并拖动光标可以选取文本，不再需要双击光标；\n- 三重点击文本可以选取整句话，四重点击可以选取整段文字；\n- 在浏览较长的文章或网页时，可以长按屏幕侧面的滚动条来快速跳转和预览；\n- 在文件、邮件、信息等  App  中，可以通过双指轻点的方式进入文件选择模式，顺势滑动还可以快速多选文件；\n- 在选中文本后，三指捏合即可复制文本，捏合两次即可剪切；张开三指可以粘贴文本。\n\n### 屏幕使用时间：One More Minute\n\n屏幕使用时间的功能也在本次  WWDC  上得到了优化，主要包括：\n\n- 在应用达到时间限额后，iOS 13  额外提供了「多一分钟」的选项，方便你快速保存或退出当前的工作；\n\n![](https://cdn.sspai.com/2019/06/05/9e7c11d53c8da8ee087f956d4d26fdc2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 在「设置-屏幕使用时间-应用限额」中，你现在可以精确地选取所需的  App  来组成一组应用限额，不再只局限于同时选择某一类别的所有应用；\n\n![](https://cdn.sspai.com/2019/06/05/5f28cd1e64ce61a4e8a749254a895bef.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)应用限额页面\n\n- 屏幕使用时间还新增了「通信限制」的选项，可以设置允许设备拨打电话、收发短信、使用  FaceTime  通话等功能的时间段和联系人；\n- 屏幕使用时间的数据保存时间延长至  30  天，从而方便你具体对比本周和过去数周的数据。\n\n### 隐私与安全性\n\niOS 13  还进一步提升了对隐私的保护力度，主要包括了以下方面：\n\n- 当  App  请求获取位置信息时，新增了「只允许一次」的选项；\n- 当  App  在后台使用你的位置信息时，iOS 13  会通过弹窗进行提醒，你可以据此选择是否更新对该应用的隐私权限设置；\n- 在分享图片时，可以在「Options」中选择是否抹除照片的地理位置信息；\n\n![](https://cdn.sspai.com/2019/06/05/b3312f283722a4a58d33a579b0bda071.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 改进后的  API  使应用更难通过  Wi-Fi  和蓝牙信息获取当前位置。此外，iOS 13  还提升了  Safari  浏览器阻止网页追踪的能力。\n\n除此之外，苹果还在  iOS 13  中推出了「通过  Apple  登陆」（Sign In with Apple）的选项。相比常见的通过  Facebook、Google  登陆，通过  Apple  登陆不会向网页泄露除名称和邮箱地址外的任何个人信息。 如果你希望更进一步，还可以在登录时隐藏真实邮箱地址，而以苹果创建的随机邮箱地址进行替代。你甚至还可以为不同应用设置使用不同的匿名邮箱。通过  Apple  登陆不需要设置密码，借助面容  ID  或   触控  ID  即可登陆，还可以通过双重验证来进一步提高安全性。\n\n### AirPods 和 HomePod\n\niOS 13  也为  AirPods  和  HomePod  带来了新功能。现在，当使用了  SiriKit  的应用接收到消息后，AirPods  会自动为你朗读内容，并可以让你即时通过  Siri  来回复。此外，当你使用  AirPods  听音乐时，还可以通过轻触设备的方式与另一名  AirPods  使用者共享当前歌曲。这一功能同样适用于所有使用了  SiriKit  的第三方  App。 ![](https://cdn.sspai.com/2019/06/05/03de73d70b55ad3dce21f9037679b0cb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)来源：WWDC 2019 与此同时，HomePod  带来了对多用户的支持。通过对不同家庭成员声音进行分析，HomePod  可以对联系人、短信、通话等指令做出更为个性化的回答。 ![](https://cdn.sspai.com/2019/06/05/0cd56e6ff049f50e08387b0ae4e880bf.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)家庭 App\n\n## 其他\n\n除了上文的主要更新外，iOS 13  还带来了以下变化：\n\n- 在没有 3D Touch  的手机上使用 Haptic Touch  可以获得 Context Menu 的效果；\n- 新增  Image Capture API，允许第三方  App  直接打开外接设备中的图片，无需再经过照片  App；\n- App Store  界面调整，新增订阅服务  Arcade  界面，应用更新移动至个人页面；\n\n![](https://cdn.sspai.com/2019/06/05/9b78b2bfbbe4750282e04308d2a43d40.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 音量调节页面更新，不再占用过多屏幕面积，并可以在屏幕上直接滑动调节；\n\n![](https://cdn.sspai.com/2019/06/05/304d77dbcbb56f2adaa2c69acd18a12b.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 图书  App  新增了每日阅读目标功能，鼓励你坚持每日读书；\n\n![](https://cdn.sspai.com/2019/06/05/6424a62d813b25475164fd97ab2db1aa.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 音乐  App  采用了新的播放页面，并新增了歌词滚动显示功能；\n\n![](https://cdn.sspai.com/2019/06/05/a399cd1520d79d8b9c44b9cddc311e07.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 邮件 App 可以屏蔽特定邮箱的来信，并新增了自动补全邮箱地址、改良的工具栏等功能；\n- 家庭 App 提升了对 HomeKit 配件的保护，自动化可以触发捷径。此外，苹果还推出了新的 HomeKit 监控，符合这一标准的配件将可以在不占用 iCloud 空间的情况下，通过 iCloud 发送录像内容；\n- 你可以在「设置-电话」中开启「静音未知来电」选项，减少骚扰电话的干扰；\n- 优化了充电方式，通过学习用户的充电习惯，并暂缓充电至 80% 以上，来减缓电池的老化；\n- 支持游戏时使用  PlayStation 4  和  Xbox One S  的手柄；\n- 在控制中心长按  Wi-Fi  和蓝牙图标后，可以直接选择要连接的网络  /  设备；\n\n![](https://cdn.sspai.com/2019/06/05/c07e27a5cc9c17a907f366928b36eff8.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 可以在「设置-信息-共享姓名和照片」中设置是否在开始新对话时，发送自己的头像和姓名给对方；\n- 可以用  Memoji  为通讯录中的联系人添加头像；\n- 分享页界面得到了更新，并会根据使用习惯，建议可能的分享对象；\n\n![](https://cdn.sspai.com/2019/06/05/2a64b8e78796656555b1f2abbea23426.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 可以在  App Store  中下载字体使用，并在设置中进行管理；\n- 截图标注页面更新，加入了直尺工具。编辑后的图片可以直接保存至文件 App；\n\n![](https://cdn.sspai.com/2019/06/05/336939de533feafdcbb566da8ca68982.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 系统键盘加入了滑动输入的功能，可以通过指尖在键盘区域不间断地滑动来实现更流畅地输入，并减少误触的情况；\n- 表情成为了系统键盘的一枚独立的按键。在多个语言之间切换时，将不会再收到表情键盘的干扰；\n- iPhone Xs、iPhone Xs Max 和 iPhone XR 增加对杜比全景声效的支持；\n- 解除了蜂窝网络环境下不能下载超过 200MB 的应用的限制；\n\n![](https://cdn.sspai.com/2019/06/05/91a7de16e3818f8cc555e7f9857a342f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 相比往年，苹果今年并没有放出  iOS 13  的  Developer Beta  版描述文件，并在相关界面特别提醒普通用户应等待  Public Beta。在我的体验中，iOS 13 的测试版也存在发热、卡顿等问题。如果你希望提前体验 iOS 13，不妨等待 7 月推出的 Public Beta 测试版。\n","source":"_posts/ios-13-e4-b8-8d-e5-8f-aa-e6-9c-89-e6-b7-b1-e8-89-b2-e6-a8-a1-e5-bc-8f-ef-bc-8c-e8-bf-99-15-e4-b8-aa-e6-96-b0-e5-8a-9f-e8-83-bd-e5-90-8c-e6-a0-b7-e5-80-bc-e5-be-97-e5-85-b3-e6-b3-a8.md","raw":"---\ntitle: iOS 13 不只有深色模式，这 15+ 个新功能同样值得关注\ntags:\n  - iOS，软件更新\nurl: 121.html\nid: 121\ncategories:\n  - 杂谈\ndate: 2019-06-22 16:24:12\n---\n\n按照惯例，苹果于北京时间 6 月 4 日凌晨的  WWDC  上发布了各个平台的新一代操作系统。相比去年专注于性能和稳定性的  iOS 12，今年的  iOS 13 有了大幅改动，带来了众多系统新特性，以及原生应用也得到了大幅改进。\n\n## 系统外观：姗姗来迟的深色模式\n\n自  iPhone X  发布以来，iOS  的深色模式就成了许多媒体每年 WWDC 预测的保留部分。在两年之后，苹果终于在  iOS 13  中将深色模式带到了  iPhone  上。 刷上 iOS 13 并在设置中开启深色模式后，我发现 iPhone  的锁屏页面、主屏幕、通知中心小组件页面以及原生应用的背景都会相应变为深色。此外，iOS 13  还提供了一组与  macOS Mojave  类似的壁纸，可以随深色模式的开关而变化。 ![](https://cdn.sspai.com/2019/06/05/e36e932d31bbc29f8719a6c2be3b011e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 你可以在「设置-显示与亮度」中更改深色模式的设置。除了手动更改外，还可以选择根据日出与日落时间进行自动更改，或是自定义深色模式的时间段。 ![](https://cdn.sspai.com/2019/06/05/b27f9c73ee0fa614673edf33dd1fb5da.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 除了在设置中开启 / 关闭深色模式，你也可以在控制中心长按亮度选项，借助弹出的选项来更加方便地切换系统外观。 ![](https://cdn.sspai.com/2019/06/05/53ba31313a1d0197881399279fcdffce.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 虽然苹果在系统界面和内置应用上下了不少功夫，但要实现全方位的一致外观，还离不开第三方  App  的支持。iOS 13  也为开发者提供了新的  API，使第三方应用也能更容易地适配深色模式。 除了深色模式，iOS 13  还对整体的设计语言进行了微调，向 iOS 12.3 中的钱包  app  的风格靠拢。例如，备忘录等应用新增了卡片式的视图；许多应用右上角也新增了「...」的选项按钮。\n\n## 摄影：除了拍，后期修图和管理也很重要\n\n苹果除了在 iPhone 上会通过硬件提升拍照的能力，还通过系统软件来提升拍照的体验，其中就包括了照片和相机应用的大幅优化。\n\n### 照片：全新的浏览视图，增强的编辑功能\n\n照片应用在原本的「所有照片」之外，又新增了「年度」、「月」和「日」三个维度。不同维度间的过渡动画颇为流畅，并会自动播放实况照片和视频。相比「所有照片」平铺式的显示方式，新的显示模式进一步优化了浏览体验，帮助使用者更好地重温回忆。 ![](https://cdn.sspai.com/2019/06/05/c4aac8818d925e2619d0a5f872f259d8.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 借助机器学习技术，照片应用会隐藏重复照片、屏幕截图、白板照片等干扰，并自动选取一张最佳照片进行放大展示。如果你正在按年份浏览，照片会尽量选取往年的今日照片进行展示；按照月份浏览时，照片还会根据照片展示的事件对图片进行分类，并显示事件的名称、位置等信息。 尤其值得一提的是，当应用检测到生日照片时，还会对照片中的人物进行识别，并与通讯录中的生日信息进行对照，从而在标题中显示寿星的名字。 在浏览照片拥有了更合理的方式之外，iOS 13  还增强了编辑图片和视频的功能。现在，包括自动增强在内，你可以通过滑动来调节色温、色调、对比度、噪点消除等  16  项参数，并可以实时预览效果。在添加滤镜时，应用同样允许你调节滤镜强度，并实时展示滤镜效果。 ![](https://cdn.sspai.com/2019/06/05/8c032a40196a81b875153b9a9e7a4fd1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 此外，原本的旋转和裁剪页面还加入了矫正畸变的功能。 ![](https://cdn.sspai.com/2019/06/05/a23cf5693b4d1c867e799151112652b0.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 值得一提的是，以上功能同样适用于视频编辑。总的来看，更新后的照片  app  已经足以满足一定的后期需求。美中不足的是，原生照片  app  缺失了局部编辑功能，因而依然无法替代泼辣修图等更为专业的修图应用。\n\n### 相机：人像光效更进一步\n\niOS 13  进一步提升了最新一代  iPhone  的人像模式效果。你可以调节不同光效的光源距离，从而实现更为理想的成像效果。 此外，人像模式还新增了名为「High-Key Mono」的光效模式，帮你拍摄出对比强烈、风格独特的人像。不过遗憾的是，本次相机的更新仅适用于  iPhone Xs、iPhone Xs Max  和  iPhone XR  机型。 ![](https://cdn.sspai.com/20190605112924.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)样张来源：苹果官网\n\n## 原生应用：全新的设计，更多的功能\n\n这次 iOS 13 更新苹果继续在自家的应用上发力，为提醒事项、备忘录、地图、Safari、文件等应用都带来新设计和更加强大的功能。\n\n### 提醒事项：更实用的筛选功能\n\niOS 13  带来了全新的提醒事项  App。新设计的主页可以帮你更清楚地浏览任务。你还可以在创建列表时自定义使用的图标和颜色。 ![](https://cdn.sspai.com/2019/06/05/441526a0d270c679bdb52118e49875c3.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 此外，创建提醒也更为容易。除了会在键盘上方提供可能的触发方式，提醒事项还会通过自然语义识别功能进一步协助你创建提醒。当你在信息  App  中聊天时，Siri  将会根据对话内容，为你创建建议的任务；当你在提醒事项  App  中输入任务时，Siri  可以根据你的输入提供建议的提醒时间。 ![](https://cdn.sspai.com/2019/06/05/199cec47e8b4b85ac04961d8c4320464.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 创建提醒事项后，你还可以在详情中进一步编辑，如添加子事件，添加图片和链接作为附件等。 ![](https://cdn.sspai.com/2019/06/05/a4146b6c817d0eba30e549953648f992.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 提醒事项还提供了新的触发方式。现在，除了设置在某一时间提醒、到达某一地点提醒，你还可以选择让提醒事项在你与选定的联系人发送短信时进行提醒。\n\n### 备忘录：查看、编辑、分享更为便捷\n\n借助备忘录的列表页面新增的选项，备忘录可以将笔记以缩略图的形式呈现。相比之前的列表，新的视图更方便你查找带有图片和  Apple Pencil  标注的笔记。 ![](https://cdn.sspai.com/2019/06/05/4c484570b95cd920d846e305d4bd9546.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 除此之外，备忘录的搜索功能也得到了提升。新增的搜索建议功能可以帮你按照不同的类别进行检索。当你输入关键词后，备忘录可以在包括笔记中添加的图片、扫描的文档等在内的位置查找关键词。 iOS  13  还为备忘录带来了多层级的文件夹系统。你可以新建一个文件夹，然后点击右上角的「...」将其移动到另一个文件夹之下。 不仅如此，备忘录还完善了其协作功能。你可以将笔记甚至整个文件夹共享给其他用户来进行协作，并可以控制协作者之间的权限。\n\n### Safari  浏览器：新增下载管理器\n\nSafari  浏览器的空白标签页也在  iOS  13  中发生了变化。「经常访问的网页」变为了与「个人收藏」平级的项目。如果你并不需要，可以在设置中将其关闭。 尽管苹果只在  iPadOS  中提及了  Safari  浏览器的下载管理器，但实际上  iOS 13  也为  Safari  浏览器加入了这一功能。你可以在「设置-Safari 浏览器-下载项」中更改下载文件的默认存放位置。值得一提的是，下载过程中并不需要保持  Safari  浏览器在前台。 除此之外，Safari  浏览器还允许你针对每个网页设定不同的显示和隐私选项。点击智能搜索栏左侧的图标，即可调整字体大小，并选择是否开启阅读模式。在「网页设置」中，你还可以进一步更改该网页的权限。在打开阅读模式后，你还可以进一步调整背景色和字体。 ![](https://cdn.sspai.com/2019/06/05/0f3d263b39fa807faa32613a28114629.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 值得一提的是，「请求桌面网站」选项同样出现在了  iOS  的  Safari  浏览器上。尽管  iPhone  的屏幕并不适合桌面网站，但这一功能可以绕开知乎等网站强制要求打开  App  才能进一步阅读的障碍。 除了上文所述之外，Safari  浏览器还有以下更新：\n\n- 上传图片时，可以更改图片尺寸；\n- 当你搜索的关键词与已经打开的标签页相关时，建议栏可以让你直接跳转到该标签页；\n- Safari  浏览器会在你用弱密码注册账号时进行警告；\n- 通过  iCloud  同步的  Safari  浏览器浏览记录和打开的标签页会被端到端加密。\n\n总的来说，本次更新为  Safari  浏览器带来了不少实用的功能，已经可以在一定程度上实现  iCab  等  [进阶型浏览器](https://sspai.com/post/45385)  的功能。\n\n### 文件：朝访达迈出的又一步\n\niOS 13  也进一步增强了文件  App  的功能。首先，你可以与其他用户共享  iCloud Drive  中的文件夹，从而进行远程协作。要为文件夹添加协作用户，只需选中文件夹后，在分享页面选择「Add People」即可。 ![](https://cdn.sspai.com/20190605114631.PNG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 此外，苹果还更新了长按文件后弹出的操作页面，并新增了数个功能：\n\n- 压缩与解压缩。相应的操作不再需要绕道捷径；\n\n![](https://cdn.sspai.com/20190605115913.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 快速查看。通过这个功能可以直接在文件应用中浏览文件，而无需跳转到第三方应用；\n\n![](https://cdn.sspai.com/20190605120006.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 不仅如此，iOS 13  还将备忘录中的扫描文档功能带到了文件  App  中。点击应用首页的「...」，选择「扫描文稿」即可。扫描后的文档可以直接分享，或是存储到文件  App  中。虽然这一原生功能并没有类似  Scanner Pro  等应用的  Workflow  选项，但扫描并保存文档的流程要比第三方  App  便捷不少。 ![](https://cdn.sspai.com/2019/06/05/fa1d40139fbdb9d8cfaa2bcd887e6348.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 文件  App  的搜索还增加了关键词过滤的功能。你可以在输入文件的格式后，点击搜索建议的提示对搜索结果进行过滤，从而更快地找到所需的文件。 ![](https://cdn.sspai.com/2019/06/05/1f2eec4b8701529e1ea3b59550fe00fc.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 值得一提的是，iOS 13  的文件  App  同样支持  iPadOS  中外接  USB  设备和连接服务器的功能。不过，目前苹果官网在售的相应配件只有一款  [闪电转  USB  相机转换器](https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=2ahUKEwj7hJTvjNHiAhXCv54KHbpNBJAQFjAAegQIAxAB&url=https%3A%2F%2Fwww.apple.com%2Fcn%2Fshop%2Fproduct%2FMD821FE%2FA&usg=AOvVaw3fZJyQjb-7Ntv-9EH1M_qA) ，其是否能支持连接  U  盘等设备还有待测试。\n\n### 地图：更详尽，更智能\n\n得益于苹果的测绘工作，新版本的地图精细度有了极大的提升。 ![](https://cdn.sspai.com/2019/06/05/5a69fd932bb7c00b38c2c45b83bfeeab.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)新旧地图精细度对比 除此之外，新版地图还加入了类似  Google Maps  的街景功能，从而方便用户获取更为准确的道路和地址等信息。苹果计划于未来两年内将这一改进应用至更多国家和地区。不过鉴于国内对测绘的管理，这一新特性能否应用至国内尚未可知。 ![](https://cdn.sspai.com/2019/06/05/7f3325db8463a605d60eca3cb940ae9d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)街景功能 此外，地图还对收藏位置的显示进行了优化。现在，你可以对不同的地点进行分类，设定家庭、工作等多个预设地址，并将这些地点和预计到达时间分享出去。 ![](https://cdn.sspai.com/2019/06/05/517793b447958b54ebfc813f9ee2c7b6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 新版地图的导航功能也得到了提高。增强的  Siri  导航功能会用类似「下个红绿灯左转」的指示代替过去的「500 米后左转」指令，并在导航快要结束前，引导你前往目的地的入口处。 除了上述的内容外，新版地图还可以实时更新你的航班信息，自动获取公交线路的时刻表，并额外为开发者提供了新的  API  接口  。\n\n### 健康：个性化与新增功能\n\niOS 13  的健康应用也获得了全新的界面。通过机器学习，健康应用会将一天中最重要的健康信息呈现给你，并将其   与之前一周的情况进行对比，激励你更加重视个人健康。当然，你也可以选择将部分数据加入收藏，从而使其始终在应用顶部显示。你也可以在「搜索」标签页中查看所有健康数据。 ![](https://cdn.sspai.com/2019/06/05/0c195e5d6b3e9feff46f0ff8cd4e2a96.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 健康应用还同时新增了数个模块，包括：\n\n- 月经周期记录。在「搜索」标签页中点击「周期跟踪」，即可根据提示进行设置。应用会根据记录数据对排卵期等进行预测和提醒。\n- 噪音检测。如果你有  Apple Watch  与  iPhone  配对，Apple Watch  将会对你的周围环境噪声进行监控，并为你提供其对听力的损害情况。此外，这一模块还会收集你使用的耳机音量，帮你判断是否需要将其调小。\n- 口腔健康。你可以在「搜索」标签页的「Other Data-刷牙」中手动记录每日的刷牙时长，或是通过带有相应功能的牙刷自动记录。\n- 教育模块，以短文的形式出现在主页面底部，为你普及健康知识。\n\n### 查找：找朋友找设备合二为一\n\niOS 13  将查找我的朋友和查找我的设备进行了合并，组成了新的「查找」应用。不过更引人关注的则是应用在查找离线设备上的进步。当其他人的  iPhone  检测到周围你的离线设备的蓝牙信号后，iOS  会自动将这一信息发送至云端，从而帮你定位丢失的设备。整个过程通过端到端加密来保证隐私安全，并且不会额外占用  iPhone  的数据流量。 ![](https://cdn.sspai.com/20190605120543.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n### Siri  和捷径：更自然的声音、自动化的触发机制\n\n相比此前  Siri  将多段语音拼合在一起的发音方式， iOS 13 采用了 TTS  模型，利用深度学习技术直接生成完整的句子，从而使  Siri  的声音听起来更为自然。此外，你还可以通过  Siri  来收听无线电广播、播客和有声书等内容。 iOS 13  也为捷径带来了新的重要功能：自动化。你可以设置通过时间、闹钟、体能训练、位置、打开应用、设备状态、NFC  贴纸等方式，自动触发相应的捷径。 这一新模块的加入，又进一步增加了捷径的玩法和实用性。例如，你可以令捷径在早晨闹钟结束后，自动为你播报今天的天气等信息。相比之下，Launch Center Pro  的订阅吸引力又小了不少。美中不足的是，目前捷径创建自动化时，其触发的动作无法设定为已经存在的捷径，制作起来略为繁琐。 ![](https://cdn.sspai.com/2019/06/05/7ee0cf871836f266ce82f222dee95e57.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n## 系统功能：更好玩，更安全\n\n### 拟我表情（Memoji）与动话表情（Animoji）：在线化妆，还能做贴纸\n\niOS 13  为拟我表情带来了大量的可调节特性，如眼线、眼影、耳饰等。在发布会上，苹果还特意请来了  Youtube  网红  Patrick Starrr  和  Desi Perkins  进行了  [演示](https://www.youtube.com/watch?v=3x7_w9Oz8lQ) 。 ![](https://cdn.sspai.com/2019/06/05/715b8d5e6207a23986e1a7c0ed1ebd64.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)新增的人物细节 动话表情也得到了更新，新增了老鼠、章鱼和奶牛三款形象。此外，制作完毕的  Memoji  和动画表情还会被自动转化为一套贴纸，可以和  Emoji  一起在表情键盘中使用，不再仅局限于信息 App 中。 ![](https://cdn.sspai.com/2019/06/05/a6b07dec1f3ef8110f6b8074d8475bc0.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)3 款新增动话表情 值得一提的是，尽管动话表情需要  iPhone X  及更新机型才能使用，Memoji  贴纸和动话表情贴纸可以在所有搭载  A9  及更新处理器的机型上使用。\n\n### 新的文本编辑和浏览手势\n\niOS 13  还带来了数个新的手势功能，更好地利用多点触控屏的优势来编辑和浏览文本：\n\n- iOS 13 可以让你直接拖动并移动光标，不再需要长按；\n- 长按并拖动光标可以选取文本，不再需要双击光标；\n- 三重点击文本可以选取整句话，四重点击可以选取整段文字；\n- 在浏览较长的文章或网页时，可以长按屏幕侧面的滚动条来快速跳转和预览；\n- 在文件、邮件、信息等  App  中，可以通过双指轻点的方式进入文件选择模式，顺势滑动还可以快速多选文件；\n- 在选中文本后，三指捏合即可复制文本，捏合两次即可剪切；张开三指可以粘贴文本。\n\n### 屏幕使用时间：One More Minute\n\n屏幕使用时间的功能也在本次  WWDC  上得到了优化，主要包括：\n\n- 在应用达到时间限额后，iOS 13  额外提供了「多一分钟」的选项，方便你快速保存或退出当前的工作；\n\n![](https://cdn.sspai.com/2019/06/05/9e7c11d53c8da8ee087f956d4d26fdc2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 在「设置-屏幕使用时间-应用限额」中，你现在可以精确地选取所需的  App  来组成一组应用限额，不再只局限于同时选择某一类别的所有应用；\n\n![](https://cdn.sspai.com/2019/06/05/5f28cd1e64ce61a4e8a749254a895bef.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)应用限额页面\n\n- 屏幕使用时间还新增了「通信限制」的选项，可以设置允许设备拨打电话、收发短信、使用  FaceTime  通话等功能的时间段和联系人；\n- 屏幕使用时间的数据保存时间延长至  30  天，从而方便你具体对比本周和过去数周的数据。\n\n### 隐私与安全性\n\niOS 13  还进一步提升了对隐私的保护力度，主要包括了以下方面：\n\n- 当  App  请求获取位置信息时，新增了「只允许一次」的选项；\n- 当  App  在后台使用你的位置信息时，iOS 13  会通过弹窗进行提醒，你可以据此选择是否更新对该应用的隐私权限设置；\n- 在分享图片时，可以在「Options」中选择是否抹除照片的地理位置信息；\n\n![](https://cdn.sspai.com/2019/06/05/b3312f283722a4a58d33a579b0bda071.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 改进后的  API  使应用更难通过  Wi-Fi  和蓝牙信息获取当前位置。此外，iOS 13  还提升了  Safari  浏览器阻止网页追踪的能力。\n\n除此之外，苹果还在  iOS 13  中推出了「通过  Apple  登陆」（Sign In with Apple）的选项。相比常见的通过  Facebook、Google  登陆，通过  Apple  登陆不会向网页泄露除名称和邮箱地址外的任何个人信息。 如果你希望更进一步，还可以在登录时隐藏真实邮箱地址，而以苹果创建的随机邮箱地址进行替代。你甚至还可以为不同应用设置使用不同的匿名邮箱。通过  Apple  登陆不需要设置密码，借助面容  ID  或   触控  ID  即可登陆，还可以通过双重验证来进一步提高安全性。\n\n### AirPods 和 HomePod\n\niOS 13  也为  AirPods  和  HomePod  带来了新功能。现在，当使用了  SiriKit  的应用接收到消息后，AirPods  会自动为你朗读内容，并可以让你即时通过  Siri  来回复。此外，当你使用  AirPods  听音乐时，还可以通过轻触设备的方式与另一名  AirPods  使用者共享当前歌曲。这一功能同样适用于所有使用了  SiriKit  的第三方  App。 ![](https://cdn.sspai.com/2019/06/05/03de73d70b55ad3dce21f9037679b0cb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)来源：WWDC 2019 与此同时，HomePod  带来了对多用户的支持。通过对不同家庭成员声音进行分析，HomePod  可以对联系人、短信、通话等指令做出更为个性化的回答。 ![](https://cdn.sspai.com/2019/06/05/0cd56e6ff049f50e08387b0ae4e880bf.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)家庭 App\n\n## 其他\n\n除了上文的主要更新外，iOS 13  还带来了以下变化：\n\n- 在没有 3D Touch  的手机上使用 Haptic Touch  可以获得 Context Menu 的效果；\n- 新增  Image Capture API，允许第三方  App  直接打开外接设备中的图片，无需再经过照片  App；\n- App Store  界面调整，新增订阅服务  Arcade  界面，应用更新移动至个人页面；\n\n![](https://cdn.sspai.com/2019/06/05/9b78b2bfbbe4750282e04308d2a43d40.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 音量调节页面更新，不再占用过多屏幕面积，并可以在屏幕上直接滑动调节；\n\n![](https://cdn.sspai.com/2019/06/05/304d77dbcbb56f2adaa2c69acd18a12b.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 图书  App  新增了每日阅读目标功能，鼓励你坚持每日读书；\n\n![](https://cdn.sspai.com/2019/06/05/6424a62d813b25475164fd97ab2db1aa.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 音乐  App  采用了新的播放页面，并新增了歌词滚动显示功能；\n\n![](https://cdn.sspai.com/2019/06/05/a399cd1520d79d8b9c44b9cddc311e07.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 邮件 App 可以屏蔽特定邮箱的来信，并新增了自动补全邮箱地址、改良的工具栏等功能；\n- 家庭 App 提升了对 HomeKit 配件的保护，自动化可以触发捷径。此外，苹果还推出了新的 HomeKit 监控，符合这一标准的配件将可以在不占用 iCloud 空间的情况下，通过 iCloud 发送录像内容；\n- 你可以在「设置-电话」中开启「静音未知来电」选项，减少骚扰电话的干扰；\n- 优化了充电方式，通过学习用户的充电习惯，并暂缓充电至 80% 以上，来减缓电池的老化；\n- 支持游戏时使用  PlayStation 4  和  Xbox One S  的手柄；\n- 在控制中心长按  Wi-Fi  和蓝牙图标后，可以直接选择要连接的网络  /  设备；\n\n![](https://cdn.sspai.com/2019/06/05/c07e27a5cc9c17a907f366928b36eff8.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 可以在「设置-信息-共享姓名和照片」中设置是否在开始新对话时，发送自己的头像和姓名给对方；\n- 可以用  Memoji  为通讯录中的联系人添加头像；\n- 分享页界面得到了更新，并会根据使用习惯，建议可能的分享对象；\n\n![](https://cdn.sspai.com/2019/06/05/2a64b8e78796656555b1f2abbea23426.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 可以在  App Store  中下载字体使用，并在设置中进行管理；\n- 截图标注页面更新，加入了直尺工具。编辑后的图片可以直接保存至文件 App；\n\n![](https://cdn.sspai.com/2019/06/05/336939de533feafdcbb566da8ca68982.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1)\n\n- 系统键盘加入了滑动输入的功能，可以通过指尖在键盘区域不间断地滑动来实现更流畅地输入，并减少误触的情况；\n- 表情成为了系统键盘的一枚独立的按键。在多个语言之间切换时，将不会再收到表情键盘的干扰；\n- iPhone Xs、iPhone Xs Max 和 iPhone XR 增加对杜比全景声效的支持；\n- 解除了蜂窝网络环境下不能下载超过 200MB 的应用的限制；\n\n![](https://cdn.sspai.com/2019/06/05/91a7de16e3818f8cc555e7f9857a342f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1) 相比往年，苹果今年并没有放出  iOS 13  的  Developer Beta  版描述文件，并在相关界面特别提醒普通用户应等待  Public Beta。在我的体验中，iOS 13 的测试版也存在发热、卡顿等问题。如果你希望提前体验 iOS 13，不妨等待 7 月推出的 Public Beta 测试版。\n","slug":"ios-13-e4-b8-8d-e5-8f-aa-e6-9c-89-e6-b7-b1-e8-89-b2-e6-a8-a1-e5-bc-8f-ef-bc-8c-e8-bf-99-15-e4-b8-aa-e6-96-b0-e5-8a-9f-e8-83-bd-e5-90-8c-e6-a0-b7-e5-80-bc-e5-be-97-e5-85-b3-e6-b3-a8","published":1,"updated":"2019-09-11T03:08:40.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269gg005ic8gs3mpy89os","content":"<p>按照惯例，苹果于北京时间 6 月 4 日凌晨的  WWDC  上发布了各个平台的新一代操作系统。相比去年专注于性能和稳定性的  iOS 12，今年的  iOS 13 有了大幅改动，带来了众多系统新特性，以及原生应用也得到了大幅改进。</p>\n<h2 id=\"系统外观：姗姗来迟的深色模式\"><a href=\"#系统外观：姗姗来迟的深色模式\" class=\"headerlink\" title=\"系统外观：姗姗来迟的深色模式\"></a>系统外观：姗姗来迟的深色模式</h2><p>自  iPhone X  发布以来，iOS  的深色模式就成了许多媒体每年 WWDC 预测的保留部分。在两年之后，苹果终于在  iOS 13  中将深色模式带到了  iPhone  上。 刷上 iOS 13 并在设置中开启深色模式后，我发现 iPhone  的锁屏页面、主屏幕、通知中心小组件页面以及原生应用的背景都会相应变为深色。此外，iOS 13  还提供了一组与  macOS Mojave  类似的壁纸，可以随深色模式的开关而变化。 <img src=\"https://cdn.sspai.com/2019/06/05/e36e932d31bbc29f8719a6c2be3b011e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在「设置-显示与亮度」中更改深色模式的设置。除了手动更改外，还可以选择根据日出与日落时间进行自动更改，或是自定义深色模式的时间段。 <img src=\"https://cdn.sspai.com/2019/06/05/b27f9c73ee0fa614673edf33dd1fb5da.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 除了在设置中开启 / 关闭深色模式，你也可以在控制中心长按亮度选项，借助弹出的选项来更加方便地切换系统外观。 <img src=\"https://cdn.sspai.com/2019/06/05/53ba31313a1d0197881399279fcdffce.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 虽然苹果在系统界面和内置应用上下了不少功夫，但要实现全方位的一致外观，还离不开第三方  App  的支持。iOS 13  也为开发者提供了新的  API，使第三方应用也能更容易地适配深色模式。 除了深色模式，iOS 13  还对整体的设计语言进行了微调，向 iOS 12.3 中的钱包  app  的风格靠拢。例如，备忘录等应用新增了卡片式的视图；许多应用右上角也新增了「…」的选项按钮。</p>\n<h2 id=\"摄影：除了拍，后期修图和管理也很重要\"><a href=\"#摄影：除了拍，后期修图和管理也很重要\" class=\"headerlink\" title=\"摄影：除了拍，后期修图和管理也很重要\"></a>摄影：除了拍，后期修图和管理也很重要</h2><p>苹果除了在 iPhone 上会通过硬件提升拍照的能力，还通过系统软件来提升拍照的体验，其中就包括了照片和相机应用的大幅优化。</p>\n<h3 id=\"照片：全新的浏览视图，增强的编辑功能\"><a href=\"#照片：全新的浏览视图，增强的编辑功能\" class=\"headerlink\" title=\"照片：全新的浏览视图，增强的编辑功能\"></a>照片：全新的浏览视图，增强的编辑功能</h3><p>照片应用在原本的「所有照片」之外，又新增了「年度」、「月」和「日」三个维度。不同维度间的过渡动画颇为流畅，并会自动播放实况照片和视频。相比「所有照片」平铺式的显示方式，新的显示模式进一步优化了浏览体验，帮助使用者更好地重温回忆。 <img src=\"https://cdn.sspai.com/2019/06/05/c4aac8818d925e2619d0a5f872f259d8.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 借助机器学习技术，照片应用会隐藏重复照片、屏幕截图、白板照片等干扰，并自动选取一张最佳照片进行放大展示。如果你正在按年份浏览，照片会尽量选取往年的今日照片进行展示；按照月份浏览时，照片还会根据照片展示的事件对图片进行分类，并显示事件的名称、位置等信息。 尤其值得一提的是，当应用检测到生日照片时，还会对照片中的人物进行识别，并与通讯录中的生日信息进行对照，从而在标题中显示寿星的名字。 在浏览照片拥有了更合理的方式之外，iOS 13  还增强了编辑图片和视频的功能。现在，包括自动增强在内，你可以通过滑动来调节色温、色调、对比度、噪点消除等  16  项参数，并可以实时预览效果。在添加滤镜时，应用同样允许你调节滤镜强度，并实时展示滤镜效果。 <img src=\"https://cdn.sspai.com/2019/06/05/8c032a40196a81b875153b9a9e7a4fd1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 此外，原本的旋转和裁剪页面还加入了矫正畸变的功能。 <img src=\"https://cdn.sspai.com/2019/06/05/a23cf5693b4d1c867e799151112652b0.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 值得一提的是，以上功能同样适用于视频编辑。总的来看，更新后的照片  app  已经足以满足一定的后期需求。美中不足的是，原生照片  app  缺失了局部编辑功能，因而依然无法替代泼辣修图等更为专业的修图应用。</p>\n<h3 id=\"相机：人像光效更进一步\"><a href=\"#相机：人像光效更进一步\" class=\"headerlink\" title=\"相机：人像光效更进一步\"></a>相机：人像光效更进一步</h3><p>iOS 13  进一步提升了最新一代  iPhone  的人像模式效果。你可以调节不同光效的光源距离，从而实现更为理想的成像效果。 此外，人像模式还新增了名为「High-Key Mono」的光效模式，帮你拍摄出对比强烈、风格独特的人像。不过遗憾的是，本次相机的更新仅适用于  iPhone Xs、iPhone Xs Max  和  iPhone XR  机型。 <img src=\"https://cdn.sspai.com/20190605112924.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">样张来源：苹果官网</p>\n<h2 id=\"原生应用：全新的设计，更多的功能\"><a href=\"#原生应用：全新的设计，更多的功能\" class=\"headerlink\" title=\"原生应用：全新的设计，更多的功能\"></a>原生应用：全新的设计，更多的功能</h2><p>这次 iOS 13 更新苹果继续在自家的应用上发力，为提醒事项、备忘录、地图、Safari、文件等应用都带来新设计和更加强大的功能。</p>\n<h3 id=\"提醒事项：更实用的筛选功能\"><a href=\"#提醒事项：更实用的筛选功能\" class=\"headerlink\" title=\"提醒事项：更实用的筛选功能\"></a>提醒事项：更实用的筛选功能</h3><p>iOS 13  带来了全新的提醒事项  App。新设计的主页可以帮你更清楚地浏览任务。你还可以在创建列表时自定义使用的图标和颜色。 <img src=\"https://cdn.sspai.com/2019/06/05/441526a0d270c679bdb52118e49875c3.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 此外，创建提醒也更为容易。除了会在键盘上方提供可能的触发方式，提醒事项还会通过自然语义识别功能进一步协助你创建提醒。当你在信息  App  中聊天时，Siri  将会根据对话内容，为你创建建议的任务；当你在提醒事项  App  中输入任务时，Siri  可以根据你的输入提供建议的提醒时间。 <img src=\"https://cdn.sspai.com/2019/06/05/199cec47e8b4b85ac04961d8c4320464.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 创建提醒事项后，你还可以在详情中进一步编辑，如添加子事件，添加图片和链接作为附件等。 <img src=\"https://cdn.sspai.com/2019/06/05/a4146b6c817d0eba30e549953648f992.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 提醒事项还提供了新的触发方式。现在，除了设置在某一时间提醒、到达某一地点提醒，你还可以选择让提醒事项在你与选定的联系人发送短信时进行提醒。</p>\n<h3 id=\"备忘录：查看、编辑、分享更为便捷\"><a href=\"#备忘录：查看、编辑、分享更为便捷\" class=\"headerlink\" title=\"备忘录：查看、编辑、分享更为便捷\"></a>备忘录：查看、编辑、分享更为便捷</h3><p>借助备忘录的列表页面新增的选项，备忘录可以将笔记以缩略图的形式呈现。相比之前的列表，新的视图更方便你查找带有图片和  Apple Pencil  标注的笔记。 <img src=\"https://cdn.sspai.com/2019/06/05/4c484570b95cd920d846e305d4bd9546.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 除此之外，备忘录的搜索功能也得到了提升。新增的搜索建议功能可以帮你按照不同的类别进行检索。当你输入关键词后，备忘录可以在包括笔记中添加的图片、扫描的文档等在内的位置查找关键词。 iOS  13  还为备忘录带来了多层级的文件夹系统。你可以新建一个文件夹，然后点击右上角的「…」将其移动到另一个文件夹之下。 不仅如此，备忘录还完善了其协作功能。你可以将笔记甚至整个文件夹共享给其他用户来进行协作，并可以控制协作者之间的权限。</p>\n<h3 id=\"Safari-浏览器：新增下载管理器\"><a href=\"#Safari-浏览器：新增下载管理器\" class=\"headerlink\" title=\"Safari  浏览器：新增下载管理器\"></a>Safari  浏览器：新增下载管理器</h3><p>Safari  浏览器的空白标签页也在  iOS  13  中发生了变化。「经常访问的网页」变为了与「个人收藏」平级的项目。如果你并不需要，可以在设置中将其关闭。 尽管苹果只在  iPadOS  中提及了  Safari  浏览器的下载管理器，但实际上  iOS 13  也为  Safari  浏览器加入了这一功能。你可以在「设置-Safari 浏览器-下载项」中更改下载文件的默认存放位置。值得一提的是，下载过程中并不需要保持  Safari  浏览器在前台。 除此之外，Safari  浏览器还允许你针对每个网页设定不同的显示和隐私选项。点击智能搜索栏左侧的图标，即可调整字体大小，并选择是否开启阅读模式。在「网页设置」中，你还可以进一步更改该网页的权限。在打开阅读模式后，你还可以进一步调整背景色和字体。 <img src=\"https://cdn.sspai.com/2019/06/05/0f3d263b39fa807faa32613a28114629.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 值得一提的是，「请求桌面网站」选项同样出现在了  iOS  的  Safari  浏览器上。尽管  iPhone  的屏幕并不适合桌面网站，但这一功能可以绕开知乎等网站强制要求打开  App  才能进一步阅读的障碍。 除了上文所述之外，Safari  浏览器还有以下更新：</p>\n<ul>\n<li>上传图片时，可以更改图片尺寸；</li>\n<li>当你搜索的关键词与已经打开的标签页相关时，建议栏可以让你直接跳转到该标签页；</li>\n<li>Safari  浏览器会在你用弱密码注册账号时进行警告；</li>\n<li>通过  iCloud  同步的  Safari  浏览器浏览记录和打开的标签页会被端到端加密。</li>\n</ul>\n<p>总的来说，本次更新为  Safari  浏览器带来了不少实用的功能，已经可以在一定程度上实现  iCab  等  <a href=\"https://sspai.com/post/45385\">进阶型浏览器</a>  的功能。</p>\n<h3 id=\"文件：朝访达迈出的又一步\"><a href=\"#文件：朝访达迈出的又一步\" class=\"headerlink\" title=\"文件：朝访达迈出的又一步\"></a>文件：朝访达迈出的又一步</h3><p>iOS 13  也进一步增强了文件  App  的功能。首先，你可以与其他用户共享  iCloud Drive  中的文件夹，从而进行远程协作。要为文件夹添加协作用户，只需选中文件夹后，在分享页面选择「Add People」即可。 <img src=\"https://cdn.sspai.com/20190605114631.PNG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 此外，苹果还更新了长按文件后弹出的操作页面，并新增了数个功能：</p>\n<ul>\n<li>压缩与解压缩。相应的操作不再需要绕道捷径；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/20190605115913.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>快速查看。通过这个功能可以直接在文件应用中浏览文件，而无需跳转到第三方应用；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/20190605120006.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 不仅如此，iOS 13  还将备忘录中的扫描文档功能带到了文件  App  中。点击应用首页的「…」，选择「扫描文稿」即可。扫描后的文档可以直接分享，或是存储到文件  App  中。虽然这一原生功能并没有类似  Scanner Pro  等应用的  Workflow  选项，但扫描并保存文档的流程要比第三方  App  便捷不少。 <img src=\"https://cdn.sspai.com/2019/06/05/fa1d40139fbdb9d8cfaa2bcd887e6348.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 文件  App  的搜索还增加了关键词过滤的功能。你可以在输入文件的格式后，点击搜索建议的提示对搜索结果进行过滤，从而更快地找到所需的文件。 <img src=\"https://cdn.sspai.com/2019/06/05/1f2eec4b8701529e1ea3b59550fe00fc.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 值得一提的是，iOS 13  的文件  App  同样支持  iPadOS  中外接  USB  设备和连接服务器的功能。不过，目前苹果官网在售的相应配件只有一款  <a href=\"https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=2ahUKEwj7hJTvjNHiAhXCv54KHbpNBJAQFjAAegQIAxAB&url=https://www.apple.com/cn/shop/product/MD821FE/A&usg=AOvVaw3fZJyQjb-7Ntv-9EH1M_qA\">闪电转  USB  相机转换器</a> ，其是否能支持连接  U  盘等设备还有待测试。</p>\n<h3 id=\"地图：更详尽，更智能\"><a href=\"#地图：更详尽，更智能\" class=\"headerlink\" title=\"地图：更详尽，更智能\"></a>地图：更详尽，更智能</h3><p>得益于苹果的测绘工作，新版本的地图精细度有了极大的提升。 <img src=\"https://cdn.sspai.com/2019/06/05/5a69fd932bb7c00b38c2c45b83bfeeab.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">新旧地图精细度对比 除此之外，新版地图还加入了类似  Google Maps  的街景功能，从而方便用户获取更为准确的道路和地址等信息。苹果计划于未来两年内将这一改进应用至更多国家和地区。不过鉴于国内对测绘的管理，这一新特性能否应用至国内尚未可知。 <img src=\"https://cdn.sspai.com/2019/06/05/7f3325db8463a605d60eca3cb940ae9d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">街景功能 此外，地图还对收藏位置的显示进行了优化。现在，你可以对不同的地点进行分类，设定家庭、工作等多个预设地址，并将这些地点和预计到达时间分享出去。 <img src=\"https://cdn.sspai.com/2019/06/05/517793b447958b54ebfc813f9ee2c7b6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 新版地图的导航功能也得到了提高。增强的  Siri  导航功能会用类似「下个红绿灯左转」的指示代替过去的「500 米后左转」指令，并在导航快要结束前，引导你前往目的地的入口处。 除了上述的内容外，新版地图还可以实时更新你的航班信息，自动获取公交线路的时刻表，并额外为开发者提供了新的  API  接口  。</p>\n<h3 id=\"健康：个性化与新增功能\"><a href=\"#健康：个性化与新增功能\" class=\"headerlink\" title=\"健康：个性化与新增功能\"></a>健康：个性化与新增功能</h3><p>iOS 13  的健康应用也获得了全新的界面。通过机器学习，健康应用会将一天中最重要的健康信息呈现给你，并将其   与之前一周的情况进行对比，激励你更加重视个人健康。当然，你也可以选择将部分数据加入收藏，从而使其始终在应用顶部显示。你也可以在「搜索」标签页中查看所有健康数据。 <img src=\"https://cdn.sspai.com/2019/06/05/0c195e5d6b3e9feff46f0ff8cd4e2a96.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 健康应用还同时新增了数个模块，包括：</p>\n<ul>\n<li>月经周期记录。在「搜索」标签页中点击「周期跟踪」，即可根据提示进行设置。应用会根据记录数据对排卵期等进行预测和提醒。</li>\n<li>噪音检测。如果你有  Apple Watch  与  iPhone  配对，Apple Watch  将会对你的周围环境噪声进行监控，并为你提供其对听力的损害情况。此外，这一模块还会收集你使用的耳机音量，帮你判断是否需要将其调小。</li>\n<li>口腔健康。你可以在「搜索」标签页的「Other Data-刷牙」中手动记录每日的刷牙时长，或是通过带有相应功能的牙刷自动记录。</li>\n<li>教育模块，以短文的形式出现在主页面底部，为你普及健康知识。</li>\n</ul>\n<h3 id=\"查找：找朋友找设备合二为一\"><a href=\"#查找：找朋友找设备合二为一\" class=\"headerlink\" title=\"查找：找朋友找设备合二为一\"></a>查找：找朋友找设备合二为一</h3><p>iOS 13  将查找我的朋友和查找我的设备进行了合并，组成了新的「查找」应用。不过更引人关注的则是应用在查找离线设备上的进步。当其他人的  iPhone  检测到周围你的离线设备的蓝牙信号后，iOS  会自动将这一信息发送至云端，从而帮你定位丢失的设备。整个过程通过端到端加密来保证隐私安全，并且不会额外占用  iPhone  的数据流量。 <img src=\"https://cdn.sspai.com/20190605120543.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<h3 id=\"Siri-和捷径：更自然的声音、自动化的触发机制\"><a href=\"#Siri-和捷径：更自然的声音、自动化的触发机制\" class=\"headerlink\" title=\"Siri  和捷径：更自然的声音、自动化的触发机制\"></a>Siri  和捷径：更自然的声音、自动化的触发机制</h3><p>相比此前  Siri  将多段语音拼合在一起的发音方式， iOS 13 采用了 TTS  模型，利用深度学习技术直接生成完整的句子，从而使  Siri  的声音听起来更为自然。此外，你还可以通过  Siri  来收听无线电广播、播客和有声书等内容。 iOS 13  也为捷径带来了新的重要功能：自动化。你可以设置通过时间、闹钟、体能训练、位置、打开应用、设备状态、NFC  贴纸等方式，自动触发相应的捷径。 这一新模块的加入，又进一步增加了捷径的玩法和实用性。例如，你可以令捷径在早晨闹钟结束后，自动为你播报今天的天气等信息。相比之下，Launch Center Pro  的订阅吸引力又小了不少。美中不足的是，目前捷径创建自动化时，其触发的动作无法设定为已经存在的捷径，制作起来略为繁琐。 <img src=\"https://cdn.sspai.com/2019/06/05/7ee0cf871836f266ce82f222dee95e57.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<h2 id=\"系统功能：更好玩，更安全\"><a href=\"#系统功能：更好玩，更安全\" class=\"headerlink\" title=\"系统功能：更好玩，更安全\"></a>系统功能：更好玩，更安全</h2><h3 id=\"拟我表情（Memoji）与动话表情（Animoji）：在线化妆，还能做贴纸\"><a href=\"#拟我表情（Memoji）与动话表情（Animoji）：在线化妆，还能做贴纸\" class=\"headerlink\" title=\"拟我表情（Memoji）与动话表情（Animoji）：在线化妆，还能做贴纸\"></a>拟我表情（Memoji）与动话表情（Animoji）：在线化妆，还能做贴纸</h3><p>iOS 13  为拟我表情带来了大量的可调节特性，如眼线、眼影、耳饰等。在发布会上，苹果还特意请来了  Youtube  网红  Patrick Starrr  和  Desi Perkins  进行了  <a href=\"https://www.youtube.com/watch?v=3x7_w9Oz8lQ\">演示</a> 。 <img src=\"https://cdn.sspai.com/2019/06/05/715b8d5e6207a23986e1a7c0ed1ebd64.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">新增的人物细节 动话表情也得到了更新，新增了老鼠、章鱼和奶牛三款形象。此外，制作完毕的  Memoji  和动画表情还会被自动转化为一套贴纸，可以和  Emoji  一起在表情键盘中使用，不再仅局限于信息 App 中。 <img src=\"https://cdn.sspai.com/2019/06/05/a6b07dec1f3ef8110f6b8074d8475bc0.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">3 款新增动话表情 值得一提的是，尽管动话表情需要  iPhone X  及更新机型才能使用，Memoji  贴纸和动话表情贴纸可以在所有搭载  A9  及更新处理器的机型上使用。</p>\n<h3 id=\"新的文本编辑和浏览手势\"><a href=\"#新的文本编辑和浏览手势\" class=\"headerlink\" title=\"新的文本编辑和浏览手势\"></a>新的文本编辑和浏览手势</h3><p>iOS 13  还带来了数个新的手势功能，更好地利用多点触控屏的优势来编辑和浏览文本：</p>\n<ul>\n<li>iOS 13 可以让你直接拖动并移动光标，不再需要长按；</li>\n<li>长按并拖动光标可以选取文本，不再需要双击光标；</li>\n<li>三重点击文本可以选取整句话，四重点击可以选取整段文字；</li>\n<li>在浏览较长的文章或网页时，可以长按屏幕侧面的滚动条来快速跳转和预览；</li>\n<li>在文件、邮件、信息等  App  中，可以通过双指轻点的方式进入文件选择模式，顺势滑动还可以快速多选文件；</li>\n<li>在选中文本后，三指捏合即可复制文本，捏合两次即可剪切；张开三指可以粘贴文本。</li>\n</ul>\n<h3 id=\"屏幕使用时间：One-More-Minute\"><a href=\"#屏幕使用时间：One-More-Minute\" class=\"headerlink\" title=\"屏幕使用时间：One More Minute\"></a>屏幕使用时间：One More Minute</h3><p>屏幕使用时间的功能也在本次  WWDC  上得到了优化，主要包括：</p>\n<ul>\n<li>在应用达到时间限额后，iOS 13  额外提供了「多一分钟」的选项，方便你快速保存或退出当前的工作；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/9e7c11d53c8da8ee087f956d4d26fdc2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>在「设置-屏幕使用时间-应用限额」中，你现在可以精确地选取所需的  App  来组成一组应用限额，不再只局限于同时选择某一类别的所有应用；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/5f28cd1e64ce61a4e8a749254a895bef.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">应用限额页面</p>\n<ul>\n<li>屏幕使用时间还新增了「通信限制」的选项，可以设置允许设备拨打电话、收发短信、使用  FaceTime  通话等功能的时间段和联系人；</li>\n<li>屏幕使用时间的数据保存时间延长至  30  天，从而方便你具体对比本周和过去数周的数据。</li>\n</ul>\n<h3 id=\"隐私与安全性\"><a href=\"#隐私与安全性\" class=\"headerlink\" title=\"隐私与安全性\"></a>隐私与安全性</h3><p>iOS 13  还进一步提升了对隐私的保护力度，主要包括了以下方面：</p>\n<ul>\n<li>当  App  请求获取位置信息时，新增了「只允许一次」的选项；</li>\n<li>当  App  在后台使用你的位置信息时，iOS 13  会通过弹窗进行提醒，你可以据此选择是否更新对该应用的隐私权限设置；</li>\n<li>在分享图片时，可以在「Options」中选择是否抹除照片的地理位置信息；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/b3312f283722a4a58d33a579b0bda071.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>改进后的  API  使应用更难通过  Wi-Fi  和蓝牙信息获取当前位置。此外，iOS 13  还提升了  Safari  浏览器阻止网页追踪的能力。</li>\n</ul>\n<p>除此之外，苹果还在  iOS 13  中推出了「通过  Apple  登陆」（Sign In with Apple）的选项。相比常见的通过  Facebook、Google  登陆，通过  Apple  登陆不会向网页泄露除名称和邮箱地址外的任何个人信息。 如果你希望更进一步，还可以在登录时隐藏真实邮箱地址，而以苹果创建的随机邮箱地址进行替代。你甚至还可以为不同应用设置使用不同的匿名邮箱。通过  Apple  登陆不需要设置密码，借助面容  ID  或   触控  ID  即可登陆，还可以通过双重验证来进一步提高安全性。</p>\n<h3 id=\"AirPods-和-HomePod\"><a href=\"#AirPods-和-HomePod\" class=\"headerlink\" title=\"AirPods 和 HomePod\"></a>AirPods 和 HomePod</h3><p>iOS 13  也为  AirPods  和  HomePod  带来了新功能。现在，当使用了  SiriKit  的应用接收到消息后，AirPods  会自动为你朗读内容，并可以让你即时通过  Siri  来回复。此外，当你使用  AirPods  听音乐时，还可以通过轻触设备的方式与另一名  AirPods  使用者共享当前歌曲。这一功能同样适用于所有使用了  SiriKit  的第三方  App。 <img src=\"https://cdn.sspai.com/2019/06/05/03de73d70b55ad3dce21f9037679b0cb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">来源：WWDC 2019 与此同时，HomePod  带来了对多用户的支持。通过对不同家庭成员声音进行分析，HomePod  可以对联系人、短信、通话等指令做出更为个性化的回答。 <img src=\"https://cdn.sspai.com/2019/06/05/0cd56e6ff049f50e08387b0ae4e880bf.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">家庭 App</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>除了上文的主要更新外，iOS 13  还带来了以下变化：</p>\n<ul>\n<li>在没有 3D Touch  的手机上使用 Haptic Touch  可以获得 Context Menu 的效果；</li>\n<li>新增  Image Capture API，允许第三方  App  直接打开外接设备中的图片，无需再经过照片  App；</li>\n<li>App Store  界面调整，新增订阅服务  Arcade  界面，应用更新移动至个人页面；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/9b78b2bfbbe4750282e04308d2a43d40.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>音量调节页面更新，不再占用过多屏幕面积，并可以在屏幕上直接滑动调节；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/304d77dbcbb56f2adaa2c69acd18a12b.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>图书  App  新增了每日阅读目标功能，鼓励你坚持每日读书；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/6424a62d813b25475164fd97ab2db1aa.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>音乐  App  采用了新的播放页面，并新增了歌词滚动显示功能；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/a399cd1520d79d8b9c44b9cddc311e07.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>邮件 App 可以屏蔽特定邮箱的来信，并新增了自动补全邮箱地址、改良的工具栏等功能；</li>\n<li>家庭 App 提升了对 HomeKit 配件的保护，自动化可以触发捷径。此外，苹果还推出了新的 HomeKit 监控，符合这一标准的配件将可以在不占用 iCloud 空间的情况下，通过 iCloud 发送录像内容；</li>\n<li>你可以在「设置-电话」中开启「静音未知来电」选项，减少骚扰电话的干扰；</li>\n<li>优化了充电方式，通过学习用户的充电习惯，并暂缓充电至 80% 以上，来减缓电池的老化；</li>\n<li>支持游戏时使用  PlayStation 4  和  Xbox One S  的手柄；</li>\n<li>在控制中心长按  Wi-Fi  和蓝牙图标后，可以直接选择要连接的网络  /  设备；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/c07e27a5cc9c17a907f366928b36eff8.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>可以在「设置-信息-共享姓名和照片」中设置是否在开始新对话时，发送自己的头像和姓名给对方；</li>\n<li>可以用  Memoji  为通讯录中的联系人添加头像；</li>\n<li>分享页界面得到了更新，并会根据使用习惯，建议可能的分享对象；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/2a64b8e78796656555b1f2abbea23426.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>可以在  App Store  中下载字体使用，并在设置中进行管理；</li>\n<li>截图标注页面更新，加入了直尺工具。编辑后的图片可以直接保存至文件 App；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/336939de533feafdcbb566da8ca68982.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>系统键盘加入了滑动输入的功能，可以通过指尖在键盘区域不间断地滑动来实现更流畅地输入，并减少误触的情况；</li>\n<li>表情成为了系统键盘的一枚独立的按键。在多个语言之间切换时，将不会再收到表情键盘的干扰；</li>\n<li>iPhone Xs、iPhone Xs Max 和 iPhone XR 增加对杜比全景声效的支持；</li>\n<li>解除了蜂窝网络环境下不能下载超过 200MB 的应用的限制；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/91a7de16e3818f8cc555e7f9857a342f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 相比往年，苹果今年并没有放出  iOS 13  的  Developer Beta  版描述文件，并在相关界面特别提醒普通用户应等待  Public Beta。在我的体验中，iOS 13 的测试版也存在发热、卡顿等问题。如果你希望提前体验 iOS 13，不妨等待 7 月推出的 Public Beta 测试版。</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>按照惯例，苹果于北京时间 6 月 4 日凌晨的  WWDC  上发布了各个平台的新一代操作系统。相比去年专注于性能和稳定性的  iOS 12，今年的  iOS 13 有了大幅改动，带来了众多系统新特性，以及原生应用也得到了大幅改进。</p>\n<h2 id=\"系统外观：姗姗来迟的深色模式\"><a href=\"#系统外观：姗姗来迟的深色模式\" class=\"headerlink\" title=\"系统外观：姗姗来迟的深色模式\"></a>系统外观：姗姗来迟的深色模式</h2><p>自  iPhone X  发布以来，iOS  的深色模式就成了许多媒体每年 WWDC 预测的保留部分。在两年之后，苹果终于在  iOS 13  中将深色模式带到了  iPhone  上。 刷上 iOS 13 并在设置中开启深色模式后，我发现 iPhone  的锁屏页面、主屏幕、通知中心小组件页面以及原生应用的背景都会相应变为深色。此外，iOS 13  还提供了一组与  macOS Mojave  类似的壁纸，可以随深色模式的开关而变化。 <img src=\"https://cdn.sspai.com/2019/06/05/e36e932d31bbc29f8719a6c2be3b011e.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 你可以在「设置-显示与亮度」中更改深色模式的设置。除了手动更改外，还可以选择根据日出与日落时间进行自动更改，或是自定义深色模式的时间段。 <img src=\"https://cdn.sspai.com/2019/06/05/b27f9c73ee0fa614673edf33dd1fb5da.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 除了在设置中开启 / 关闭深色模式，你也可以在控制中心长按亮度选项，借助弹出的选项来更加方便地切换系统外观。 <img src=\"https://cdn.sspai.com/2019/06/05/53ba31313a1d0197881399279fcdffce.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 虽然苹果在系统界面和内置应用上下了不少功夫，但要实现全方位的一致外观，还离不开第三方  App  的支持。iOS 13  也为开发者提供了新的  API，使第三方应用也能更容易地适配深色模式。 除了深色模式，iOS 13  还对整体的设计语言进行了微调，向 iOS 12.3 中的钱包  app  的风格靠拢。例如，备忘录等应用新增了卡片式的视图；许多应用右上角也新增了「…」的选项按钮。</p>\n<h2 id=\"摄影：除了拍，后期修图和管理也很重要\"><a href=\"#摄影：除了拍，后期修图和管理也很重要\" class=\"headerlink\" title=\"摄影：除了拍，后期修图和管理也很重要\"></a>摄影：除了拍，后期修图和管理也很重要</h2><p>苹果除了在 iPhone 上会通过硬件提升拍照的能力，还通过系统软件来提升拍照的体验，其中就包括了照片和相机应用的大幅优化。</p>\n<h3 id=\"照片：全新的浏览视图，增强的编辑功能\"><a href=\"#照片：全新的浏览视图，增强的编辑功能\" class=\"headerlink\" title=\"照片：全新的浏览视图，增强的编辑功能\"></a>照片：全新的浏览视图，增强的编辑功能</h3><p>照片应用在原本的「所有照片」之外，又新增了「年度」、「月」和「日」三个维度。不同维度间的过渡动画颇为流畅，并会自动播放实况照片和视频。相比「所有照片」平铺式的显示方式，新的显示模式进一步优化了浏览体验，帮助使用者更好地重温回忆。 <img src=\"https://cdn.sspai.com/2019/06/05/c4aac8818d925e2619d0a5f872f259d8.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 借助机器学习技术，照片应用会隐藏重复照片、屏幕截图、白板照片等干扰，并自动选取一张最佳照片进行放大展示。如果你正在按年份浏览，照片会尽量选取往年的今日照片进行展示；按照月份浏览时，照片还会根据照片展示的事件对图片进行分类，并显示事件的名称、位置等信息。 尤其值得一提的是，当应用检测到生日照片时，还会对照片中的人物进行识别，并与通讯录中的生日信息进行对照，从而在标题中显示寿星的名字。 在浏览照片拥有了更合理的方式之外，iOS 13  还增强了编辑图片和视频的功能。现在，包括自动增强在内，你可以通过滑动来调节色温、色调、对比度、噪点消除等  16  项参数，并可以实时预览效果。在添加滤镜时，应用同样允许你调节滤镜强度，并实时展示滤镜效果。 <img src=\"https://cdn.sspai.com/2019/06/05/8c032a40196a81b875153b9a9e7a4fd1.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 此外，原本的旋转和裁剪页面还加入了矫正畸变的功能。 <img src=\"https://cdn.sspai.com/2019/06/05/a23cf5693b4d1c867e799151112652b0.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 值得一提的是，以上功能同样适用于视频编辑。总的来看，更新后的照片  app  已经足以满足一定的后期需求。美中不足的是，原生照片  app  缺失了局部编辑功能，因而依然无法替代泼辣修图等更为专业的修图应用。</p>\n<h3 id=\"相机：人像光效更进一步\"><a href=\"#相机：人像光效更进一步\" class=\"headerlink\" title=\"相机：人像光效更进一步\"></a>相机：人像光效更进一步</h3><p>iOS 13  进一步提升了最新一代  iPhone  的人像模式效果。你可以调节不同光效的光源距离，从而实现更为理想的成像效果。 此外，人像模式还新增了名为「High-Key Mono」的光效模式，帮你拍摄出对比强烈、风格独特的人像。不过遗憾的是，本次相机的更新仅适用于  iPhone Xs、iPhone Xs Max  和  iPhone XR  机型。 <img src=\"https://cdn.sspai.com/20190605112924.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">样张来源：苹果官网</p>\n<h2 id=\"原生应用：全新的设计，更多的功能\"><a href=\"#原生应用：全新的设计，更多的功能\" class=\"headerlink\" title=\"原生应用：全新的设计，更多的功能\"></a>原生应用：全新的设计，更多的功能</h2><p>这次 iOS 13 更新苹果继续在自家的应用上发力，为提醒事项、备忘录、地图、Safari、文件等应用都带来新设计和更加强大的功能。</p>\n<h3 id=\"提醒事项：更实用的筛选功能\"><a href=\"#提醒事项：更实用的筛选功能\" class=\"headerlink\" title=\"提醒事项：更实用的筛选功能\"></a>提醒事项：更实用的筛选功能</h3><p>iOS 13  带来了全新的提醒事项  App。新设计的主页可以帮你更清楚地浏览任务。你还可以在创建列表时自定义使用的图标和颜色。 <img src=\"https://cdn.sspai.com/2019/06/05/441526a0d270c679bdb52118e49875c3.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 此外，创建提醒也更为容易。除了会在键盘上方提供可能的触发方式，提醒事项还会通过自然语义识别功能进一步协助你创建提醒。当你在信息  App  中聊天时，Siri  将会根据对话内容，为你创建建议的任务；当你在提醒事项  App  中输入任务时，Siri  可以根据你的输入提供建议的提醒时间。 <img src=\"https://cdn.sspai.com/2019/06/05/199cec47e8b4b85ac04961d8c4320464.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 创建提醒事项后，你还可以在详情中进一步编辑，如添加子事件，添加图片和链接作为附件等。 <img src=\"https://cdn.sspai.com/2019/06/05/a4146b6c817d0eba30e549953648f992.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 提醒事项还提供了新的触发方式。现在，除了设置在某一时间提醒、到达某一地点提醒，你还可以选择让提醒事项在你与选定的联系人发送短信时进行提醒。</p>\n<h3 id=\"备忘录：查看、编辑、分享更为便捷\"><a href=\"#备忘录：查看、编辑、分享更为便捷\" class=\"headerlink\" title=\"备忘录：查看、编辑、分享更为便捷\"></a>备忘录：查看、编辑、分享更为便捷</h3><p>借助备忘录的列表页面新增的选项，备忘录可以将笔记以缩略图的形式呈现。相比之前的列表，新的视图更方便你查找带有图片和  Apple Pencil  标注的笔记。 <img src=\"https://cdn.sspai.com/2019/06/05/4c484570b95cd920d846e305d4bd9546.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 除此之外，备忘录的搜索功能也得到了提升。新增的搜索建议功能可以帮你按照不同的类别进行检索。当你输入关键词后，备忘录可以在包括笔记中添加的图片、扫描的文档等在内的位置查找关键词。 iOS  13  还为备忘录带来了多层级的文件夹系统。你可以新建一个文件夹，然后点击右上角的「…」将其移动到另一个文件夹之下。 不仅如此，备忘录还完善了其协作功能。你可以将笔记甚至整个文件夹共享给其他用户来进行协作，并可以控制协作者之间的权限。</p>\n<h3 id=\"Safari-浏览器：新增下载管理器\"><a href=\"#Safari-浏览器：新增下载管理器\" class=\"headerlink\" title=\"Safari  浏览器：新增下载管理器\"></a>Safari  浏览器：新增下载管理器</h3><p>Safari  浏览器的空白标签页也在  iOS  13  中发生了变化。「经常访问的网页」变为了与「个人收藏」平级的项目。如果你并不需要，可以在设置中将其关闭。 尽管苹果只在  iPadOS  中提及了  Safari  浏览器的下载管理器，但实际上  iOS 13  也为  Safari  浏览器加入了这一功能。你可以在「设置-Safari 浏览器-下载项」中更改下载文件的默认存放位置。值得一提的是，下载过程中并不需要保持  Safari  浏览器在前台。 除此之外，Safari  浏览器还允许你针对每个网页设定不同的显示和隐私选项。点击智能搜索栏左侧的图标，即可调整字体大小，并选择是否开启阅读模式。在「网页设置」中，你还可以进一步更改该网页的权限。在打开阅读模式后，你还可以进一步调整背景色和字体。 <img src=\"https://cdn.sspai.com/2019/06/05/0f3d263b39fa807faa32613a28114629.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 值得一提的是，「请求桌面网站」选项同样出现在了  iOS  的  Safari  浏览器上。尽管  iPhone  的屏幕并不适合桌面网站，但这一功能可以绕开知乎等网站强制要求打开  App  才能进一步阅读的障碍。 除了上文所述之外，Safari  浏览器还有以下更新：</p>\n<ul>\n<li>上传图片时，可以更改图片尺寸；</li>\n<li>当你搜索的关键词与已经打开的标签页相关时，建议栏可以让你直接跳转到该标签页；</li>\n<li>Safari  浏览器会在你用弱密码注册账号时进行警告；</li>\n<li>通过  iCloud  同步的  Safari  浏览器浏览记录和打开的标签页会被端到端加密。</li>\n</ul>\n<p>总的来说，本次更新为  Safari  浏览器带来了不少实用的功能，已经可以在一定程度上实现  iCab  等  <a href=\"https://sspai.com/post/45385\">进阶型浏览器</a>  的功能。</p>\n<h3 id=\"文件：朝访达迈出的又一步\"><a href=\"#文件：朝访达迈出的又一步\" class=\"headerlink\" title=\"文件：朝访达迈出的又一步\"></a>文件：朝访达迈出的又一步</h3><p>iOS 13  也进一步增强了文件  App  的功能。首先，你可以与其他用户共享  iCloud Drive  中的文件夹，从而进行远程协作。要为文件夹添加协作用户，只需选中文件夹后，在分享页面选择「Add People」即可。 <img src=\"https://cdn.sspai.com/20190605114631.PNG?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 此外，苹果还更新了长按文件后弹出的操作页面，并新增了数个功能：</p>\n<ul>\n<li>压缩与解压缩。相应的操作不再需要绕道捷径；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/20190605115913.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>快速查看。通过这个功能可以直接在文件应用中浏览文件，而无需跳转到第三方应用；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/20190605120006.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 不仅如此，iOS 13  还将备忘录中的扫描文档功能带到了文件  App  中。点击应用首页的「…」，选择「扫描文稿」即可。扫描后的文档可以直接分享，或是存储到文件  App  中。虽然这一原生功能并没有类似  Scanner Pro  等应用的  Workflow  选项，但扫描并保存文档的流程要比第三方  App  便捷不少。 <img src=\"https://cdn.sspai.com/2019/06/05/fa1d40139fbdb9d8cfaa2bcd887e6348.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 文件  App  的搜索还增加了关键词过滤的功能。你可以在输入文件的格式后，点击搜索建议的提示对搜索结果进行过滤，从而更快地找到所需的文件。 <img src=\"https://cdn.sspai.com/2019/06/05/1f2eec4b8701529e1ea3b59550fe00fc.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 值得一提的是，iOS 13  的文件  App  同样支持  iPadOS  中外接  USB  设备和连接服务器的功能。不过，目前苹果官网在售的相应配件只有一款  <a href=\"https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&ved=2ahUKEwj7hJTvjNHiAhXCv54KHbpNBJAQFjAAegQIAxAB&url=https://www.apple.com/cn/shop/product/MD821FE/A&usg=AOvVaw3fZJyQjb-7Ntv-9EH1M_qA\">闪电转  USB  相机转换器</a> ，其是否能支持连接  U  盘等设备还有待测试。</p>\n<h3 id=\"地图：更详尽，更智能\"><a href=\"#地图：更详尽，更智能\" class=\"headerlink\" title=\"地图：更详尽，更智能\"></a>地图：更详尽，更智能</h3><p>得益于苹果的测绘工作，新版本的地图精细度有了极大的提升。 <img src=\"https://cdn.sspai.com/2019/06/05/5a69fd932bb7c00b38c2c45b83bfeeab.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">新旧地图精细度对比 除此之外，新版地图还加入了类似  Google Maps  的街景功能，从而方便用户获取更为准确的道路和地址等信息。苹果计划于未来两年内将这一改进应用至更多国家和地区。不过鉴于国内对测绘的管理，这一新特性能否应用至国内尚未可知。 <img src=\"https://cdn.sspai.com/2019/06/05/7f3325db8463a605d60eca3cb940ae9d.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">街景功能 此外，地图还对收藏位置的显示进行了优化。现在，你可以对不同的地点进行分类，设定家庭、工作等多个预设地址，并将这些地点和预计到达时间分享出去。 <img src=\"https://cdn.sspai.com/2019/06/05/517793b447958b54ebfc813f9ee2c7b6.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 新版地图的导航功能也得到了提高。增强的  Siri  导航功能会用类似「下个红绿灯左转」的指示代替过去的「500 米后左转」指令，并在导航快要结束前，引导你前往目的地的入口处。 除了上述的内容外，新版地图还可以实时更新你的航班信息，自动获取公交线路的时刻表，并额外为开发者提供了新的  API  接口  。</p>\n<h3 id=\"健康：个性化与新增功能\"><a href=\"#健康：个性化与新增功能\" class=\"headerlink\" title=\"健康：个性化与新增功能\"></a>健康：个性化与新增功能</h3><p>iOS 13  的健康应用也获得了全新的界面。通过机器学习，健康应用会将一天中最重要的健康信息呈现给你，并将其   与之前一周的情况进行对比，激励你更加重视个人健康。当然，你也可以选择将部分数据加入收藏，从而使其始终在应用顶部显示。你也可以在「搜索」标签页中查看所有健康数据。 <img src=\"https://cdn.sspai.com/2019/06/05/0c195e5d6b3e9feff46f0ff8cd4e2a96.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 健康应用还同时新增了数个模块，包括：</p>\n<ul>\n<li>月经周期记录。在「搜索」标签页中点击「周期跟踪」，即可根据提示进行设置。应用会根据记录数据对排卵期等进行预测和提醒。</li>\n<li>噪音检测。如果你有  Apple Watch  与  iPhone  配对，Apple Watch  将会对你的周围环境噪声进行监控，并为你提供其对听力的损害情况。此外，这一模块还会收集你使用的耳机音量，帮你判断是否需要将其调小。</li>\n<li>口腔健康。你可以在「搜索」标签页的「Other Data-刷牙」中手动记录每日的刷牙时长，或是通过带有相应功能的牙刷自动记录。</li>\n<li>教育模块，以短文的形式出现在主页面底部，为你普及健康知识。</li>\n</ul>\n<h3 id=\"查找：找朋友找设备合二为一\"><a href=\"#查找：找朋友找设备合二为一\" class=\"headerlink\" title=\"查找：找朋友找设备合二为一\"></a>查找：找朋友找设备合二为一</h3><p>iOS 13  将查找我的朋友和查找我的设备进行了合并，组成了新的「查找」应用。不过更引人关注的则是应用在查找离线设备上的进步。当其他人的  iPhone  检测到周围你的离线设备的蓝牙信号后，iOS  会自动将这一信息发送至云端，从而帮你定位丢失的设备。整个过程通过端到端加密来保证隐私安全，并且不会额外占用  iPhone  的数据流量。 <img src=\"https://cdn.sspai.com/20190605120543.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<h3 id=\"Siri-和捷径：更自然的声音、自动化的触发机制\"><a href=\"#Siri-和捷径：更自然的声音、自动化的触发机制\" class=\"headerlink\" title=\"Siri  和捷径：更自然的声音、自动化的触发机制\"></a>Siri  和捷径：更自然的声音、自动化的触发机制</h3><p>相比此前  Siri  将多段语音拼合在一起的发音方式， iOS 13 采用了 TTS  模型，利用深度学习技术直接生成完整的句子，从而使  Siri  的声音听起来更为自然。此外，你还可以通过  Siri  来收听无线电广播、播客和有声书等内容。 iOS 13  也为捷径带来了新的重要功能：自动化。你可以设置通过时间、闹钟、体能训练、位置、打开应用、设备状态、NFC  贴纸等方式，自动触发相应的捷径。 这一新模块的加入，又进一步增加了捷径的玩法和实用性。例如，你可以令捷径在早晨闹钟结束后，自动为你播报今天的天气等信息。相比之下，Launch Center Pro  的订阅吸引力又小了不少。美中不足的是，目前捷径创建自动化时，其触发的动作无法设定为已经存在的捷径，制作起来略为繁琐。 <img src=\"https://cdn.sspai.com/2019/06/05/7ee0cf871836f266ce82f222dee95e57.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<h2 id=\"系统功能：更好玩，更安全\"><a href=\"#系统功能：更好玩，更安全\" class=\"headerlink\" title=\"系统功能：更好玩，更安全\"></a>系统功能：更好玩，更安全</h2><h3 id=\"拟我表情（Memoji）与动话表情（Animoji）：在线化妆，还能做贴纸\"><a href=\"#拟我表情（Memoji）与动话表情（Animoji）：在线化妆，还能做贴纸\" class=\"headerlink\" title=\"拟我表情（Memoji）与动话表情（Animoji）：在线化妆，还能做贴纸\"></a>拟我表情（Memoji）与动话表情（Animoji）：在线化妆，还能做贴纸</h3><p>iOS 13  为拟我表情带来了大量的可调节特性，如眼线、眼影、耳饰等。在发布会上，苹果还特意请来了  Youtube  网红  Patrick Starrr  和  Desi Perkins  进行了  <a href=\"https://www.youtube.com/watch?v=3x7_w9Oz8lQ\">演示</a> 。 <img src=\"https://cdn.sspai.com/2019/06/05/715b8d5e6207a23986e1a7c0ed1ebd64.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">新增的人物细节 动话表情也得到了更新，新增了老鼠、章鱼和奶牛三款形象。此外，制作完毕的  Memoji  和动画表情还会被自动转化为一套贴纸，可以和  Emoji  一起在表情键盘中使用，不再仅局限于信息 App 中。 <img src=\"https://cdn.sspai.com/2019/06/05/a6b07dec1f3ef8110f6b8074d8475bc0.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">3 款新增动话表情 值得一提的是，尽管动话表情需要  iPhone X  及更新机型才能使用，Memoji  贴纸和动话表情贴纸可以在所有搭载  A9  及更新处理器的机型上使用。</p>\n<h3 id=\"新的文本编辑和浏览手势\"><a href=\"#新的文本编辑和浏览手势\" class=\"headerlink\" title=\"新的文本编辑和浏览手势\"></a>新的文本编辑和浏览手势</h3><p>iOS 13  还带来了数个新的手势功能，更好地利用多点触控屏的优势来编辑和浏览文本：</p>\n<ul>\n<li>iOS 13 可以让你直接拖动并移动光标，不再需要长按；</li>\n<li>长按并拖动光标可以选取文本，不再需要双击光标；</li>\n<li>三重点击文本可以选取整句话，四重点击可以选取整段文字；</li>\n<li>在浏览较长的文章或网页时，可以长按屏幕侧面的滚动条来快速跳转和预览；</li>\n<li>在文件、邮件、信息等  App  中，可以通过双指轻点的方式进入文件选择模式，顺势滑动还可以快速多选文件；</li>\n<li>在选中文本后，三指捏合即可复制文本，捏合两次即可剪切；张开三指可以粘贴文本。</li>\n</ul>\n<h3 id=\"屏幕使用时间：One-More-Minute\"><a href=\"#屏幕使用时间：One-More-Minute\" class=\"headerlink\" title=\"屏幕使用时间：One More Minute\"></a>屏幕使用时间：One More Minute</h3><p>屏幕使用时间的功能也在本次  WWDC  上得到了优化，主要包括：</p>\n<ul>\n<li>在应用达到时间限额后，iOS 13  额外提供了「多一分钟」的选项，方便你快速保存或退出当前的工作；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/9e7c11d53c8da8ee087f956d4d26fdc2.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>在「设置-屏幕使用时间-应用限额」中，你现在可以精确地选取所需的  App  来组成一组应用限额，不再只局限于同时选择某一类别的所有应用；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/5f28cd1e64ce61a4e8a749254a895bef.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">应用限额页面</p>\n<ul>\n<li>屏幕使用时间还新增了「通信限制」的选项，可以设置允许设备拨打电话、收发短信、使用  FaceTime  通话等功能的时间段和联系人；</li>\n<li>屏幕使用时间的数据保存时间延长至  30  天，从而方便你具体对比本周和过去数周的数据。</li>\n</ul>\n<h3 id=\"隐私与安全性\"><a href=\"#隐私与安全性\" class=\"headerlink\" title=\"隐私与安全性\"></a>隐私与安全性</h3><p>iOS 13  还进一步提升了对隐私的保护力度，主要包括了以下方面：</p>\n<ul>\n<li>当  App  请求获取位置信息时，新增了「只允许一次」的选项；</li>\n<li>当  App  在后台使用你的位置信息时，iOS 13  会通过弹窗进行提醒，你可以据此选择是否更新对该应用的隐私权限设置；</li>\n<li>在分享图片时，可以在「Options」中选择是否抹除照片的地理位置信息；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/b3312f283722a4a58d33a579b0bda071.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>改进后的  API  使应用更难通过  Wi-Fi  和蓝牙信息获取当前位置。此外，iOS 13  还提升了  Safari  浏览器阻止网页追踪的能力。</li>\n</ul>\n<p>除此之外，苹果还在  iOS 13  中推出了「通过  Apple  登陆」（Sign In with Apple）的选项。相比常见的通过  Facebook、Google  登陆，通过  Apple  登陆不会向网页泄露除名称和邮箱地址外的任何个人信息。 如果你希望更进一步，还可以在登录时隐藏真实邮箱地址，而以苹果创建的随机邮箱地址进行替代。你甚至还可以为不同应用设置使用不同的匿名邮箱。通过  Apple  登陆不需要设置密码，借助面容  ID  或   触控  ID  即可登陆，还可以通过双重验证来进一步提高安全性。</p>\n<h3 id=\"AirPods-和-HomePod\"><a href=\"#AirPods-和-HomePod\" class=\"headerlink\" title=\"AirPods 和 HomePod\"></a>AirPods 和 HomePod</h3><p>iOS 13  也为  AirPods  和  HomePod  带来了新功能。现在，当使用了  SiriKit  的应用接收到消息后，AirPods  会自动为你朗读内容，并可以让你即时通过  Siri  来回复。此外，当你使用  AirPods  听音乐时，还可以通过轻触设备的方式与另一名  AirPods  使用者共享当前歌曲。这一功能同样适用于所有使用了  SiriKit  的第三方  App。 <img src=\"https://cdn.sspai.com/2019/06/05/03de73d70b55ad3dce21f9037679b0cb.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">来源：WWDC 2019 与此同时，HomePod  带来了对多用户的支持。通过对不同家庭成员声音进行分析，HomePod  可以对联系人、短信、通话等指令做出更为个性化的回答。 <img src=\"https://cdn.sspai.com/2019/06/05/0cd56e6ff049f50e08387b0ae4e880bf.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\">家庭 App</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><p>除了上文的主要更新外，iOS 13  还带来了以下变化：</p>\n<ul>\n<li>在没有 3D Touch  的手机上使用 Haptic Touch  可以获得 Context Menu 的效果；</li>\n<li>新增  Image Capture API，允许第三方  App  直接打开外接设备中的图片，无需再经过照片  App；</li>\n<li>App Store  界面调整，新增订阅服务  Arcade  界面，应用更新移动至个人页面；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/9b78b2bfbbe4750282e04308d2a43d40.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>音量调节页面更新，不再占用过多屏幕面积，并可以在屏幕上直接滑动调节；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/304d77dbcbb56f2adaa2c69acd18a12b.gif?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>图书  App  新增了每日阅读目标功能，鼓励你坚持每日读书；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/6424a62d813b25475164fd97ab2db1aa.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>音乐  App  采用了新的播放页面，并新增了歌词滚动显示功能；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/a399cd1520d79d8b9c44b9cddc311e07.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>邮件 App 可以屏蔽特定邮箱的来信，并新增了自动补全邮箱地址、改良的工具栏等功能；</li>\n<li>家庭 App 提升了对 HomeKit 配件的保护，自动化可以触发捷径。此外，苹果还推出了新的 HomeKit 监控，符合这一标准的配件将可以在不占用 iCloud 空间的情况下，通过 iCloud 发送录像内容；</li>\n<li>你可以在「设置-电话」中开启「静音未知来电」选项，减少骚扰电话的干扰；</li>\n<li>优化了充电方式，通过学习用户的充电习惯，并暂缓充电至 80% 以上，来减缓电池的老化；</li>\n<li>支持游戏时使用  PlayStation 4  和  Xbox One S  的手柄；</li>\n<li>在控制中心长按  Wi-Fi  和蓝牙图标后，可以直接选择要连接的网络  /  设备；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/c07e27a5cc9c17a907f366928b36eff8.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>可以在「设置-信息-共享姓名和照片」中设置是否在开始新对话时，发送自己的头像和姓名给对方；</li>\n<li>可以用  Memoji  为通讯录中的联系人添加头像；</li>\n<li>分享页界面得到了更新，并会根据使用习惯，建议可能的分享对象；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/2a64b8e78796656555b1f2abbea23426.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>可以在  App Store  中下载字体使用，并在设置中进行管理；</li>\n<li>截图标注页面更新，加入了直尺工具。编辑后的图片可以直接保存至文件 App；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/336939de533feafdcbb566da8ca68982.jpeg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"></p>\n<ul>\n<li>系统键盘加入了滑动输入的功能，可以通过指尖在键盘区域不间断地滑动来实现更流畅地输入，并减少误触的情况；</li>\n<li>表情成为了系统键盘的一枚独立的按键。在多个语言之间切换时，将不会再收到表情键盘的干扰；</li>\n<li>iPhone Xs、iPhone Xs Max 和 iPhone XR 增加对杜比全景声效的支持；</li>\n<li>解除了蜂窝网络环境下不能下载超过 200MB 的应用的限制；</li>\n</ul>\n<p><img src=\"https://cdn.sspai.com/2019/06/05/91a7de16e3818f8cc555e7f9857a342f.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1\"> 相比往年，苹果今年并没有放出  iOS 13  的  Developer Beta  版描述文件，并在相关界面特别提醒普通用户应等待  Public Beta。在我的体验中，iOS 13 的测试版也存在发热、卡顿等问题。如果你希望提前体验 iOS 13，不妨等待 7 月推出的 Public Beta 测试版。</p>\n"},{"title":"Web 实现前后端分离，前后端解耦","url":"281.html","id":"281","date":"2019-08-09T04:41:50.000Z","_content":"\n  \n\n（给前端大全加星标，提升前端技能）\n\n> 作者：山河远阔\n> \n> blog.csdn.net/weixin_37539378/article/details/79956760\n\n### **一、前言**\n\n”前后端分离“已经成为互联网项目开发的业界标杆，通过Tomcat+Ngnix(也可以中间有个Node.js)，有效地进行解耦。并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。\n\n前后端分离(解耦)的核心思想是：前端Html页面通过Ajax调用后端的RestFul API并使用Json数据进行交互。\n\n> 注：【在互联网架构中，web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。】\n\n一般只有Web服务器才能被外网访问，应用服务器只能内网访问。\n\n### **二、为什么前后端分离**\n\n一般公司后端开发人员直接兼顾前端的工作，一边实现API接口，一边开发页面，两者互相切换着做，而且根据不同的url动态拼接页面，这也导致后台的开发压力大大增加。前后端工作分配不均。不仅仅开发效率慢，而且代码难以维护。\n\n而前后端分离的话，则可以很好的解决前后端分工不均的问题，将更多的交互逻辑分配给前端来处理，而后端则可以专注于其本职工作，比如提供API接口，进行权限控制以及进行运算工作。而前端开发人员则可以利用nodejs来搭建自己的本地服务器，直接在本地开发，然后通过一些插件来将api请求转发到后台，这样就可以完全模拟线上的场景，并且与后台解耦。前端可以独立完成与用户交互的整一个过程，两者都可以同时开工，不互相依赖，开发效率更快，而且分工比较均衡。\n\n### **三、从MVC到前后端分离**\n\nMVC 是一种经典的设计模式，全名为 Model-View-Controller，即 模型-视图-控制器。\n\n其中，模型 是用于封装数据的载体，例如，在 Java 中一般通过一个简单的 POJO（Plain Ordinary Java Object）来表示，其本质是一个普通的 Java Bean，包含一系列的成员变量及其 getter/setter 方法。对于 视图 而言，它更加偏重于展现，也就是说，视图决定了界面到底长什么样子，在 Java 中可通过 JSP 来充当视图，或者通过纯 HTML 的方式进行展现，而后者才是目前的主流。模型和视图需要通过 控制器 来进行粘合，例如，用户发送一个 HTTP 请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。\n\n综上所述，MVC 的交互过程如下图所示：\n\n![Web 实现前后端分离，前后端解耦](https://www.v5ant.com/wp-content/uploads/2019/08/frc-f6191858287f4dbe8a6b273e2d096ec8.jpeg)\n\n也就是说，我们输入的是 AJAX 请求，输出的是 JSON 数据，市面上有这样的技术来实现这个功能吗？答案是 REST。\n\nREST 全称是 Representational State Transfer（表述性状态转移），它是 Roy Fielding 博士在 2000 年写的一篇关于软件架构风格的论文，此文一出，威震四方！国内外许多知名互联网公司纷纷开始采用这种轻量级的 Web 服务，大家习惯将其称为 RESTful Web Services，或简称 REST 服务。\n\n如果将浏览器这一端视为前端，而服务器那一端视为后端的话，可以将以上改进后的 MVC 模式简化为以下前后端分离模式：\n\n![Web 实现前后端分离，前后端解耦](https://www.v5ant.com/wp-content/uploads/2019/08/frc-bb8908b8a92cec7af6280e7188ffb2d7.jpeg)\n\n可见，有了 REST 服务，前端关注界面展现，后端关注业务逻辑，分工明确，职责清晰。\n\n### **四、认识Rest架构**\n\nREST 本质上是使用 URL 来访问资源种方式。众所周知，URL 就是我们平常使用的请求地址了，其中包括两部分：请求方式 与 请求路径，比较常见的请求方式是 GET 与 POST，但在 REST 中又提出了几种其它类型的请求方式，汇总起来有六种：GET、POST、PUT、DELETE、HEAD、OPTIONS。\n\n尤其是前四种，正好与CRUD（Create-Retrieve-Update-Delete，增删改查）四种操作相对应，例如，GET（查）、POST（增）、PUT（改）、DELETE（删），这正是 REST 与 CRUD 的异曲同工之妙！需要强调的是，REST 是“面向资源”的，这里提到的资源，实际上就是我们常说的领域对象，在系统设计过程中，我们经常通过领域对象来进行数据建模。\n\nREST 是一个“无状态”的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。也就是说，服务端将内部资源发布 REST 服务，客户端通过 URL 来访问这些资源，这不就是 SOA 所提倡的“面向服务”的思想吗？所以，REST 也被人们看做是一种“轻量级”的 SOA 实现技术，因此在企业级应用与互联网应用中都得到了广泛应用。\n\n**下面我们举几个例子对 REST 请求进行简单描述：**\n\n![Web 实现前后端分离，前后端解耦](https://www.v5ant.com/wp-content/uploads/2019/08/frc-9bac505f92672a7e1db6f349a58ad531.jpeg)\n\n可见，请求路径相同，但请求方式不同，所代表的业务操作也不同，例如，/advertiser/1 这个请求，带有 GET、PUT、DELETE 三种不同的请求方式，对应三种不同的业务操作。\n\n虽然 REST 看起来还是很简单的，实际上我们往往需要提供一个 REST 框架，让其实现前后端分离架构，让开发人员将精力集中在业务上，而并非那些具体的技术细节。\n\n### **五、前后端分离意义大吗？**\n\n1、该网站前端变化远比后端变化频繁，则意义大。\n\n2、该网站尚处于原始开发模式，数据逻辑与表现逻辑混杂不清，则意义大。\n\n3、该网站前端团队和后端团队分属两个领导班子，技能点差异很大，则意义大。\n\n4、该网站前端效果绚丽/跨设备兼容要求高，则意义大。\n\n### **六、术业有专攻（开发人员分离）**\n\n以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端（ajax/jquery/js/html/css等等），又搞后端（java/mysql/oracle等等）。\n\n随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。\n\n正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。\n\n大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。\n\n### **对于后端java工程师：**\n\n把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理等等。\n\n后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。\n\n### **对于前端工程师：**\n\n把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。\n\n前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。\n\n### **七、耦合时代**\n\n几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。\n\n大多数项目在java后端都是分了三层，控制层（controller/action），业务层（service/manage），持久层（dao）。\n\n控制层负责接收参数，调用相关业务层，封装数据，以及路由&渲染到jsp页面。\n\n然后jsp页面上使用各种标签（jstl/el/struts标签等）或者手写java表达式（<%=%>）将后台的数据展现出来，玩的是MVC那套思路。\n\n我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？\n\n你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器（tomcat/jboss/weblogic/websphere/jetty/resin）里，对吧？\n\n发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。\n\n那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？\n\n好，下面在浏览器中输入你的网站域名（www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）\n\n我捡干的说了啊，基础不好的童鞋请自己去搜。\n\n浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。\n\n那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。\n\n重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？\n\n**这就是为什么，越是大中型的web应用，他们越是要解耦。**\n\n理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。\n\n但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。\n\n如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。  \n注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期。\n\n此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？  \n还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？（引用：《架构探险-轻量级微服务架构》，黄勇）\n\n正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。  \n\n**JSP的痛点**\n\n以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。\n\n1、动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。\n\n一旦服务器出现状况，前后台一起玩完，用户体验极差。\n\n2、UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），  \n修改问题时需要双方协同开发，效率低下。\n\n3、jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），  \n性能提不上来。\n\n4、第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。\n\n5.每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。\n\n6、jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。\n\n7、如果jsp中的内容很多，页面响应会很慢，因为是同步加载。\n\n8、需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。\n\n基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！\n\n### **开发模式**\n\n**以前老的方式是：**\n\n*   产品经历/领导/客户提出需求\n    \n*   UI做出设计图\n    \n*   前端工程师做html页面\n    \n*   后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）\n    \n*   集成出现问题\n    \n*   前端返工\n    \n*   后端返工\n    \n\n二次集成\n\n集成成功\n\n交付\n\n**新的方式是：**\n\n*   产品经历/领导/客户提出需求\n    \n*   UI做出设计图\n    \n*   前后端约定接口&数据&参数\n    \n*   前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&参数不变，就不用两边都修改代码，开发效率高）\n    \n*   前后端集成\n    \n*   前端页面调整\n    \n*   集成成功\n    \n*   交付\n    \n\n### **请求方式**\n\n**以前老的方式是：**\n\n*   客户端请求\n    \n*   服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）\n    \n*   调用service,dao代码完成业务逻辑\n    \n*   返回jsp\n    \n*   jsp展现一些动态的代码\n    \n\n**新的方式是：**\n\n*   浏览器发送请求\n    \n*   直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）\n    \n*   html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）\n    \n*   填充html，展现动态效果，在页面上进行解析并操作DOM。\n    \n\n（有兴趣的童鞋可以访问一下阿里巴巴等大型网站，然后按一下F12，监控一下你刷新一次页面，他的http是怎么玩的，大多数都是单独请求后台数据，使用json传输数据，而不是一个大而全的http请求把整个页面包括动+静全部返回过来）\n\n**总结一下新的方式的请求步骤：**\n\n大量并发浏览器请求--->web服务器集群(nginx)--->应用服务器集群(tomcat)--->文件/数据库/缓存/消息队列服务器集群\n\n同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。\n\n### **前后分离的优势**\n\n1、可以实现真正的前后端解耦，前端服务器使用nginx。\n\n前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&跳转&路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。\n\n> 这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack\n\n2、发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。\n\n页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。\n\n接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。\n\n双方互不干扰，前端与后端是相亲相爱的一家人。\n\n3、在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。\n\n> 去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。\n\n4、减少后端服务器的并发/负载压力\n\n除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。\n\n且除了第一次页面请求外，浏览器会大量调用本地缓存。\n\n5、即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。\n\n6、也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）\n\n7、页面显示的东西再多也不怕，因为是异步加载。\n\n8、nginx支持页面热部署，不用重启服务器，前端升级更无缝。\n\n9、增加代码的维护性&易读性（前后端耦在一起的代码读起来相当费劲）。\n\n10、提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。\n\n11、在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），  \n内网使用http，性能和安全都有保障。\n\n12、前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！\n\n### **注意事项**\n\n1、在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，  \n推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？\n\n2、上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。\n\n3、加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。\n\n4、我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。\n\n5、如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。\n\n6、以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。\n\n7、这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？\n\n8、如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。\n\n9、对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？\n\n因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&内存&cpu等等计算资源，你要记住一点就是：服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。\n\n> 类似于数据校验这种，前后端都需要做！\n\n10、前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。\n\n**扩展阅读**\n--------\n\n1、其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，io会有很严重的性能问题），再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。\n\n2、如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。\n\n浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。\n\n3、如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。  \nJSONP的方式也被淘汰掉了。\n\n4、如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。\n\n5、前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。\n\n### **总结**\n\n前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。\n\n千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了。需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。\n\n前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。\n\n前端只需要关注页面的样式与动态数据的解析&渲染，而后端专注于具体业务逻辑。\n\n  \n\n**推荐阅读**\n\n（点击标题可跳转阅读）\n\n[通过阅读源码，提高你的 JS 水平](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556866&idx=2&sn=680dde6cb7c8c5ac56094aec3ba08f50&chksm=80255bc3b752d2d5c04036eb778b34599be1b218377632dc96fda3cc14aa82bbb6f9319841da&scene=21#wechat_redirect)  \n\n[深入理解 ESLint](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556840&idx=1&sn=37d4554cd243d4f30f53ac06f2dfe109&chksm=80255c29b752d53f34e58c1676eb4ab169605be2b1f9d58fa5855938bdc0dca68eadbe9ca5a5&scene=21#wechat_redirect)  \n\n[详解 ES 2018 新特性](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556854&idx=1&sn=4d1fc907d4844e39262c8ea559fe5a1d&chksm=80255c37b752d521ae03100d27b67d7912ffe0b5f1997f4c52a15e69bec164131cac15ea2247&scene=21#wechat_redirect)\n\n  \n\n觉得本文对你有帮助？请分享给更多人\n\n关注「前端大全」加星标，提升前端技能\n\n![Web 实现前后端分离，前后端解耦](https://www.v5ant.com/wp-content/uploads/2019/08/frc-d6041b8e6c4ba2a422c4ed4a2ce1c6f3.jpeg)\n\n好文章，我在看❤️","source":"_posts/web-e5-ae-9e-e7-8e-b0-e5-89-8d-e5-90-8e-e7-ab-af-e5-88-86-e7-a6-bb-ef-bc-8c-e5-89-8d-e5-90-8e-e7-ab-af-e8-a7-a3-e8-80-a6.md","raw":"---\ntitle: Web 实现前后端分离，前后端解耦\nurl: 281.html\nid: 281\ncategories:\n  - 大前端\ndate: 2019-08-09 12:41:50\ntags:\n---\n\n  \n\n（给前端大全加星标，提升前端技能）\n\n> 作者：山河远阔\n> \n> blog.csdn.net/weixin_37539378/article/details/79956760\n\n### **一、前言**\n\n”前后端分离“已经成为互联网项目开发的业界标杆，通过Tomcat+Ngnix(也可以中间有个Node.js)，有效地进行解耦。并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。\n\n前后端分离(解耦)的核心思想是：前端Html页面通过Ajax调用后端的RestFul API并使用Json数据进行交互。\n\n> 注：【在互联网架构中，web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。】\n\n一般只有Web服务器才能被外网访问，应用服务器只能内网访问。\n\n### **二、为什么前后端分离**\n\n一般公司后端开发人员直接兼顾前端的工作，一边实现API接口，一边开发页面，两者互相切换着做，而且根据不同的url动态拼接页面，这也导致后台的开发压力大大增加。前后端工作分配不均。不仅仅开发效率慢，而且代码难以维护。\n\n而前后端分离的话，则可以很好的解决前后端分工不均的问题，将更多的交互逻辑分配给前端来处理，而后端则可以专注于其本职工作，比如提供API接口，进行权限控制以及进行运算工作。而前端开发人员则可以利用nodejs来搭建自己的本地服务器，直接在本地开发，然后通过一些插件来将api请求转发到后台，这样就可以完全模拟线上的场景，并且与后台解耦。前端可以独立完成与用户交互的整一个过程，两者都可以同时开工，不互相依赖，开发效率更快，而且分工比较均衡。\n\n### **三、从MVC到前后端分离**\n\nMVC 是一种经典的设计模式，全名为 Model-View-Controller，即 模型-视图-控制器。\n\n其中，模型 是用于封装数据的载体，例如，在 Java 中一般通过一个简单的 POJO（Plain Ordinary Java Object）来表示，其本质是一个普通的 Java Bean，包含一系列的成员变量及其 getter/setter 方法。对于 视图 而言，它更加偏重于展现，也就是说，视图决定了界面到底长什么样子，在 Java 中可通过 JSP 来充当视图，或者通过纯 HTML 的方式进行展现，而后者才是目前的主流。模型和视图需要通过 控制器 来进行粘合，例如，用户发送一个 HTTP 请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。\n\n综上所述，MVC 的交互过程如下图所示：\n\n![Web 实现前后端分离，前后端解耦](https://www.v5ant.com/wp-content/uploads/2019/08/frc-f6191858287f4dbe8a6b273e2d096ec8.jpeg)\n\n也就是说，我们输入的是 AJAX 请求，输出的是 JSON 数据，市面上有这样的技术来实现这个功能吗？答案是 REST。\n\nREST 全称是 Representational State Transfer（表述性状态转移），它是 Roy Fielding 博士在 2000 年写的一篇关于软件架构风格的论文，此文一出，威震四方！国内外许多知名互联网公司纷纷开始采用这种轻量级的 Web 服务，大家习惯将其称为 RESTful Web Services，或简称 REST 服务。\n\n如果将浏览器这一端视为前端，而服务器那一端视为后端的话，可以将以上改进后的 MVC 模式简化为以下前后端分离模式：\n\n![Web 实现前后端分离，前后端解耦](https://www.v5ant.com/wp-content/uploads/2019/08/frc-bb8908b8a92cec7af6280e7188ffb2d7.jpeg)\n\n可见，有了 REST 服务，前端关注界面展现，后端关注业务逻辑，分工明确，职责清晰。\n\n### **四、认识Rest架构**\n\nREST 本质上是使用 URL 来访问资源种方式。众所周知，URL 就是我们平常使用的请求地址了，其中包括两部分：请求方式 与 请求路径，比较常见的请求方式是 GET 与 POST，但在 REST 中又提出了几种其它类型的请求方式，汇总起来有六种：GET、POST、PUT、DELETE、HEAD、OPTIONS。\n\n尤其是前四种，正好与CRUD（Create-Retrieve-Update-Delete，增删改查）四种操作相对应，例如，GET（查）、POST（增）、PUT（改）、DELETE（删），这正是 REST 与 CRUD 的异曲同工之妙！需要强调的是，REST 是“面向资源”的，这里提到的资源，实际上就是我们常说的领域对象，在系统设计过程中，我们经常通过领域对象来进行数据建模。\n\nREST 是一个“无状态”的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。也就是说，服务端将内部资源发布 REST 服务，客户端通过 URL 来访问这些资源，这不就是 SOA 所提倡的“面向服务”的思想吗？所以，REST 也被人们看做是一种“轻量级”的 SOA 实现技术，因此在企业级应用与互联网应用中都得到了广泛应用。\n\n**下面我们举几个例子对 REST 请求进行简单描述：**\n\n![Web 实现前后端分离，前后端解耦](https://www.v5ant.com/wp-content/uploads/2019/08/frc-9bac505f92672a7e1db6f349a58ad531.jpeg)\n\n可见，请求路径相同，但请求方式不同，所代表的业务操作也不同，例如，/advertiser/1 这个请求，带有 GET、PUT、DELETE 三种不同的请求方式，对应三种不同的业务操作。\n\n虽然 REST 看起来还是很简单的，实际上我们往往需要提供一个 REST 框架，让其实现前后端分离架构，让开发人员将精力集中在业务上，而并非那些具体的技术细节。\n\n### **五、前后端分离意义大吗？**\n\n1、该网站前端变化远比后端变化频繁，则意义大。\n\n2、该网站尚处于原始开发模式，数据逻辑与表现逻辑混杂不清，则意义大。\n\n3、该网站前端团队和后端团队分属两个领导班子，技能点差异很大，则意义大。\n\n4、该网站前端效果绚丽/跨设备兼容要求高，则意义大。\n\n### **六、术业有专攻（开发人员分离）**\n\n以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端（ajax/jquery/js/html/css等等），又搞后端（java/mysql/oracle等等）。\n\n随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。\n\n正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。\n\n大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。\n\n### **对于后端java工程师：**\n\n把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理等等。\n\n后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。\n\n### **对于前端工程师：**\n\n把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。\n\n前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。\n\n### **七、耦合时代**\n\n几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。\n\n大多数项目在java后端都是分了三层，控制层（controller/action），业务层（service/manage），持久层（dao）。\n\n控制层负责接收参数，调用相关业务层，封装数据，以及路由&渲染到jsp页面。\n\n然后jsp页面上使用各种标签（jstl/el/struts标签等）或者手写java表达式（<%=%>）将后台的数据展现出来，玩的是MVC那套思路。\n\n我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？\n\n你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器（tomcat/jboss/weblogic/websphere/jetty/resin）里，对吧？\n\n发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。\n\n那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？\n\n好，下面在浏览器中输入你的网站域名（www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）\n\n我捡干的说了啊，基础不好的童鞋请自己去搜。\n\n浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。\n\n那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。\n\n重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？\n\n**这就是为什么，越是大中型的web应用，他们越是要解耦。**\n\n理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。\n\n但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。\n\n如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。  \n注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期。\n\n此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？  \n还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？（引用：《架构探险-轻量级微服务架构》，黄勇）\n\n正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。  \n\n**JSP的痛点**\n\n以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。\n\n1、动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。\n\n一旦服务器出现状况，前后台一起玩完，用户体验极差。\n\n2、UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），  \n修改问题时需要双方协同开发，效率低下。\n\n3、jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），  \n性能提不上来。\n\n4、第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。\n\n5.每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。\n\n6、jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。\n\n7、如果jsp中的内容很多，页面响应会很慢，因为是同步加载。\n\n8、需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。\n\n基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！\n\n### **开发模式**\n\n**以前老的方式是：**\n\n*   产品经历/领导/客户提出需求\n    \n*   UI做出设计图\n    \n*   前端工程师做html页面\n    \n*   后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）\n    \n*   集成出现问题\n    \n*   前端返工\n    \n*   后端返工\n    \n\n二次集成\n\n集成成功\n\n交付\n\n**新的方式是：**\n\n*   产品经历/领导/客户提出需求\n    \n*   UI做出设计图\n    \n*   前后端约定接口&数据&参数\n    \n*   前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&参数不变，就不用两边都修改代码，开发效率高）\n    \n*   前后端集成\n    \n*   前端页面调整\n    \n*   集成成功\n    \n*   交付\n    \n\n### **请求方式**\n\n**以前老的方式是：**\n\n*   客户端请求\n    \n*   服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）\n    \n*   调用service,dao代码完成业务逻辑\n    \n*   返回jsp\n    \n*   jsp展现一些动态的代码\n    \n\n**新的方式是：**\n\n*   浏览器发送请求\n    \n*   直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）\n    \n*   html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）\n    \n*   填充html，展现动态效果，在页面上进行解析并操作DOM。\n    \n\n（有兴趣的童鞋可以访问一下阿里巴巴等大型网站，然后按一下F12，监控一下你刷新一次页面，他的http是怎么玩的，大多数都是单独请求后台数据，使用json传输数据，而不是一个大而全的http请求把整个页面包括动+静全部返回过来）\n\n**总结一下新的方式的请求步骤：**\n\n大量并发浏览器请求--->web服务器集群(nginx)--->应用服务器集群(tomcat)--->文件/数据库/缓存/消息队列服务器集群\n\n同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。\n\n### **前后分离的优势**\n\n1、可以实现真正的前后端解耦，前端服务器使用nginx。\n\n前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&跳转&路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。\n\n> 这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack\n\n2、发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。\n\n页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。\n\n接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。\n\n双方互不干扰，前端与后端是相亲相爱的一家人。\n\n3、在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。\n\n> 去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。\n\n4、减少后端服务器的并发/负载压力\n\n除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。\n\n且除了第一次页面请求外，浏览器会大量调用本地缓存。\n\n5、即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。\n\n6、也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）\n\n7、页面显示的东西再多也不怕，因为是异步加载。\n\n8、nginx支持页面热部署，不用重启服务器，前端升级更无缝。\n\n9、增加代码的维护性&易读性（前后端耦在一起的代码读起来相当费劲）。\n\n10、提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。\n\n11、在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），  \n内网使用http，性能和安全都有保障。\n\n12、前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！\n\n### **注意事项**\n\n1、在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，  \n推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？\n\n2、上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。\n\n3、加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。\n\n4、我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。\n\n5、如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。\n\n6、以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。\n\n7、这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？\n\n8、如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。\n\n9、对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？\n\n因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&内存&cpu等等计算资源，你要记住一点就是：服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。\n\n> 类似于数据校验这种，前后端都需要做！\n\n10、前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。\n\n**扩展阅读**\n--------\n\n1、其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，io会有很严重的性能问题），再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。\n\n2、如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。\n\n浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。\n\n3、如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。  \nJSONP的方式也被淘汰掉了。\n\n4、如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。\n\n5、前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。\n\n### **总结**\n\n前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。\n\n千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了。需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。\n\n前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。\n\n前端只需要关注页面的样式与动态数据的解析&渲染，而后端专注于具体业务逻辑。\n\n  \n\n**推荐阅读**\n\n（点击标题可跳转阅读）\n\n[通过阅读源码，提高你的 JS 水平](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556866&idx=2&sn=680dde6cb7c8c5ac56094aec3ba08f50&chksm=80255bc3b752d2d5c04036eb778b34599be1b218377632dc96fda3cc14aa82bbb6f9319841da&scene=21#wechat_redirect)  \n\n[深入理解 ESLint](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556840&idx=1&sn=37d4554cd243d4f30f53ac06f2dfe109&chksm=80255c29b752d53f34e58c1676eb4ab169605be2b1f9d58fa5855938bdc0dca68eadbe9ca5a5&scene=21#wechat_redirect)  \n\n[详解 ES 2018 新特性](http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556854&idx=1&sn=4d1fc907d4844e39262c8ea559fe5a1d&chksm=80255c37b752d521ae03100d27b67d7912ffe0b5f1997f4c52a15e69bec164131cac15ea2247&scene=21#wechat_redirect)\n\n  \n\n觉得本文对你有帮助？请分享给更多人\n\n关注「前端大全」加星标，提升前端技能\n\n![Web 实现前后端分离，前后端解耦](https://www.v5ant.com/wp-content/uploads/2019/08/frc-d6041b8e6c4ba2a422c4ed4a2ce1c6f3.jpeg)\n\n好文章，我在看❤️","slug":"web-e5-ae-9e-e7-8e-b0-e5-89-8d-e5-90-8e-e7-ab-af-e5-88-86-e7-a6-bb-ef-bc-8c-e5-89-8d-e5-90-8e-e7-ab-af-e8-a7-a3-e8-80-a6","published":1,"updated":"2019-09-10T07:46:08.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269gi005lc8gs79059zar","content":"<p>（给前端大全加星标，提升前端技能）</p>\n<blockquote>\n<p>作者：山河远阔</p>\n<p>blog.csdn.net/weixin_37539378/article/details/79956760</p>\n</blockquote>\n<h3 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a><strong>一、前言</strong></h3><p>”前后端分离“已经成为互联网项目开发的业界标杆，通过Tomcat+Ngnix(也可以中间有个Node.js)，有效地进行解耦。并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。</p>\n<p>前后端分离(解耦)的核心思想是：前端Html页面通过Ajax调用后端的RestFul API并使用Json数据进行交互。</p>\n<blockquote>\n<p>注：【在互联网架构中，web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。】</p>\n</blockquote>\n<p>一般只有Web服务器才能被外网访问，应用服务器只能内网访问。</p>\n<h3 id=\"二、为什么前后端分离\"><a href=\"#二、为什么前后端分离\" class=\"headerlink\" title=\"二、为什么前后端分离\"></a><strong>二、为什么前后端分离</strong></h3><p>一般公司后端开发人员直接兼顾前端的工作，一边实现API接口，一边开发页面，两者互相切换着做，而且根据不同的url动态拼接页面，这也导致后台的开发压力大大增加。前后端工作分配不均。不仅仅开发效率慢，而且代码难以维护。</p>\n<p>而前后端分离的话，则可以很好的解决前后端分工不均的问题，将更多的交互逻辑分配给前端来处理，而后端则可以专注于其本职工作，比如提供API接口，进行权限控制以及进行运算工作。而前端开发人员则可以利用nodejs来搭建自己的本地服务器，直接在本地开发，然后通过一些插件来将api请求转发到后台，这样就可以完全模拟线上的场景，并且与后台解耦。前端可以独立完成与用户交互的整一个过程，两者都可以同时开工，不互相依赖，开发效率更快，而且分工比较均衡。</p>\n<h3 id=\"三、从MVC到前后端分离\"><a href=\"#三、从MVC到前后端分离\" class=\"headerlink\" title=\"三、从MVC到前后端分离\"></a><strong>三、从MVC到前后端分离</strong></h3><p>MVC 是一种经典的设计模式，全名为 Model-View-Controller，即 模型-视图-控制器。</p>\n<p>其中，模型 是用于封装数据的载体，例如，在 Java 中一般通过一个简单的 POJO（Plain Ordinary Java Object）来表示，其本质是一个普通的 Java Bean，包含一系列的成员变量及其 getter/setter 方法。对于 视图 而言，它更加偏重于展现，也就是说，视图决定了界面到底长什么样子，在 Java 中可通过 JSP 来充当视图，或者通过纯 HTML 的方式进行展现，而后者才是目前的主流。模型和视图需要通过 控制器 来进行粘合，例如，用户发送一个 HTTP 请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。</p>\n<p>综上所述，MVC 的交互过程如下图所示：</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-f6191858287f4dbe8a6b273e2d096ec8.jpeg\" alt=\"Web 实现前后端分离，前后端解耦\"></p>\n<p>也就是说，我们输入的是 AJAX 请求，输出的是 JSON 数据，市面上有这样的技术来实现这个功能吗？答案是 REST。</p>\n<p>REST 全称是 Representational State Transfer（表述性状态转移），它是 Roy Fielding 博士在 2000 年写的一篇关于软件架构风格的论文，此文一出，威震四方！国内外许多知名互联网公司纷纷开始采用这种轻量级的 Web 服务，大家习惯将其称为 RESTful Web Services，或简称 REST 服务。</p>\n<p>如果将浏览器这一端视为前端，而服务器那一端视为后端的话，可以将以上改进后的 MVC 模式简化为以下前后端分离模式：</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-bb8908b8a92cec7af6280e7188ffb2d7.jpeg\" alt=\"Web 实现前后端分离，前后端解耦\"></p>\n<p>可见，有了 REST 服务，前端关注界面展现，后端关注业务逻辑，分工明确，职责清晰。</p>\n<h3 id=\"四、认识Rest架构\"><a href=\"#四、认识Rest架构\" class=\"headerlink\" title=\"四、认识Rest架构\"></a><strong>四、认识Rest架构</strong></h3><p>REST 本质上是使用 URL 来访问资源种方式。众所周知，URL 就是我们平常使用的请求地址了，其中包括两部分：请求方式 与 请求路径，比较常见的请求方式是 GET 与 POST，但在 REST 中又提出了几种其它类型的请求方式，汇总起来有六种：GET、POST、PUT、DELETE、HEAD、OPTIONS。</p>\n<p>尤其是前四种，正好与CRUD（Create-Retrieve-Update-Delete，增删改查）四种操作相对应，例如，GET（查）、POST（增）、PUT（改）、DELETE（删），这正是 REST 与 CRUD 的异曲同工之妙！需要强调的是，REST 是“面向资源”的，这里提到的资源，实际上就是我们常说的领域对象，在系统设计过程中，我们经常通过领域对象来进行数据建模。</p>\n<p>REST 是一个“无状态”的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。也就是说，服务端将内部资源发布 REST 服务，客户端通过 URL 来访问这些资源，这不就是 SOA 所提倡的“面向服务”的思想吗？所以，REST 也被人们看做是一种“轻量级”的 SOA 实现技术，因此在企业级应用与互联网应用中都得到了广泛应用。</p>\n<p><strong>下面我们举几个例子对 REST 请求进行简单描述：</strong></p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-9bac505f92672a7e1db6f349a58ad531.jpeg\" alt=\"Web 实现前后端分离，前后端解耦\"></p>\n<p>可见，请求路径相同，但请求方式不同，所代表的业务操作也不同，例如，/advertiser/1 这个请求，带有 GET、PUT、DELETE 三种不同的请求方式，对应三种不同的业务操作。</p>\n<p>虽然 REST 看起来还是很简单的，实际上我们往往需要提供一个 REST 框架，让其实现前后端分离架构，让开发人员将精力集中在业务上，而并非那些具体的技术细节。</p>\n<h3 id=\"五、前后端分离意义大吗？\"><a href=\"#五、前后端分离意义大吗？\" class=\"headerlink\" title=\"五、前后端分离意义大吗？\"></a><strong>五、前后端分离意义大吗？</strong></h3><p>1、该网站前端变化远比后端变化频繁，则意义大。</p>\n<p>2、该网站尚处于原始开发模式，数据逻辑与表现逻辑混杂不清，则意义大。</p>\n<p>3、该网站前端团队和后端团队分属两个领导班子，技能点差异很大，则意义大。</p>\n<p>4、该网站前端效果绚丽/跨设备兼容要求高，则意义大。</p>\n<h3 id=\"六、术业有专攻（开发人员分离）\"><a href=\"#六、术业有专攻（开发人员分离）\" class=\"headerlink\" title=\"六、术业有专攻（开发人员分离）\"></a><strong>六、术业有专攻（开发人员分离）</strong></h3><p>以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端（ajax/jquery/js/html/css等等），又搞后端（java/mysql/oracle等等）。</p>\n<p>随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。</p>\n<p>正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。</p>\n<p>大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。</p>\n<h3 id=\"对于后端java工程师：\"><a href=\"#对于后端java工程师：\" class=\"headerlink\" title=\"对于后端java工程师：\"></a><strong>对于后端java工程师：</strong></h3><p>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理等等。</p>\n<p>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。</p>\n<h3 id=\"对于前端工程师：\"><a href=\"#对于前端工程师：\" class=\"headerlink\" title=\"对于前端工程师：\"></a><strong>对于前端工程师：</strong></h3><p>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。</p>\n<p>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</p>\n<h3 id=\"七、耦合时代\"><a href=\"#七、耦合时代\" class=\"headerlink\" title=\"七、耦合时代\"></a><strong>七、耦合时代</strong></h3><p>几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。</p>\n<p>大多数项目在java后端都是分了三层，控制层（controller/action），业务层（service/manage），持久层（dao）。</p>\n<p>控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;渲染到jsp页面。</p>\n<p>然后jsp页面上使用各种标签（jstl/el/struts标签等）或者手写java表达式（&lt;%=%&gt;）将后台的数据展现出来，玩的是MVC那套思路。</p>\n<p>我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？</p>\n<p>你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器（tomcat/jboss/weblogic/websphere/jetty/resin）里，对吧？</p>\n<p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。</p>\n<p>那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？</p>\n<p>好，下面在浏览器中输入你的网站域名（<a href=\"http://www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）\">www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）</a></p>\n<p>我捡干的说了啊，基础不好的童鞋请自己去搜。</p>\n<p>浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。</p>\n<p>那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。</p>\n<p>重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？</p>\n<p><strong>这就是为什么，越是大中型的web应用，他们越是要解耦。</strong></p>\n<p>理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。</p>\n<p>但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。</p>\n<p>如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。<br>注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期。</p>\n<p>此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？<br>还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？（引用：《架构探险-轻量级微服务架构》，黄勇）</p>\n<p>正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。  </p>\n<p><strong>JSP的痛点</strong></p>\n<p>以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。</p>\n<p>1、动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。</p>\n<p>一旦服务器出现状况，前后台一起玩完，用户体验极差。</p>\n<p>2、UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），<br>修改问题时需要双方协同开发，效率低下。</p>\n<p>3、jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），<br>性能提不上来。</p>\n<p>4、第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。</p>\n<p>5.每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。</p>\n<p>6、jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。</p>\n<p>7、如果jsp中的内容很多，页面响应会很慢，因为是同步加载。</p>\n<p>8、需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。</p>\n<p>基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！</p>\n<h3 id=\"开发模式\"><a href=\"#开发模式\" class=\"headerlink\" title=\"开发模式\"></a><strong>开发模式</strong></h3><p><strong>以前老的方式是：</strong></p>\n<ul>\n<li>产品经历/领导/客户提出需求</li>\n<li>UI做出设计图</li>\n<li>前端工程师做html页面</li>\n<li>后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）</li>\n<li>集成出现问题</li>\n<li>前端返工</li>\n<li>后端返工</li>\n</ul>\n<p>二次集成</p>\n<p>集成成功</p>\n<p>交付</p>\n<p><strong>新的方式是：</strong></p>\n<ul>\n<li>产品经历/领导/客户提出需求</li>\n<li>UI做出设计图</li>\n<li>前后端约定接口&amp;数据&amp;参数</li>\n<li>前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高）</li>\n<li>前后端集成</li>\n<li>前端页面调整</li>\n<li>集成成功</li>\n<li>交付</li>\n</ul>\n<h3 id=\"请求方式\"><a href=\"#请求方式\" class=\"headerlink\" title=\"请求方式\"></a><strong>请求方式</strong></h3><p><strong>以前老的方式是：</strong></p>\n<ul>\n<li>客户端请求</li>\n<li>服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）</li>\n<li>调用service,dao代码完成业务逻辑</li>\n<li>返回jsp</li>\n<li>jsp展现一些动态的代码</li>\n</ul>\n<p><strong>新的方式是：</strong></p>\n<ul>\n<li>浏览器发送请求</li>\n<li>直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）</li>\n<li>html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）</li>\n<li>填充html，展现动态效果，在页面上进行解析并操作DOM。</li>\n</ul>\n<p>（有兴趣的童鞋可以访问一下阿里巴巴等大型网站，然后按一下F12，监控一下你刷新一次页面，他的http是怎么玩的，大多数都是单独请求后台数据，使用json传输数据，而不是一个大而全的http请求把整个页面包括动+静全部返回过来）</p>\n<p><strong>总结一下新的方式的请求步骤：</strong></p>\n<p>大量并发浏览器请求—&gt;web服务器集群(nginx)—&gt;应用服务器集群(tomcat)—&gt;文件/数据库/缓存/消息队列服务器集群</p>\n<p>同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。</p>\n<h3 id=\"前后分离的优势\"><a href=\"#前后分离的优势\" class=\"headerlink\" title=\"前后分离的优势\"></a><strong>前后分离的优势</strong></h3><p>1、可以实现真正的前后端解耦，前端服务器使用nginx。</p>\n<p>前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。</p>\n<blockquote>\n<p>这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack</p>\n</blockquote>\n<p>2、发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。</p>\n<p>页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。</p>\n<p>接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。</p>\n<p>双方互不干扰，前端与后端是相亲相爱的一家人。</p>\n<p>3、在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。</p>\n<blockquote>\n<p>去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。</p>\n</blockquote>\n<p>4、减少后端服务器的并发/负载压力</p>\n<p>除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。</p>\n<p>且除了第一次页面请求外，浏览器会大量调用本地缓存。</p>\n<p>5、即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。</p>\n<p>6、也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）</p>\n<p>7、页面显示的东西再多也不怕，因为是异步加载。</p>\n<p>8、nginx支持页面热部署，不用重启服务器，前端升级更无缝。</p>\n<p>9、增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。</p>\n<p>10、提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。</p>\n<p>11、在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），<br>内网使用http，性能和安全都有保障。</p>\n<p>12、前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a><strong>注意事项</strong></h3><p>1、在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，<br>推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？</p>\n<p>2、上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。</p>\n<p>3、加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。</p>\n<p>4、我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。</p>\n<p>5、如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。</p>\n<p>6、以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。</p>\n<p>7、这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？</p>\n<p>8、如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。</p>\n<p>9、对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？</p>\n<p>因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是：服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。</p>\n<blockquote>\n<p>类似于数据校验这种，前后端都需要做！</p>\n</blockquote>\n<p>10、前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a><strong>扩展阅读</strong></h2><p>1、其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&amp;操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，io会有很严重的性能问题），再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。</p>\n<p>2、如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。</p>\n<p>浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。</p>\n<p>3、如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。<br>JSONP的方式也被淘汰掉了。</p>\n<p>4、如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。</p>\n<p>5、前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。</p>\n<p>千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了。需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。</p>\n<p>前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。</p>\n<p>前端只需要关注页面的样式与动态数据的解析&amp;渲染，而后端专注于具体业务逻辑。</p>\n<p><strong>推荐阅读</strong></p>\n<p>（点击标题可跳转阅读）</p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556866&idx=2&sn=680dde6cb7c8c5ac56094aec3ba08f50&chksm=80255bc3b752d2d5c04036eb778b34599be1b218377632dc96fda3cc14aa82bbb6f9319841da&scene=21#wechat_redirect\">通过阅读源码，提高你的 JS 水平</a>  </p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556840&idx=1&sn=37d4554cd243d4f30f53ac06f2dfe109&chksm=80255c29b752d53f34e58c1676eb4ab169605be2b1f9d58fa5855938bdc0dca68eadbe9ca5a5&scene=21#wechat_redirect\">深入理解 ESLint</a>  </p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556854&idx=1&sn=4d1fc907d4844e39262c8ea559fe5a1d&chksm=80255c37b752d521ae03100d27b67d7912ffe0b5f1997f4c52a15e69bec164131cac15ea2247&scene=21#wechat_redirect\">详解 ES 2018 新特性</a></p>\n<p>觉得本文对你有帮助？请分享给更多人</p>\n<p>关注「前端大全」加星标，提升前端技能</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-d6041b8e6c4ba2a422c4ed4a2ce1c6f3.jpeg\" alt=\"Web 实现前后端分离，前后端解耦\"></p>\n<p>好文章，我在看❤️</p>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<p>（给前端大全加星标，提升前端技能）</p>\n<blockquote>\n<p>作者：山河远阔</p>\n<p>blog.csdn.net/weixin_37539378/article/details/79956760</p>\n</blockquote>\n<h3 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a><strong>一、前言</strong></h3><p>”前后端分离“已经成为互联网项目开发的业界标杆，通过Tomcat+Ngnix(也可以中间有个Node.js)，有效地进行解耦。并且前后端分离会为以后的大型分布式架构、弹性计算架构、微服务架构、多端化服务（多种客户端，例如：浏览器，车载终端，安卓，IOS等等）打下坚实的基础。</p>\n<p>前后端分离(解耦)的核心思想是：前端Html页面通过Ajax调用后端的RestFul API并使用Json数据进行交互。</p>\n<blockquote>\n<p>注：【在互联网架构中，web服务器：一般指像nginx，apache这类的服务器，他们一般只能解析静态资源。应用服务器：一般指像tomcat，jetty，resin这类的服务器可以解析动态资源也可以解析静态资源，但解析静态资源的能力没有web服务器好。】</p>\n</blockquote>\n<p>一般只有Web服务器才能被外网访问，应用服务器只能内网访问。</p>\n<h3 id=\"二、为什么前后端分离\"><a href=\"#二、为什么前后端分离\" class=\"headerlink\" title=\"二、为什么前后端分离\"></a><strong>二、为什么前后端分离</strong></h3><p>一般公司后端开发人员直接兼顾前端的工作，一边实现API接口，一边开发页面，两者互相切换着做，而且根据不同的url动态拼接页面，这也导致后台的开发压力大大增加。前后端工作分配不均。不仅仅开发效率慢，而且代码难以维护。</p>\n<p>而前后端分离的话，则可以很好的解决前后端分工不均的问题，将更多的交互逻辑分配给前端来处理，而后端则可以专注于其本职工作，比如提供API接口，进行权限控制以及进行运算工作。而前端开发人员则可以利用nodejs来搭建自己的本地服务器，直接在本地开发，然后通过一些插件来将api请求转发到后台，这样就可以完全模拟线上的场景，并且与后台解耦。前端可以独立完成与用户交互的整一个过程，两者都可以同时开工，不互相依赖，开发效率更快，而且分工比较均衡。</p>\n<h3 id=\"三、从MVC到前后端分离\"><a href=\"#三、从MVC到前后端分离\" class=\"headerlink\" title=\"三、从MVC到前后端分离\"></a><strong>三、从MVC到前后端分离</strong></h3><p>MVC 是一种经典的设计模式，全名为 Model-View-Controller，即 模型-视图-控制器。</p>\n<p>其中，模型 是用于封装数据的载体，例如，在 Java 中一般通过一个简单的 POJO（Plain Ordinary Java Object）来表示，其本质是一个普通的 Java Bean，包含一系列的成员变量及其 getter/setter 方法。对于 视图 而言，它更加偏重于展现，也就是说，视图决定了界面到底长什么样子，在 Java 中可通过 JSP 来充当视图，或者通过纯 HTML 的方式进行展现，而后者才是目前的主流。模型和视图需要通过 控制器 来进行粘合，例如，用户发送一个 HTTP 请求，此时该请求首先会进入控制器，然后控制器去获取数据并将其封装为模型，最后将模型传递到视图中进行展现。</p>\n<p>综上所述，MVC 的交互过程如下图所示：</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-f6191858287f4dbe8a6b273e2d096ec8.jpeg\" alt=\"Web 实现前后端分离，前后端解耦\"></p>\n<p>也就是说，我们输入的是 AJAX 请求，输出的是 JSON 数据，市面上有这样的技术来实现这个功能吗？答案是 REST。</p>\n<p>REST 全称是 Representational State Transfer（表述性状态转移），它是 Roy Fielding 博士在 2000 年写的一篇关于软件架构风格的论文，此文一出，威震四方！国内外许多知名互联网公司纷纷开始采用这种轻量级的 Web 服务，大家习惯将其称为 RESTful Web Services，或简称 REST 服务。</p>\n<p>如果将浏览器这一端视为前端，而服务器那一端视为后端的话，可以将以上改进后的 MVC 模式简化为以下前后端分离模式：</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-bb8908b8a92cec7af6280e7188ffb2d7.jpeg\" alt=\"Web 实现前后端分离，前后端解耦\"></p>\n<p>可见，有了 REST 服务，前端关注界面展现，后端关注业务逻辑，分工明确，职责清晰。</p>\n<h3 id=\"四、认识Rest架构\"><a href=\"#四、认识Rest架构\" class=\"headerlink\" title=\"四、认识Rest架构\"></a><strong>四、认识Rest架构</strong></h3><p>REST 本质上是使用 URL 来访问资源种方式。众所周知，URL 就是我们平常使用的请求地址了，其中包括两部分：请求方式 与 请求路径，比较常见的请求方式是 GET 与 POST，但在 REST 中又提出了几种其它类型的请求方式，汇总起来有六种：GET、POST、PUT、DELETE、HEAD、OPTIONS。</p>\n<p>尤其是前四种，正好与CRUD（Create-Retrieve-Update-Delete，增删改查）四种操作相对应，例如，GET（查）、POST（增）、PUT（改）、DELETE（删），这正是 REST 与 CRUD 的异曲同工之妙！需要强调的是，REST 是“面向资源”的，这里提到的资源，实际上就是我们常说的领域对象，在系统设计过程中，我们经常通过领域对象来进行数据建模。</p>\n<p>REST 是一个“无状态”的架构模式，因为在任何时候都可以由客户端发出请求到服务端，最终返回自己想要的数据，当前请求不会受到上次请求的影响。也就是说，服务端将内部资源发布 REST 服务，客户端通过 URL 来访问这些资源，这不就是 SOA 所提倡的“面向服务”的思想吗？所以，REST 也被人们看做是一种“轻量级”的 SOA 实现技术，因此在企业级应用与互联网应用中都得到了广泛应用。</p>\n<p><strong>下面我们举几个例子对 REST 请求进行简单描述：</strong></p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-9bac505f92672a7e1db6f349a58ad531.jpeg\" alt=\"Web 实现前后端分离，前后端解耦\"></p>\n<p>可见，请求路径相同，但请求方式不同，所代表的业务操作也不同，例如，/advertiser/1 这个请求，带有 GET、PUT、DELETE 三种不同的请求方式，对应三种不同的业务操作。</p>\n<p>虽然 REST 看起来还是很简单的，实际上我们往往需要提供一个 REST 框架，让其实现前后端分离架构，让开发人员将精力集中在业务上，而并非那些具体的技术细节。</p>\n<h3 id=\"五、前后端分离意义大吗？\"><a href=\"#五、前后端分离意义大吗？\" class=\"headerlink\" title=\"五、前后端分离意义大吗？\"></a><strong>五、前后端分离意义大吗？</strong></h3><p>1、该网站前端变化远比后端变化频繁，则意义大。</p>\n<p>2、该网站尚处于原始开发模式，数据逻辑与表现逻辑混杂不清，则意义大。</p>\n<p>3、该网站前端团队和后端团队分属两个领导班子，技能点差异很大，则意义大。</p>\n<p>4、该网站前端效果绚丽/跨设备兼容要求高，则意义大。</p>\n<h3 id=\"六、术业有专攻（开发人员分离）\"><a href=\"#六、术业有专攻（开发人员分离）\" class=\"headerlink\" title=\"六、术业有专攻（开发人员分离）\"></a><strong>六、术业有专攻（开发人员分离）</strong></h3><p>以前的JavaWeb项目大多数都是java程序员又当爹又当妈，又搞前端（ajax/jquery/js/html/css等等），又搞后端（java/mysql/oracle等等）。</p>\n<p>随着时代的发展，渐渐的许多大中小公司开始把前后端的界限分的越来越明确，前端工程师只管前端的事情，后端工程师只管后端的事情。</p>\n<p>正所谓术业有专攻，一个人如果什么都会，那么他毕竟什么都不精。</p>\n<p>大中型公司需要专业人才，小公司需要全才，但是对于个人职业发展来说，我建议是分开。</p>\n<h3 id=\"对于后端java工程师：\"><a href=\"#对于后端java工程师：\" class=\"headerlink\" title=\"对于后端java工程师：\"></a><strong>对于后端java工程师：</strong></h3><p>把精力放在java基础，设计模式，jvm原理，spring+springmvc原理及源码，linux，mysql事务隔离与锁机制，mongodb，http/tcp，多线程，分布式架构（dubbo，dubbox，spring cloud），弹性计算架构，微服务架构（springboot+zookeeper+docker+jenkins），java性能优化，以及相关的项目管理等等。</p>\n<p>后端追求的是：三高（高并发，高可用，高性能），安全，存储，业务等等。</p>\n<h3 id=\"对于前端工程师：\"><a href=\"#对于前端工程师：\" class=\"headerlink\" title=\"对于前端工程师：\"></a><strong>对于前端工程师：</strong></h3><p>把精力放在html5，css3，jquery，angularjs，bootstrap，reactjs，vuejs，webpack，less/sass，gulp，nodejs，Google V8引擎，javascript多线程，模块化，面向切面编程，设计模式，浏览器兼容性，性能优化等等。</p>\n<p>前端追求的是：页面表现，速度流畅，兼容性，用户体验等等。</p>\n<h3 id=\"七、耦合时代\"><a href=\"#七、耦合时代\" class=\"headerlink\" title=\"七、耦合时代\"></a><strong>七、耦合时代</strong></h3><p>几曾何时，我们的JavaWeb项目都是使用了若干后台框架，springmvc/struts + spring + spring jdbc/hibernate/mybatis 等等。</p>\n<p>大多数项目在java后端都是分了三层，控制层（controller/action），业务层（service/manage），持久层（dao）。</p>\n<p>控制层负责接收参数，调用相关业务层，封装数据，以及路由&amp;渲染到jsp页面。</p>\n<p>然后jsp页面上使用各种标签（jstl/el/struts标签等）或者手写java表达式（&lt;%=%&gt;）将后台的数据展现出来，玩的是MVC那套思路。</p>\n<p>我们先看这种情况：需求定完了，代码写完了，测试测完了，然后呢？要发布了吧？</p>\n<p>你需要用maven或者eclipse等工具把你的代码打成一个war包，然后把这个war包发布到你的生产环境下的web容器（tomcat/jboss/weblogic/websphere/jetty/resin）里，对吧？</p>\n<p>发布完了之后，你要启动你的web容器，开始提供服务，这时候你通过配置域名，dns等等相关，你的网站就可以访问了（假设你是个网站）。</p>\n<p>那我们来看，你的前后端代码是不是全都在那个war包里？包括你的js，css，图片，各种第三方的库，对吧？</p>\n<p>好，下面在浏览器中输入你的网站域名（<a href=\"http://www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）\">www.xxx.com），之后发生了什么？（这个问题也是很多公司的面试题）</a></p>\n<p>我捡干的说了啊，基础不好的童鞋请自己去搜。</p>\n<p>浏览器在通过域名通过dns服务器找到你的服务器外网ip,将http请求发送到你的服务器，在tcp3次握手之后（http下面是tcp/ip），通过tcp协议开始传输数据，你的服务器得到请求后，开始提供服务，接收参数，之后返回你的应答给浏览器，浏览器再通过content-type来解析你返回的内容，呈现给用户。</p>\n<p>那么我们来看，我们先假设你的首页中有100张图片，此时，用户的看似一次http请求，其实并不是一次，用户在第一次访问的时候，浏览器中不会有缓存，你的100张图片，浏览器要连着请求100次http请求（有人会跟我说http长连短连的问题，不在这里讨论），你的服务器接收这些请求，都需要耗费内存去创建socket来玩tcp传输（消耗你服务器上的计算资源）。</p>\n<p>重点来了，这样的话，你的服务器的压力会非常大，因为页面中的所有请求都是只请求到你这台服务器上，如果1个人还好，如果10000个人并发访问呢（先不聊服务器集群，这里就说是单实例服务器），那你的服务器能扛住多少个tcp连接？你的带宽有多大？你的服务器的内存有多大？你的硬盘是高性能的吗？你能抗住多少IO？你给web服务器分的内存有多大？会不会宕机？</p>\n<p><strong>这就是为什么，越是大中型的web应用，他们越是要解耦。</strong></p>\n<p>理论上你可以把你的数据库+应用服务+消息队列+缓存+用户上传的文件+日志+等等都扔在一台服务器上，你也不用玩什么服务治理，也不用做什么性能监控，什么报警机制等等，就乱成一锅粥好了。</p>\n<p>但是这样就好像是你把鸡蛋都放在一个篮子里，隐患非常大。如果因为一个子应用的内存不稳定导致整个服务器内存溢出而hung住，那你的整个网站就挂掉了。</p>\n<p>如果出意外挂掉，而恰好这时你们的业务又处于井喷式发展高峰期，那么恭喜你，业务成功被技术卡住，很可能会流失大量用户，后果不堪设想。<br>注意：技术一定是要走在业务前面的，否则你将错过最佳的发展期。</p>\n<p>此外，你的应用全部都耦合在一起，相当于一个巨石，当服务端负载能力不足时，一般会使用负载均衡的方式，将服务器做成集群，这样其实你是在水平扩展一块块巨石，性能加速度会越来越低，要知道，本身负载就低的功能or模块是没有必要水平扩展的，在本文中的例子就是你的性能瓶颈不在前端，那干嘛要水平扩展前端呢？？？<br>还有发版部署上线的时候，我明明只改了后端的代码，为什么要前端也跟着发布呢？？？（引用：《架构探险-轻量级微服务架构》，黄勇）</p>\n<p>正常的互联网架构，是都要拆开的，你的web服务器集群，你的应用服务器集群+文件服务器集群+数据库服务器集群+消息队列集群+缓存集群等等。  </p>\n<p><strong>JSP的痛点</strong></p>\n<p>以前的javaWeb项目大多数使用jsp作为页面层展示数据给用户，因为流量不高，因此也没有那么苛刻的性能要求，但现在是大数据时代，对于互联网项目的性能要求是越来越高，因此原始的前后端耦合在一起的架构模式已经逐渐不能满足我们，因此我们需要需找一种解耦的方式，来大幅度提升我们的负载能力。</p>\n<p>1、动态资源和静态资源全部耦合在一起，服务器压力大，因为服务器会收到各种http请求，例如css的http请求，js的，图片的等等。</p>\n<p>一旦服务器出现状况，前后台一起玩完，用户体验极差。</p>\n<p>2、UI出好设计图后，前端工程师只负责将设计图切成html，需要由java工程师来将html套成jsp页面，出错率较高（因为页面中经常会出现大量的js代码），<br>修改问题时需要双方协同开发，效率低下。</p>\n<p>3、jsp必须要在支持java的web服务器里运行（例如tomcat，jetty，resin等），无法使用nginx等（nginx据说单实例http并发高达5w，这个优势要用上），<br>性能提不上来。</p>\n<p>4、第一次请求jsp，必须要在web服务器中编译成servlet，第一次运行会较慢。</p>\n<p>5.每次请求jsp都是访问servlet再用输出流输出的html页面，效率没有直接使用html高（是每次哟，亲~）。</p>\n<p>6、jsp内有较多标签和表达式，前端工程师在修改页面时会捉襟见肘，遇到很多痛点。</p>\n<p>7、如果jsp中的内容很多，页面响应会很慢，因为是同步加载。</p>\n<p>8、需要前端工程师使用java的ide（例如eclipse），以及需要配置各种后端的开发环境，你们有考虑过前端工程师的感受吗。</p>\n<p>基于上述的一些痛点，我们应该把整个项目的开发权重往前移，实现前后端真正的解耦！</p>\n<h3 id=\"开发模式\"><a href=\"#开发模式\" class=\"headerlink\" title=\"开发模式\"></a><strong>开发模式</strong></h3><p><strong>以前老的方式是：</strong></p>\n<ul>\n<li>产品经历/领导/客户提出需求</li>\n<li>UI做出设计图</li>\n<li>前端工程师做html页面</li>\n<li>后端工程师将html页面套成jsp页面（前后端强依赖，后端必须要等前端的html做好才能套jsp。如果html发生变更，就更痛了，开发效率低）</li>\n<li>集成出现问题</li>\n<li>前端返工</li>\n<li>后端返工</li>\n</ul>\n<p>二次集成</p>\n<p>集成成功</p>\n<p>交付</p>\n<p><strong>新的方式是：</strong></p>\n<ul>\n<li>产品经历/领导/客户提出需求</li>\n<li>UI做出设计图</li>\n<li>前后端约定接口&amp;数据&amp;参数</li>\n<li>前后端并行开发（无强依赖，可前后端并行开发，如果需求变更，只要接口&amp;参数不变，就不用两边都修改代码，开发效率高）</li>\n<li>前后端集成</li>\n<li>前端页面调整</li>\n<li>集成成功</li>\n<li>交付</li>\n</ul>\n<h3 id=\"请求方式\"><a href=\"#请求方式\" class=\"headerlink\" title=\"请求方式\"></a><strong>请求方式</strong></h3><p><strong>以前老的方式是：</strong></p>\n<ul>\n<li>客户端请求</li>\n<li>服务端的servlet或controller接收请求（后端控制路由与渲染页面，整个项目开发的权重大部分在后端）</li>\n<li>调用service,dao代码完成业务逻辑</li>\n<li>返回jsp</li>\n<li>jsp展现一些动态的代码</li>\n</ul>\n<p><strong>新的方式是：</strong></p>\n<ul>\n<li>浏览器发送请求</li>\n<li>直接到达html页面（前端控制路由与渲染页面，整个项目开发的权重前移）</li>\n<li>html页面负责调用服务端接口产生数据（通过ajax等等，后台返回json格式数据，json数据格式因为简洁高效而取代xml）</li>\n<li>填充html，展现动态效果，在页面上进行解析并操作DOM。</li>\n</ul>\n<p>（有兴趣的童鞋可以访问一下阿里巴巴等大型网站，然后按一下F12，监控一下你刷新一次页面，他的http是怎么玩的，大多数都是单独请求后台数据，使用json传输数据，而不是一个大而全的http请求把整个页面包括动+静全部返回过来）</p>\n<p><strong>总结一下新的方式的请求步骤：</strong></p>\n<p>大量并发浏览器请求—&gt;web服务器集群(nginx)—&gt;应用服务器集群(tomcat)—&gt;文件/数据库/缓存/消息队列服务器集群</p>\n<p>同时又可以玩分模块，还可以按业务拆成一个个的小集群，为后面的架构升级做准备。</p>\n<h3 id=\"前后分离的优势\"><a href=\"#前后分离的优势\" class=\"headerlink\" title=\"前后分离的优势\"></a><strong>前后分离的优势</strong></h3><p>1、可以实现真正的前后端解耦，前端服务器使用nginx。</p>\n<p>前端/WEB服务器放的是css，js，图片等等一系列静态资源（甚至你还可以css，js，图片等资源放到特定的文件服务器，例如阿里云的oss，并使用cdn加速），前端服务器负责控制页面引用&amp;跳转&amp;路由，前端页面异步调用后端的接口，后端/应用服务器使用tomcat（把tomcat想象成一个数据提供者），加快整体响应速度。</p>\n<blockquote>\n<p>这里需要使用一些前端工程化的框架比如nodejs，react，router，react，redux，webpack</p>\n</blockquote>\n<p>2、发现bug，可以快速定位是谁的问题，不会出现互相踢皮球的现象。</p>\n<p>页面逻辑，跳转错误，浏览器兼容性问题，脚本错误，页面样式等问题，全部由前端工程师来负责。</p>\n<p>接口数据出错，数据没有提交成功，应答超时等问题，全部由后端工程师来解决。</p>\n<p>双方互不干扰，前端与后端是相亲相爱的一家人。</p>\n<p>3、在大并发情况下，我可以同时水平扩展前后端服务器，比如淘宝的一个首页就需要2000+台前端服务器做集群来抗住日均多少亿+的日均pv。</p>\n<blockquote>\n<p>去参加阿里的技术峰会，听他们说他们的web容器都是自己写的，就算他单实例抗10万http并发，2000台是2亿http并发，并且他们还可以根据预知洪峰来无限拓展，很恐怖，就一个首页。。。</p>\n</blockquote>\n<p>4、减少后端服务器的并发/负载压力</p>\n<p>除了接口以外的其他所有http请求全部转移到前端nginx上，接口的请求调用tomcat，参考nginx反向代理tomcat。</p>\n<p>且除了第一次页面请求外，浏览器会大量调用本地缓存。</p>\n<p>5、即使后端服务暂时超时或者宕机了，前端页面也会正常访问，只不过数据刷不出来而已。</p>\n<p>6、也许你也需要有微信相关的轻应用，那样你的接口完全可以共用，如果也有app相关的服务，那么只要通过一些代码重构，也可以大量复用接口，提升效率。（多端应用）</p>\n<p>7、页面显示的东西再多也不怕，因为是异步加载。</p>\n<p>8、nginx支持页面热部署，不用重启服务器，前端升级更无缝。</p>\n<p>9、增加代码的维护性&amp;易读性（前后端耦在一起的代码读起来相当费劲）。</p>\n<p>10、提升开发效率，因为可以前后端并行开发，而不是像以前的强依赖。</p>\n<p>11、在nginx中部署证书，外网使用https访问，并且只开放443和80端口，其他端口一律关闭（防止黑客端口扫描），<br>内网使用http，性能和安全都有保障。</p>\n<p>12、前端大量的组件代码得以复用，组件化，提升开发效率，抽出来！</p>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a><strong>注意事项</strong></h3><p>1、在开需求会议的时候，前后端工程师必须全部参加，并且需要制定好接口文档，后端工程师要写好测试用例（2个维度），不要让前端工程师充当你的专职测试，<br>推荐使用chrome的插件postman或soapui或jmeter，service层的测试用例拿junit写。ps：前端也可以玩单元测试吗？</p>\n<p>2、上述的接口并不是java里的interface，说白了调用接口就是调用你controler里的方法。</p>\n<p>3、加重了前端团队的工作量，减轻了后端团队的工作量，提高了性能和可扩展性。</p>\n<p>4、我们需要一些前端的框架来解决类似于页面嵌套，分页，页面跳转控制等功能。（上面提到的那些前端框架）。</p>\n<p>5、如果你的项目很小，或者是一个单纯的内网项目，那你大可放心，不用任何架构而言，但是如果你的项目是外网项目，呵呵哒。</p>\n<p>6、以前还有人在使用类似于velocity/freemarker等模板框架来生成静态页面，仁者见仁智者见智。</p>\n<p>7、这篇文章主要的目的是说jsp在大型外网java web项目中被淘汰掉，可没说jsp可以完全不学，对于一些学生朋友来说，jsp/servlet等相关的java web基础还是要掌握牢的，不然你以为springmvc这种框架是基于什么来写的？</p>\n<p>8、如果页面上有一些权限等等相关的校验，那么这些相关的数据也可以通过ajax从接口里拿。</p>\n<p>9、对于既可以前端做也可以后端做的逻辑，我建议是放到前端，为什么？</p>\n<p>因为你的逻辑需要计算资源进行计算，如果放到后端去run逻辑，则会消耗带宽&amp;内存&amp;cpu等等计算资源，你要记住一点就是：服务端的计算资源是有限的，而如果放到前端，使用的是客户端的计算资源，这样你的服务端负载就会下降（高并发场景）。</p>\n<blockquote>\n<p>类似于数据校验这种，前后端都需要做！</p>\n</blockquote>\n<p>10、前端需要有机制应对后端请求超时以及后端服务宕机的情况，友好的展示给用户。</p>\n<h2 id=\"扩展阅读\"><a href=\"#扩展阅读\" class=\"headerlink\" title=\"扩展阅读\"></a><strong>扩展阅读</strong></h2><p>1、其实对于js，css，图片这类的静态资源可以考虑放到类似于阿里云的oss这类文件服务器上（如果是普通的服务器&amp;操作系统，存储在到达pb级的文件后，或者单个文件夹内的文件数量达到3-5万，io会有很严重的性能问题），再在oss上配cdn（全国子节点加速），这样你页面打开的速度像飞一样， 无论你在全国的哪个地方，并且你的nginx的负载会进一步降低。</p>\n<p>2、如果你要玩轻量级微服务架构，要使用nodejs做网关，用nodejs的好处还有利于seo优化，因为nginx只是向浏览器返回页面静态资源，而国内的搜索引擎爬虫只会抓取静态数据，不会解析页面中的js，这使得应用得不到良好的搜索引擎支持。同时因为nginx不会进行页面的组装渲染，需要把静态页面返回到浏览器，然后完成渲染工作，这加重了浏览器的渲染负担。</p>\n<p>浏览器发起的请求经过nginx进行分发，URL请求统一分发到nodejs，在nodejs中进行页面组装渲染；API请求则直接发送到后端服务器，完成响应。</p>\n<p>3、如果遇到跨域问题，spring4的CORS可以完美解决，但一般使用nginx反向代理都不会有跨域问题，除非你把前端服务和后端服务分成两个域名。<br>JSONP的方式也被淘汰掉了。</p>\n<p>4、如果想玩多端应用，注意要去掉tomcat原生的session机制，要使用token机制，使用缓存（因为是分布式系统），做单点，对于token机制的安全性问题，可以搜一下jwt。</p>\n<p>5、前端项目中可以加入mock测试（构造虚拟测试对象来模拟后端，可以独立开发和测试），后端需要有详细的测试用例，保证服务的可用性与稳定性。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><p>前后端分离并非仅仅只是一种开发模式，而是一种架构模式（前后端分离架构）。</p>\n<p>千万不要以为只有在撸代码的时候把前端和后端分开就是前后端分离了。需要区分前后端项目。前端项目与后端项目是两个项目，放在两个不同的服务器，需要独立部署，两个不同的工程，两个不同的代码库，不同的开发人员。</p>\n<p>前后端工程师需要约定交互接口，实现并行开发，开发结束后需要进行独立部署，前端通过ajax来调用http请求调用后端的restful api。</p>\n<p>前端只需要关注页面的样式与动态数据的解析&amp;渲染，而后端专注于具体业务逻辑。</p>\n<p><strong>推荐阅读</strong></p>\n<p>（点击标题可跳转阅读）</p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556866&idx=2&sn=680dde6cb7c8c5ac56094aec3ba08f50&chksm=80255bc3b752d2d5c04036eb778b34599be1b218377632dc96fda3cc14aa82bbb6f9319841da&scene=21#wechat_redirect\">通过阅读源码，提高你的 JS 水平</a>  </p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556840&idx=1&sn=37d4554cd243d4f30f53ac06f2dfe109&chksm=80255c29b752d53f34e58c1676eb4ab169605be2b1f9d58fa5855938bdc0dca68eadbe9ca5a5&scene=21#wechat_redirect\">深入理解 ESLint</a>  </p>\n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&mid=2651556854&idx=1&sn=4d1fc907d4844e39262c8ea559fe5a1d&chksm=80255c37b752d521ae03100d27b67d7912ffe0b5f1997f4c52a15e69bec164131cac15ea2247&scene=21#wechat_redirect\">详解 ES 2018 新特性</a></p>\n<p>觉得本文对你有帮助？请分享给更多人</p>\n<p>关注「前端大全」加星标，提升前端技能</p>\n<p><img src=\"https://www.v5ant.com/wp-content/uploads/2019/08/frc-d6041b8e6c4ba2a422c4ed4a2ce1c6f3.jpeg\" alt=\"Web 实现前后端分离，前后端解耦\"></p>\n<p>好文章，我在看❤️</p>\n"},{"title":"2019最新前端知识梳理(基础部分)-面试宝典","url":"158.html","id":"158","date":"2019-06-22T09:19:35.000Z","_content":"\n## 一、HTML、HTTP、web 综合问题\n\n### 1 前端需要注意哪些 SEO\n\n- 合理的`title`、`description`、`keywords`：搜索对着三项的权重逐个减小，`title`值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面`title`要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description`有所不同；`keywords`列举出重要关键词即可\n- 语义化的`HTML`代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页\n- 重要内容`HTML`代码放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取\n- 重要内容不要用`js`输出：爬虫不会执行 js 获取内容\n- 少用`iframe`：搜索引擎不会抓取`iframe`中的内容\n- 非装饰性图片必须加`alt`\n- 提高网站速度：网站速度是搜索引擎排序的一个重要指标\n\n### 2 `<img>`的`title`和`alt`有什么区别\n\n- 通常当鼠标滑动到元素上的时候显示\n- `alt`是`<img>`的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。\n\n### 3 HTTP 的几种请求方法用途\n\n- `GET`方法\n  - 发送一个请求来取得服务器上的某一资源\n- `POST`方法\n  - 向`URL`指定的资源提交数据或附加新的数据\n- `PUT`方法\n  - 跟`POST`方法很像，也是想服务器提交数据。但是，它们之间有不同。`PUT`指定了资源在服务器上的位置，而`POST`没有\n- `HEAD`方法\n  - 只请求页面的首部\n- `DELETE`方法\n  - 删除服务器上的某资源\n- `OPTIONS`方法\n  - 它用于获取当前`URL`所支持的方法。如果请求成功，会有一个`Allow`的头包含类似`“GET,POST”`这样的信息\n- `TRACE`方法\n  - `TRACE`方法被用于激发一个远程的，应用层的请求消息回路\n- `CONNECT`方法\n  - 把请求连接转换到透明的`TCP/IP`通道\n\n### 4 从浏览器地址栏输入 url 到显示页面的步骤\n\n基础版本\n\n- 浏览器根据请求的`URL`交给`DNS`域名解析，找到真实`IP`，向服务器发起请求；\n- 服务器交给后台处理完成后返回数据，浏览器接收文件（`HTML、JS、CSS`、图象等）；\n- 浏览器对加载到的资源（`HTML、JS、CSS`等）进行语法解析，建立相应的内部数据结构（如`HTML`的`DOM`）；\n- 载入解析到的资源文件，渲染页面，完成。\n\n详细版\n\n1.  在浏览器地址栏输入 URL\n2.  浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤\n\n    - HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期\n    - HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间\n\n    1.  如果资源未缓存，发起新请求\n    2.  如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。\n    3.  检验新鲜通常有两个 HTTP 头进行控制`Expires`和`Cache-Control`：\n\n3.  浏览器解析 URL 获取协议，主机，端口，path\n4.  浏览器组装一个 HTTP（GET）请求报文\n5.  浏览器获取主机 ip 地址，过程如下：\n    1.  浏览器缓存\n    2.  本机缓存\n    3.  hosts 文件\n    4.  路由器缓存\n    5.  ISP DNS 缓存\n    6.  DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）\n6.  打开一个 socket 与目标 IP 地址，端口建立 TCP 链接，三次握手如下：\n    1.  客户端发送一个 TCP 的 SYN=1，Seq=X 的包到服务器端口\n    2.  服务器发回 SYN=1， ACK=X+1， Seq=Y 的响应包\n    3.  客户端发送 ACK=Y+1， Seq=Z\n7.  TCP 链接建立后发送 HTTP 请求\n8.  服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序\n9.  服务器检查 HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回 304 等对应状态码\n10. 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作\n11. 服务器将响应报文通过 TCP 连接发送回浏览器\n12. 浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下：\n    1.  主动方发送 Fin=1， Ack=Z， Seq= X 报文\n    2.  被动方发送 ACK=X+1， Seq=Z 报文\n    3.  被动方发送 Fin=1， ACK=X， Seq=Y 报文\n    4.  主动方发送 ACK=Y， Seq=X 报文\n13. 浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同\n14. 如果资源可缓存，进行缓存\n15. 对响应进行解码（例如 gzip 压缩）\n16. 根据资源类型决定如何处理（假设资源为 HTML 文档）\n17. 解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释\n18. 构建 DOM 树：\n    1.  Tokenizing：根据 HTML 规范将字符流解析为标记\n    2.  Lexing：词法分析将标记转换为对象并定义属性和规则\n    3.  DOM construction：根据 HTML 标记关系将对象组成 DOM 树\n19. 解析过程中遇到图片、样式表、js 文件，启动下载\n20. 构建 CSSOM 树：\n    1.  Tokenizing：字符流转换为标记流\n    2.  Node：根据标记创建节点\n    3.  CSSOM：节点创建 CSSOM 树\n21. 根据 DOM 树和 CSSOM 树构建渲染树:\n    1.  从 DOM 树的根节点遍历所有可见节点，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被 css 隐藏的节点，如`display: none`\n    2.  对每一个可见节点，找到恰当的 CSSOM 规则并应用\n    3.  发布可视节点的内容和计算样式\n22. js 解析如下：\n    1.  浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时 document.readystate 为 loading\n    2.  HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容\n    3.  当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素\n    4.  当文档完成解析，document.readState 变成 interactive\n    5.  所有 defer 脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()\n    6.  浏览器在 Document 对象上触发 DOMContentLoaded 事件\n    7.  此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete，window 触发 load 事件\n23. 显示页面（HTML 解析过程中会逐步显示页面）\n\n详细简版\n\n1.  从浏览器接收`url`到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）\n2.  开启网络线程到发出一个完整的`HTTP`请求（这一部分涉及到 dns 查询，`TCP/IP`请求，五层因特网协议栈等知识）\n3.  从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）\n4.  后台和前台的`HTTP`交互（这一部分包括`HTTP`头部、响应码、报文结构、`cookie`等知识，可以提下静态资源的`cookie`优化，以及编码解码，如`gzip`压缩等）\n5.  单独拎出来的缓存问题，`HTTP`的缓存（这部分包括 http 缓存头部，`ETag`，`catch-control`等）\n6.  浏览器接收到`HTTP`数据包后的解析流程（解析`html`-词法分析然后解析成`dom`树、解析`css`生成`css`规则树、合并成`render`树，然后`layout`、`painting`渲染、复合图层的合成、`GPU`绘制、外链资源的处理、`loaded`和`DOMContentLoaded`等）\n7.  `CSS`的可视化格式模型（元素的渲染规则，如包含块，控制框，`BFC`，`IFC`等概念）\n8.  `JS`引擎解析过程（`JS`的解释阶段，预处理阶段，执行阶段生成执行上下文，`VO`，作用域链、回收机制等等）\n9.  其它（可以拓展不同的知识模块，如跨域，web 安全，`hybrid`模式等等内容）\n\n### 5 如何进行网站性能优化\n\n- `content`方面\n  - 减少`HTTP`请求：合并文件、`CSS`精灵、`inline Image`\n  - 减少`DNS`查询：`DNS`缓存、将资源分布到恰当数量的主机名\n  - 减少`DOM`元素数量\n- `Server`方面\n  - 使用`CDN`\n  - 配置`ETag`\n  - 对组件使用`Gzip`压缩\n- `Cookie`方面\n  - 减小`cookie`大小\n- `css`方面\n  - 将样式表放到页面顶部\n  - 不使用`CSS`表达式\n  - 使用`<link>`不使用`@import`\n- `Javascript`方面\n  - 将脚本放到页面底部\n  - 将`javascript`和`css`从外部引入\n  - 压缩`javascript`和`css`\n  - 删除不需要的脚本\n  - 减少`DOM`访问\n- 图片方面\n  - 优化图片：根据实际颜色需要选择色深、压缩\n  - 优化`css`精灵\n  - 不要在`HTML`中拉伸图片\n\n### 6 HTTP 状态码及其含义\n\n- `1XX`：信息状态码\n  - `100 Continue`  继续，一般在发送`post`请求时，已发送了`http header`之后服务端将返回此信息，表示确认，之后发送具体参数信息\n- `2XX`：成功状态码\n  - `200 OK`  正常返回信息\n  - `201 Created`  请求成功并且服务器创建了新的资源\n  - `202 Accepted`  服务器已接受请求，但尚未处理\n- `3XX`：重定向\n  - `301 Moved Permanently`  请求的网页已永久移动到新位置。\n  - `302 Found`  临时性重定向。\n  - `303 See Other`  临时性重定向，且总是使用  `GET`  请求新的  `URI`。\n  - `304 Not Modified`  自从上次请求后，请求的网页未修改过。\n- `4XX`：客户端错误\n  - `400 Bad Request`  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n  - `401 Unauthorized`  请求未授权。\n  - `403 Forbidden`  禁止访问。\n  - `404 Not Found`  找不到如何与  `URI`  相匹配的资源。\n- `5XX:`  服务器错误\n  - `500 Internal Server Error`  最常见的服务器端错误。\n  - `503 Service Unavailable`  服务器端暂时无法处理请求（可能是过载或维护）。\n\n### 7 语义化的理解\n\n- 用正确的标签做正确的事情！\n- `HTML`语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；\n- 在没有样式`CSS`情况下也以一种文档格式显示，并且是容易阅读的。\n- 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于  `SEO`。\n- 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解\n\n### 8 介绍一下你对浏览器内核的理解？\n\n- 主要分成两部分：渲染引擎(`layout engineer`或`Rendering Engine`)和`JS`引擎\n- 渲染引擎：负责取得网页的内容（`HTML`、`XML`、图像等等）、整理讯息（例如加入`CSS`等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核\n- `JS`引擎则：解析和执行`javascript`来实现网页的动态效果\n- 最开始渲染引擎和`JS`引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎\n\n### 9 html5 有哪些新特性、移除了那些元素？\n\n- `HTML5`  现在已经不是  `SGML`  的子集，主要是关于图像，位置，存储，多任务等功能的增加\n  - 绘画  `canvas`\n  - 用于媒介回放的  `video`  和  `audio`  元素\n  - 本地离线存储  `localStorage`  长期存储数据，浏览器关闭后数据不丢失\n  - `sessionStorage`  的数据在浏览器关闭后自动删除\n  - 语意化更好的内容元素，比如`article`、`footer`、`header`、`nav`、`section`\n  - 表单控件，`calendar`、`date`、`time`、`email`、`url`、`search`\n  - 新的技术`webworker`、 `websocket`、 `Geolocation`\n- 移除的元素：\n  - 纯表现的元素：`basefont`、`big`、`center`、`font`、 `s`、`strike`、`tt`、`u`\n  - 对可用性产生负面影响的元素：`frame`、`frameset`、`noframes`\n- 支持`HTML5`新标签：\n  - `IE8/IE7/IE6`支持通过`document.createElement`方法产生的标签\n  - 可以利用这一特性让这些浏览器支持`HTML5`新标签\n  - 浏览器支持新标签后，还需要添加标签默认的样式\n- 当然也可以直接使用成熟的框架、比如`html5shim`\n\n### 10 `HTML5`的离线储存怎么使用，工作原理能不能解释一下？\n\n- 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件\n- 原理：`HTML5`的离线存储是基于一个新建的`.appcache`文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像`cookie`一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n- 如何使用：\n\n  - 页面头部像下面一样加入一个`manifest`的属性；\n  - 在`cache.manifest`文件的编写离线存储的资源\n  - 在离线状态时，操作`window.applicationCache`进行需求实现\n\n  CACHE MANIFEST\n  #v0.11CACHE:js/app.js\n  css/style.css\n  NETWORK:resourse/logo.png\n  FALLBACK:/offline.html\n\n### 11 浏览器是怎么对`HTML5`的离线储存资源进行管理和加载的呢\n\n- 在线的情况下，浏览器发现`html`头部有`manifest`属性，它会请求`manifest`文件，如果是第一次访问`app`，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过`app`并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的`manifest`文件与旧的`manifest`文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n- 离线的情况下，浏览器就直接使用离线存储的资源。\n\n### 12 请描述一下  `cookies`，`sessionStorage`  和  `localStorage`  的区别？\n\n- `cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）\n- cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递\n- `sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存\n- 存储大小：\n  - `cookie`数据大小不能超过 4k\n  - `sessionStorage`和`localStorage`虽然也有存储大小的限制，但比`cookie`大得多，可以达到 5M 或更大\n- 有期时间：\n  - `localStorage`  存储持久数据，浏览器关闭后数据不丢失除非主动删除数据\n  - `sessionStorage`  数据在当前浏览器窗口关闭后自动删除\n  - `cookie`  设置的`cookie`过期时间之前一直有效，即使窗口或浏览器关闭\n\n### 13 iframe 有那些缺点？\n\n- `iframe`会阻塞主页面的`Onload`事件\n- 搜索引擎的检索程序无法解读这种页面，不利于`SEO`\n- `iframe`和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载\n- 使用`iframe`之前需要考虑这两个缺点。如果需要使用`iframe`，最好是通过`javascript`动态给`iframe`添加`src`属性值，这样可以绕开以上两个问题\n\n### 14 WEB 标准以及 W3C 标准是什么?\n\n- 标签闭合、标签小写、不乱嵌套、使用外链`css`和`js`、结构行为表现的分离\n\n### 15 xhtml 和 html 有什么区别?\n\n- 一个是功能上的差别\n  - 主要是`XHTML`可兼容各大浏览器、手机以及`PDA`，并且浏览器也能快速正确地编译网页\n- 另外是书写习惯的差别\n  - `XHTML`  元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素\n\n### 16 Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?\n\n- 页面被加载的时，`link`会同时被加载，而`@imort`页面被加载的时，`link`会同时被加载，而`@import`引用的`CSS`会等到页面被加载完再加载  `import`只在`IE5`以上才能识别，而`link`是`XHTML`标签，无兼容问题  `link`方式的样式的权重 高于`@import`的权重\n- `<!DOCTYPE>`  声明位于文档中的最前面，处于  `<html>`  标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档\n- 严格模式的排版和  `JS`  运作模式是 以该浏览器支持的最高标准运行\n- 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 `DOCTYPE`不存在或格式不正确会导致文档以混杂模式呈现\n\n### 17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？\n\n- 行内元素有：`a b span img input select strong`\n- 块级元素有：`div ul ol li dl dt dd h1 h2 h3 h4… p`\n- 空元素：`<br> <hr> <img> <input> <link> <meta>`\n- 行内元素不可以设置宽高，不独占一行\n- 块级元素可以设置宽高，独占一行\n\n### 18 HTML 全局属性(global attribute)有哪些\n\n- `class`:为元素设置类标识\n- `data-*`: 为元素增加自定义属性\n- `draggable`: 设置元素是否可拖拽\n- `id`: 元素`id`，文档内唯一\n- `lang`: 元素内容的的语言\n- `style`: 行内`css`样式\n- `title`: 元素相关的建议信息\n- `svg`绘制出来的每一个图形的元素都是独立的`DOM`节点，能够方便的绑定事件或用来修改。`canvas`输出的是一整幅画布\n- `svg`输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而`canvas`输出标量画布，就像一张图片一样，放大会失真或者锯齿\n- 20 HTML5 为什么只需要写 <!DOCTYPE HTML>\n- `HTML5`  不基于  `SGML`，因此不需要对`DTD`进行引用，但是需要`doctype`来规范浏览器的行为\n- 而`HTML4.01`基于`SGML`,所以需要对`DTD`进行引用，才能告知浏览器文档所使用的文档类型\n\n### 21 如何在页面上实现一个圆形的可点击区域？\n\n- `svg`\n- `border-radius`\n- 纯`js`实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等\n\n### 22 网页验证码是干嘛的，是为了解决什么安全问题\n\n- 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水\n- 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试\n\n### 23 viewport\n\n     <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n        // width    设置viewport宽度，为一个正整数，或字符串‘device-width’\n        // device-width  设备宽度\n        // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置\n        // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数\n        // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数\n        // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数\n        // user-scalable    是否允许手动缩放\n\n- 延伸提问\n  - 怎样处理 移动端  `1px`  被 渲染成  `2px`问题\n\n局部处理\n\n- `mate`标签中的  `viewport`属性 ，`initial-scale`  设置为  `1`\n- `rem`按照设计稿标准走，外加利用`transfrome`  的`scale(0.5)`  缩小一倍即可；\n\n全局处理\n\n- `mate`标签中的  `viewport`属性 ，`initial-scale`  设置为  `0.5`\n- `rem`  按照设计稿标准走即可\n\n### 24 渲染优化\n\n- 禁止使用`iframe`（阻塞父文档`onload`事件）\n  - `iframe`会阻塞主页面的`Onload`事件\n  - 搜索引擎的检索程序无法解读这种页面，不利于 SEO\n  - `iframe`和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载\n  - 使用`iframe`之前需要考虑这两个缺点。如果需要使用`iframe`，最好是通过`javascript`\n  - 动态给`iframe`添加`src`属性值，这样可以绕开以上两个问题\n- 禁止使用`gif`图片实现`loading`效果（降低`CPU`消耗，提升渲染性能）\n- 使用`CSS3`代码代替`JS`动画（尽可能避免重绘重排以及回流）\n- 对于一些小图标，可以使用 base64 位编码，以减少网络请求。但不建议大图使用，比较耗费`CPU`\n  - 减少`HTTP`请求\n  - 避免文件跨域\n  - 修改及时生效\n  - 小图标优势在于\n- 页面头部的` <style></style>``<script></script> `  会阻塞页面；（因为  `Renderer`进程中  `JS`线程和渲染线程是互斥的）\n- 页面中空的  `href`  和  `src`  会阻塞页面其他资源的加载 (阻塞下载进程)\n- 网页`gzip`，`CDN`托管，`data`缓存 ，图片服务器\n- 前端模板 JS+数据，减少由于`HTML`标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数\n- 用`innerHTML`代替`DOM`操作，减少`DOM`操作次数，优化`javascript`性能\n- 当需要设置的样式很多时设置`className`而不是直接操作`style`\n- 少用全局变量、缓存`DOM`节点查找的结果。减少`IO`读取操作\n- 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳\n- 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘`IO`\n\n### 25 meta viewport 相关\n\n    <!DOCTYPE html>  <!--H5标准声明，使用 HTML5 doctype，不区分大小写--><head lang=”en”> <!--标准的 lang 属性写法--><meta charset=’utf-8′>    <!--声明文档使用的字符编码--><meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/>   <!--优先使用 IE 最新版本和 Chrome--><meta name=”description” content=”不超过150个字符”/>       <!--页面描述--><meta name=”keywords” content=””/>     <!-- 页面关键词--><meta name=”author” content=”name, email@gmail.com”/>    <!--网页作者--><meta name=”robots” content=”index,follow”/>      <!--搜索引擎抓取--><meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”> <!--为移动设备添加 viewport--><meta name=”apple-mobile-web-app-title” content=”标题”> <!--iOS 设备 begin--><meta name=”apple-mobile-web-app-capable” content=”yes”/>  <!--添加到主屏后的标题（iOS 6 新增）\n    是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--><meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”><!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--><meta name=”apple-mobile-web-app-status-bar-style” content=”black”/><meta name=”format-detection” content=”telphone=no, email=no”/>  <!--设置苹果工具栏颜色--><meta name=”renderer” content=”webkit”> <!-- 启用360浏览器的极速模式(webkit)--><meta http-equiv=”X-UA-Compatible” content=”IE=edge”>     <!--避免IE使用兼容模式--><meta http-equiv=”Cache-Control” content=”no-siteapp” />    <!--不让百度转码--><meta name=”HandheldFriendly” content=”true”>     <!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--><meta name=”MobileOptimized” content=”320″>   <!--微软的老式浏览器--><meta name=”screen-orientation” content=”portrait”>   <!--uc强制竖屏--><meta name=”x5-orientation” content=”portrait”>    <!--QQ强制竖屏--><meta name=”full-screen” content=”yes”>              <!--UC强制全屏--><meta name=”x5-fullscreen” content=”true”>       <!--QQ强制全屏--><meta name=”browsermode” content=”application”>   <!--UC应用模式--><meta name=”x5-page-mode” content=”app”>   <!-- QQ应用模式--><meta name=”msapplication-tap-highlight” content=”no”>    <!--windows phone 点击无高亮\n    设置页面不缓存--><meta http-equiv=”pragma” content=”no-cache”><meta http-equiv=”cache-control” content=”no-cache”><meta http-equiv=”expires” content=”0″>\n\n### 26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?\n\n- `IE`: `trident`内核\n- `Firefox`：`gecko`内核\n- `Safari`:`webkit`内核\n- `Opera`:以前是`presto`内核，`Opera`现已改用 Google - `Chrome`的`Blink`内核\n- `Chrome:Blink`(基于`webkit`，Google 与 Opera Software 共同开发)\n\n### 27 div+css 的布局较 table 布局有什么优点？\n\n- 改版的时候更方便 只要改`css`文件。\n- 页面加载速度更快、结构化清晰、页面显示简洁。\n- 表现与结构相分离。\n- 易于优化（`seo`）搜索引擎更友好，排名更容易靠前。\n\n### 28 a：img 的 alt 与 title 有何异同？b：strong 与 em 的异同？\n\n- `alt(alt text)`:为不能显示图像、窗体或`applets`的用户代理（`UA`），`alt`属性用来指定替换文字。替换文字的语言由`lang`属性指定。(在 IE 浏览器下会在没有`title`时把`alt`当成  `tool tip`显示)\n- `title(tool tip)`:该属性为设置该属性的元素提供建议性的信息\n- `strong`:粗体强调标签，强调，表示内容的重要性\n- `em`:斜体强调标签，更强烈强调，表示内容的强调点\n\n### 29 你能描述一下渐进增强和优雅降级之间的不同吗\n\n- 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n- 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n> 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带\n\n### 30 为什么利用多个域名来存储网站资源会更有效？\n\n- `CDN`缓存更方便\n- 突破浏览器并发限制\n- 节约`cookie`带宽\n- 节约主域名的连接数，优化页面响应速度\n- 防止不必要的安全问题\n\n### 31 简述一下 src 与 href 的区别\n\n- `src`用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。\n- `src`是`source`的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求`src`资源时会将其指向的资源下载并应用到文档内，例如`js`脚本，`img`图片和`frame`等元素\n\n> `<script src =\"js.js\"></script>`  当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部\n\n- `href`是`Hypertext Reference`的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加\n- `<link href=\"common.css\" rel=\"stylesheet\"/>`那么浏览器会识别该文档为`css`文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用`link`方式来加载`css`，而不是使用`@import`方式\n\n### 32 知道的网页制作会用到的图片格式有哪些？\n\n- `png-8`、`png-24`、`jpeg`、`gif`、`svg`\n\n> 但是上面的那些都不是面试官想要的最后答案。面试官希望听到是`Webp`,`Apng`。（是否有关注新技术，新鲜事物）\n\n- Webp：`WebP`格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有`JPEG`的`2/3`，并能节省大量的服务器带宽资源和数据空间。`Facebook Ebay`等知名网站已经开始测试并使用`WebP`格式。\n- 在质量相同的情况下，WebP 格式图像的体积要比 JPEG 格式图像小`40%`。\n- Apng：全称是`“Animated Portable Network Graphics”`, 是 PNG 的位图动画扩展，可以实现 png 格式的动态图片效果。04 年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到  `iOS safari 8`的支持，有望代替`GIF`成为下一代动态图标准\n\n### 33.1 在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？\n\n> `dns`缓存，`cdn`缓存，浏览器缓存，服务器缓存\n\n### 33.2 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。\n\n- 图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。\n- 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。\n- 如果图片为 css 图片，可以使用`CSSsprite`，`SVGsprite`，`Iconfont`、`Base64`等技术。\n- 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。\n- 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。\n\n### 34 常见排序算法的时间复杂度,空间复杂度\n\n![](https://github.com/qiu-deqing/FE-interview/raw/master/img/sort-compare.png)\n\n### 35 web 开发中会话跟踪的方法有哪些\n\n- `cookie`\n- `session`\n- `url`重写\n- 隐藏`input`\n- `ip`地址\n\n### 36 HTTP request 报文结构是怎样的\n\n1.  首行是 Request-Line 包括：请求方法，请求 URI，协议版本，CRLF\n2.  首行之后是若干行请求头，包括 general-header，request-header 或者 entity-header，每个一行以 CRLF 结束\n3.  请求头和消息实体之间有一个 CRLF 分隔\n4.  根据实际请求需要可能包含一个消息实体   一个请求报文例子如下：\n\n    GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1\n    Host: www.w3.org\n    Connection: keep-alive\n    Cache-Control: max-age=0\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,_/_;q=0.8\n    User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\n    Referer: https://www.google.com.hk/\n    Accept-Encoding: gzip,deflate,sdch\n    Accept-Language: zh-CN,zh;q=0.8,en;q=0.6\n    Cookie: authorstyle=yes\n    If-None-Match: \"2cc8-3e3073913b100\"\n    If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT\n\n    name=qiu&age=25\n\n### 37 HTTP response 报文结构是怎样的\n\n- 首行是状态行包括：HTTP 版本，状态码，状态描述，后面跟一个 CRLF\n- 首行之后是若干行响应头，包括：通用头部，响应头部，实体头部\n- 响应头部和响应实体之间用一个 CRLF 空行分隔\n- 最后是一个可能的消息实体   响应报文例子如下：\n\n  HTTP/1.1 200 OK\n  Date: Tue, 08 Jul 2014 05:28:43 GMT\n  Server: Apache/2\n  Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT\n  ETag: \"40d7-3e3073913b100\"\n  Accept-Ranges: bytes\n  Content-Length: 16599\n  Cache-Control: max-age=21600\n  Expires: Tue, 08 Jul 2014 11:28:43 GMT\n  P3P: policyref=\"http://www.w3.org/2001/05/P3P/p3p.xml\"\n  Content-Type: text/html; charset=iso-8859-1\n\n  {\"name\": \"qiu\", \"age\": 25}\n","source":"_posts/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e5-9f-ba-e7-a1-80-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8.md","raw":"---\ntitle: 2019最新前端知识梳理(基础部分)-面试宝典\ntags:\n  - JavaScript\n  - 面试题\nurl: 158.html\nid: 158\ncategories:\n  - 大前端\n  - 面试题类\ndate: 2019-06-22 17:19:35\n---\n\n## 一、HTML、HTTP、web 综合问题\n\n### 1 前端需要注意哪些 SEO\n\n- 合理的`title`、`description`、`keywords`：搜索对着三项的权重逐个减小，`title`值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面`title`要有所不同；`description`把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面`description`有所不同；`keywords`列举出重要关键词即可\n- 语义化的`HTML`代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页\n- 重要内容`HTML`代码放在最前：搜索引擎抓取`HTML`顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取\n- 重要内容不要用`js`输出：爬虫不会执行 js 获取内容\n- 少用`iframe`：搜索引擎不会抓取`iframe`中的内容\n- 非装饰性图片必须加`alt`\n- 提高网站速度：网站速度是搜索引擎排序的一个重要指标\n\n### 2 `<img>`的`title`和`alt`有什么区别\n\n- 通常当鼠标滑动到元素上的时候显示\n- `alt`是`<img>`的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。\n\n### 3 HTTP 的几种请求方法用途\n\n- `GET`方法\n  - 发送一个请求来取得服务器上的某一资源\n- `POST`方法\n  - 向`URL`指定的资源提交数据或附加新的数据\n- `PUT`方法\n  - 跟`POST`方法很像，也是想服务器提交数据。但是，它们之间有不同。`PUT`指定了资源在服务器上的位置，而`POST`没有\n- `HEAD`方法\n  - 只请求页面的首部\n- `DELETE`方法\n  - 删除服务器上的某资源\n- `OPTIONS`方法\n  - 它用于获取当前`URL`所支持的方法。如果请求成功，会有一个`Allow`的头包含类似`“GET,POST”`这样的信息\n- `TRACE`方法\n  - `TRACE`方法被用于激发一个远程的，应用层的请求消息回路\n- `CONNECT`方法\n  - 把请求连接转换到透明的`TCP/IP`通道\n\n### 4 从浏览器地址栏输入 url 到显示页面的步骤\n\n基础版本\n\n- 浏览器根据请求的`URL`交给`DNS`域名解析，找到真实`IP`，向服务器发起请求；\n- 服务器交给后台处理完成后返回数据，浏览器接收文件（`HTML、JS、CSS`、图象等）；\n- 浏览器对加载到的资源（`HTML、JS、CSS`等）进行语法解析，建立相应的内部数据结构（如`HTML`的`DOM`）；\n- 载入解析到的资源文件，渲染页面，完成。\n\n详细版\n\n1.  在浏览器地址栏输入 URL\n2.  浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤\n\n    - HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期\n    - HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间\n\n    1.  如果资源未缓存，发起新请求\n    2.  如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。\n    3.  检验新鲜通常有两个 HTTP 头进行控制`Expires`和`Cache-Control`：\n\n3.  浏览器解析 URL 获取协议，主机，端口，path\n4.  浏览器组装一个 HTTP（GET）请求报文\n5.  浏览器获取主机 ip 地址，过程如下：\n    1.  浏览器缓存\n    2.  本机缓存\n    3.  hosts 文件\n    4.  路由器缓存\n    5.  ISP DNS 缓存\n    6.  DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）\n6.  打开一个 socket 与目标 IP 地址，端口建立 TCP 链接，三次握手如下：\n    1.  客户端发送一个 TCP 的 SYN=1，Seq=X 的包到服务器端口\n    2.  服务器发回 SYN=1， ACK=X+1， Seq=Y 的响应包\n    3.  客户端发送 ACK=Y+1， Seq=Z\n7.  TCP 链接建立后发送 HTTP 请求\n8.  服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序\n9.  服务器检查 HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回 304 等对应状态码\n10. 处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作\n11. 服务器将响应报文通过 TCP 连接发送回浏览器\n12. 浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下：\n    1.  主动方发送 Fin=1， Ack=Z， Seq= X 报文\n    2.  被动方发送 ACK=X+1， Seq=Z 报文\n    3.  被动方发送 Fin=1， ACK=X， Seq=Y 报文\n    4.  主动方发送 ACK=Y， Seq=X 报文\n13. 浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同\n14. 如果资源可缓存，进行缓存\n15. 对响应进行解码（例如 gzip 压缩）\n16. 根据资源类型决定如何处理（假设资源为 HTML 文档）\n17. 解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释\n18. 构建 DOM 树：\n    1.  Tokenizing：根据 HTML 规范将字符流解析为标记\n    2.  Lexing：词法分析将标记转换为对象并定义属性和规则\n    3.  DOM construction：根据 HTML 标记关系将对象组成 DOM 树\n19. 解析过程中遇到图片、样式表、js 文件，启动下载\n20. 构建 CSSOM 树：\n    1.  Tokenizing：字符流转换为标记流\n    2.  Node：根据标记创建节点\n    3.  CSSOM：节点创建 CSSOM 树\n21. 根据 DOM 树和 CSSOM 树构建渲染树:\n    1.  从 DOM 树的根节点遍历所有可见节点，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被 css 隐藏的节点，如`display: none`\n    2.  对每一个可见节点，找到恰当的 CSSOM 规则并应用\n    3.  发布可视节点的内容和计算样式\n22. js 解析如下：\n    1.  浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时 document.readystate 为 loading\n    2.  HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容\n    3.  当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素\n    4.  当文档完成解析，document.readState 变成 interactive\n    5.  所有 defer 脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()\n    6.  浏览器在 Document 对象上触发 DOMContentLoaded 事件\n    7.  此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete，window 触发 load 事件\n23. 显示页面（HTML 解析过程中会逐步显示页面）\n\n详细简版\n\n1.  从浏览器接收`url`到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）\n2.  开启网络线程到发出一个完整的`HTTP`请求（这一部分涉及到 dns 查询，`TCP/IP`请求，五层因特网协议栈等知识）\n3.  从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）\n4.  后台和前台的`HTTP`交互（这一部分包括`HTTP`头部、响应码、报文结构、`cookie`等知识，可以提下静态资源的`cookie`优化，以及编码解码，如`gzip`压缩等）\n5.  单独拎出来的缓存问题，`HTTP`的缓存（这部分包括 http 缓存头部，`ETag`，`catch-control`等）\n6.  浏览器接收到`HTTP`数据包后的解析流程（解析`html`-词法分析然后解析成`dom`树、解析`css`生成`css`规则树、合并成`render`树，然后`layout`、`painting`渲染、复合图层的合成、`GPU`绘制、外链资源的处理、`loaded`和`DOMContentLoaded`等）\n7.  `CSS`的可视化格式模型（元素的渲染规则，如包含块，控制框，`BFC`，`IFC`等概念）\n8.  `JS`引擎解析过程（`JS`的解释阶段，预处理阶段，执行阶段生成执行上下文，`VO`，作用域链、回收机制等等）\n9.  其它（可以拓展不同的知识模块，如跨域，web 安全，`hybrid`模式等等内容）\n\n### 5 如何进行网站性能优化\n\n- `content`方面\n  - 减少`HTTP`请求：合并文件、`CSS`精灵、`inline Image`\n  - 减少`DNS`查询：`DNS`缓存、将资源分布到恰当数量的主机名\n  - 减少`DOM`元素数量\n- `Server`方面\n  - 使用`CDN`\n  - 配置`ETag`\n  - 对组件使用`Gzip`压缩\n- `Cookie`方面\n  - 减小`cookie`大小\n- `css`方面\n  - 将样式表放到页面顶部\n  - 不使用`CSS`表达式\n  - 使用`<link>`不使用`@import`\n- `Javascript`方面\n  - 将脚本放到页面底部\n  - 将`javascript`和`css`从外部引入\n  - 压缩`javascript`和`css`\n  - 删除不需要的脚本\n  - 减少`DOM`访问\n- 图片方面\n  - 优化图片：根据实际颜色需要选择色深、压缩\n  - 优化`css`精灵\n  - 不要在`HTML`中拉伸图片\n\n### 6 HTTP 状态码及其含义\n\n- `1XX`：信息状态码\n  - `100 Continue`  继续，一般在发送`post`请求时，已发送了`http header`之后服务端将返回此信息，表示确认，之后发送具体参数信息\n- `2XX`：成功状态码\n  - `200 OK`  正常返回信息\n  - `201 Created`  请求成功并且服务器创建了新的资源\n  - `202 Accepted`  服务器已接受请求，但尚未处理\n- `3XX`：重定向\n  - `301 Moved Permanently`  请求的网页已永久移动到新位置。\n  - `302 Found`  临时性重定向。\n  - `303 See Other`  临时性重定向，且总是使用  `GET`  请求新的  `URI`。\n  - `304 Not Modified`  自从上次请求后，请求的网页未修改过。\n- `4XX`：客户端错误\n  - `400 Bad Request`  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n  - `401 Unauthorized`  请求未授权。\n  - `403 Forbidden`  禁止访问。\n  - `404 Not Found`  找不到如何与  `URI`  相匹配的资源。\n- `5XX:`  服务器错误\n  - `500 Internal Server Error`  最常见的服务器端错误。\n  - `503 Service Unavailable`  服务器端暂时无法处理请求（可能是过载或维护）。\n\n### 7 语义化的理解\n\n- 用正确的标签做正确的事情！\n- `HTML`语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；\n- 在没有样式`CSS`情况下也以一种文档格式显示，并且是容易阅读的。\n- 搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于  `SEO`。\n- 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解\n\n### 8 介绍一下你对浏览器内核的理解？\n\n- 主要分成两部分：渲染引擎(`layout engineer`或`Rendering Engine`)和`JS`引擎\n- 渲染引擎：负责取得网页的内容（`HTML`、`XML`、图像等等）、整理讯息（例如加入`CSS`等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核\n- `JS`引擎则：解析和执行`javascript`来实现网页的动态效果\n- 最开始渲染引擎和`JS`引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎\n\n### 9 html5 有哪些新特性、移除了那些元素？\n\n- `HTML5`  现在已经不是  `SGML`  的子集，主要是关于图像，位置，存储，多任务等功能的增加\n  - 绘画  `canvas`\n  - 用于媒介回放的  `video`  和  `audio`  元素\n  - 本地离线存储  `localStorage`  长期存储数据，浏览器关闭后数据不丢失\n  - `sessionStorage`  的数据在浏览器关闭后自动删除\n  - 语意化更好的内容元素，比如`article`、`footer`、`header`、`nav`、`section`\n  - 表单控件，`calendar`、`date`、`time`、`email`、`url`、`search`\n  - 新的技术`webworker`、 `websocket`、 `Geolocation`\n- 移除的元素：\n  - 纯表现的元素：`basefont`、`big`、`center`、`font`、 `s`、`strike`、`tt`、`u`\n  - 对可用性产生负面影响的元素：`frame`、`frameset`、`noframes`\n- 支持`HTML5`新标签：\n  - `IE8/IE7/IE6`支持通过`document.createElement`方法产生的标签\n  - 可以利用这一特性让这些浏览器支持`HTML5`新标签\n  - 浏览器支持新标签后，还需要添加标签默认的样式\n- 当然也可以直接使用成熟的框架、比如`html5shim`\n\n### 10 `HTML5`的离线储存怎么使用，工作原理能不能解释一下？\n\n- 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件\n- 原理：`HTML5`的离线存储是基于一个新建的`.appcache`文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像`cookie`一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n- 如何使用：\n\n  - 页面头部像下面一样加入一个`manifest`的属性；\n  - 在`cache.manifest`文件的编写离线存储的资源\n  - 在离线状态时，操作`window.applicationCache`进行需求实现\n\n  CACHE MANIFEST\n  #v0.11CACHE:js/app.js\n  css/style.css\n  NETWORK:resourse/logo.png\n  FALLBACK:/offline.html\n\n### 11 浏览器是怎么对`HTML5`的离线储存资源进行管理和加载的呢\n\n- 在线的情况下，浏览器发现`html`头部有`manifest`属性，它会请求`manifest`文件，如果是第一次访问`app`，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过`app`并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的`manifest`文件与旧的`manifest`文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n- 离线的情况下，浏览器就直接使用离线存储的资源。\n\n### 12 请描述一下  `cookies`，`sessionStorage`  和  `localStorage`  的区别？\n\n- `cookie`是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）\n- cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递\n- `sessionStorage`和`localStorage`不会自动把数据发给服务器，仅在本地保存\n- 存储大小：\n  - `cookie`数据大小不能超过 4k\n  - `sessionStorage`和`localStorage`虽然也有存储大小的限制，但比`cookie`大得多，可以达到 5M 或更大\n- 有期时间：\n  - `localStorage`  存储持久数据，浏览器关闭后数据不丢失除非主动删除数据\n  - `sessionStorage`  数据在当前浏览器窗口关闭后自动删除\n  - `cookie`  设置的`cookie`过期时间之前一直有效，即使窗口或浏览器关闭\n\n### 13 iframe 有那些缺点？\n\n- `iframe`会阻塞主页面的`Onload`事件\n- 搜索引擎的检索程序无法解读这种页面，不利于`SEO`\n- `iframe`和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载\n- 使用`iframe`之前需要考虑这两个缺点。如果需要使用`iframe`，最好是通过`javascript`动态给`iframe`添加`src`属性值，这样可以绕开以上两个问题\n\n### 14 WEB 标准以及 W3C 标准是什么?\n\n- 标签闭合、标签小写、不乱嵌套、使用外链`css`和`js`、结构行为表现的分离\n\n### 15 xhtml 和 html 有什么区别?\n\n- 一个是功能上的差别\n  - 主要是`XHTML`可兼容各大浏览器、手机以及`PDA`，并且浏览器也能快速正确地编译网页\n- 另外是书写习惯的差别\n  - `XHTML`  元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素\n\n### 16 Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?\n\n- 页面被加载的时，`link`会同时被加载，而`@imort`页面被加载的时，`link`会同时被加载，而`@import`引用的`CSS`会等到页面被加载完再加载  `import`只在`IE5`以上才能识别，而`link`是`XHTML`标签，无兼容问题  `link`方式的样式的权重 高于`@import`的权重\n- `<!DOCTYPE>`  声明位于文档中的最前面，处于  `<html>`  标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档\n- 严格模式的排版和  `JS`  运作模式是 以该浏览器支持的最高标准运行\n- 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 `DOCTYPE`不存在或格式不正确会导致文档以混杂模式呈现\n\n### 17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？\n\n- 行内元素有：`a b span img input select strong`\n- 块级元素有：`div ul ol li dl dt dd h1 h2 h3 h4… p`\n- 空元素：`<br> <hr> <img> <input> <link> <meta>`\n- 行内元素不可以设置宽高，不独占一行\n- 块级元素可以设置宽高，独占一行\n\n### 18 HTML 全局属性(global attribute)有哪些\n\n- `class`:为元素设置类标识\n- `data-*`: 为元素增加自定义属性\n- `draggable`: 设置元素是否可拖拽\n- `id`: 元素`id`，文档内唯一\n- `lang`: 元素内容的的语言\n- `style`: 行内`css`样式\n- `title`: 元素相关的建议信息\n- `svg`绘制出来的每一个图形的元素都是独立的`DOM`节点，能够方便的绑定事件或用来修改。`canvas`输出的是一整幅画布\n- `svg`输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而`canvas`输出标量画布，就像一张图片一样，放大会失真或者锯齿\n- 20 HTML5 为什么只需要写 <!DOCTYPE HTML>\n- `HTML5`  不基于  `SGML`，因此不需要对`DTD`进行引用，但是需要`doctype`来规范浏览器的行为\n- 而`HTML4.01`基于`SGML`,所以需要对`DTD`进行引用，才能告知浏览器文档所使用的文档类型\n\n### 21 如何在页面上实现一个圆形的可点击区域？\n\n- `svg`\n- `border-radius`\n- 纯`js`实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等\n\n### 22 网页验证码是干嘛的，是为了解决什么安全问题\n\n- 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水\n- 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试\n\n### 23 viewport\n\n     <meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" />\n        // width    设置viewport宽度，为一个正整数，或字符串‘device-width’\n        // device-width  设备宽度\n        // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置\n        // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数\n        // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数\n        // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数\n        // user-scalable    是否允许手动缩放\n\n- 延伸提问\n  - 怎样处理 移动端  `1px`  被 渲染成  `2px`问题\n\n局部处理\n\n- `mate`标签中的  `viewport`属性 ，`initial-scale`  设置为  `1`\n- `rem`按照设计稿标准走，外加利用`transfrome`  的`scale(0.5)`  缩小一倍即可；\n\n全局处理\n\n- `mate`标签中的  `viewport`属性 ，`initial-scale`  设置为  `0.5`\n- `rem`  按照设计稿标准走即可\n\n### 24 渲染优化\n\n- 禁止使用`iframe`（阻塞父文档`onload`事件）\n  - `iframe`会阻塞主页面的`Onload`事件\n  - 搜索引擎的检索程序无法解读这种页面，不利于 SEO\n  - `iframe`和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载\n  - 使用`iframe`之前需要考虑这两个缺点。如果需要使用`iframe`，最好是通过`javascript`\n  - 动态给`iframe`添加`src`属性值，这样可以绕开以上两个问题\n- 禁止使用`gif`图片实现`loading`效果（降低`CPU`消耗，提升渲染性能）\n- 使用`CSS3`代码代替`JS`动画（尽可能避免重绘重排以及回流）\n- 对于一些小图标，可以使用 base64 位编码，以减少网络请求。但不建议大图使用，比较耗费`CPU`\n  - 减少`HTTP`请求\n  - 避免文件跨域\n  - 修改及时生效\n  - 小图标优势在于\n- 页面头部的` <style></style>``<script></script> `  会阻塞页面；（因为  `Renderer`进程中  `JS`线程和渲染线程是互斥的）\n- 页面中空的  `href`  和  `src`  会阻塞页面其他资源的加载 (阻塞下载进程)\n- 网页`gzip`，`CDN`托管，`data`缓存 ，图片服务器\n- 前端模板 JS+数据，减少由于`HTML`标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数\n- 用`innerHTML`代替`DOM`操作，减少`DOM`操作次数，优化`javascript`性能\n- 当需要设置的样式很多时设置`className`而不是直接操作`style`\n- 少用全局变量、缓存`DOM`节点查找的结果。减少`IO`读取操作\n- 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳\n- 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘`IO`\n\n### 25 meta viewport 相关\n\n    <!DOCTYPE html>  <!--H5标准声明，使用 HTML5 doctype，不区分大小写--><head lang=”en”> <!--标准的 lang 属性写法--><meta charset=’utf-8′>    <!--声明文档使用的字符编码--><meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/>   <!--优先使用 IE 最新版本和 Chrome--><meta name=”description” content=”不超过150个字符”/>       <!--页面描述--><meta name=”keywords” content=””/>     <!-- 页面关键词--><meta name=”author” content=”name, email@gmail.com”/>    <!--网页作者--><meta name=”robots” content=”index,follow”/>      <!--搜索引擎抓取--><meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”> <!--为移动设备添加 viewport--><meta name=”apple-mobile-web-app-title” content=”标题”> <!--iOS 设备 begin--><meta name=”apple-mobile-web-app-capable” content=”yes”/>  <!--添加到主屏后的标题（iOS 6 新增）\n    是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--><meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”><!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--><meta name=”apple-mobile-web-app-status-bar-style” content=”black”/><meta name=”format-detection” content=”telphone=no, email=no”/>  <!--设置苹果工具栏颜色--><meta name=”renderer” content=”webkit”> <!-- 启用360浏览器的极速模式(webkit)--><meta http-equiv=”X-UA-Compatible” content=”IE=edge”>     <!--避免IE使用兼容模式--><meta http-equiv=”Cache-Control” content=”no-siteapp” />    <!--不让百度转码--><meta name=”HandheldFriendly” content=”true”>     <!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--><meta name=”MobileOptimized” content=”320″>   <!--微软的老式浏览器--><meta name=”screen-orientation” content=”portrait”>   <!--uc强制竖屏--><meta name=”x5-orientation” content=”portrait”>    <!--QQ强制竖屏--><meta name=”full-screen” content=”yes”>              <!--UC强制全屏--><meta name=”x5-fullscreen” content=”true”>       <!--QQ强制全屏--><meta name=”browsermode” content=”application”>   <!--UC应用模式--><meta name=”x5-page-mode” content=”app”>   <!-- QQ应用模式--><meta name=”msapplication-tap-highlight” content=”no”>    <!--windows phone 点击无高亮\n    设置页面不缓存--><meta http-equiv=”pragma” content=”no-cache”><meta http-equiv=”cache-control” content=”no-cache”><meta http-equiv=”expires” content=”0″>\n\n### 26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?\n\n- `IE`: `trident`内核\n- `Firefox`：`gecko`内核\n- `Safari`:`webkit`内核\n- `Opera`:以前是`presto`内核，`Opera`现已改用 Google - `Chrome`的`Blink`内核\n- `Chrome:Blink`(基于`webkit`，Google 与 Opera Software 共同开发)\n\n### 27 div+css 的布局较 table 布局有什么优点？\n\n- 改版的时候更方便 只要改`css`文件。\n- 页面加载速度更快、结构化清晰、页面显示简洁。\n- 表现与结构相分离。\n- 易于优化（`seo`）搜索引擎更友好，排名更容易靠前。\n\n### 28 a：img 的 alt 与 title 有何异同？b：strong 与 em 的异同？\n\n- `alt(alt text)`:为不能显示图像、窗体或`applets`的用户代理（`UA`），`alt`属性用来指定替换文字。替换文字的语言由`lang`属性指定。(在 IE 浏览器下会在没有`title`时把`alt`当成  `tool tip`显示)\n- `title(tool tip)`:该属性为设置该属性的元素提供建议性的信息\n- `strong`:粗体强调标签，强调，表示内容的重要性\n- `em`:斜体强调标签，更强烈强调，表示内容的强调点\n\n### 29 你能描述一下渐进增强和优雅降级之间的不同吗\n\n- 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n- 优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。\n\n> 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带\n\n### 30 为什么利用多个域名来存储网站资源会更有效？\n\n- `CDN`缓存更方便\n- 突破浏览器并发限制\n- 节约`cookie`带宽\n- 节约主域名的连接数，优化页面响应速度\n- 防止不必要的安全问题\n\n### 31 简述一下 src 与 href 的区别\n\n- `src`用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。\n- `src`是`source`的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求`src`资源时会将其指向的资源下载并应用到文档内，例如`js`脚本，`img`图片和`frame`等元素\n\n> `<script src =\"js.js\"></script>`  当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部\n\n- `href`是`Hypertext Reference`的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加\n- `<link href=\"common.css\" rel=\"stylesheet\"/>`那么浏览器会识别该文档为`css`文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用`link`方式来加载`css`，而不是使用`@import`方式\n\n### 32 知道的网页制作会用到的图片格式有哪些？\n\n- `png-8`、`png-24`、`jpeg`、`gif`、`svg`\n\n> 但是上面的那些都不是面试官想要的最后答案。面试官希望听到是`Webp`,`Apng`。（是否有关注新技术，新鲜事物）\n\n- Webp：`WebP`格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有`JPEG`的`2/3`，并能节省大量的服务器带宽资源和数据空间。`Facebook Ebay`等知名网站已经开始测试并使用`WebP`格式。\n- 在质量相同的情况下，WebP 格式图像的体积要比 JPEG 格式图像小`40%`。\n- Apng：全称是`“Animated Portable Network Graphics”`, 是 PNG 的位图动画扩展，可以实现 png 格式的动态图片效果。04 年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到  `iOS safari 8`的支持，有望代替`GIF`成为下一代动态图标准\n\n### 33.1 在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？\n\n> `dns`缓存，`cdn`缓存，浏览器缓存，服务器缓存\n\n### 33.2 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。\n\n- 图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。\n- 如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。\n- 如果图片为 css 图片，可以使用`CSSsprite`，`SVGsprite`，`Iconfont`、`Base64`等技术。\n- 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。\n- 如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。\n\n### 34 常见排序算法的时间复杂度,空间复杂度\n\n![](https://github.com/qiu-deqing/FE-interview/raw/master/img/sort-compare.png)\n\n### 35 web 开发中会话跟踪的方法有哪些\n\n- `cookie`\n- `session`\n- `url`重写\n- 隐藏`input`\n- `ip`地址\n\n### 36 HTTP request 报文结构是怎样的\n\n1.  首行是 Request-Line 包括：请求方法，请求 URI，协议版本，CRLF\n2.  首行之后是若干行请求头，包括 general-header，request-header 或者 entity-header，每个一行以 CRLF 结束\n3.  请求头和消息实体之间有一个 CRLF 分隔\n4.  根据实际请求需要可能包含一个消息实体   一个请求报文例子如下：\n\n    GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1\n    Host: www.w3.org\n    Connection: keep-alive\n    Cache-Control: max-age=0\n    Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,_/_;q=0.8\n    User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36\n    Referer: https://www.google.com.hk/\n    Accept-Encoding: gzip,deflate,sdch\n    Accept-Language: zh-CN,zh;q=0.8,en;q=0.6\n    Cookie: authorstyle=yes\n    If-None-Match: \"2cc8-3e3073913b100\"\n    If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT\n\n    name=qiu&age=25\n\n### 37 HTTP response 报文结构是怎样的\n\n- 首行是状态行包括：HTTP 版本，状态码，状态描述，后面跟一个 CRLF\n- 首行之后是若干行响应头，包括：通用头部，响应头部，实体头部\n- 响应头部和响应实体之间用一个 CRLF 空行分隔\n- 最后是一个可能的消息实体   响应报文例子如下：\n\n  HTTP/1.1 200 OK\n  Date: Tue, 08 Jul 2014 05:28:43 GMT\n  Server: Apache/2\n  Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT\n  ETag: \"40d7-3e3073913b100\"\n  Accept-Ranges: bytes\n  Content-Length: 16599\n  Cache-Control: max-age=21600\n  Expires: Tue, 08 Jul 2014 11:28:43 GMT\n  P3P: policyref=\"http://www.w3.org/2001/05/P3P/p3p.xml\"\n  Content-Type: text/html; charset=iso-8859-1\n\n  {\"name\": \"qiu\", \"age\": 25}\n","slug":"2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86-e5-9f-ba-e7-a1-80-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8","published":1,"updated":"2019-09-12T02:59:49.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269gn005xc8gsdp4x75sy","content":"<h2 id=\"一、HTML、HTTP、web-综合问题\"><a href=\"#一、HTML、HTTP、web-综合问题\" class=\"headerlink\" title=\"一、HTML、HTTP、web 综合问题\"></a>一、HTML、HTTP、web 综合问题</h2><h3 id=\"1-前端需要注意哪些-SEO\"><a href=\"#1-前端需要注意哪些-SEO\" class=\"headerlink\" title=\"1 前端需要注意哪些 SEO\"></a>1 前端需要注意哪些 SEO</h3><ul>\n<li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li>\n<li>语义化的<code>HTML</code>代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</li>\n<li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>\n<li>重要内容不要用<code>js</code>输出：爬虫不会执行 js 获取内容</li>\n<li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li>\n<li>非装饰性图片必须加<code>alt</code></li>\n<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>\n</ul>\n<h3 id=\"2-lt-img-gt-的title和alt有什么区别\"><a href=\"#2-lt-img-gt-的title和alt有什么区别\" class=\"headerlink\" title=\"2 &lt;img&gt;的title和alt有什么区别\"></a>2 <code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h3><ul>\n<li>通常当鼠标滑动到元素上的时候显示</li>\n<li><code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li>\n</ul>\n<h3 id=\"3-HTTP-的几种请求方法用途\"><a href=\"#3-HTTP-的几种请求方法用途\" class=\"headerlink\" title=\"3 HTTP 的几种请求方法用途\"></a>3 HTTP 的几种请求方法用途</h3><ul>\n<li><code>GET</code>方法<ul>\n<li>发送一个请求来取得服务器上的某一资源</li>\n</ul>\n</li>\n<li><code>POST</code>方法<ul>\n<li>向<code>URL</code>指定的资源提交数据或附加新的数据</li>\n</ul>\n</li>\n<li><code>PUT</code>方法<ul>\n<li>跟<code>POST</code>方法很像，也是想服务器提交数据。但是，它们之间有不同。<code>PUT</code>指定了资源在服务器上的位置，而<code>POST</code>没有</li>\n</ul>\n</li>\n<li><code>HEAD</code>方法<ul>\n<li>只请求页面的首部</li>\n</ul>\n</li>\n<li><code>DELETE</code>方法<ul>\n<li>删除服务器上的某资源</li>\n</ul>\n</li>\n<li><code>OPTIONS</code>方法<ul>\n<li>它用于获取当前<code>URL</code>所支持的方法。如果请求成功，会有一个<code>Allow</code>的头包含类似<code>“GET,POST”</code>这样的信息</li>\n</ul>\n</li>\n<li><code>TRACE</code>方法<ul>\n<li><code>TRACE</code>方法被用于激发一个远程的，应用层的请求消息回路</li>\n</ul>\n</li>\n<li><code>CONNECT</code>方法<ul>\n<li>把请求连接转换到透明的<code>TCP/IP</code>通道</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-从浏览器地址栏输入-url-到显示页面的步骤\"><a href=\"#4-从浏览器地址栏输入-url-到显示页面的步骤\" class=\"headerlink\" title=\"4 从浏览器地址栏输入 url 到显示页面的步骤\"></a>4 从浏览器地址栏输入 url 到显示页面的步骤</h3><p>基础版本</p>\n<ul>\n<li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li>\n<li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</li>\n<li>浏览器对加载到的资源（<code>HTML、JS、CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li>\n<li>载入解析到的资源文件，渲染页面，完成。</li>\n</ul>\n<p>详细版</p>\n<ol>\n<li><p> 在浏览器地址栏输入 URL</p>\n</li>\n<li><p>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p>\n<ul>\n<li>HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期</li>\n<li>HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li>\n</ul>\n<ol>\n<li> 如果资源未缓存，发起新请求</li>\n<li> 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li>\n<li> 检验新鲜通常有两个 HTTP 头进行控制<code>Expires</code>和<code>Cache-Control</code>：</li>\n</ol>\n</li>\n<li><p> 浏览器解析 URL 获取协议，主机，端口，path</p>\n</li>\n<li><p> 浏览器组装一个 HTTP（GET）请求报文</p>\n</li>\n<li><p>浏览器获取主机 ip 地址，过程如下：</p>\n<ol>\n<li> 浏览器缓存</li>\n<li> 本机缓存</li>\n<li> hosts 文件</li>\n<li> 路由器缓存</li>\n<li> ISP DNS 缓存</li>\n<li> DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）</li>\n</ol>\n</li>\n<li><p>打开一个 socket 与目标 IP 地址，端口建立 TCP 链接，三次握手如下：</p>\n<ol>\n<li> 客户端发送一个 TCP 的 SYN=1，Seq=X 的包到服务器端口</li>\n<li> 服务器发回 SYN=1， ACK=X+1， Seq=Y 的响应包</li>\n<li> 客户端发送 ACK=Y+1， Seq=Z</li>\n</ol>\n</li>\n<li><p> TCP 链接建立后发送 HTTP 请求</p>\n</li>\n<li><p> 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序</p>\n</li>\n<li><p> 服务器检查 HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回 304 等对应状态码</p>\n</li>\n<li><p>处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作</p>\n</li>\n<li><p>服务器将响应报文通过 TCP 连接发送回浏览器</p>\n</li>\n<li><p>浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下：</p>\n<ol>\n<li> 主动方发送 Fin=1， Ack=Z， Seq= X 报文</li>\n<li> 被动方发送 ACK=X+1， Seq=Z 报文</li>\n<li> 被动方发送 Fin=1， ACK=X， Seq=Y 报文</li>\n<li> 主动方发送 ACK=Y， Seq=X 报文</li>\n</ol>\n</li>\n<li><p>浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同</p>\n</li>\n<li><p>如果资源可缓存，进行缓存</p>\n</li>\n<li><p>对响应进行解码（例如 gzip 压缩）</p>\n</li>\n<li><p>根据资源类型决定如何处理（假设资源为 HTML 文档）</p>\n</li>\n<li><p>解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释</p>\n</li>\n<li><p>构建 DOM 树：</p>\n<ol>\n<li> Tokenizing：根据 HTML 规范将字符流解析为标记</li>\n<li> Lexing：词法分析将标记转换为对象并定义属性和规则</li>\n<li> DOM construction：根据 HTML 标记关系将对象组成 DOM 树</li>\n</ol>\n</li>\n<li><p>解析过程中遇到图片、样式表、js 文件，启动下载</p>\n</li>\n<li><p>构建 CSSOM 树：</p>\n<ol>\n<li> Tokenizing：字符流转换为标记流</li>\n<li> Node：根据标记创建节点</li>\n<li> CSSOM：节点创建 CSSOM 树</li>\n</ol>\n</li>\n<li><p>根据 DOM 树和 CSSOM 树构建渲染树:</p>\n<ol>\n<li> 从 DOM 树的根节点遍历所有可见节点，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被 css 隐藏的节点，如<code>display: none</code></li>\n<li> 对每一个可见节点，找到恰当的 CSSOM 规则并应用</li>\n<li> 发布可视节点的内容和计算样式</li>\n</ol>\n</li>\n<li><p>js 解析如下：</p>\n<ol>\n<li> 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时 document.readystate 为 loading</li>\n<li> HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容</li>\n<li> 当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素</li>\n<li> 当文档完成解析，document.readState 变成 interactive</li>\n<li> 所有 defer 脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()</li>\n<li> 浏览器在 Document 对象上触发 DOMContentLoaded 事件</li>\n<li> 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete，window 触发 load 事件</li>\n</ol>\n</li>\n<li><p>显示页面（HTML 解析过程中会逐步显示页面）</p>\n</li>\n</ol>\n<p>详细简版</p>\n<ol>\n<li> 从浏览器接收<code>url</code>到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li>\n<li> 开启网络线程到发出一个完整的<code>HTTP</code>请求（这一部分涉及到 dns 查询，<code>TCP/IP</code>请求，五层因特网协议栈等知识）</li>\n<li> 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li>\n<li> 后台和前台的<code>HTTP</code>交互（这一部分包括<code>HTTP</code>头部、响应码、报文结构、<code>cookie</code>等知识，可以提下静态资源的<code>cookie</code>优化，以及编码解码，如<code>gzip</code>压缩等）</li>\n<li> 单独拎出来的缓存问题，<code>HTTP</code>的缓存（这部分包括 http 缓存头部，<code>ETag</code>，<code>catch-control</code>等）</li>\n<li> 浏览器接收到<code>HTTP</code>数据包后的解析流程（解析<code>html</code>-词法分析然后解析成<code>dom</code>树、解析<code>css</code>生成<code>css</code>规则树、合并成<code>render</code>树，然后<code>layout</code>、<code>painting</code>渲染、复合图层的合成、<code>GPU</code>绘制、外链资源的处理、<code>loaded</code>和<code>DOMContentLoaded</code>等）</li>\n<li> <code>CSS</code>的可视化格式模型（元素的渲染规则，如包含块，控制框，<code>BFC</code>，<code>IFC</code>等概念）</li>\n<li> <code>JS</code>引擎解析过程（<code>JS</code>的解释阶段，预处理阶段，执行阶段生成执行上下文，<code>VO</code>，作用域链、回收机制等等）</li>\n<li> 其它（可以拓展不同的知识模块，如跨域，web 安全，<code>hybrid</code>模式等等内容）</li>\n</ol>\n<h3 id=\"5-如何进行网站性能优化\"><a href=\"#5-如何进行网站性能优化\" class=\"headerlink\" title=\"5 如何进行网站性能优化\"></a>5 如何进行网站性能优化</h3><ul>\n<li><code>content</code>方面<ul>\n<li>减少<code>HTTP</code>请求：合并文件、<code>CSS</code>精灵、<code>inline Image</code></li>\n<li>减少<code>DNS</code>查询：<code>DNS</code>缓存、将资源分布到恰当数量的主机名</li>\n<li>减少<code>DOM</code>元素数量</li>\n</ul>\n</li>\n<li><code>Server</code>方面<ul>\n<li>使用<code>CDN</code></li>\n<li>配置<code>ETag</code></li>\n<li>对组件使用<code>Gzip</code>压缩</li>\n</ul>\n</li>\n<li><code>Cookie</code>方面<ul>\n<li>减小<code>cookie</code>大小</li>\n</ul>\n</li>\n<li><code>css</code>方面<ul>\n<li>将样式表放到页面顶部</li>\n<li>不使用<code>CSS</code>表达式</li>\n<li>使用<code>&lt;link&gt;</code>不使用<code>@import</code></li>\n</ul>\n</li>\n<li><code>Javascript</code>方面<ul>\n<li>将脚本放到页面底部</li>\n<li>将<code>javascript</code>和<code>css</code>从外部引入</li>\n<li>压缩<code>javascript</code>和<code>css</code></li>\n<li>删除不需要的脚本</li>\n<li>减少<code>DOM</code>访问</li>\n</ul>\n</li>\n<li>图片方面<ul>\n<li>优化图片：根据实际颜色需要选择色深、压缩</li>\n<li>优化<code>css</code>精灵</li>\n<li>不要在<code>HTML</code>中拉伸图片</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-HTTP-状态码及其含义\"><a href=\"#6-HTTP-状态码及其含义\" class=\"headerlink\" title=\"6 HTTP 状态码及其含义\"></a>6 HTTP 状态码及其含义</h3><ul>\n<li><code>1XX</code>：信息状态码<ul>\n<li><code>100 Continue</code>  继续，一般在发送<code>post</code>请求时，已发送了<code>http header</code>之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n</ul>\n</li>\n<li><code>2XX</code>：成功状态码<ul>\n<li><code>200 OK</code>  正常返回信息</li>\n<li><code>201 Created</code>  请求成功并且服务器创建了新的资源</li>\n<li><code>202 Accepted</code>  服务器已接受请求，但尚未处理</li>\n</ul>\n</li>\n<li><code>3XX</code>：重定向<ul>\n<li><code>301 Moved Permanently</code>  请求的网页已永久移动到新位置。</li>\n<li><code>302 Found</code>  临时性重定向。</li>\n<li><code>303 See Other</code>  临时性重定向，且总是使用  <code>GET</code>  请求新的  <code>URI</code>。</li>\n<li><code>304 Not Modified</code>  自从上次请求后，请求的网页未修改过。</li>\n</ul>\n</li>\n<li><code>4XX</code>：客户端错误<ul>\n<li><code>400 Bad Request</code>  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>\n<li><code>401 Unauthorized</code>  请求未授权。</li>\n<li><code>403 Forbidden</code>  禁止访问。</li>\n<li><code>404 Not Found</code>  找不到如何与  <code>URI</code>  相匹配的资源。</li>\n</ul>\n</li>\n<li><code>5XX:</code>  服务器错误<ul>\n<li><code>500 Internal Server Error</code>  最常见的服务器端错误。</li>\n<li><code>503 Service Unavailable</code>  服务器端暂时无法处理请求（可能是过载或维护）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-语义化的理解\"><a href=\"#7-语义化的理解\" class=\"headerlink\" title=\"7 语义化的理解\"></a>7 语义化的理解</h3><ul>\n<li>用正确的标签做正确的事情！</li>\n<li><code>HTML</code>语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；</li>\n<li>在没有样式<code>CSS</code>情况下也以一种文档格式显示，并且是容易阅读的。</li>\n<li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于  <code>SEO</code>。</li>\n<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li>\n</ul>\n<h3 id=\"8-介绍一下你对浏览器内核的理解？\"><a href=\"#8-介绍一下你对浏览器内核的理解？\" class=\"headerlink\" title=\"8 介绍一下你对浏览器内核的理解？\"></a>8 介绍一下你对浏览器内核的理解？</h3><ul>\n<li>主要分成两部分：渲染引擎(<code>layout engineer</code>或<code>Rendering Engine</code>)和<code>JS</code>引擎</li>\n<li>渲染引擎：负责取得网页的内容（<code>HTML</code>、<code>XML</code>、图像等等）、整理讯息（例如加入<code>CSS</code>等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核</li>\n<li><code>JS</code>引擎则：解析和执行<code>javascript</code>来实现网页的动态效果</li>\n<li>最开始渲染引擎和<code>JS</code>引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎</li>\n</ul>\n<h3 id=\"9-html5-有哪些新特性、移除了那些元素？\"><a href=\"#9-html5-有哪些新特性、移除了那些元素？\" class=\"headerlink\" title=\"9 html5 有哪些新特性、移除了那些元素？\"></a>9 html5 有哪些新特性、移除了那些元素？</h3><ul>\n<li><code>HTML5</code>  现在已经不是  <code>SGML</code>  的子集，主要是关于图像，位置，存储，多任务等功能的增加<ul>\n<li>绘画  <code>canvas</code></li>\n<li>用于媒介回放的  <code>video</code>  和  <code>audio</code>  元素</li>\n<li>本地离线存储  <code>localStorage</code>  长期存储数据，浏览器关闭后数据不丢失</li>\n<li><code>sessionStorage</code>  的数据在浏览器关闭后自动删除</li>\n<li>语意化更好的内容元素，比如<code>article</code>、<code>footer</code>、<code>header</code>、<code>nav</code>、<code>section</code></li>\n<li>表单控件，<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code></li>\n<li>新的技术<code>webworker</code>、 <code>websocket</code>、 <code>Geolocation</code></li>\n</ul>\n</li>\n<li>移除的元素：<ul>\n<li>纯表现的元素：<code>basefont</code>、<code>big</code>、<code>center</code>、<code>font</code>、 <code>s</code>、<code>strike</code>、<code>tt</code>、<code>u</code></li>\n<li>对可用性产生负面影响的元素：<code>frame</code>、<code>frameset</code>、<code>noframes</code></li>\n</ul>\n</li>\n<li>支持<code>HTML5</code>新标签：<ul>\n<li><code>IE8/IE7/IE6</code>支持通过<code>document.createElement</code>方法产生的标签</li>\n<li>可以利用这一特性让这些浏览器支持<code>HTML5</code>新标签</li>\n<li>浏览器支持新标签后，还需要添加标签默认的样式</li>\n</ul>\n</li>\n<li>当然也可以直接使用成熟的框架、比如<code>html5shim</code></li>\n</ul>\n<h3 id=\"10-HTML5的离线储存怎么使用，工作原理能不能解释一下？\"><a href=\"#10-HTML5的离线储存怎么使用，工作原理能不能解释一下？\" class=\"headerlink\" title=\"10 HTML5的离线储存怎么使用，工作原理能不能解释一下？\"></a>10 <code>HTML5</code>的离线储存怎么使用，工作原理能不能解释一下？</h3><ul>\n<li><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件</p>\n</li>\n<li><p>原理：<code>HTML5</code>的离线存储是基于一个新建的<code>.appcache</code>文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像<code>cookie</code>一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>\n</li>\n<li><p>如何使用：</p>\n<ul>\n<li>页面头部像下面一样加入一个<code>manifest</code>的属性；</li>\n<li>在<code>cache.manifest</code>文件的编写离线存储的资源</li>\n<li>在离线状态时，操作<code>window.applicationCache</code>进行需求实现</li>\n</ul>\n<p>CACHE MANIFEST<br>#v0.11CACHE:js/app.js<br>css/style.css<br>NETWORK:resourse/logo.png<br>FALLBACK:/offline.html</p>\n</li>\n</ul>\n<h3 id=\"11-浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\"><a href=\"#11-浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\" class=\"headerlink\" title=\"11 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\"></a>11 浏览器是怎么对<code>HTML5</code>的离线储存资源进行管理和加载的呢</h3><ul>\n<li>在线的情况下，浏览器发现<code>html</code>头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是第一次访问<code>app</code>，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过<code>app</code>并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的<code>manifest</code>文件与旧的<code>manifest</code>文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li>\n<li>离线的情况下，浏览器就直接使用离线存储的资源。</li>\n</ul>\n<h3 id=\"12-请描述一下-cookies，sessionStorage-和-localStorage-的区别？\"><a href=\"#12-请描述一下-cookies，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"12 请描述一下  cookies，sessionStorage  和  localStorage  的区别？\"></a>12 请描述一下  <code>cookies</code>，<code>sessionStorage</code>  和  <code>localStorage</code>  的区别？</h3><ul>\n<li><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li>\n<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li>\n<li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li>\n<li>存储大小：<ul>\n<li><code>cookie</code>数据大小不能超过 4k</li>\n<li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到 5M 或更大</li>\n</ul>\n</li>\n<li>有期时间：<ul>\n<li><code>localStorage</code>  存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>\n<li><code>sessionStorage</code>  数据在当前浏览器窗口关闭后自动删除</li>\n<li><code>cookie</code>  设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"13-iframe-有那些缺点？\"><a href=\"#13-iframe-有那些缺点？\" class=\"headerlink\" title=\"13 iframe 有那些缺点？\"></a>13 iframe 有那些缺点？</h3><ul>\n<li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li>\n<li>搜索引擎的检索程序无法解读这种页面，不利于<code>SEO</code></li>\n<li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>\n<li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li>\n</ul>\n<h3 id=\"14-WEB-标准以及-W3C-标准是什么\"><a href=\"#14-WEB-标准以及-W3C-标准是什么\" class=\"headerlink\" title=\"14 WEB 标准以及 W3C 标准是什么?\"></a>14 WEB 标准以及 W3C 标准是什么?</h3><ul>\n<li>标签闭合、标签小写、不乱嵌套、使用外链<code>css</code>和<code>js</code>、结构行为表现的分离</li>\n</ul>\n<h3 id=\"15-xhtml-和-html-有什么区别\"><a href=\"#15-xhtml-和-html-有什么区别\" class=\"headerlink\" title=\"15 xhtml 和 html 有什么区别?\"></a>15 xhtml 和 html 有什么区别?</h3><ul>\n<li>一个是功能上的差别<ul>\n<li>主要是<code>XHTML</code>可兼容各大浏览器、手机以及<code>PDA</code>，并且浏览器也能快速正确地编译网页</li>\n</ul>\n</li>\n<li>另外是书写习惯的差别<ul>\n<li><code>XHTML</code>  元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"16-Doctype-作用-严格模式与混杂模式如何区分？它们有何意义\"><a href=\"#16-Doctype-作用-严格模式与混杂模式如何区分？它们有何意义\" class=\"headerlink\" title=\"16 Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?\"></a>16 Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><ul>\n<li>页面被加载的时，<code>link</code>会同时被加载，而<code>@imort</code>页面被加载的时，<code>link</code>会同时被加载，而<code>@import</code>引用的<code>CSS</code>会等到页面被加载完再加载  <code>import</code>只在<code>IE5</code>以上才能识别，而<code>link</code>是<code>XHTML</code>标签，无兼容问题  <code>link</code>方式的样式的权重 高于<code>@import</code>的权重</li>\n<li><code>&lt;!DOCTYPE&gt;</code>  声明位于文档中的最前面，处于  <code>&lt;html&gt;</code>  标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档</li>\n<li>严格模式的排版和  <code>JS</code>  运作模式是 以该浏览器支持的最高标准运行</li>\n<li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 <code>DOCTYPE</code>不存在或格式不正确会导致文档以混杂模式呈现</li>\n</ul>\n<h3 id=\"17-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？\"><a href=\"#17-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？\" class=\"headerlink\" title=\"17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？\"></a>17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</h3><ul>\n<li>行内元素有：<code>a b span img input select strong</code></li>\n<li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4… p</code></li>\n<li>空元素：<code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li>\n<li>行内元素不可以设置宽高，不独占一行</li>\n<li>块级元素可以设置宽高，独占一行</li>\n</ul>\n<h3 id=\"18-HTML-全局属性-global-attribute-有哪些\"><a href=\"#18-HTML-全局属性-global-attribute-有哪些\" class=\"headerlink\" title=\"18 HTML 全局属性(global attribute)有哪些\"></a>18 HTML 全局属性(global attribute)有哪些</h3><ul>\n<li><code>class</code>:为元素设置类标识</li>\n<li><code>data-*</code>: 为元素增加自定义属性</li>\n<li><code>draggable</code>: 设置元素是否可拖拽</li>\n<li><code>id</code>: 元素<code>id</code>，文档内唯一</li>\n<li><code>lang</code>: 元素内容的的语言</li>\n<li><code>style</code>: 行内<code>css</code>样式</li>\n<li><code>title</code>: 元素相关的建议信息</li>\n<li><code>svg</code>绘制出来的每一个图形的元素都是独立的<code>DOM</code>节点，能够方便的绑定事件或用来修改。<code>canvas</code>输出的是一整幅画布</li>\n<li><code>svg</code>输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而<code>canvas</code>输出标量画布，就像一张图片一样，放大会失真或者锯齿</li>\n<li>20 HTML5 为什么只需要写 <!DOCTYPE HTML></li>\n<li><code>HTML5</code>  不基于  <code>SGML</code>，因此不需要对<code>DTD</code>进行引用，但是需要<code>doctype</code>来规范浏览器的行为</li>\n<li>而<code>HTML4.01</code>基于<code>SGML</code>,所以需要对<code>DTD</code>进行引用，才能告知浏览器文档所使用的文档类型</li>\n</ul>\n<h3 id=\"21-如何在页面上实现一个圆形的可点击区域？\"><a href=\"#21-如何在页面上实现一个圆形的可点击区域？\" class=\"headerlink\" title=\"21 如何在页面上实现一个圆形的可点击区域？\"></a>21 如何在页面上实现一个圆形的可点击区域？</h3><ul>\n<li><code>svg</code></li>\n<li><code>border-radius</code></li>\n<li>纯<code>js</code>实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li>\n</ul>\n<h3 id=\"22-网页验证码是干嘛的，是为了解决什么安全问题\"><a href=\"#22-网页验证码是干嘛的，是为了解决什么安全问题\" class=\"headerlink\" title=\"22 网页验证码是干嘛的，是为了解决什么安全问题\"></a>22 网页验证码是干嘛的，是为了解决什么安全问题</h3><ul>\n<li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li>\n<li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li>\n</ul>\n<h3 id=\"23-viewport\"><a href=\"#23-viewport\" class=\"headerlink\" title=\"23 viewport\"></a>23 viewport</h3><pre><code> &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n    // width    设置viewport宽度，为一个正整数，或字符串‘device-width’\n    // device-width  设备宽度\n    // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置\n    // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数\n    // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数\n    // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数\n    // user-scalable    是否允许手动缩放\n</code></pre>\n<ul>\n<li>延伸提问<ul>\n<li>怎样处理 移动端  <code>1px</code>  被 渲染成  <code>2px</code>问题</li>\n</ul>\n</li>\n</ul>\n<p>局部处理</p>\n<ul>\n<li><code>mate</code>标签中的  <code>viewport</code>属性 ，<code>initial-scale</code>  设置为  <code>1</code></li>\n<li><code>rem</code>按照设计稿标准走，外加利用<code>transfrome</code>  的<code>scale(0.5)</code>  缩小一倍即可；</li>\n</ul>\n<p>全局处理</p>\n<ul>\n<li><code>mate</code>标签中的  <code>viewport</code>属性 ，<code>initial-scale</code>  设置为  <code>0.5</code></li>\n<li><code>rem</code>  按照设计稿标准走即可</li>\n</ul>\n<h3 id=\"24-渲染优化\"><a href=\"#24-渲染优化\" class=\"headerlink\" title=\"24 渲染优化\"></a>24 渲染优化</h3><ul>\n<li>禁止使用<code>iframe</code>（阻塞父文档<code>onload</code>事件）<ul>\n<li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li>\n<li>搜索引擎的检索程序无法解读这种页面，不利于 SEO</li>\n<li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>\n<li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code></li>\n<li>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li>\n</ul>\n</li>\n<li>禁止使用<code>gif</code>图片实现<code>loading</code>效果（降低<code>CPU</code>消耗，提升渲染性能）</li>\n<li>使用<code>CSS3</code>代码代替<code>JS</code>动画（尽可能避免重绘重排以及回流）</li>\n<li>对于一些小图标，可以使用 base64 位编码，以减少网络请求。但不建议大图使用，比较耗费<code>CPU</code><ul>\n<li>减少<code>HTTP</code>请求</li>\n<li>避免文件跨域</li>\n<li>修改及时生效</li>\n<li>小图标优势在于</li>\n</ul>\n</li>\n<li>页面头部的<code>&lt;style&gt;&lt;/style&gt;``&lt;script&gt;&lt;/script&gt;</code>  会阻塞页面；（因为  <code>Renderer</code>进程中  <code>JS</code>线程和渲染线程是互斥的）</li>\n<li>页面中空的  <code>href</code>  和  <code>src</code>  会阻塞页面其他资源的加载 (阻塞下载进程)</li>\n<li>网页<code>gzip</code>，<code>CDN</code>托管，<code>data</code>缓存 ，图片服务器</li>\n<li>前端模板 JS+数据，减少由于<code>HTML</code>标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数</li>\n<li>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</li>\n<li>当需要设置的样式很多时设置<code>className</code>而不是直接操作<code>style</code></li>\n<li>少用全局变量、缓存<code>DOM</code>节点查找的结果。减少<code>IO</code>读取操作</li>\n<li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li>\n<li>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘<code>IO</code></li>\n</ul>\n<h3 id=\"25-meta-viewport-相关\"><a href=\"#25-meta-viewport-相关\" class=\"headerlink\" title=\"25 meta viewport 相关\"></a>25 meta viewport 相关</h3><pre><code>&lt;!DOCTYPE html&gt;  &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;&lt;head lang=”en”&gt; &lt;!--标准的 lang 属性写法--&gt;&lt;meta charset=’utf-8′&gt;    &lt;!--声明文档使用的字符编码--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt;   &lt;!--优先使用 IE 最新版本和 Chrome--&gt;&lt;meta name=”description” content=”不超过150个字符”/&gt;       &lt;!--页面描述--&gt;&lt;meta name=”keywords” content=””/&gt;     &lt;!-- 页面关键词--&gt;&lt;meta name=”author” content=”name, email@gmail.com”/&gt;    &lt;!--网页作者--&gt;&lt;meta name=”robots” content=”index,follow”/&gt;      &lt;!--搜索引擎抓取--&gt;&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt; &lt;!--为移动设备添加 viewport--&gt;&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; &lt;!--iOS 设备 begin--&gt;&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;  &lt;!--添加到主屏后的标题（iOS 6 新增）\n是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;&lt;!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--&gt;&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt;  &lt;!--设置苹果工具栏颜色--&gt;&lt;meta name=”renderer” content=”webkit”&gt; &lt;!-- 启用360浏览器的极速模式(webkit)--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;     &lt;!--避免IE使用兼容模式--&gt;&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;    &lt;!--不让百度转码--&gt;&lt;meta name=”HandheldFriendly” content=”true”&gt;     &lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--&gt;&lt;meta name=”MobileOptimized” content=”320″&gt;   &lt;!--微软的老式浏览器--&gt;&lt;meta name=”screen-orientation” content=”portrait”&gt;   &lt;!--uc强制竖屏--&gt;&lt;meta name=”x5-orientation” content=”portrait”&gt;    &lt;!--QQ强制竖屏--&gt;&lt;meta name=”full-screen” content=”yes”&gt;              &lt;!--UC强制全屏--&gt;&lt;meta name=”x5-fullscreen” content=”true”&gt;       &lt;!--QQ强制全屏--&gt;&lt;meta name=”browsermode” content=”application”&gt;   &lt;!--UC应用模式--&gt;&lt;meta name=”x5-page-mode” content=”app”&gt;   &lt;!-- QQ应用模式--&gt;&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;    &lt;!--windows phone 点击无高亮\n设置页面不缓存--&gt;&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt;\n</code></pre>\n<h3 id=\"26-你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么\"><a href=\"#26-你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么\" class=\"headerlink\" title=\"26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?\"></a>26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</h3><ul>\n<li><code>IE</code>: <code>trident</code>内核</li>\n<li><code>Firefox</code>：<code>gecko</code>内核</li>\n<li><code>Safari</code>:<code>webkit</code>内核</li>\n<li><code>Opera</code>:以前是<code>presto</code>内核，<code>Opera</code>现已改用 Google - <code>Chrome</code>的<code>Blink</code>内核</li>\n<li><code>Chrome:Blink</code>(基于<code>webkit</code>，Google 与 Opera Software 共同开发)</li>\n</ul>\n<h3 id=\"27-div-css-的布局较-table-布局有什么优点？\"><a href=\"#27-div-css-的布局较-table-布局有什么优点？\" class=\"headerlink\" title=\"27 div+css 的布局较 table 布局有什么优点？\"></a>27 div+css 的布局较 table 布局有什么优点？</h3><ul>\n<li>改版的时候更方便 只要改<code>css</code>文件。</li>\n<li>页面加载速度更快、结构化清晰、页面显示简洁。</li>\n<li>表现与结构相分离。</li>\n<li>易于优化（<code>seo</code>）搜索引擎更友好，排名更容易靠前。</li>\n</ul>\n<h3 id=\"28-a：img-的-alt-与-title-有何异同？b：strong-与-em-的异同？\"><a href=\"#28-a：img-的-alt-与-title-有何异同？b：strong-与-em-的异同？\" class=\"headerlink\" title=\"28 a：img 的 alt 与 title 有何异同？b：strong 与 em 的异同？\"></a>28 a：img 的 alt 与 title 有何异同？b：strong 与 em 的异同？</h3><ul>\n<li><code>alt(alt text)</code>:为不能显示图像、窗体或<code>applets</code>的用户代理（<code>UA</code>），<code>alt</code>属性用来指定替换文字。替换文字的语言由<code>lang</code>属性指定。(在 IE 浏览器下会在没有<code>title</code>时把<code>alt</code>当成  <code>tool tip</code>显示)</li>\n<li><code>title(tool tip)</code>:该属性为设置该属性的元素提供建议性的信息</li>\n<li><code>strong</code>:粗体强调标签，强调，表示内容的重要性</li>\n<li><code>em</code>:斜体强调标签，更强烈强调，表示内容的强调点</li>\n</ul>\n<h3 id=\"29-你能描述一下渐进增强和优雅降级之间的不同吗\"><a href=\"#29-你能描述一下渐进增强和优雅降级之间的不同吗\" class=\"headerlink\" title=\"29 你能描述一下渐进增强和优雅降级之间的不同吗\"></a>29 你能描述一下渐进增强和优雅降级之间的不同吗</h3><ul>\n<li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>\n<li>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li>\n</ul>\n<blockquote>\n<p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>\n</blockquote>\n<h3 id=\"30-为什么利用多个域名来存储网站资源会更有效？\"><a href=\"#30-为什么利用多个域名来存储网站资源会更有效？\" class=\"headerlink\" title=\"30 为什么利用多个域名来存储网站资源会更有效？\"></a>30 为什么利用多个域名来存储网站资源会更有效？</h3><ul>\n<li><code>CDN</code>缓存更方便</li>\n<li>突破浏览器并发限制</li>\n<li>节约<code>cookie</code>带宽</li>\n<li>节约主域名的连接数，优化页面响应速度</li>\n<li>防止不必要的安全问题</li>\n</ul>\n<h3 id=\"31-简述一下-src-与-href-的区别\"><a href=\"#31-简述一下-src-与-href-的区别\" class=\"headerlink\" title=\"31 简述一下 src 与 href 的区别\"></a>31 简述一下 src 与 href 的区别</h3><ul>\n<li><code>src</code>用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</li>\n<li><code>src</code>是<code>source</code>的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求<code>src</code>资源时会将其指向的资源下载并应用到文档内，例如<code>js</code>脚本，<code>img</code>图片和<code>frame</code>等元素</li>\n</ul>\n<blockquote>\n<p><code>&lt;script src =&quot;js.js&quot;&gt;&lt;/script&gt;</code>  当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部</p>\n</blockquote>\n<ul>\n<li><code>href</code>是<code>Hypertext Reference</code>的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</li>\n<li><code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</code>那么浏览器会识别该文档为<code>css</code>文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用<code>link</code>方式来加载<code>css</code>，而不是使用<code>@import</code>方式</li>\n</ul>\n<h3 id=\"32-知道的网页制作会用到的图片格式有哪些？\"><a href=\"#32-知道的网页制作会用到的图片格式有哪些？\" class=\"headerlink\" title=\"32 知道的网页制作会用到的图片格式有哪些？\"></a>32 知道的网页制作会用到的图片格式有哪些？</h3><ul>\n<li><code>png-8</code>、<code>png-24</code>、<code>jpeg</code>、<code>gif</code>、<code>svg</code></li>\n</ul>\n<blockquote>\n<p>但是上面的那些都不是面试官想要的最后答案。面试官希望听到是<code>Webp</code>,<code>Apng</code>。（是否有关注新技术，新鲜事物）</p>\n</blockquote>\n<ul>\n<li>Webp：<code>WebP</code>格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有<code>JPEG</code>的<code>2/3</code>，并能节省大量的服务器带宽资源和数据空间。<code>Facebook Ebay</code>等知名网站已经开始测试并使用<code>WebP</code>格式。</li>\n<li>在质量相同的情况下，WebP 格式图像的体积要比 JPEG 格式图像小<code>40%</code>。</li>\n<li>Apng：全称是<code>“Animated Portable Network Graphics”</code>, 是 PNG 的位图动画扩展，可以实现 png 格式的动态图片效果。04 年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到  <code>iOS safari 8</code>的支持，有望代替<code>GIF</code>成为下一代动态图标准</li>\n</ul>\n<h3 id=\"33-1-在-css-js-代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理？\"><a href=\"#33-1-在-css-js-代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理？\" class=\"headerlink\" title=\"33.1 在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？\"></a>33.1 在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？</h3><blockquote>\n<p><code>dns</code>缓存，<code>cdn</code>缓存，浏览器缓存，服务器缓存</p>\n</blockquote>\n<h3 id=\"33-2-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。\"><a href=\"#33-2-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。\" class=\"headerlink\" title=\"33.2 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。\"></a>33.2 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</h3><ul>\n<li>图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li>\n<li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li>\n<li>如果图片为 css 图片，可以使用<code>CSSsprite</code>，<code>SVGsprite</code>，<code>Iconfont</code>、<code>Base64</code>等技术。</li>\n<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li>\n<li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</li>\n</ul>\n<h3 id=\"34-常见排序算法的时间复杂度-空间复杂度\"><a href=\"#34-常见排序算法的时间复杂度-空间复杂度\" class=\"headerlink\" title=\"34 常见排序算法的时间复杂度,空间复杂度\"></a>34 常见排序算法的时间复杂度,空间复杂度</h3><p><img src=\"https://github.com/qiu-deqing/FE-interview/raw/master/img/sort-compare.png\"></p>\n<h3 id=\"35-web-开发中会话跟踪的方法有哪些\"><a href=\"#35-web-开发中会话跟踪的方法有哪些\" class=\"headerlink\" title=\"35 web 开发中会话跟踪的方法有哪些\"></a>35 web 开发中会话跟踪的方法有哪些</h3><ul>\n<li><code>cookie</code></li>\n<li><code>session</code></li>\n<li><code>url</code>重写</li>\n<li>隐藏<code>input</code></li>\n<li><code>ip</code>地址</li>\n</ul>\n<h3 id=\"36-HTTP-request-报文结构是怎样的\"><a href=\"#36-HTTP-request-报文结构是怎样的\" class=\"headerlink\" title=\"36 HTTP request 报文结构是怎样的\"></a>36 HTTP request 报文结构是怎样的</h3><ol>\n<li><p> 首行是 Request-Line 包括：请求方法，请求 URI，协议版本，CRLF</p>\n</li>\n<li><p> 首行之后是若干行请求头，包括 general-header，request-header 或者 entity-header，每个一行以 CRLF 结束</p>\n</li>\n<li><p> 请求头和消息实体之间有一个 CRLF 分隔</p>\n</li>\n<li><p>根据实际请求需要可能包含一个消息实体   一个请求报文例子如下：</p>\n<p> GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1<br> Host: <a href=\"http://www.w3.org/\">www.w3.org</a><br> Connection: keep-alive<br> Cache-Control: max-age=0<br> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8<br> User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36<br> Referer: <a href=\"https://www.google.com.hk/\">https://www.google.com.hk/</a><br> Accept-Encoding: gzip,deflate,sdch<br> Accept-Language: zh-CN,zh;q=0.8,en;q=0.6<br> Cookie: authorstyle=yes<br> If-None-Match: “2cc8-3e3073913b100”<br> If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</p>\n<p> name=qiu&amp;age=25</p>\n</li>\n</ol>\n<h3 id=\"37-HTTP-response-报文结构是怎样的\"><a href=\"#37-HTTP-response-报文结构是怎样的\" class=\"headerlink\" title=\"37 HTTP response 报文结构是怎样的\"></a>37 HTTP response 报文结构是怎样的</h3><ul>\n<li><p>首行是状态行包括：HTTP 版本，状态码，状态描述，后面跟一个 CRLF</p>\n</li>\n<li><p>首行之后是若干行响应头，包括：通用头部，响应头部，实体头部</p>\n</li>\n<li><p>响应头部和响应实体之间用一个 CRLF 空行分隔</p>\n</li>\n<li><p>最后是一个可能的消息实体   响应报文例子如下：</p>\n<p>HTTP/1.1 200 OK<br>Date: Tue, 08 Jul 2014 05:28:43 GMT<br>Server: Apache/2<br>Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT<br>ETag: “40d7-3e3073913b100”<br>Accept-Ranges: bytes<br>Content-Length: 16599<br>Cache-Control: max-age=21600<br>Expires: Tue, 08 Jul 2014 11:28:43 GMT<br>P3P: policyref=”<a href=\"http://www.w3.org/2001/05/P3P/p3p.xml&quot;\">http://www.w3.org/2001/05/P3P/p3p.xml&quot;</a><br>Content-Type: text/html; charset=iso-8859-1</p>\n<p>{“name”: “qiu”, “age”: 25}</p>\n</li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"一、HTML、HTTP、web-综合问题\"><a href=\"#一、HTML、HTTP、web-综合问题\" class=\"headerlink\" title=\"一、HTML、HTTP、web 综合问题\"></a>一、HTML、HTTP、web 综合问题</h2><h3 id=\"1-前端需要注意哪些-SEO\"><a href=\"#1-前端需要注意哪些-SEO\" class=\"headerlink\" title=\"1 前端需要注意哪些 SEO\"></a>1 前端需要注意哪些 SEO</h3><ul>\n<li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li>\n<li>语义化的<code>HTML</code>代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</li>\n<li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>\n<li>重要内容不要用<code>js</code>输出：爬虫不会执行 js 获取内容</li>\n<li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li>\n<li>非装饰性图片必须加<code>alt</code></li>\n<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>\n</ul>\n<h3 id=\"2-lt-img-gt-的title和alt有什么区别\"><a href=\"#2-lt-img-gt-的title和alt有什么区别\" class=\"headerlink\" title=\"2 &lt;img&gt;的title和alt有什么区别\"></a>2 <code>&lt;img&gt;</code>的<code>title</code>和<code>alt</code>有什么区别</h3><ul>\n<li>通常当鼠标滑动到元素上的时候显示</li>\n<li><code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li>\n</ul>\n<h3 id=\"3-HTTP-的几种请求方法用途\"><a href=\"#3-HTTP-的几种请求方法用途\" class=\"headerlink\" title=\"3 HTTP 的几种请求方法用途\"></a>3 HTTP 的几种请求方法用途</h3><ul>\n<li><code>GET</code>方法<ul>\n<li>发送一个请求来取得服务器上的某一资源</li>\n</ul>\n</li>\n<li><code>POST</code>方法<ul>\n<li>向<code>URL</code>指定的资源提交数据或附加新的数据</li>\n</ul>\n</li>\n<li><code>PUT</code>方法<ul>\n<li>跟<code>POST</code>方法很像，也是想服务器提交数据。但是，它们之间有不同。<code>PUT</code>指定了资源在服务器上的位置，而<code>POST</code>没有</li>\n</ul>\n</li>\n<li><code>HEAD</code>方法<ul>\n<li>只请求页面的首部</li>\n</ul>\n</li>\n<li><code>DELETE</code>方法<ul>\n<li>删除服务器上的某资源</li>\n</ul>\n</li>\n<li><code>OPTIONS</code>方法<ul>\n<li>它用于获取当前<code>URL</code>所支持的方法。如果请求成功，会有一个<code>Allow</code>的头包含类似<code>“GET,POST”</code>这样的信息</li>\n</ul>\n</li>\n<li><code>TRACE</code>方法<ul>\n<li><code>TRACE</code>方法被用于激发一个远程的，应用层的请求消息回路</li>\n</ul>\n</li>\n<li><code>CONNECT</code>方法<ul>\n<li>把请求连接转换到透明的<code>TCP/IP</code>通道</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"4-从浏览器地址栏输入-url-到显示页面的步骤\"><a href=\"#4-从浏览器地址栏输入-url-到显示页面的步骤\" class=\"headerlink\" title=\"4 从浏览器地址栏输入 url 到显示页面的步骤\"></a>4 从浏览器地址栏输入 url 到显示页面的步骤</h3><p>基础版本</p>\n<ul>\n<li>浏览器根据请求的<code>URL</code>交给<code>DNS</code>域名解析，找到真实<code>IP</code>，向服务器发起请求；</li>\n<li>服务器交给后台处理完成后返回数据，浏览器接收文件（<code>HTML、JS、CSS</code>、图象等）；</li>\n<li>浏览器对加载到的资源（<code>HTML、JS、CSS</code>等）进行语法解析，建立相应的内部数据结构（如<code>HTML</code>的<code>DOM</code>）；</li>\n<li>载入解析到的资源文件，渲染页面，完成。</li>\n</ul>\n<p>详细版</p>\n<ol>\n<li><p> 在浏览器地址栏输入 URL</p>\n</li>\n<li><p>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p>\n<ul>\n<li>HTTP1.0 提供 Expires，值为一个绝对时间表示缓存新鲜日期</li>\n<li>HTTP1.1 增加了 Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li>\n</ul>\n<ol>\n<li> 如果资源未缓存，发起新请求</li>\n<li> 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li>\n<li> 检验新鲜通常有两个 HTTP 头进行控制<code>Expires</code>和<code>Cache-Control</code>：</li>\n</ol>\n</li>\n<li><p> 浏览器解析 URL 获取协议，主机，端口，path</p>\n</li>\n<li><p> 浏览器组装一个 HTTP（GET）请求报文</p>\n</li>\n<li><p>浏览器获取主机 ip 地址，过程如下：</p>\n<ol>\n<li> 浏览器缓存</li>\n<li> 本机缓存</li>\n<li> hosts 文件</li>\n<li> 路由器缓存</li>\n<li> ISP DNS 缓存</li>\n<li> DNS 递归查询（可能存在负载均衡导致每次 IP 不一样）</li>\n</ol>\n</li>\n<li><p>打开一个 socket 与目标 IP 地址，端口建立 TCP 链接，三次握手如下：</p>\n<ol>\n<li> 客户端发送一个 TCP 的 SYN=1，Seq=X 的包到服务器端口</li>\n<li> 服务器发回 SYN=1， ACK=X+1， Seq=Y 的响应包</li>\n<li> 客户端发送 ACK=Y+1， Seq=Z</li>\n</ol>\n</li>\n<li><p> TCP 链接建立后发送 HTTP 请求</p>\n</li>\n<li><p> 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用 HTTP Host 头部判断请求的服务程序</p>\n</li>\n<li><p> 服务器检查 HTTP 请求头是否包含缓存验证信息如果验证缓存新鲜，返回 304 等对应状态码</p>\n</li>\n<li><p>处理程序读取完整请求并准备 HTTP 响应，可能需要查询数据库等操作</p>\n</li>\n<li><p>服务器将响应报文通过 TCP 连接发送回浏览器</p>\n</li>\n<li><p>浏览器接收 HTTP 响应，然后根据情况选择关闭 TCP 连接或者保留重用，关闭 TCP 连接的四次握手如下：</p>\n<ol>\n<li> 主动方发送 Fin=1， Ack=Z， Seq= X 报文</li>\n<li> 被动方发送 ACK=X+1， Seq=Z 报文</li>\n<li> 被动方发送 Fin=1， ACK=X， Seq=Y 报文</li>\n<li> 主动方发送 ACK=Y， Seq=X 报文</li>\n</ol>\n</li>\n<li><p>浏览器检查响应状态吗：是否为 1XX，3XX， 4XX， 5XX，这些情况处理与 2XX 不同</p>\n</li>\n<li><p>如果资源可缓存，进行缓存</p>\n</li>\n<li><p>对响应进行解码（例如 gzip 压缩）</p>\n</li>\n<li><p>根据资源类型决定如何处理（假设资源为 HTML 文档）</p>\n</li>\n<li><p>解析 HTML 文档，构件 DOM 树，下载资源，构造 CSSOM 树，执行 js 脚本，这些操作没有严格的先后顺序，以下分别解释</p>\n</li>\n<li><p>构建 DOM 树：</p>\n<ol>\n<li> Tokenizing：根据 HTML 规范将字符流解析为标记</li>\n<li> Lexing：词法分析将标记转换为对象并定义属性和规则</li>\n<li> DOM construction：根据 HTML 标记关系将对象组成 DOM 树</li>\n</ol>\n</li>\n<li><p>解析过程中遇到图片、样式表、js 文件，启动下载</p>\n</li>\n<li><p>构建 CSSOM 树：</p>\n<ol>\n<li> Tokenizing：字符流转换为标记流</li>\n<li> Node：根据标记创建节点</li>\n<li> CSSOM：节点创建 CSSOM 树</li>\n</ol>\n</li>\n<li><p>根据 DOM 树和 CSSOM 树构建渲染树:</p>\n<ol>\n<li> 从 DOM 树的根节点遍历所有可见节点，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被 css 隐藏的节点，如<code>display: none</code></li>\n<li> 对每一个可见节点，找到恰当的 CSSOM 规则并应用</li>\n<li> 发布可视节点的内容和计算样式</li>\n</ol>\n</li>\n<li><p>js 解析如下：</p>\n<ol>\n<li> 浏览器创建 Document 对象并解析 HTML，将解析到的元素和文本节点添加到文档中，此时 document.readystate 为 loading</li>\n<li> HTML 解析器遇到没有 async 和 defer 的 script 时，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用 document.write()把文本插入到输入流中。同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作 script 和他们之前的文档内容</li>\n<li> 当解析器遇到设置了 async 属性的 script 时，开始下载脚本并继续解析文档。脚本会在它下载完成后尽快执行，但是解析器不会停下来等它下载。异步脚本禁止使用 document.write()，它们可以访问自己 script 和之前的文档元素</li>\n<li> 当文档完成解析，document.readState 变成 interactive</li>\n<li> 所有 defer 脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树，禁止使用 document.write()</li>\n<li> 浏览器在 Document 对象上触发 DOMContentLoaded 事件</li>\n<li> 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些内容完成载入并且所有异步脚本完成载入和执行，document.readState 变为 complete，window 触发 load 事件</li>\n</ol>\n</li>\n<li><p>显示页面（HTML 解析过程中会逐步显示页面）</p>\n</li>\n</ol>\n<p>详细简版</p>\n<ol>\n<li> 从浏览器接收<code>url</code>到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）</li>\n<li> 开启网络线程到发出一个完整的<code>HTTP</code>请求（这一部分涉及到 dns 查询，<code>TCP/IP</code>请求，五层因特网协议栈等知识）</li>\n<li> 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）</li>\n<li> 后台和前台的<code>HTTP</code>交互（这一部分包括<code>HTTP</code>头部、响应码、报文结构、<code>cookie</code>等知识，可以提下静态资源的<code>cookie</code>优化，以及编码解码，如<code>gzip</code>压缩等）</li>\n<li> 单独拎出来的缓存问题，<code>HTTP</code>的缓存（这部分包括 http 缓存头部，<code>ETag</code>，<code>catch-control</code>等）</li>\n<li> 浏览器接收到<code>HTTP</code>数据包后的解析流程（解析<code>html</code>-词法分析然后解析成<code>dom</code>树、解析<code>css</code>生成<code>css</code>规则树、合并成<code>render</code>树，然后<code>layout</code>、<code>painting</code>渲染、复合图层的合成、<code>GPU</code>绘制、外链资源的处理、<code>loaded</code>和<code>DOMContentLoaded</code>等）</li>\n<li> <code>CSS</code>的可视化格式模型（元素的渲染规则，如包含块，控制框，<code>BFC</code>，<code>IFC</code>等概念）</li>\n<li> <code>JS</code>引擎解析过程（<code>JS</code>的解释阶段，预处理阶段，执行阶段生成执行上下文，<code>VO</code>，作用域链、回收机制等等）</li>\n<li> 其它（可以拓展不同的知识模块，如跨域，web 安全，<code>hybrid</code>模式等等内容）</li>\n</ol>\n<h3 id=\"5-如何进行网站性能优化\"><a href=\"#5-如何进行网站性能优化\" class=\"headerlink\" title=\"5 如何进行网站性能优化\"></a>5 如何进行网站性能优化</h3><ul>\n<li><code>content</code>方面<ul>\n<li>减少<code>HTTP</code>请求：合并文件、<code>CSS</code>精灵、<code>inline Image</code></li>\n<li>减少<code>DNS</code>查询：<code>DNS</code>缓存、将资源分布到恰当数量的主机名</li>\n<li>减少<code>DOM</code>元素数量</li>\n</ul>\n</li>\n<li><code>Server</code>方面<ul>\n<li>使用<code>CDN</code></li>\n<li>配置<code>ETag</code></li>\n<li>对组件使用<code>Gzip</code>压缩</li>\n</ul>\n</li>\n<li><code>Cookie</code>方面<ul>\n<li>减小<code>cookie</code>大小</li>\n</ul>\n</li>\n<li><code>css</code>方面<ul>\n<li>将样式表放到页面顶部</li>\n<li>不使用<code>CSS</code>表达式</li>\n<li>使用<code>&lt;link&gt;</code>不使用<code>@import</code></li>\n</ul>\n</li>\n<li><code>Javascript</code>方面<ul>\n<li>将脚本放到页面底部</li>\n<li>将<code>javascript</code>和<code>css</code>从外部引入</li>\n<li>压缩<code>javascript</code>和<code>css</code></li>\n<li>删除不需要的脚本</li>\n<li>减少<code>DOM</code>访问</li>\n</ul>\n</li>\n<li>图片方面<ul>\n<li>优化图片：根据实际颜色需要选择色深、压缩</li>\n<li>优化<code>css</code>精灵</li>\n<li>不要在<code>HTML</code>中拉伸图片</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"6-HTTP-状态码及其含义\"><a href=\"#6-HTTP-状态码及其含义\" class=\"headerlink\" title=\"6 HTTP 状态码及其含义\"></a>6 HTTP 状态码及其含义</h3><ul>\n<li><code>1XX</code>：信息状态码<ul>\n<li><code>100 Continue</code>  继续，一般在发送<code>post</code>请求时，已发送了<code>http header</code>之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>\n</ul>\n</li>\n<li><code>2XX</code>：成功状态码<ul>\n<li><code>200 OK</code>  正常返回信息</li>\n<li><code>201 Created</code>  请求成功并且服务器创建了新的资源</li>\n<li><code>202 Accepted</code>  服务器已接受请求，但尚未处理</li>\n</ul>\n</li>\n<li><code>3XX</code>：重定向<ul>\n<li><code>301 Moved Permanently</code>  请求的网页已永久移动到新位置。</li>\n<li><code>302 Found</code>  临时性重定向。</li>\n<li><code>303 See Other</code>  临时性重定向，且总是使用  <code>GET</code>  请求新的  <code>URI</code>。</li>\n<li><code>304 Not Modified</code>  自从上次请求后，请求的网页未修改过。</li>\n</ul>\n</li>\n<li><code>4XX</code>：客户端错误<ul>\n<li><code>400 Bad Request</code>  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</li>\n<li><code>401 Unauthorized</code>  请求未授权。</li>\n<li><code>403 Forbidden</code>  禁止访问。</li>\n<li><code>404 Not Found</code>  找不到如何与  <code>URI</code>  相匹配的资源。</li>\n</ul>\n</li>\n<li><code>5XX:</code>  服务器错误<ul>\n<li><code>500 Internal Server Error</code>  最常见的服务器端错误。</li>\n<li><code>503 Service Unavailable</code>  服务器端暂时无法处理请求（可能是过载或维护）。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"7-语义化的理解\"><a href=\"#7-语义化的理解\" class=\"headerlink\" title=\"7 语义化的理解\"></a>7 语义化的理解</h3><ul>\n<li>用正确的标签做正确的事情！</li>\n<li><code>HTML</code>语义化就是让页面的内容结构化，便于对浏览器、搜索引擎解析；</li>\n<li>在没有样式<code>CSS</code>情况下也以一种文档格式显示，并且是容易阅读的。</li>\n<li>搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重，利于  <code>SEO</code>。</li>\n<li>使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解</li>\n</ul>\n<h3 id=\"8-介绍一下你对浏览器内核的理解？\"><a href=\"#8-介绍一下你对浏览器内核的理解？\" class=\"headerlink\" title=\"8 介绍一下你对浏览器内核的理解？\"></a>8 介绍一下你对浏览器内核的理解？</h3><ul>\n<li>主要分成两部分：渲染引擎(<code>layout engineer</code>或<code>Rendering Engine</code>)和<code>JS</code>引擎</li>\n<li>渲染引擎：负责取得网页的内容（<code>HTML</code>、<code>XML</code>、图像等等）、整理讯息（例如加入<code>CSS</code>等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核</li>\n<li><code>JS</code>引擎则：解析和执行<code>javascript</code>来实现网页的动态效果</li>\n<li>最开始渲染引擎和<code>JS</code>引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎</li>\n</ul>\n<h3 id=\"9-html5-有哪些新特性、移除了那些元素？\"><a href=\"#9-html5-有哪些新特性、移除了那些元素？\" class=\"headerlink\" title=\"9 html5 有哪些新特性、移除了那些元素？\"></a>9 html5 有哪些新特性、移除了那些元素？</h3><ul>\n<li><code>HTML5</code>  现在已经不是  <code>SGML</code>  的子集，主要是关于图像，位置，存储，多任务等功能的增加<ul>\n<li>绘画  <code>canvas</code></li>\n<li>用于媒介回放的  <code>video</code>  和  <code>audio</code>  元素</li>\n<li>本地离线存储  <code>localStorage</code>  长期存储数据，浏览器关闭后数据不丢失</li>\n<li><code>sessionStorage</code>  的数据在浏览器关闭后自动删除</li>\n<li>语意化更好的内容元素，比如<code>article</code>、<code>footer</code>、<code>header</code>、<code>nav</code>、<code>section</code></li>\n<li>表单控件，<code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code></li>\n<li>新的技术<code>webworker</code>、 <code>websocket</code>、 <code>Geolocation</code></li>\n</ul>\n</li>\n<li>移除的元素：<ul>\n<li>纯表现的元素：<code>basefont</code>、<code>big</code>、<code>center</code>、<code>font</code>、 <code>s</code>、<code>strike</code>、<code>tt</code>、<code>u</code></li>\n<li>对可用性产生负面影响的元素：<code>frame</code>、<code>frameset</code>、<code>noframes</code></li>\n</ul>\n</li>\n<li>支持<code>HTML5</code>新标签：<ul>\n<li><code>IE8/IE7/IE6</code>支持通过<code>document.createElement</code>方法产生的标签</li>\n<li>可以利用这一特性让这些浏览器支持<code>HTML5</code>新标签</li>\n<li>浏览器支持新标签后，还需要添加标签默认的样式</li>\n</ul>\n</li>\n<li>当然也可以直接使用成熟的框架、比如<code>html5shim</code></li>\n</ul>\n<h3 id=\"10-HTML5的离线储存怎么使用，工作原理能不能解释一下？\"><a href=\"#10-HTML5的离线储存怎么使用，工作原理能不能解释一下？\" class=\"headerlink\" title=\"10 HTML5的离线储存怎么使用，工作原理能不能解释一下？\"></a>10 <code>HTML5</code>的离线储存怎么使用，工作原理能不能解释一下？</h3><ul>\n<li><p>在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件</p>\n</li>\n<li><p>原理：<code>HTML5</code>的离线存储是基于一个新建的<code>.appcache</code>文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像<code>cookie</code>一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>\n</li>\n<li><p>如何使用：</p>\n<ul>\n<li>页面头部像下面一样加入一个<code>manifest</code>的属性；</li>\n<li>在<code>cache.manifest</code>文件的编写离线存储的资源</li>\n<li>在离线状态时，操作<code>window.applicationCache</code>进行需求实现</li>\n</ul>\n<p>CACHE MANIFEST<br>#v0.11CACHE:js/app.js<br>css/style.css<br>NETWORK:resourse/logo.png<br>FALLBACK:/offline.html</p>\n</li>\n</ul>\n<h3 id=\"11-浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\"><a href=\"#11-浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\" class=\"headerlink\" title=\"11 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢\"></a>11 浏览器是怎么对<code>HTML5</code>的离线储存资源进行管理和加载的呢</h3><ul>\n<li>在线的情况下，浏览器发现<code>html</code>头部有<code>manifest</code>属性，它会请求<code>manifest</code>文件，如果是第一次访问<code>app</code>，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过<code>app</code>并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的<code>manifest</code>文件与旧的<code>manifest</code>文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。</li>\n<li>离线的情况下，浏览器就直接使用离线存储的资源。</li>\n</ul>\n<h3 id=\"12-请描述一下-cookies，sessionStorage-和-localStorage-的区别？\"><a href=\"#12-请描述一下-cookies，sessionStorage-和-localStorage-的区别？\" class=\"headerlink\" title=\"12 请描述一下  cookies，sessionStorage  和  localStorage  的区别？\"></a>12 请描述一下  <code>cookies</code>，<code>sessionStorage</code>  和  <code>localStorage</code>  的区别？</h3><ul>\n<li><code>cookie</code>是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li>\n<li>cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li>\n<li><code>sessionStorage</code>和<code>localStorage</code>不会自动把数据发给服务器，仅在本地保存</li>\n<li>存储大小：<ul>\n<li><code>cookie</code>数据大小不能超过 4k</li>\n<li><code>sessionStorage</code>和<code>localStorage</code>虽然也有存储大小的限制，但比<code>cookie</code>大得多，可以达到 5M 或更大</li>\n</ul>\n</li>\n<li>有期时间：<ul>\n<li><code>localStorage</code>  存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li>\n<li><code>sessionStorage</code>  数据在当前浏览器窗口关闭后自动删除</li>\n<li><code>cookie</code>  设置的<code>cookie</code>过期时间之前一直有效，即使窗口或浏览器关闭</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"13-iframe-有那些缺点？\"><a href=\"#13-iframe-有那些缺点？\" class=\"headerlink\" title=\"13 iframe 有那些缺点？\"></a>13 iframe 有那些缺点？</h3><ul>\n<li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li>\n<li>搜索引擎的检索程序无法解读这种页面，不利于<code>SEO</code></li>\n<li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>\n<li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li>\n</ul>\n<h3 id=\"14-WEB-标准以及-W3C-标准是什么\"><a href=\"#14-WEB-标准以及-W3C-标准是什么\" class=\"headerlink\" title=\"14 WEB 标准以及 W3C 标准是什么?\"></a>14 WEB 标准以及 W3C 标准是什么?</h3><ul>\n<li>标签闭合、标签小写、不乱嵌套、使用外链<code>css</code>和<code>js</code>、结构行为表现的分离</li>\n</ul>\n<h3 id=\"15-xhtml-和-html-有什么区别\"><a href=\"#15-xhtml-和-html-有什么区别\" class=\"headerlink\" title=\"15 xhtml 和 html 有什么区别?\"></a>15 xhtml 和 html 有什么区别?</h3><ul>\n<li>一个是功能上的差别<ul>\n<li>主要是<code>XHTML</code>可兼容各大浏览器、手机以及<code>PDA</code>，并且浏览器也能快速正确地编译网页</li>\n</ul>\n</li>\n<li>另外是书写习惯的差别<ul>\n<li><code>XHTML</code>  元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"16-Doctype-作用-严格模式与混杂模式如何区分？它们有何意义\"><a href=\"#16-Doctype-作用-严格模式与混杂模式如何区分？它们有何意义\" class=\"headerlink\" title=\"16 Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?\"></a>16 Doctype 作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><ul>\n<li>页面被加载的时，<code>link</code>会同时被加载，而<code>@imort</code>页面被加载的时，<code>link</code>会同时被加载，而<code>@import</code>引用的<code>CSS</code>会等到页面被加载完再加载  <code>import</code>只在<code>IE5</code>以上才能识别，而<code>link</code>是<code>XHTML</code>标签，无兼容问题  <code>link</code>方式的样式的权重 高于<code>@import</code>的权重</li>\n<li><code>&lt;!DOCTYPE&gt;</code>  声明位于文档中的最前面，处于  <code>&lt;html&gt;</code>  标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档</li>\n<li>严格模式的排版和  <code>JS</code>  运作模式是 以该浏览器支持的最高标准运行</li>\n<li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 <code>DOCTYPE</code>不存在或格式不正确会导致文档以混杂模式呈现</li>\n</ul>\n<h3 id=\"17-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？\"><a href=\"#17-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？行内元素和块级元素有什么区别？\" class=\"headerlink\" title=\"17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？\"></a>17 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？</h3><ul>\n<li>行内元素有：<code>a b span img input select strong</code></li>\n<li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4… p</code></li>\n<li>空元素：<code>&lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt;</code></li>\n<li>行内元素不可以设置宽高，不独占一行</li>\n<li>块级元素可以设置宽高，独占一行</li>\n</ul>\n<h3 id=\"18-HTML-全局属性-global-attribute-有哪些\"><a href=\"#18-HTML-全局属性-global-attribute-有哪些\" class=\"headerlink\" title=\"18 HTML 全局属性(global attribute)有哪些\"></a>18 HTML 全局属性(global attribute)有哪些</h3><ul>\n<li><code>class</code>:为元素设置类标识</li>\n<li><code>data-*</code>: 为元素增加自定义属性</li>\n<li><code>draggable</code>: 设置元素是否可拖拽</li>\n<li><code>id</code>: 元素<code>id</code>，文档内唯一</li>\n<li><code>lang</code>: 元素内容的的语言</li>\n<li><code>style</code>: 行内<code>css</code>样式</li>\n<li><code>title</code>: 元素相关的建议信息</li>\n<li><code>svg</code>绘制出来的每一个图形的元素都是独立的<code>DOM</code>节点，能够方便的绑定事件或用来修改。<code>canvas</code>输出的是一整幅画布</li>\n<li><code>svg</code>输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而<code>canvas</code>输出标量画布，就像一张图片一样，放大会失真或者锯齿</li>\n<li>20 HTML5 为什么只需要写 <!DOCTYPE HTML></li>\n<li><code>HTML5</code>  不基于  <code>SGML</code>，因此不需要对<code>DTD</code>进行引用，但是需要<code>doctype</code>来规范浏览器的行为</li>\n<li>而<code>HTML4.01</code>基于<code>SGML</code>,所以需要对<code>DTD</code>进行引用，才能告知浏览器文档所使用的文档类型</li>\n</ul>\n<h3 id=\"21-如何在页面上实现一个圆形的可点击区域？\"><a href=\"#21-如何在页面上实现一个圆形的可点击区域？\" class=\"headerlink\" title=\"21 如何在页面上实现一个圆形的可点击区域？\"></a>21 如何在页面上实现一个圆形的可点击区域？</h3><ul>\n<li><code>svg</code></li>\n<li><code>border-radius</code></li>\n<li>纯<code>js</code>实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等</li>\n</ul>\n<h3 id=\"22-网页验证码是干嘛的，是为了解决什么安全问题\"><a href=\"#22-网页验证码是干嘛的，是为了解决什么安全问题\" class=\"headerlink\" title=\"22 网页验证码是干嘛的，是为了解决什么安全问题\"></a>22 网页验证码是干嘛的，是为了解决什么安全问题</h3><ul>\n<li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li>\n<li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li>\n</ul>\n<h3 id=\"23-viewport\"><a href=\"#23-viewport\" class=\"headerlink\" title=\"23 viewport\"></a>23 viewport</h3><pre><code> &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no&quot; /&gt;\n    // width    设置viewport宽度，为一个正整数，或字符串‘device-width’\n    // device-width  设备宽度\n    // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置\n    // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数\n    // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数\n    // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数\n    // user-scalable    是否允许手动缩放\n</code></pre>\n<ul>\n<li>延伸提问<ul>\n<li>怎样处理 移动端  <code>1px</code>  被 渲染成  <code>2px</code>问题</li>\n</ul>\n</li>\n</ul>\n<p>局部处理</p>\n<ul>\n<li><code>mate</code>标签中的  <code>viewport</code>属性 ，<code>initial-scale</code>  设置为  <code>1</code></li>\n<li><code>rem</code>按照设计稿标准走，外加利用<code>transfrome</code>  的<code>scale(0.5)</code>  缩小一倍即可；</li>\n</ul>\n<p>全局处理</p>\n<ul>\n<li><code>mate</code>标签中的  <code>viewport</code>属性 ，<code>initial-scale</code>  设置为  <code>0.5</code></li>\n<li><code>rem</code>  按照设计稿标准走即可</li>\n</ul>\n<h3 id=\"24-渲染优化\"><a href=\"#24-渲染优化\" class=\"headerlink\" title=\"24 渲染优化\"></a>24 渲染优化</h3><ul>\n<li>禁止使用<code>iframe</code>（阻塞父文档<code>onload</code>事件）<ul>\n<li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li>\n<li>搜索引擎的检索程序无法解读这种页面，不利于 SEO</li>\n<li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>\n<li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code></li>\n<li>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li>\n</ul>\n</li>\n<li>禁止使用<code>gif</code>图片实现<code>loading</code>效果（降低<code>CPU</code>消耗，提升渲染性能）</li>\n<li>使用<code>CSS3</code>代码代替<code>JS</code>动画（尽可能避免重绘重排以及回流）</li>\n<li>对于一些小图标，可以使用 base64 位编码，以减少网络请求。但不建议大图使用，比较耗费<code>CPU</code><ul>\n<li>减少<code>HTTP</code>请求</li>\n<li>避免文件跨域</li>\n<li>修改及时生效</li>\n<li>小图标优势在于</li>\n</ul>\n</li>\n<li>页面头部的<code>&lt;style&gt;&lt;/style&gt;``&lt;script&gt;&lt;/script&gt;</code>  会阻塞页面；（因为  <code>Renderer</code>进程中  <code>JS</code>线程和渲染线程是互斥的）</li>\n<li>页面中空的  <code>href</code>  和  <code>src</code>  会阻塞页面其他资源的加载 (阻塞下载进程)</li>\n<li>网页<code>gzip</code>，<code>CDN</code>托管，<code>data</code>缓存 ，图片服务器</li>\n<li>前端模板 JS+数据，减少由于<code>HTML</code>标签导致的带宽浪费，前端用变量保存 AJAX 请求结果，每次操作本地变量，不用请求，减少请求次数</li>\n<li>用<code>innerHTML</code>代替<code>DOM</code>操作，减少<code>DOM</code>操作次数，优化<code>javascript</code>性能</li>\n<li>当需要设置的样式很多时设置<code>className</code>而不是直接操作<code>style</code></li>\n<li>少用全局变量、缓存<code>DOM</code>节点查找的结果。减少<code>IO</code>读取操作</li>\n<li>图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳</li>\n<li>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘<code>IO</code></li>\n</ul>\n<h3 id=\"25-meta-viewport-相关\"><a href=\"#25-meta-viewport-相关\" class=\"headerlink\" title=\"25 meta viewport 相关\"></a>25 meta viewport 相关</h3><pre><code>&lt;!DOCTYPE html&gt;  &lt;!--H5标准声明，使用 HTML5 doctype，不区分大小写--&gt;&lt;head lang=”en”&gt; &lt;!--标准的 lang 属性写法--&gt;&lt;meta charset=’utf-8′&gt;    &lt;!--声明文档使用的字符编码--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=1″/&gt;   &lt;!--优先使用 IE 最新版本和 Chrome--&gt;&lt;meta name=”description” content=”不超过150个字符”/&gt;       &lt;!--页面描述--&gt;&lt;meta name=”keywords” content=””/&gt;     &lt;!-- 页面关键词--&gt;&lt;meta name=”author” content=”name, email@gmail.com”/&gt;    &lt;!--网页作者--&gt;&lt;meta name=”robots” content=”index,follow”/&gt;      &lt;!--搜索引擎抓取--&gt;&lt;meta name=”viewport” content=”initial-scale=1, maximum-scale=3, minimum-scale=1, user-scalable=no”&gt; &lt;!--为移动设备添加 viewport--&gt;&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; &lt;!--iOS 设备 begin--&gt;&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;  &lt;!--添加到主屏后的标题（iOS 6 新增）\n是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏--&gt;&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;&lt;!--添加智能 App 广告条 Smart App Banner（iOS 6+ Safari）--&gt;&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt;  &lt;!--设置苹果工具栏颜色--&gt;&lt;meta name=”renderer” content=”webkit”&gt; &lt;!-- 启用360浏览器的极速模式(webkit)--&gt;&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;     &lt;!--避免IE使用兼容模式--&gt;&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;    &lt;!--不让百度转码--&gt;&lt;meta name=”HandheldFriendly” content=”true”&gt;     &lt;!--针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓--&gt;&lt;meta name=”MobileOptimized” content=”320″&gt;   &lt;!--微软的老式浏览器--&gt;&lt;meta name=”screen-orientation” content=”portrait”&gt;   &lt;!--uc强制竖屏--&gt;&lt;meta name=”x5-orientation” content=”portrait”&gt;    &lt;!--QQ强制竖屏--&gt;&lt;meta name=”full-screen” content=”yes”&gt;              &lt;!--UC强制全屏--&gt;&lt;meta name=”x5-fullscreen” content=”true”&gt;       &lt;!--QQ强制全屏--&gt;&lt;meta name=”browsermode” content=”application”&gt;   &lt;!--UC应用模式--&gt;&lt;meta name=”x5-page-mode” content=”app”&gt;   &lt;!-- QQ应用模式--&gt;&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;    &lt;!--windows phone 点击无高亮\n设置页面不缓存--&gt;&lt;meta http-equiv=”pragma” content=”no-cache”&gt;&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;&lt;meta http-equiv=”expires” content=”0″&gt;\n</code></pre>\n<h3 id=\"26-你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么\"><a href=\"#26-你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么\" class=\"headerlink\" title=\"26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?\"></a>26 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?</h3><ul>\n<li><code>IE</code>: <code>trident</code>内核</li>\n<li><code>Firefox</code>：<code>gecko</code>内核</li>\n<li><code>Safari</code>:<code>webkit</code>内核</li>\n<li><code>Opera</code>:以前是<code>presto</code>内核，<code>Opera</code>现已改用 Google - <code>Chrome</code>的<code>Blink</code>内核</li>\n<li><code>Chrome:Blink</code>(基于<code>webkit</code>，Google 与 Opera Software 共同开发)</li>\n</ul>\n<h3 id=\"27-div-css-的布局较-table-布局有什么优点？\"><a href=\"#27-div-css-的布局较-table-布局有什么优点？\" class=\"headerlink\" title=\"27 div+css 的布局较 table 布局有什么优点？\"></a>27 div+css 的布局较 table 布局有什么优点？</h3><ul>\n<li>改版的时候更方便 只要改<code>css</code>文件。</li>\n<li>页面加载速度更快、结构化清晰、页面显示简洁。</li>\n<li>表现与结构相分离。</li>\n<li>易于优化（<code>seo</code>）搜索引擎更友好，排名更容易靠前。</li>\n</ul>\n<h3 id=\"28-a：img-的-alt-与-title-有何异同？b：strong-与-em-的异同？\"><a href=\"#28-a：img-的-alt-与-title-有何异同？b：strong-与-em-的异同？\" class=\"headerlink\" title=\"28 a：img 的 alt 与 title 有何异同？b：strong 与 em 的异同？\"></a>28 a：img 的 alt 与 title 有何异同？b：strong 与 em 的异同？</h3><ul>\n<li><code>alt(alt text)</code>:为不能显示图像、窗体或<code>applets</code>的用户代理（<code>UA</code>），<code>alt</code>属性用来指定替换文字。替换文字的语言由<code>lang</code>属性指定。(在 IE 浏览器下会在没有<code>title</code>时把<code>alt</code>当成  <code>tool tip</code>显示)</li>\n<li><code>title(tool tip)</code>:该属性为设置该属性的元素提供建议性的信息</li>\n<li><code>strong</code>:粗体强调标签，强调，表示内容的重要性</li>\n<li><code>em</code>:斜体强调标签，更强烈强调，表示内容的强调点</li>\n</ul>\n<h3 id=\"29-你能描述一下渐进增强和优雅降级之间的不同吗\"><a href=\"#29-你能描述一下渐进增强和优雅降级之间的不同吗\" class=\"headerlink\" title=\"29 你能描述一下渐进增强和优雅降级之间的不同吗\"></a>29 你能描述一下渐进增强和优雅降级之间的不同吗</h3><ul>\n<li>渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>\n<li>优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</li>\n</ul>\n<blockquote>\n<p>区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带</p>\n</blockquote>\n<h3 id=\"30-为什么利用多个域名来存储网站资源会更有效？\"><a href=\"#30-为什么利用多个域名来存储网站资源会更有效？\" class=\"headerlink\" title=\"30 为什么利用多个域名来存储网站资源会更有效？\"></a>30 为什么利用多个域名来存储网站资源会更有效？</h3><ul>\n<li><code>CDN</code>缓存更方便</li>\n<li>突破浏览器并发限制</li>\n<li>节约<code>cookie</code>带宽</li>\n<li>节约主域名的连接数，优化页面响应速度</li>\n<li>防止不必要的安全问题</li>\n</ul>\n<h3 id=\"31-简述一下-src-与-href-的区别\"><a href=\"#31-简述一下-src-与-href-的区别\" class=\"headerlink\" title=\"31 简述一下 src 与 href 的区别\"></a>31 简述一下 src 与 href 的区别</h3><ul>\n<li><code>src</code>用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</li>\n<li><code>src</code>是<code>source</code>的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求<code>src</code>资源时会将其指向的资源下载并应用到文档内，例如<code>js</code>脚本，<code>img</code>图片和<code>frame</code>等元素</li>\n</ul>\n<blockquote>\n<p><code>&lt;script src =&quot;js.js&quot;&gt;&lt;/script&gt;</code>  当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部</p>\n</blockquote>\n<ul>\n<li><code>href</code>是<code>Hypertext Reference</code>的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，如果我们在文档中添加</li>\n<li><code>&lt;link href=&quot;common.css&quot; rel=&quot;stylesheet&quot;/&gt;</code>那么浏览器会识别该文档为<code>css</code>文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用<code>link</code>方式来加载<code>css</code>，而不是使用<code>@import</code>方式</li>\n</ul>\n<h3 id=\"32-知道的网页制作会用到的图片格式有哪些？\"><a href=\"#32-知道的网页制作会用到的图片格式有哪些？\" class=\"headerlink\" title=\"32 知道的网页制作会用到的图片格式有哪些？\"></a>32 知道的网页制作会用到的图片格式有哪些？</h3><ul>\n<li><code>png-8</code>、<code>png-24</code>、<code>jpeg</code>、<code>gif</code>、<code>svg</code></li>\n</ul>\n<blockquote>\n<p>但是上面的那些都不是面试官想要的最后答案。面试官希望听到是<code>Webp</code>,<code>Apng</code>。（是否有关注新技术，新鲜事物）</p>\n</blockquote>\n<ul>\n<li>Webp：<code>WebP</code>格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有<code>JPEG</code>的<code>2/3</code>，并能节省大量的服务器带宽资源和数据空间。<code>Facebook Ebay</code>等知名网站已经开始测试并使用<code>WebP</code>格式。</li>\n<li>在质量相同的情况下，WebP 格式图像的体积要比 JPEG 格式图像小<code>40%</code>。</li>\n<li>Apng：全称是<code>“Animated Portable Network Graphics”</code>, 是 PNG 的位图动画扩展，可以实现 png 格式的动态图片效果。04 年诞生，但一直得不到各大浏览器厂商的支持，直到日前得到  <code>iOS safari 8</code>的支持，有望代替<code>GIF</code>成为下一代动态图标准</li>\n</ul>\n<h3 id=\"33-1-在-css-js-代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理？\"><a href=\"#33-1-在-css-js-代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次-js-请求一般情况下有哪些地方会有缓存处理？\" class=\"headerlink\" title=\"33.1 在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？\"></a>33.1 在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始，一次 js 请求一般情况下有哪些地方会有缓存处理？</h3><blockquote>\n<p><code>dns</code>缓存，<code>cdn</code>缓存，浏览器缓存，服务器缓存</p>\n</blockquote>\n<h3 id=\"33-2-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。\"><a href=\"#33-2-一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。\" class=\"headerlink\" title=\"33.2 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。\"></a>33.2 一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些方法优化这些图片的加载，给用户更好的体验。</h3><ul>\n<li>图片懒加载，在页面上的未可视区域可以添加一个滚动事件，判断图片位置与浏览器顶端的距离与页面的距离，如果前者小于后者，优先加载。</li>\n<li>如果为幻灯片、相册等，可以使用图片预加载技术，将当前展示图片的前一张和后一张优先下载。</li>\n<li>如果图片为 css 图片，可以使用<code>CSSsprite</code>，<code>SVGsprite</code>，<code>Iconfont</code>、<code>Base64</code>等技术。</li>\n<li>如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩的特别厉害的缩略图，以提高用户体验。</li>\n<li>如果图片展示区域小于图片的真实大小，则因在服务器端根据业务需要先行进行图片压缩，图片压缩后大小与展示一致。</li>\n</ul>\n<h3 id=\"34-常见排序算法的时间复杂度-空间复杂度\"><a href=\"#34-常见排序算法的时间复杂度-空间复杂度\" class=\"headerlink\" title=\"34 常见排序算法的时间复杂度,空间复杂度\"></a>34 常见排序算法的时间复杂度,空间复杂度</h3><p><img src=\"https://github.com/qiu-deqing/FE-interview/raw/master/img/sort-compare.png\"></p>\n<h3 id=\"35-web-开发中会话跟踪的方法有哪些\"><a href=\"#35-web-开发中会话跟踪的方法有哪些\" class=\"headerlink\" title=\"35 web 开发中会话跟踪的方法有哪些\"></a>35 web 开发中会话跟踪的方法有哪些</h3><ul>\n<li><code>cookie</code></li>\n<li><code>session</code></li>\n<li><code>url</code>重写</li>\n<li>隐藏<code>input</code></li>\n<li><code>ip</code>地址</li>\n</ul>\n<h3 id=\"36-HTTP-request-报文结构是怎样的\"><a href=\"#36-HTTP-request-报文结构是怎样的\" class=\"headerlink\" title=\"36 HTTP request 报文结构是怎样的\"></a>36 HTTP request 报文结构是怎样的</h3><ol>\n<li><p> 首行是 Request-Line 包括：请求方法，请求 URI，协议版本，CRLF</p>\n</li>\n<li><p> 首行之后是若干行请求头，包括 general-header，request-header 或者 entity-header，每个一行以 CRLF 结束</p>\n</li>\n<li><p> 请求头和消息实体之间有一个 CRLF 分隔</p>\n</li>\n<li><p>根据实际请求需要可能包含一个消息实体   一个请求报文例子如下：</p>\n<p> GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1<br> Host: <a href=\"http://www.w3.org/\">www.w3.org</a><br> Connection: keep-alive<br> Cache-Control: max-age=0<br> Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,<em>/</em>;q=0.8<br> User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36<br> Referer: <a href=\"https://www.google.com.hk/\">https://www.google.com.hk/</a><br> Accept-Encoding: gzip,deflate,sdch<br> Accept-Language: zh-CN,zh;q=0.8,en;q=0.6<br> Cookie: authorstyle=yes<br> If-None-Match: “2cc8-3e3073913b100”<br> If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT</p>\n<p> name=qiu&amp;age=25</p>\n</li>\n</ol>\n<h3 id=\"37-HTTP-response-报文结构是怎样的\"><a href=\"#37-HTTP-response-报文结构是怎样的\" class=\"headerlink\" title=\"37 HTTP response 报文结构是怎样的\"></a>37 HTTP response 报文结构是怎样的</h3><ul>\n<li><p>首行是状态行包括：HTTP 版本，状态码，状态描述，后面跟一个 CRLF</p>\n</li>\n<li><p>首行之后是若干行响应头，包括：通用头部，响应头部，实体头部</p>\n</li>\n<li><p>响应头部和响应实体之间用一个 CRLF 空行分隔</p>\n</li>\n<li><p>最后是一个可能的消息实体   响应报文例子如下：</p>\n<p>HTTP/1.1 200 OK<br>Date: Tue, 08 Jul 2014 05:28:43 GMT<br>Server: Apache/2<br>Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT<br>ETag: “40d7-3e3073913b100”<br>Accept-Ranges: bytes<br>Content-Length: 16599<br>Cache-Control: max-age=21600<br>Expires: Tue, 08 Jul 2014 11:28:43 GMT<br>P3P: policyref=”<a href=\"http://www.w3.org/2001/05/P3P/p3p.xml&quot;\">http://www.w3.org/2001/05/P3P/p3p.xml&quot;</a><br>Content-Type: text/html; charset=iso-8859-1</p>\n<p>{“name”: “qiu”, “age”: 25}</p>\n</li>\n</ul>\n"},{"title":"2019最新前端知识梳理(JavaScript部分)-面试宝典","url":"162.html","id":"162","date":"2019-06-22T09:22:00.000Z","_content":"\n三、JavaScript\n------------\n\n### 1 闭包\n\n*   闭包就是能够读取其他函数内部变量的函数\n*   闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域\n*   闭包的特性：\n    *   函数内再嵌套函数\n    *   内部函数可以引用外层的参数和变量\n    *   参数和变量不会被垃圾回收机制回收\n\n说说你对闭包的理解\n\n*   使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念\n*   闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中\n*   闭包的另一个用处，是封装对象的私有属性和私有方法\n*   好处：能够实现封装和缓存等；\n*   坏处：就是消耗内存、不正当使用会造成内存溢出的问题\n\n使用闭包的注意点\n\n*   由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露\n*   解决方法是，在退出函数之前，将不使用的局部变量全部删除\n\n### 2 说说你对作用域链的理解\n\n*   作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到`window`对象即被终止，作用域链向下访问变量是不被允许的\n*   简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期\n\n### 3 JavaScript原型，原型链 ? 有什么特点？\n\n*   每个对象都会在其内部初始化一个属性，就是`prototype`(原型)，当我们访问一个对象的属性时\n*   如果这个对象内部不存在这个属性，那么他就会去`prototype`里找这个属性，这个`prototype`又会有自己的`prototype`，于是就这样一直找下去，也就是我们平时所说的原型链的概念\n*   关系：`instance.constructor.prototype = instance.__proto__`\n*   特点：\n    *   `JavaScript`对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变\n*   当我们需要一个属性的时，`Javascript`引擎会先看当前对象中是否有这个属性， 如果没有的\n*   就会查找他的`Prototype`对象是否有这个属性，如此递推下去，一直检索到 `Object` 内建对象\n\n### 4 请解释什么是事件代理\n\n*   事件代理（`Event Delegation`），又称之为事件委托。是 `JavaScript` 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能\n*   可以大量节省内存占用，减少事件注册，比如在`table`上代理所有`td`的`click`事件就非常棒\n*   可以实现当新增子对象时无需再次对其绑定\n\n### 5 Javascript如何实现继承？\n\n*   构造继承\n*   原型继承\n*   实例继承\n*   拷贝继承\n*   原型`prototype`机制或`apply`和`call`方法去实现较简单，建议使用构造函数与原型混合方式\n\nfunction Parent(){\n this.name = 'wang';}function Child(){\n        this.age = 28;}\n    Child.prototype = new Parent();//继承了Parent，通过原型var demo = new Child();alert(demo.age);alert(demo.name);//得到被继承的属性\n\n### 6 谈谈This对象的理解\n\n*   `this`总是指向函数的直接调用者（而非间接调用者）\n*   如果有`new`关键字，`this`指向`new`出来的那个对象\n*   在事件中，`this`指向触发这个事件的对象，特殊的是，`IE`中的`attachEvent`中的`this`总是指向全局对象`Window`\n\n### 7 事件模型\n\n> `W3C`中定义事件的发生经历三个阶段：捕获阶段（`capturing`）、目标阶段（`targetin`）、冒泡阶段（`bubbling`）\n\n*   冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发\n*   捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发\n*   `DOM`事件流：同时支持两种事件模型：捕获型事件和冒泡型事件\n*   阻止冒泡：在`W3c`中，使用`stopPropagation()`方法；在IE下设置`cancelBubble = true`\n*   阻止捕获：阻止事件的默认行为，例如`click - <a>`后的跳转。在`W3c`中，使用`preventDefault()`方法，在`IE`下设置`window.event.returnValue = false`\n\n### 8 new操作符具体干了什么呢?\n\n*   创建一个空对象，并且 `this` 变量引用该对象，同时还继承了该函数的原型\n*   属性和方法被加入到 `this` 引用的对象中\n*   新创建的对象由 `this` 所引用，并且最后隐式的返回 `this`\n\n### 9 Ajax原理\n\n*   `Ajax`的原理简单来说是在用户和服务器之间加了—个中间层(`AJAX`引擎)，通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用`javascrip`t来操作`DOM`而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据\n*   `Ajax`的过程只涉及`JavaScript`、`XMLHttpRequest`和`DOM`。`XMLHttpRequest`是`aja`x的核心机制\n\n/** 1. 创建连接 **/var xhr = null;xhr = new XMLHttpRequest()/** 2. 连接服务器 **/xhr.open('get', url, true)/** 3. 发送请求 **/xhr.send(null);/** 4. 接受请求 **/xhr.onreadystatechange = function(){\n if(xhr.readyState == 4){\n if(xhr.status == 200){\n success(xhr.responseText);\n } else { \n /** false **/\n fail && fail(xhr.status);\n }\n }}\n\najax 有那些优缺点?\n\n*   优点：\n    *   通过异步模式，提升了用户体验.\n    *   优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.\n    *   `Ajax`在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。\n    *   `Ajax`可以实现动态不刷新（局部刷新）\n*   缺点：\n    *   安全问题 `AJAX`暴露了与服务器交互的细节。\n    *   对搜索引擎的支持比较弱。\n    *   不容易调试。\n\n### 10 如何解决跨域问题?\n\n> 首先了解下浏览器的同源策略 同源策略`/SOP（Same origin policy）`是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到`XSS`、`CSFR`等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源\n\n那么怎样解决跨域问题的呢？\n\n*   通过jsonp跨域\n\nvar script = document.createElement('script');script.type = 'text/javascript';// 传参并指定回调执行函数为onBackscript.src = 'http://www.....:8080/login?user=admin&callback=onBack';document.head.appendChild(script);// 回调执行函数function onBack(res) {\n    alert(JSON.stringify(res));}\n\n*   document.domain + iframe跨域\n\n> 此方案仅限主域相同，子域不同的跨域应用场景\n\n1.）父窗口：(http://www.domain.com/a.html)\n\n<iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe><script>\n    document.domain = 'domain.com';\n    var user = 'admin';</script>\n\n2.）子窗口：(http://child.domain.com/b.html)\n\ndocument.domain = 'domain.com';// 获取父窗口中变量alert('get js data from parent ---> ' + window.parent.user);\n\n*   nginx代理跨域\n*   nodejs中间件代理跨域\n*   后端在头部信息里面设置安全域名\n\n### 11 模块化开发怎么做？\n\n*   立即执行函数,不暴露私有成员\n\nvar module1 = (function(){　　　　var _count = 0;　　　　var m1 = function(){　　　　　　//...　　　　};　　　　var m2 = function(){　　　　　　//...　　　　};　　　　return {　　　　　　m1 : m1,　　　　　　m2 : m2\n　　　　};})();\n\n### 12 异步加载JS的方式有哪些？\n\n*   defer，只支持`IE`\n*   `async`：\n*   创建`script`，插入到`DOM`中，加载完毕后`callBack`\n\n### 13 那些操作会造成内存泄漏？\n\n*   内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\n*   `setTimeout` 的第一个参数使用字符串而非函数的话，会引发内存泄漏\n*   闭包使用不当\n\n### 14 XML和JSON的区别？\n\n*   数据体积方面\n    *   `JSON`相对`于XML`来讲，数据的体积小，传递的速度更快些。\n*   数据交互方面\n    *   `JSON`与`JavaScript`的交互更加方便，更容易解析处理，更好的数据交互\n*   数据描述方面\n    *   `JSON`对数据的描述性比`XML`较差\n*   传输速度方面\n    *   `JSON`的速度要远远快于`XML`\n\n### 15 谈谈你对webpack的看法\n\n*   `WebPack` 是一个模块打包工具，你可以使用`WebPack`管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包`Web`开发中所用到的`HTML`、`Javascript`、`CSS`以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，`webpack`有对应的模块加载器。`webpack`模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源\n\n### 16 说说你对AMD和Commonjs的理解\n\n*   `CommonJS`是服务器端模块的规范，`Node.js`采用了这个规范。`CommonJS`规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。`AMD`规范则是非同步加载模块，允许指定回调函数\n*   `AMD`推荐的风格通过返回一个对象做为模块对象，`CommonJS`的风格通过对`module.exports`或`exports`的属性赋值来达到暴露模块对象的目的\n\n### 17 常见web安全及防护原理\n\n*   `sql`注入原理\n    *   就是通过把`SQL`命令插入到`Web`表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令\n*   总的来说有以下几点\n    *   永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双`\"-\"`进行转换等\n    *   永远不要使用动态拼装SQL，可以使用参数化的`SQL`或者直接使用存储过程进行数据查询存取\n    *   永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接\n    *   不要把机密信息明文存放，请加密或者`hash`掉密码和敏感的信息\n\nXSS原理及防范\n\n*   `Xss(cross-site scripting)`攻击指的是攻击者往`Web`页面里插入恶意`html`标签或者`javascript`代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取`cookie`中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点\n\nXSS防范方法\n\n*   首先代码里对用户输入的地方和变量都需要仔细检查长度和对`”<”,”>”,”;”,”’”`等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把`html tag` 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击\n\nXSS与CSRF有什么区别吗？\n\n*   `XSS`是获取信息，不需要提前知道其他用户页面的代码和数据包。`CSRF`是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次`CSRF`攻击，受害者必须依次完成两个步骤\n*   登录受信任网站`A`，并在本地生成`Cookie`\n*   在不登出`A`的情况下，访问危险网站`B`\n\nCSRF的防御\n\n*   服务端的`CSRF`方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数\n*   通过验证码的方法\n\n### 18 用过哪些设计模式？\n\n*   工厂模式：\n    *   工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法\n    *   主要好处就是可以消除对象间的耦合，通过使用工程方法而不是`new`关键字\n*   构造函数模式\n    *   使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于\n    *   直接将属性和方法赋值给 `this`对象;\n\n### 19 为什么要有同源限制？\n\n*   同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议\n*   举例说明：比如一个黑客程序，他利用`Iframe`把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过`Javascript`读取到你的表单中`input`中的内容，这样用户名，密码就轻松到手了。\n\n### 20 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别\n\n*   `offsetWidth/offsetHeight`返回值包含content + padding + border，效果与e.getBoundingClientRect()相同\n*   `clientWidth/clientHeight`返回值只包含content + padding，如果有滚动条，也不包含滚动条\n*   `scrollWidth/scrollHeight`返回值包含content + padding + 溢出内容的尺寸\n\n### 21 javascript有哪些方法定义对象\n\n*   对象字面量： `var obj = {};`\n*   构造函数： `var obj = new Object();`\n*   Object.create(): `var obj = Object.create(Object.prototype);`\n\n### 22 常见兼容性问题？\n\n*   `png24`位的图片在iE6浏览器上出现背景，解决方案是做成`PNG8`\n*   浏览器默认的`margin`和`padding`不同。解决方案是加一个全局的`*{margin:0;padding:0;}`来统一,，但是全局效率很低，一般是如下这样解决：\n\nbody,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p{margin:0;padding:0;}\n\n*   `IE`下,`event`对象有`x`,`y`属性,但是没有`pageX`,`pageY`属性\n*   `Firefox`下,`event`对象有`pageX`,`pageY`属性,但是没有`x,y`属性.\n\n### 23 说说你对promise的了解\n\n*   依照 `Promise/A+` 的定义，`Promise` 有四种状态：\n    *   `pending:` 初始状态, 非 `fulfilled` 或 `rejected.`\n    *   `fulfilled:` 成功的操作.\n    *   `rejected:` 失败的操作.\n    *   `settled: Promise`已被`fulfilled`或`rejected`，且不是`pending`\n*   另外， `fulfilled`与 `rejected`一起合称 `settled`\n*   `Promise` 对象用来进行延迟(`deferred`) 和异步(`asynchronous`) 计算\n\nPromise 的构造函数\n\n*   构造一个 `Promise`，最基本的用法如下：\n\nvar promise = new Promise(function(resolve, reject) {\n\n        if (...) {  // succeed\n\n            resolve(result);\n\n        } else {   // fails\n\n            reject(Error(errMessage));\n\n        }\n    });\n\n*   `Promise` 实例拥有 `then` 方法（具有 `then` 方法的对象，通常被称为`thenable`）。它的使用方法如下：\n\npromise.then(onFulfilled, onRejected)\n\n*   接收两个函数作为参数，一个在 `fulfilled` 的时候被调用，一个在`rejected`的时候被调用，接收参数就是 `future`，`onFulfilled` 对应`resolve`, `onRejected`对应 `reject`\n\n### 24 你觉得jQuery源码有哪些写的好的地方\n\n*   `jquery`源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入`window`对象参数，可以使`window`对象作为局部变量使用，好处是当`jquery`中访问`window`对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入`undefined`参数，可以缩短查找`undefined`时的作用域链\n*   `jquery`将一些原型属性和方法封装在了`jquery.prototype`中，为了缩短名称，又赋值给了`jquery.fn`，这是很形象的写法\n*   有一些数组或对象的方法经常能使用到，`jQuery`将其保存为局部变量以提高访问速度\n*   `jquery`实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率\n\n### 25 vue、react、angular\n\n*   `Vue.js` 一个用于创建 `web` 交互界面的库，是一个精简的 `MVVM`。它通过双向数据绑定把 `View`层和 `Model` 层连接了起来。实际的 `DOM` 封装和输出格式都被抽象为了`Directives` 和 `Filters`\n*   `AngularJS` 是一个比较完善的前端`MVVM`框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 `Angular`指令\n*   `react` `React` 仅仅是 `VIEW` 层是`facebook`公司。推出的一个用于构建`UI`的一个库，能够实现服务器端的渲染。用了`virtual dom`，所以性能很好。\n\n### 26 Node的应用场景\n\n*   特点：\n    *   1、它是一个`Javascript`运行环境\n    *   2、依赖于`Chrome V8`引擎进行代码解释\n    *   3、事件驱动\n    *   4、非阻塞`I/O`\n    *   5、单进程，单线程\n*   优点：\n    *   高并发（最重要的优点）\n*   缺点：\n    *   1、只支持单核`CPU`，不能充分利用`CPU`\n    *   2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃\n\n### 27 谈谈你对AMD、CMD的理解\n\n*   `CommonJS`是服务器端模块的规范，`Node.js`采用了这个规范。`CommonJS`规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。`AMD`规范则是非同步加载模块，允许指定回调函数\n*   `AMD`推荐的风格通过返回一个对象做为模块对象，`CommonJS`的风格通过对`module.exports`或`exports`的属性赋值来达到暴露模块对象的目的\n\nes6模块 CommonJS、AMD、CMD\n\n*   `CommonJS` 的规范中，每个 `JavaScript` 文件就是一个独立的模块上下文（`module context`），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。\n*   `CommonJS`是同步加载模块,在浏览器中会出现堵塞情况，所以不适用\n*   `AMD` 异步，需要定义回调`define`方式\n*   `es6` 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量 `es6`还可以导出类、方法，自动适用严格模式\n\n### 28 那些操作会造成内存泄漏\n\n*   内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\n*   `setTimeout` 的第一个参数使用字符串而非函数的话，会引发内存泄漏\n*   闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n\n### 29 web开发中会话跟踪的方法有哪些\n\n*   `cookie`\n*   `session`\n*   `url`重写\n*   隐藏`input`\n*   `ip`地址\n\n### 30 介绍js的基本数据类型\n\n*   `Undefined`、`Null`、`Boolean`、`Number`、`String`\n\n### 31 介绍js有哪些内置对象\n\n*   `Object` 是 `JavaScript` 中所有对象的父对象\n*   数据封装类对象：`Object`、`Array`、`Boolean`、`Number` 和 `String`\n*   其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`\n\n### 32 说几条写JavaScript的基本规范\n\n*   不要在同一行声明多个变量\n*   请使用`===/!==`来比较`true/false`或者数值\n*   使用对象字面量替代`new Array`这种形式\n*   不要使用全局函数\n*   `Switch`语句必须带有`default`分支\n*   `If`语句必须使用大括号\n*   `for-in`循环中的变量 应该使用`var`关键字明确限定作用域，从而避免作用域污\n\n### 33 JavaScript有几种类型的值\n\n*   栈：原始数据类型（`Undefined`，`Null`，`Boolean`，`Number`、`String`）\n*   堆：引用数据类型（对象、数组和函数）\n*   两种类型的区别是：存储位置不同；\n*   原始数据类型直接存储在栈(`stack`)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n*   引用数据类型存储在堆(`heap`)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其\n*   在栈中的地址，取得地址后从堆中获得实体\n\n![](https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966)\n\n### 34 javascript创建对象的几种方式\n\n> `javascript`创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用`JSON`；但写法有很多种，也能混合使用\n\n*   对象字面量的方式\n\nperson={firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"};\n\n*   用`function`来模拟无参的构造函数\n\nfunction Person(){}\n var person=new Person();//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class\n        person.name=\"Mark\";\n        person.age=\"25\";\n        person.work=function(){\n        alert(person.name+\" hello...\");}person.work();\n\n*   用`function`来模拟参构造函数来实现（用`this`关键字定义构造的上下文属性）\n\nfunction Pet(name,age,hobby){\n       this.name=name;//this作用域：当前对象\n       this.age=age;\n       this.hobby=hobby;\n       this.eat=function(){\n           alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\");\n       }}var maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象maidou.eat();//调用eat方法\n\n*   用工厂方式来创建（内置对象）\n\nvar wcDog =new Object();\n     wcDog.name=\"旺财\";\n     wcDog.age=3;\n     wcDog.work=function(){\n       alert(\"我是\"+wcDog.name+\",汪汪汪......\");\n     }\n     wcDog.work();\n\n*   用原型方式来创建\n\nfunction Dog(){}Dog.prototype.name=\"旺财\";Dog.prototype.eat=function(){\n alert(this.name+\"是个吃货\");}var wangcai =new Dog();wangcai.eat();\n\n*   用混合方式来创建\n\n function Car(name,price){\n this.name=name;\n this.price=price;}Car.prototype.sell=function(){\n alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\");}var camry =new Car(\"凯美瑞\",27);camry.sell();\n\n### 35 eval是做什么的\n\n*   它的功能是把对应的字符串解析成`JS`代码并运行\n*   应该避免使用`eval`，不安全，非常耗性能（`2`次，一次解析成`js`语句，一次执行）\n*   由`JSON`字符串转换为JSON对象的时候可以用`eval，var obj =eval('('+ str +')')`\n\n### 36 null，undefined 的区别\n\n*   `undefined` 表示不存在这个值。\n*   `undefined` :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 `undefined`\n*   例如变量被声明了，但没有赋值时，就等于`undefined`\n*   `null` 表示一个对象被定义了，值为“空值”\n*   `null` : 是一个对象(空对象, 没有任何属性和方法)\n*   例如作为函数的参数，表示该函数的参数不是对象；\n*   在验证`null`时，一定要使用　`===` ，因为 `==`无法分别`null` 和　`undefined`\n\n### 37 \\[\"1\", \"2\", \"3\"\\].map(parseInt) 答案是多少\n\n*   `[1, NaN, NaN]`因为 `parseInt` 需要两个参数 `(val, radix)`，其中`radix` 表示解析时用的基数。\n*   `map`传了 `3`个`(element, index, array)`，对应的 `radix` 不合法导致解析失败。\n\n### 38 javascript 代码中的\"use strict\";是什么意思\n\n*   `use strict`是一种`ECMAscript 5` 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使`JS`编码更加规范化的模式,消除`Javascript`语法的一些不合理、不严谨之处，减少一些怪异行为\n\n### 39 JSON 的了解\n\n*   `JSON(JavaScript Object Notation)` 是一种轻量级的数据交换格式\n*   它是基于`JavaScript`的一个子集。数据格式简单, 易于读写, 占用带宽小\n*   `JSON`字符串转换为JSON对象:\n\nvar obj =eval('('+ str +')');var obj = str.parseJSON();var obj = JSON.parse(str);\n\n*   `JSON`对象转换为JSON字符串：\n\nvar last=obj.toJSONString();\nvar last=JSON.stringify(obj);\n\n### 40 js延迟加载的方式有哪些\n\n*   `defer`和`async`、动态创建`DOM`方式（用得最多）、按需异步载入`js`\n\n### 41 同步和异步的区别\n\n*   同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作\n*   异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容\n\n### 42 渐进增强和优雅降级\n\n*   渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n*   优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容\n\n### 43 defer和async\n\n*   `defer`并行加载`js`文件，会按照页面上`script`标签的顺序执行\n*   `async`并行加载`js`文件，下载完成立即执行，不会按照页面上`script`标签的顺序执行\n\n### 44 说说严格模式的限制\n\n*   变量必须声明后再使用\n*   函数的参数不能有同名属性，否则报错\n*   不能使用`with`语句\n*   禁止`this`指向全局对象\n\n### 45 attribute和property的区别是什么\n\n*   `attribute`是`dom`元素在文档中作为`html`标签拥有的属性；\n*   `property`就是`dom`元素在`js`中作为对象拥有的属性。\n*   对于`html`的标准属性来说，`attribute`和`property`是同步的，是会自动更新的\n*   但是对于自定义的属性来说，他们是不同步的\n\n### 46 谈谈你对ES6的理解\n\n*   新增模板字符串（为`JavaScript`提供了简单的字符串插值功能）\n*   箭头函数\n*   `for-of`（用来遍历数据—例如数组中的值。）\n*   `arguments`对象可被不定参数和默认参数完美代替。\n*   `ES6`将p`romise`对象纳入规范，提供了原生的`Promise`对象。\n*   增加了`let`和`const`命令，用来声明变量。\n*   增加了块级作用域。\n*   `let`命令实际上就增加了块级作用域。\n*   还有就是引入`module`模块的概念\n\n### 47 ECMAScript6 怎么写class么\n\n*   这个语法糖可以让有`OOP`基础的人更快上手`js`，至少是一个官方的实现了\n*   但对熟悉`js`的人来说，这个东西没啥大影响；一个`Object.creat()`搞定继承，比`class`简洁清晰的多\n\n### 48 什么是面向对象编程及面向过程编程，它们的异同和优缺点\n\n*   面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了\n*   面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为\n*   面向对象是以功能来划分问题，而不是步骤\n\n### 49 面向对象编程思想\n\n*   基本思想是使用对象，类，继承，封装等基本概念来进行程序设计\n*   优点\n    *   采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的\n    *   易维护\n    *   易扩展\n    *   开发工作的重用性、继承性高，降低重复工作量。\n    *   缩短了开发周期\n\n### 50 对web标准、可用性、可访问性的理解\n\n*   可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力\n*   可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性\n*   可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。\n\n### 51 如何通过JS判断一个数组\n\n*   `instanceof`方法\n    *   `instanceof` 运算符是用来测试一个对象是否在其原型链原型构造函数的属性\n\nvar arr = \\[\\];arr instanceof Array; // true\n\n*   `constructor`方法\n    *   `constructor`属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数\n\nvar arr = \\[\\];arr.constructor == Array; //true\n\n*   最简单的方法\n    *   这种写法，是 `jQuery` 正在使用的\n\nObject.prototype.toString.call(value) == '\\[object Array\\]'// 利用这个方法，可以写一个返回数据类型的方法var isType = function (obj) {\n     return Object.prototype.toString.call(obj).slice(8,-1);}\n\n*   `ES5`新增方法`isArray()`\n\nvar a = new Array(123);var b = new Date();console.log(Array.isArray(a)); //trueconsole.log(Array.isArray(b)); //false\n\n### 52 谈一谈let与var的区别\n\n*   `let`命令不存在变量提升，如果在`let`前使用，会导致报错\n*   如果块区中存在`let`和`const`命令，就会形成封闭作用域\n*   不允许重复声明，因此，不能在函数内部重新声明参数\n\n### 53 map与forEach的区别\n\n*   `forEach`方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容`item`、数组索引`index`、和当前遍历数组`Array`\n*   `map`方法，基本用法与`forEach`一致，但是不同的，它会返回一个新的数组，所以在callback需要有`return`值，如果没有，会返回`undefined`\n\n### 54 谈一谈你理解的函数式编程\n\n*   简单说，\"函数式编程\"是一种\"编程范式\"（programming paradigm），也就是如何编写程序的方法论\n*   它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是\"第一等公民\"、只用\"表达式\"\n\n### 55 谈一谈箭头函数与普通函数的区别？\n\n*   函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象\n*   不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误\n*   不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用`Rest`参数代替\n*   不可以使用`yield`命令，因此箭头函数不能用作`Generator`函数\n\n### 56 谈一谈函数中this的指向\n\n*   this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象\n*   《javascript语言精髓》中大概概括了4种调用方式：\n*   方法调用模式\n*   函数调用模式\n*   构造器调用模式\n\ngraph LRA-->B\n\n*   apply/call调用模式\n\n### 57 异步编程的实现方式\n\n*   回调函数\n    *   优点：简单、容易理解\n    *   缺点：不利于维护，代码耦合高\n*   事件监听(采用时间驱动模式，取决于某个事件是否发生)：\n    *   优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数\n    *   缺点：事件驱动型，流程不够清晰\n*   发布/订阅(观察者模式)\n    *   类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者\n*   Promise对象\n    *   优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；\n    *   缺点：编写和理解，相对比较难\n*   Generator函数\n    *   优点：函数体内外的数据交换、错误处理机制\n    *   缺点：流程管理不方便\n*   async函数\n    *   优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。\n    *   缺点：错误处理机制\n\n### 58 对原生Javascript了解程度\n\n*   数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、`RegExp`、`JSON`、`Ajax`、`DOM`、`BOM`、内存泄漏、跨域、异步装载、模板引擎、前端`MVC`、路由、模块化、`Canvas`、`ECMAScript`\n\n### 59 Js动画与CSS动画区别及相应实现\n\n*   `CSS3`的动画的优点\n    *   在性能上会稍微好一些，浏览器会对`CSS3`的动画做一些优化\n    *   代码相对简单\n*   缺点\n    *   在动画控制上不够灵活\n    *   兼容性不好\n*   `JavaScript`的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容`IE6`，并且功能强大。对于一些复杂控制的动画，使用`javascript`会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑`CSS`吧\n\n### 60 JS 数组和对象的遍历方式，以及几种方式的比较\n\n> 通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历\n\n*   `for in`循环\n*   `for`循环\n*   `forEach`\n    *   这里的 `forEach`回调中两个参数分别为 `value`，`index`\n    *   `forEach` 无法遍历对象\n    *   IE不支持该方法；`Firefox` 和 `chrome` 支持\n    *   `forEach` 无法使用 `break`，`continue` 跳出循环，且使用 `return` 是跳过本次循环\n*   这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题\n*   在方式一中，`for-in`需要分析出`array`的每个属性，这个操作性能开销很大。用在 `key` 已知的数组上是非常不划算的。所以尽量不要用`for-in`，除非你不清楚要处理哪些属性，例如 `JSON`对象这样的情况\n*   在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 `array` 里存放的都是 `DOM` 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低\n\n### 61 gulp是什么\n\n*   `gulp`是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成\n*   Gulp的核心概念：流\n*   流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向\n*   gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作\n*   Gulp的特点：\n    *   易于使用：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理\n    *   构建快速 利用 `Node.js` 流的威力，你可以快速构建项目并减少频繁的 `IO` 操作\n    *   易于学习 通过最少的 `API`，掌握 `gulp` 毫不费力，构建工作尽在掌握：如同一系列流管道\n\n### 62 说一下Vue的双向绑定数据的原理\n\n*   `vue.js` 则是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调\n\n### 63 事件的各个阶段\n\n*   1：捕获阶段 ---> 2：目标阶段 ---> 3：冒泡阶段\n*   `document` ---> `target`目标 ----> `document`\n*   由此，`addEventListener`的第三个参数设置为`true`和`false`的区别已经非常清晰了\n    *   `true`表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件\n    *   `false`表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件\n\n### 64 let var const\n\nlet\n\n*   允许你声明一个作用域被限制在块级中的变量、语句或者表达式\n*   let绑定不受变量提升的约束，这意味着let声明不会被提升到当前\n*   该变量处于从块开始到初始化处理的“暂存死区”\n\nvar\n\n*   声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的\n*   由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明\n\nconst\n\n*   声明创建一个值的只读引用 (即指针)\n*   基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 `const`申明基本数据类型时\n*   再将其值改变时，将会造成报错， 例如 `const a = 3` ; `a = 5`时 将会报错\n*   但是如果是复合类型时，如果只改变复合类型的其中某个`Value`项时， 将还是正常使用\n\n### 65 快速的让一个数组乱序\n\nvar arr = \\[1,2,3,4,5,6,7,8,9,10\\];arr.sort(function(){\n    return Math.random() - 0.5;})console.log(arr);\n\n### 66 如何渲染几万条数据并不卡住界面\n\n> 这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 `DOM`，那么就可以通过 `requestAnimationFrame` 来每 `16 ms` 刷新一次\n\n<!DOCTYPE html><html lang=\"en\"><head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title></head><body>\n  <ul>控件</ul>\n  <script>\n    setTimeout(() => {\n      // 插入十万条数据\n      const total = 100000\n      // 一次插入 20 条，如果觉得性能不好就减少\n      const once = 20\n      // 渲染数据总共需要几次\n      const loopCount = total / once      let countOfRender = 0\n      let ul = document.querySelector(\"ul\");\n      function add() {\n        // 优化性能，插入不会造成回流\n        const fragment = document.createDocumentFragment();\n        for (let i = 0; i < once; i++) {\n          const li = document.createElement(\"li\");\n          li.innerText = Math.floor(Math.random() * total);\n          fragment.appendChild(li);\n        }\n        ul.appendChild(fragment);\n        countOfRender += 1;\n        loop();\n      }\n      function loop() {\n        if (countOfRender < loopCount) {\n          window.requestAnimationFrame(add);\n        }\n      }\n      loop();\n    }, 0);\n  </script></body></html>\n\n### 67 希望获取到页面中所有的checkbox怎么做？\n\n> 不使用第三方框架\n\n var domList = document.getElementsByTagName(‘input’)\n var checkBoxList = \\[\\];\n var len = domList.length;　　//缓存到局部变量\n while (len--) {　　//使用while的效率会比for循环更高\n 　　if (domList\\[len\\].type == ‘checkbox’) {\n     　　checkBoxList.push(domList\\[len\\]);\n 　　}\n }\n\n### 68 怎样添加、移除、移动、复制、创建和查找节点\n\n创建新节点\n\ncreateDocumentFragment()    //创建一个DOM片段createElement()   //创建一个具体的元素createTextNode()   //创建一个文本节点\n\n添加、移除、替换、插入\n\nappendChild()      //添加removeChild()      //移除replaceChild()      //替换insertBefore()      //插入\n\n查找\n\ngetElementsByTagName()    //通过标签名称getElementsByName()     //通过元素的Name属性的值getElementById()        //通过元素Id，唯一性\n\n### 69 正则表达式\n\n> 正则表达式构造函数`var reg=new RegExp(“xxx”)`与正则表达字面量`var reg=//`有什么不同？匹配邮箱的正则表达式？\n\n*   当使用`RegExp()`构造函数的时候，不仅需要转义引号（即`\\`”表示”），并且还需要双反斜杠（即`\\\\`表示一个`\\`）。使用正则表达字面量的效率更高\n\n邮箱的正则匹配：\n\nvar regMail = /^(\\[a-zA-Z0-9_-\\])+@(\\[a-zA-Z0-9_-\\])+((.\\[a-zA-Z0-9_-\\]{2,3}){1,2})$/;\n\n### 70 Javascript中callee和caller的作用？\n\n*   `caller`是返回一个对函数的引用，该函数调用了当前函数；\n*   `callee`是返回正在被执行的`function`函数，也就是所指定的`function`对象的正文\n\n> 那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用`callee`完成）\n\nvar result=\\[\\];\n  function fn(n){  //典型的斐波那契数列\n     if(n==1){\n          return 1;\n     }else if(n==2){\n             return 1;\n     }else{\n          if(result\\[n\\]){\n                  return result\\[n\\];\n         }else{\n                 //argument.callee()表示fn()\n                 result\\[n\\]=arguments.callee(n-1)+arguments.callee(n-2);\n                 return result\\[n\\];\n         }\n    }\n }\n\n### 71 window.onload和$(document).ready\n\n> 原生`JS`的`window.onload`与`Jquery`的`$(document).ready(function(){})`有什么不同？如何用原生JS实现Jq的`ready`方法？\n\n*   `window.onload()`方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。\n*   `$(document).ready()`是`DOM`结构绘制完毕后就执行，不必等到加载完毕\n\nfunction ready(fn){\n      if(document.addEventListener) {        //标准浏览器\n          document.addEventListener('DOMContentLoaded', function() {\n              //注销事件, 避免反复触发\n              document.removeEventListener('DOMContentLoaded',arguments.callee, false);\n              fn();            //执行函数\n          }, false);\n      }else if(document.attachEvent) {        //IE\n          document.attachEvent('onreadystatechange', function() {\n             if(document.readyState == 'complete') {\n                 document.detachEvent('onreadystatechange', arguments.callee);\n                 fn();        //函数执行\n             }\n         });\n     }\n };\n\n### 72 addEventListener()和attachEvent()的区别\n\n*   `addEventListener()`是符合W3C规范的标准方法; `attachEvent()`是IE低版本的非标准方法\n*   `addEventListener()`支持事件冒泡和事件捕获; \\- 而`attachEvent()`只支持事件冒泡\n*   `addEventListener()`的第一个参数中,事件类型不需要添加`on`; `attachEvent()`需要添加`'on'`\n*   如果为同一个元素绑定多个事件, `addEventListener()`会按照事件绑定的顺序依次执行,`attachEvent()`会按照事件绑定的顺序倒序执行\n\n### 73 获取页面所有的checkbox\n\nvar resultArr= \\[\\];var input = document.querySelectorAll('input');for( var i = 0; i < input.length; i++ ) {\n    if( input\\[i\\].type == 'checkbox' ) {\n        resultArr.push( input\\[i\\] );\n    }}//resultArr即中获取到了页面中的所有checkbox\n\n### 74 数组去重方法总结\n\n方法一、利用ES6 Set去重（ES6中最常用）\n\nfunction unique (arr) {\n  return Array.from(new Set(arr))}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))\n //\\[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}\\]\n\n方法二、利用for嵌套for，然后splice去重（ES5中最常用）\n\nfunction unique(arr){            \n        for(var i=0; i<arr.length; i++){\n            for(var j=i+1; j<arr.length; j++){\n                if(arr\\[i\\]==arr\\[j\\]){         //第一个等同于第二个，splice方法删除第二个\n                    arr.splice(j,1);\n                    j--;\n                }\n            }\n        }\n return arr;}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))\n    //\\[1, \"true\", 15, false, undefined, NaN, NaN, \"NaN\", \"a\", {…}, {…}\\]     //NaN和{}没有去重，两个null直接消失了\n\n*   双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。\n*   想快速学习更多常用的`ES6`语法\n\n方法三、利用indexOf去重\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array = \\[\\];\n    for (var i = 0; i < arr.length; i++) {\n        if (array .indexOf(arr\\[i\\]) === -1) {\n            array .push(arr\\[i\\])\n        }\n    }\n    return array;}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))\n   // \\[1, \"true\", true, 15, false, undefined, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, {…}\\]  //NaN、{}没有去重\n\n> 新建一个空的结果数组，`for` 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则`push`进数组\n\n方法四、利用sort()\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return;\n    }\n    arr = arr.sort()\n    var arrry= \\[arr\\[0\\]\\];\n    for (var i = 1; i < arr.length; i++) {\n        if (arr\\[i\\] !== arr\\[i-1\\]) {\n            arrry.push(arr\\[i\\]);\n        }\n    }\n    return arrry;}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))// \\[0, 1, 15, \"NaN\", NaN, NaN, {…}, {…}, \"a\", false, null, true, \"true\", undefined\\]      //NaN、{}没有去重\n\n> 利用`sort()`排序方法，然后根据排序后的结果进行遍历及相邻元素比对\n\n方法五、利用对象的属性不能相同的特点进行去重\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var arrry= \\[\\];\n     var  obj = {};\n    for (var i = 0; i < arr.length; i++) {\n        if (!obj\\[arr\\[i\\]\\]) {\n            arrry.push(arr\\[i\\])\n            obj\\[arr\\[i\\]\\] = 1\n        } else {\n            obj\\[arr\\[i\\]\\]++\n        }\n    }\n    return arrry;}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))//\\[1, \"true\", 15, false, undefined, null, NaN, 0, \"a\", {…}\\]    //两个true直接去掉了，NaN和{}去重\n\n方法六、利用includes\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array =\\[\\];\n    for(var i = 0; i < arr.length; i++) {\n            if( !array.includes( arr\\[i\\]) ) {//includes 检测数组是否有某个值\n                    array.push(arr\\[i\\]);\n              }\n    }\n    return array}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))\n    //\\[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}\\]     //{}没有去重\n\n方法七、利用hasOwnProperty\n\nfunction unique(arr) {\n    var obj = {};\n    return arr.filter(function(item, index, arr){\n        return obj.hasOwnProperty(typeof item + item) ? false : (obj\\[typeof item + item\\] = true)\n    })}\n    var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];\n        console.log(unique(arr))//\\[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}\\]   //所有的都去重了\n\n> 利用`hasOwnProperty` 判断是否存在对象属性\n\n方法八、利用filter\n\nfunction unique(arr) {\n  return arr.filter(function(item, index, arr) {\n    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素\n    return arr.indexOf(item, 0) === index;\n  });}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))//\\[1, \"true\", true, 15, false, undefined, null, \"NaN\", 0, \"a\", {…}, {…}\\]\n\n方法九、利用递归去重\n\nfunction unique(arr) {\n    var array= arr;\n    var len = array.length;\n\n array.sort(function(a,b){   //排序后更加方便去重\n return a - b;\n })\n\n function loop(index){\n        if(index >= 1){\n            if(array\\[index\\] === array\\[index-1\\]){\n            array.splice(index,1);\n            }\n            loop(index - 1);    //递归loop，然后数组去重\n        }\n }\n loop(len-1);\n return array;}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))//\\[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined\\]\n\n方法十、利用Map数据结构去重\n\nfunction arrayNonRepeatfy(arr) {\n let map = new Map();\n let array = new Array();  // 数组用于返回结果\n for (let i = 0; i < arr.length; i++) {\n if(map .has(arr\\[i\\])) {  // 如果有该key值\n map .set(arr\\[i\\], true);\n } else {\n map .set(arr\\[i\\], false);   // 如果没有该key值\n array .push(arr\\[i\\]);\n }\n }\n return array ;}\n var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];\n    console.log(unique(arr))//\\[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined\\]\n\n> 创建一个空`Map`数据结构，遍历需要去重的数组，把数组的每一个元素作为`key`存到`Map`中。由于`Map`中不会出现相同的`key`值，所以最终得到的就是去重后的结果\n\n方法十一、利用reduce+includes\n\nfunction unique(arr){\n    return arr.reduce((prev,cur) => prev.includes(cur) ? prev : \\[...prev,cur\\],\\[\\]);}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr));// \\[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}\\]\n\n方法十二、\\[...new Set(arr)\\]\n\n\\[...new Set(arr)\\]//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）\n\n### 75 （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）\n\n*   给需要拖拽的节点绑定`mousedown`, `mousemove`, `mouseup`事件\n*   `mousedown`事件触发后，开始拖拽\n*   `mousemove`时，需要通过`event.clientX`和`clientY`获取拖拽位置，并实时更新位置\n*   `mouseup`时，拖拽结束\n*   需要注意浏览器边界的情况\n\n### 76 Javascript全局函数和全局变量\n\n全局变量\n\n*   `Infinity` 代表正的无穷大的数值。\n*   `NaN` 指示某个值是不是数字值。\n*   `undefined` 指示未定义的值。\n\n全局函数\n\n*   `decodeURI()` 解码某个编码的 `URI`。\n*   `decodeURIComponent()` 解码一个编码的 `URI` 组件。\n*   `encodeURI()` 把字符串编码为 URI。\n*   `encodeURIComponent()` 把字符串编码为 `URI` 组件。\n*   `escape()` 对字符串进行编码。\n*   `eval()` 计算 `JavaScript` 字符串，并把它作为脚本代码来执行。\n*   `isFinite()` 检查某个值是否为有穷大的数。\n*   `isNaN()` 检查某个值是否是数字。\n*   `Number()` 把对象的值转换为数字。\n*   `parseFloat()` 解析一个字符串并返回一个浮点数。\n*   `parseInt()` 解析一个字符串并返回一个整数。\n*   `String()` 把对象的值转换为字符串。\n*   `unescape()` 对由`escape()` 编码的字符串进行解码\n\n### 77 使用js实现一个持续的动画效果\n\n定时器思路\n\nvar e = document.getElementById('e')var flag = true;var left = 0;setInterval(() => {\n    left == 0 ? flag = true : left == 100 ? flag = false : ''\n    flag ? e.style.left = ` ${left++}px` : e.style.left = ` ${left--}px`}, 1000 / 60)\n\nrequestAnimationFrame\n\n//兼容性处理window.requestAnimFrame = (function(){\n    return window.requestAnimationFrame       ||\n           window.webkitRequestAnimationFrame ||\n           window.mozRequestAnimationFrame    ||\n           function(callback){\n                window.setTimeout(callback, 1000 / 60);\n           };})();var e = document.getElementById(\"e\");var flag = true;var left = 0;function render() {\n    left == 0 ? flag = true : left == 100 ? flag = false : '';\n    flag ? e.style.left = ` ${left++}px` :\n        e.style.left = ` ${left--}px`;}(function animloop() {\n    render();\n    requestAnimFrame(animloop);})();\n\n使用css实现一个持续的动画效果\n\nanimation:mymove 5s infinite;@keyframes mymove {\n    from {top:0px;}\n    to {top:200px;}}\n\n*   `animation-name` 规定需要绑定到选择器的 `keyframe`名称。\n*   `animation-duration` 规定完成动画所花费的时间，以秒或毫秒计。\n*   `animation-timing-function` 规定动画的速度曲线。\n*   `animation-delay` 规定在动画开始之前的延迟。\n*   `animation-iteration-count` 规定动画应该播放的次数。\n*   `animation-direction` 规定是否应该轮流反向播放动画\n\n### 78 封装一个函数，参数是定时器的时间，.then执行回调函数\n\nfunction sleep (time) {\n    return new Promise((resolve) => setTimeout(resolve, time));}\n\n### 79 怎么判断两个对象相等？\n\nobj={\n    a:1,\n    b:2}obj2={\n    a:1,\n    b:2}obj3={\n    a:1,\n    b:'2'}\n\n> 可以转换为字符串来判断\n\nJSON.stringify(obj)==JSON.stringify(obj2);//trueJSON.stringify(obj)==JSON.stringify(obj3);//false\n\n### 80 项目做过哪些性能优化？\n\n*   减少 `HTTP` 请求数\n*   减少 `DNS` 查询\n*   使用 `CDN`\n*   避免重定向\n*   图片懒加载\n*   减少 `DOM` 元素数量\n*   减少`DOM` 操作\n*   使用外部 `JavaScript` 和 `CSS`\n*   压缩 `JavaScript` 、 `CSS` 、字体、图片等\n*   优化 `CSS Sprite`\n*   使用 `iconfont`\n*   字体裁剪\n*   多域名分发划分内容到不同域名\n*   尽量减少 `iframe` 使用\n*   避免图片 `src` 为空\n*   把样式表放在`link` 中\n*   把`JavaScript`放在页面底部\n\n### 81 浏览器缓存\n\n> 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下\n\n*   先根据这个资源的一些 `http header` 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；\n*   当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些`request header`验证这个资源是否命中协商缓存，称为`http`再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；\n*   强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。\n*   当协商缓存也没命中时，服务器就会将资源发送回客户端。\n*   当 `ctrl+f5` 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n*   当 `f5`刷新网页时，跳过强缓存，但是会检查协商缓存；\n\n强缓存\n\n*   `Expires`（该字段是 `http1.0` 时的规范，值为一个绝对时间的 `GMT` 格式的时间字符串，代表缓存资源的过期时间）\n*   `Cache-Control:max-age`（该字段是 `http1.1`的规范，强缓存利用其 `max-age` 值来判断缓存资源的最大生命周期，它的值单位为秒）\n\n协商缓存\n\n*   `Last-Modified`（值为资源最后更新时间，随服务器response返回）\n*   `If-Modified-Since`（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）\n*   `ETag`（表示资源内容的唯一标识，随服务器`response`返回）\n*   `If-None-Match`（服务器通过比较请求头部的`If-None-Match`与当前资源的`ETag`是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）\n\n### 82 WebSocket\n\n> 由于 `http` 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 `WebSocket`被发明出来\n\n> 相比与 `http` 具有以下有点\n\n*   支持双向通信，实时性更强；\n*   可以发送文本，也可以二进制文件；\n*   协议标识符是 `ws`，加密后是 `wss` ；\n*   较少的控制开销。连接创建后，`ws`客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有`2~10`字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而`HTTP`协议每次通信都需要携带完整的头部；\n*   支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）\n*   无跨域问题。\n\n> 实现比较简单，服务端库如 `socket.io`、`ws`，可以很好的帮助我们入门。而客户端也只需要参照 `api` 实现即可\n\n### 83 尽可能多的说出你对 Electron 的理解\n\n> 最最重要的一点，`electron` 实际上是一个套了 `Chrome` 的 `nodeJS`程序\n\n所以应该是从两个方面说开来\n\n*   `Chrome` （无各种兼容性问题）；\n*   `NodeJS`（`NodeJS` 能做的它也能做）\n\n### 84 深浅拷贝\n\n浅拷贝\n\n*   `Object.assign`\n*   或者展开运算符\n\n深拷贝\n\n*   可以通过 `JSON.parse(JSON.stringify(object))` 来解决\n\nlet a = {\n    age: 1,\n    jobs: {\n        first: 'FE'\n    }}let b = JSON.parse(JSON.stringify(a))a.jobs.first = 'native'console.log(b.jobs.first) // FE\n\n该方法也是有局限性的\n\n*   会忽略 `undefined`\n*   不能序列化函数\n*   不能解决循环引用的对象\n\n### 85 防抖/节流\n\n防抖\n\n> 在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现\n\n// 使用 underscore 的源码来解释防抖动/**\n * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        回调函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，是否立即调用函数\n * @return {function}             返回客户调用函数\n */_.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      // 现在和上一次时间戳比较\n      var last = _.now() - timestamp;\n      // 如果当前间隔时间少于设定时间且大于0就重新设置定时器\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        // 否则的话就是时间到了执行回调函数\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      // 获得时间戳\n      timestamp = _.now();\n      // 如果定时器不存在且立即执行函数\n      var callNow = immediate && !timeout;\n      // 如果定时器不存在就创建一个\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        // 如果需要立即执行函数的话 通过 apply 执行\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n> 整体函数实现\n\n对于按钮防点击来说的实现\n\n*   开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了\n*   对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数\n\n节流\n\n> 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行\n\n/**\n * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait\n *\n * @param  {function}   func      回调函数\n * @param  {number}     wait      表示时间窗口的间隔\n * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。\n *                                如果想忽略结尾函数的调用，传入{trailing: false}\n *                                两者不能共存，否则函数不能执行\n * @return {function}             返回客户调用函数   \n */_.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    // 之前的时间戳\n    var previous = 0;\n    // 如果 options 没传则设为空对象\n    if (!options) options = {};\n    // 定时器回调函数\n    var later = function() {\n      // 如果设置了 leading，就将 previous 设为 0\n      // 用于下面函数的第一个 if 判断\n      previous = options.leading === false ? 0 : _.now();\n      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      // 获得当前时间戳\n      var now = _.now();\n      // 首次进入前者肯定为 true\n   // 如果需要第一次不执行函数\n   // 就将上次时间戳设为当前的\n      // 这样在接下来计算 remaining 的值时会大于0\n      if (!previous && options.leading === false) previous = now;\n      // 计算剩余时间\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      // 如果当前调用已经大于上次调用时间 + wait\n      // 或者用户手动调了时间\n    // 如果设置了 trailing，只会进入这个条件\n   // 如果没有设置 leading，那么第一次会进入这个条件\n   // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了\n   // 其实还是会进入的，因为定时器的延时\n   // 并不是准确的时间，很可能你设置了2秒\n   // 但是他需要2.2秒才触发，这时候就会进入这个条件\n      if (remaining <= 0 || remaining > wait) {\n        // 如果存在定时器就清理掉否则会调用二次回调\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        // 判断是否设置了定时器和 trailing\n     // 没有的话就开启一个定时器\n        // 并且不能不能同时设置 leading 和 trailing\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n### 86 谈谈变量提升？\n\n> 当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境\n\n*   接下来让我们看一个老生常谈的例子，`var`\n\nb() // call bconsole.log(a) // undefinedvar a = 'Hello world'function b() {\n    console.log('call b')}\n\n变量提升 这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 `undefined`，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升\n\nb() // call b secondfunction b() {\n    console.log('call b fist')}function b() {\n    console.log('call b second')}var b = 'Hello world'\n\n> 复制代码`var` 会产生很多错误，所以在 `ES6`中引入了 `let`。`let` 不能在声明前使用，但是这并不是常说的 `let` 不会提升，`let` 提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用\n\n### 87 什么是单线程，和异步的关系\n\n*   单线程 \\- 只有一个线程，只能做一件事\n*   原因 \\- 避免 `DOM` 渲染的冲突\n    *   浏览器需要渲染 `DOM`\n    *   `JS` 可以修改 `DOM` 结构\n    *   `JS` 执行的时候，浏览器 `DOM` 渲染会暂停\n    *   两段 JS 也不能同时执行（都修改 `DOM` 就冲突了）\n    *   `webworker` 支持多线程，但是不能访问 `DOM`\n*   解决方案 \\- 异步\n\n### 88 是否用过 jQuery 的 Deferred\n\n![image.png](https://upload-images.jianshu.io/upload_images/1480597-77a330fbdcc1f1cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-6f79b726f5341f7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-82ac861eced36a45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-69092d725f2b1e79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-9d9b67a6859cf8cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-9970b83118b10829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-243444771c6b30ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ![image.png](https://upload-images.jianshu.io/upload_images/1480597-d2db463132d1572a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-c589d6f7caf8b27c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-ab3b7f684e99e6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 89 前端面试之hybrid\n\n> [http://blog.poetries.top/2018/10/20/fe-interview-hybrid/](http://blog.poetries.top/2018/10/20/fe-interview-hybrid/)\n\n### 90 前端面试之组件化\n\n> [http://blog.poetries.top/2018/10/20/fe-interview-component/](http://blog.poetries.top/2018/10/20/fe-interview-component/)\n\n### 91 前端面试之MVVM浅析\n\n> [http://blog.poetries.top/2018/10/20/fe-interview-mvvm/](http://blog.poetries.top/2018/10/20/fe-interview-mvvm/)\n\n### 92 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置\n\nconst box = document.getElementById('box');function isIcon(target) {\n  return target.className.includes('icon');}box.onClick = function(e) {\n  e.stopPropagation();\n  const target = e.target;\n  if (isIcon(target)) {\n    target.style.border = '1px solid red';\n  }}const doc = document;doc.onclick = function(e) {\n  const children = box.children;\n  for(let i; i < children.length; i++) {\n    if (isIcon(children\\[i\\])) {\n      children\\[i\\].style.border = 'none';\n    }\n  }}\n\n### 93 请简单实现双向数据绑定`mvvm`\n\n<input id=\"input\"/>\n\nconst data = {};const input = document.getElementById('input');Object.defineProperty(data, 'text', {\n  set(value) {\n    input.value = value;\n    this.value = value;\n  }});input.onChange = function(e) {\n  data.text = e.target.value;}\n\n### 94 实现Storage，使得该对象为单例，并对`localStorage`进行封装设置值setItem(key,value)和getItem(key)\n\nvar instance = null;class Storage {\n  static getInstance() {\n    if (!instance) {\n      instance = new Storage();\n    }\n    return instance;\n  }\n  setItem = (key, value) => localStorage.setItem(key, value),\n  getItem = key => localStorage.getItem(key)}\n\n### 95 说说`event loop`\n\n> 首先，`js`是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应`DOM`的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被`push`进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步`HTTP`请求线程满足特定条件下的回调函数`push`到事件队列中，等待`js`引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务`microtask（promise）`，如果有那就优先执行微任务，如果没有，在去查找宏任务`macrotask（setTimeout、setInterval）`进行执行\n\n### 96 说说事件流\n\n事件流分为两种，捕获事件流和冒泡事件流\n\n*   捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点\n*   冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点\n\n> 事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段\n\n### 97 为什么`canvas`的图片为什么过有跨域问题\n\n### 98 我现在有一个`canvas`，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块\n\n> https://www.jianshu.com/p/f54d265f7aa4\n\n### 99 请手写实现一个`promise`\n\n> https://segmentfault.com/a/1190000013396601\n\n### 100 说说从输入URL到看到页面发生的全过程，越详细越好\n\n*   首先浏览器主进程接管，开了一个下载线程。\n*   然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。\n*   将下载完的内容转交给Renderer进程管理。\n*   Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。\n*   解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。\n*   css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。\n*   绘制结束后，关闭TCP连接，过程有四次挥手\n\n### 101 描述一下`this`\n\n> `this`，函数执行的上下文，可以通过`apply`，`call`，`bind`改变`this`的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，NodeJS为`global`），剩下的函数调用，那就是谁调用它，`this`就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，`this`就指向哪里\n\n### 102 说一下浏览器的缓存机制\n\n> 浏览器缓存机制有两种，一种为强缓存，一种为协商缓存\n\n*   对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。\n*   对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存\n\n协商缓存相关设置\n\n*   `Exprires`：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。`Exprires`的缺陷是必须保证服务端时间和客户端时间严格同步。\n*   `Cache-control：max-age`：表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题，\n*   `If-None-Match/ETag`：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回`If-None-Match`标识是否表示匹配。\n*   `Last-modified/If-Modified-Since`：第一次请求的时候服务端返回`Last-modified`表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头`If-Modified-Since`，表示资源上次的修改时间，服务端拿到这两个字段进行对比\n\n### 103 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？\n\n*   该组件需要提供`hook`指定渲染位置，默认渲染在body下面。\n*   然后改组件可以指定外层样式，如宽度等\n*   组件外层还需要一层`mask`来遮住底层内容，点击`mask`可以执行传进来的`onCancel`函数关闭`Dialog`。\n*   另外组件是可控的，需要外层传入`visible`表示是否可见。\n*   然后`Dialog`可能需要自定义头head和底部`footer`，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的`onOk`事件，然后取消按钮会执行外部传进来的`onCancel`事件。\n*   当组件的`visible`为`true`时候，设置`body`的`overflow`为`hidden`，隐藏`body`的滚动条，反之显示滚动条。\n*   组件高度可能大于页面高度，组件内部需要滚动条。\n*   只有组件的`visible`有变化且为`ture`时候，才重渲染组件内的所有内容\n\n### 104 `caller`和`callee`的区别\n\ncallee\n\n> `caller`返回一个函数的引用，这个函数调用了当前的函数。\n\n使用这个属性要注意\n\n*   这个属性只有当函数在执行时才有用\n*   如果在`javascript`程序中，函数是由顶层调用的，则返回`null`\n\n> `functionName.caller: functionName`是当前正在执行的函数。\n\nfunction a() {\n  console.log(a.caller)}\n\ncallee\n\n> `callee`放回正在执行的函数本身的引用，它是`arguments`的一个属性\n\n> 使用callee时要注意:\n\n*   这个属性只有在函数执行时才有效\n*   它有一个`length`属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较`arguments.length`是否等于`arguments.callee.length`\n*   它可以用来递归匿名函数。\n\nfunction a() {\n  console.log(arguments.callee)}\n\n### 105 ajax、axios、fetch区别\n\njQuery ajax\n\n$.ajax({\n   type: 'POST',\n   url: url,\n   data: data,\n   dataType: dataType,\n   success: function () {},\n   error: function () {}});\n\n优缺点：\n\n*   本身是针对`MVC`的编程,不符合现在前端`MVVM`的浪潮\n*   基于原生的`XHR`开发，`XHR`本身的架构不清晰，已经有了`fetch`的替代方案\n*   `JQuery`整个项目太大，单纯使用`ajax`却要引入整个`JQuery`非常的不合理（采取个性化打包的方案又不能享受CDN服务）\n\naxios\n\naxios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n        firstName: 'Fred',\n        lastName: 'Flintstone'\n    }}).then(function (response) {\n    console.log(response);}).catch(function (error) {\n    console.log(error);});\n\n优缺点：\n\n*   从浏览器中创建 `XMLHttpRequest`\n*   从 `node.js` 发出 `http` 请求\n*   支持 `Promise API`\n*   拦截请求和响应\n*   转换请求和响应数据\n*   取消请求\n*   自动转换`JSON`数据\n*   客户端支持防止`CSRF/XSRF`\n\nfetch\n\ntry {\n  let response = await fetch(url);\n  let data = response.json();\n  console.log(data);} catch(e) {\n  console.log(\"Oops, error\", e);}\n\n优缺点：\n\n*   `fetcht`只对网络请求报错，对`400`，`500`都当做成功的请求，需要封装去处理\n*   `fetch`默认不会带`cookie`，需要添加配置项\n*   `fetch`不支持`abort`，不支持超时控制，使用`setTimeout`及`Promise.reject`的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费\n*   `fetch`没有办法原生监测请求的进度，而XHR可以","source":"_posts/2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86javascript-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8.md","raw":"---\ntitle: 2019最新前端知识梳理(JavaScript部分)-面试宝典\ntags:\n  - JavaScript\n  - 面试题\nurl: 162.html\nid: 162\ncategories:\n  - 大前端\n  - 面试题类\ndate: 2019-06-22 17:22:00\n---\n\n三、JavaScript\n------------\n\n### 1 闭包\n\n*   闭包就是能够读取其他函数内部变量的函数\n*   闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域\n*   闭包的特性：\n    *   函数内再嵌套函数\n    *   内部函数可以引用外层的参数和变量\n    *   参数和变量不会被垃圾回收机制回收\n\n说说你对闭包的理解\n\n*   使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念\n*   闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中\n*   闭包的另一个用处，是封装对象的私有属性和私有方法\n*   好处：能够实现封装和缓存等；\n*   坏处：就是消耗内存、不正当使用会造成内存溢出的问题\n\n使用闭包的注意点\n\n*   由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露\n*   解决方法是，在退出函数之前，将不使用的局部变量全部删除\n\n### 2 说说你对作用域链的理解\n\n*   作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到`window`对象即被终止，作用域链向下访问变量是不被允许的\n*   简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期\n\n### 3 JavaScript原型，原型链 ? 有什么特点？\n\n*   每个对象都会在其内部初始化一个属性，就是`prototype`(原型)，当我们访问一个对象的属性时\n*   如果这个对象内部不存在这个属性，那么他就会去`prototype`里找这个属性，这个`prototype`又会有自己的`prototype`，于是就这样一直找下去，也就是我们平时所说的原型链的概念\n*   关系：`instance.constructor.prototype = instance.__proto__`\n*   特点：\n    *   `JavaScript`对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变\n*   当我们需要一个属性的时，`Javascript`引擎会先看当前对象中是否有这个属性， 如果没有的\n*   就会查找他的`Prototype`对象是否有这个属性，如此递推下去，一直检索到 `Object` 内建对象\n\n### 4 请解释什么是事件代理\n\n*   事件代理（`Event Delegation`），又称之为事件委托。是 `JavaScript` 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能\n*   可以大量节省内存占用，减少事件注册，比如在`table`上代理所有`td`的`click`事件就非常棒\n*   可以实现当新增子对象时无需再次对其绑定\n\n### 5 Javascript如何实现继承？\n\n*   构造继承\n*   原型继承\n*   实例继承\n*   拷贝继承\n*   原型`prototype`机制或`apply`和`call`方法去实现较简单，建议使用构造函数与原型混合方式\n\nfunction Parent(){\n this.name = 'wang';}function Child(){\n        this.age = 28;}\n    Child.prototype = new Parent();//继承了Parent，通过原型var demo = new Child();alert(demo.age);alert(demo.name);//得到被继承的属性\n\n### 6 谈谈This对象的理解\n\n*   `this`总是指向函数的直接调用者（而非间接调用者）\n*   如果有`new`关键字，`this`指向`new`出来的那个对象\n*   在事件中，`this`指向触发这个事件的对象，特殊的是，`IE`中的`attachEvent`中的`this`总是指向全局对象`Window`\n\n### 7 事件模型\n\n> `W3C`中定义事件的发生经历三个阶段：捕获阶段（`capturing`）、目标阶段（`targetin`）、冒泡阶段（`bubbling`）\n\n*   冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发\n*   捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发\n*   `DOM`事件流：同时支持两种事件模型：捕获型事件和冒泡型事件\n*   阻止冒泡：在`W3c`中，使用`stopPropagation()`方法；在IE下设置`cancelBubble = true`\n*   阻止捕获：阻止事件的默认行为，例如`click - <a>`后的跳转。在`W3c`中，使用`preventDefault()`方法，在`IE`下设置`window.event.returnValue = false`\n\n### 8 new操作符具体干了什么呢?\n\n*   创建一个空对象，并且 `this` 变量引用该对象，同时还继承了该函数的原型\n*   属性和方法被加入到 `this` 引用的对象中\n*   新创建的对象由 `this` 所引用，并且最后隐式的返回 `this`\n\n### 9 Ajax原理\n\n*   `Ajax`的原理简单来说是在用户和服务器之间加了—个中间层(`AJAX`引擎)，通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用`javascrip`t来操作`DOM`而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据\n*   `Ajax`的过程只涉及`JavaScript`、`XMLHttpRequest`和`DOM`。`XMLHttpRequest`是`aja`x的核心机制\n\n/** 1. 创建连接 **/var xhr = null;xhr = new XMLHttpRequest()/** 2. 连接服务器 **/xhr.open('get', url, true)/** 3. 发送请求 **/xhr.send(null);/** 4. 接受请求 **/xhr.onreadystatechange = function(){\n if(xhr.readyState == 4){\n if(xhr.status == 200){\n success(xhr.responseText);\n } else { \n /** false **/\n fail && fail(xhr.status);\n }\n }}\n\najax 有那些优缺点?\n\n*   优点：\n    *   通过异步模式，提升了用户体验.\n    *   优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.\n    *   `Ajax`在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。\n    *   `Ajax`可以实现动态不刷新（局部刷新）\n*   缺点：\n    *   安全问题 `AJAX`暴露了与服务器交互的细节。\n    *   对搜索引擎的支持比较弱。\n    *   不容易调试。\n\n### 10 如何解决跨域问题?\n\n> 首先了解下浏览器的同源策略 同源策略`/SOP（Same origin policy）`是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到`XSS`、`CSFR`等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源\n\n那么怎样解决跨域问题的呢？\n\n*   通过jsonp跨域\n\nvar script = document.createElement('script');script.type = 'text/javascript';// 传参并指定回调执行函数为onBackscript.src = 'http://www.....:8080/login?user=admin&callback=onBack';document.head.appendChild(script);// 回调执行函数function onBack(res) {\n    alert(JSON.stringify(res));}\n\n*   document.domain + iframe跨域\n\n> 此方案仅限主域相同，子域不同的跨域应用场景\n\n1.）父窗口：(http://www.domain.com/a.html)\n\n<iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe><script>\n    document.domain = 'domain.com';\n    var user = 'admin';</script>\n\n2.）子窗口：(http://child.domain.com/b.html)\n\ndocument.domain = 'domain.com';// 获取父窗口中变量alert('get js data from parent ---> ' + window.parent.user);\n\n*   nginx代理跨域\n*   nodejs中间件代理跨域\n*   后端在头部信息里面设置安全域名\n\n### 11 模块化开发怎么做？\n\n*   立即执行函数,不暴露私有成员\n\nvar module1 = (function(){　　　　var _count = 0;　　　　var m1 = function(){　　　　　　//...　　　　};　　　　var m2 = function(){　　　　　　//...　　　　};　　　　return {　　　　　　m1 : m1,　　　　　　m2 : m2\n　　　　};})();\n\n### 12 异步加载JS的方式有哪些？\n\n*   defer，只支持`IE`\n*   `async`：\n*   创建`script`，插入到`DOM`中，加载完毕后`callBack`\n\n### 13 那些操作会造成内存泄漏？\n\n*   内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\n*   `setTimeout` 的第一个参数使用字符串而非函数的话，会引发内存泄漏\n*   闭包使用不当\n\n### 14 XML和JSON的区别？\n\n*   数据体积方面\n    *   `JSON`相对`于XML`来讲，数据的体积小，传递的速度更快些。\n*   数据交互方面\n    *   `JSON`与`JavaScript`的交互更加方便，更容易解析处理，更好的数据交互\n*   数据描述方面\n    *   `JSON`对数据的描述性比`XML`较差\n*   传输速度方面\n    *   `JSON`的速度要远远快于`XML`\n\n### 15 谈谈你对webpack的看法\n\n*   `WebPack` 是一个模块打包工具，你可以使用`WebPack`管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包`Web`开发中所用到的`HTML`、`Javascript`、`CSS`以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，`webpack`有对应的模块加载器。`webpack`模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源\n\n### 16 说说你对AMD和Commonjs的理解\n\n*   `CommonJS`是服务器端模块的规范，`Node.js`采用了这个规范。`CommonJS`规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。`AMD`规范则是非同步加载模块，允许指定回调函数\n*   `AMD`推荐的风格通过返回一个对象做为模块对象，`CommonJS`的风格通过对`module.exports`或`exports`的属性赋值来达到暴露模块对象的目的\n\n### 17 常见web安全及防护原理\n\n*   `sql`注入原理\n    *   就是通过把`SQL`命令插入到`Web`表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令\n*   总的来说有以下几点\n    *   永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双`\"-\"`进行转换等\n    *   永远不要使用动态拼装SQL，可以使用参数化的`SQL`或者直接使用存储过程进行数据查询存取\n    *   永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接\n    *   不要把机密信息明文存放，请加密或者`hash`掉密码和敏感的信息\n\nXSS原理及防范\n\n*   `Xss(cross-site scripting)`攻击指的是攻击者往`Web`页面里插入恶意`html`标签或者`javascript`代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取`cookie`中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点\n\nXSS防范方法\n\n*   首先代码里对用户输入的地方和变量都需要仔细检查长度和对`”<”,”>”,”;”,”’”`等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把`html tag` 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击\n\nXSS与CSRF有什么区别吗？\n\n*   `XSS`是获取信息，不需要提前知道其他用户页面的代码和数据包。`CSRF`是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次`CSRF`攻击，受害者必须依次完成两个步骤\n*   登录受信任网站`A`，并在本地生成`Cookie`\n*   在不登出`A`的情况下，访问危险网站`B`\n\nCSRF的防御\n\n*   服务端的`CSRF`方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数\n*   通过验证码的方法\n\n### 18 用过哪些设计模式？\n\n*   工厂模式：\n    *   工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法\n    *   主要好处就是可以消除对象间的耦合，通过使用工程方法而不是`new`关键字\n*   构造函数模式\n    *   使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于\n    *   直接将属性和方法赋值给 `this`对象;\n\n### 19 为什么要有同源限制？\n\n*   同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议\n*   举例说明：比如一个黑客程序，他利用`Iframe`把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过`Javascript`读取到你的表单中`input`中的内容，这样用户名，密码就轻松到手了。\n\n### 20 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别\n\n*   `offsetWidth/offsetHeight`返回值包含content + padding + border，效果与e.getBoundingClientRect()相同\n*   `clientWidth/clientHeight`返回值只包含content + padding，如果有滚动条，也不包含滚动条\n*   `scrollWidth/scrollHeight`返回值包含content + padding + 溢出内容的尺寸\n\n### 21 javascript有哪些方法定义对象\n\n*   对象字面量： `var obj = {};`\n*   构造函数： `var obj = new Object();`\n*   Object.create(): `var obj = Object.create(Object.prototype);`\n\n### 22 常见兼容性问题？\n\n*   `png24`位的图片在iE6浏览器上出现背景，解决方案是做成`PNG8`\n*   浏览器默认的`margin`和`padding`不同。解决方案是加一个全局的`*{margin:0;padding:0;}`来统一,，但是全局效率很低，一般是如下这样解决：\n\nbody,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p{margin:0;padding:0;}\n\n*   `IE`下,`event`对象有`x`,`y`属性,但是没有`pageX`,`pageY`属性\n*   `Firefox`下,`event`对象有`pageX`,`pageY`属性,但是没有`x,y`属性.\n\n### 23 说说你对promise的了解\n\n*   依照 `Promise/A+` 的定义，`Promise` 有四种状态：\n    *   `pending:` 初始状态, 非 `fulfilled` 或 `rejected.`\n    *   `fulfilled:` 成功的操作.\n    *   `rejected:` 失败的操作.\n    *   `settled: Promise`已被`fulfilled`或`rejected`，且不是`pending`\n*   另外， `fulfilled`与 `rejected`一起合称 `settled`\n*   `Promise` 对象用来进行延迟(`deferred`) 和异步(`asynchronous`) 计算\n\nPromise 的构造函数\n\n*   构造一个 `Promise`，最基本的用法如下：\n\nvar promise = new Promise(function(resolve, reject) {\n\n        if (...) {  // succeed\n\n            resolve(result);\n\n        } else {   // fails\n\n            reject(Error(errMessage));\n\n        }\n    });\n\n*   `Promise` 实例拥有 `then` 方法（具有 `then` 方法的对象，通常被称为`thenable`）。它的使用方法如下：\n\npromise.then(onFulfilled, onRejected)\n\n*   接收两个函数作为参数，一个在 `fulfilled` 的时候被调用，一个在`rejected`的时候被调用，接收参数就是 `future`，`onFulfilled` 对应`resolve`, `onRejected`对应 `reject`\n\n### 24 你觉得jQuery源码有哪些写的好的地方\n\n*   `jquery`源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入`window`对象参数，可以使`window`对象作为局部变量使用，好处是当`jquery`中访问`window`对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入`undefined`参数，可以缩短查找`undefined`时的作用域链\n*   `jquery`将一些原型属性和方法封装在了`jquery.prototype`中，为了缩短名称，又赋值给了`jquery.fn`，这是很形象的写法\n*   有一些数组或对象的方法经常能使用到，`jQuery`将其保存为局部变量以提高访问速度\n*   `jquery`实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率\n\n### 25 vue、react、angular\n\n*   `Vue.js` 一个用于创建 `web` 交互界面的库，是一个精简的 `MVVM`。它通过双向数据绑定把 `View`层和 `Model` 层连接了起来。实际的 `DOM` 封装和输出格式都被抽象为了`Directives` 和 `Filters`\n*   `AngularJS` 是一个比较完善的前端`MVVM`框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 `Angular`指令\n*   `react` `React` 仅仅是 `VIEW` 层是`facebook`公司。推出的一个用于构建`UI`的一个库，能够实现服务器端的渲染。用了`virtual dom`，所以性能很好。\n\n### 26 Node的应用场景\n\n*   特点：\n    *   1、它是一个`Javascript`运行环境\n    *   2、依赖于`Chrome V8`引擎进行代码解释\n    *   3、事件驱动\n    *   4、非阻塞`I/O`\n    *   5、单进程，单线程\n*   优点：\n    *   高并发（最重要的优点）\n*   缺点：\n    *   1、只支持单核`CPU`，不能充分利用`CPU`\n    *   2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃\n\n### 27 谈谈你对AMD、CMD的理解\n\n*   `CommonJS`是服务器端模块的规范，`Node.js`采用了这个规范。`CommonJS`规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。`AMD`规范则是非同步加载模块，允许指定回调函数\n*   `AMD`推荐的风格通过返回一个对象做为模块对象，`CommonJS`的风格通过对`module.exports`或`exports`的属性赋值来达到暴露模块对象的目的\n\nes6模块 CommonJS、AMD、CMD\n\n*   `CommonJS` 的规范中，每个 `JavaScript` 文件就是一个独立的模块上下文（`module context`），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。\n*   `CommonJS`是同步加载模块,在浏览器中会出现堵塞情况，所以不适用\n*   `AMD` 异步，需要定义回调`define`方式\n*   `es6` 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用`export`关键字输出该变量 `es6`还可以导出类、方法，自动适用严格模式\n\n### 28 那些操作会造成内存泄漏\n\n*   内存泄漏指任何对象在您不再拥有或需要它之后仍然存在\n*   `setTimeout` 的第一个参数使用字符串而非函数的话，会引发内存泄漏\n*   闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n\n### 29 web开发中会话跟踪的方法有哪些\n\n*   `cookie`\n*   `session`\n*   `url`重写\n*   隐藏`input`\n*   `ip`地址\n\n### 30 介绍js的基本数据类型\n\n*   `Undefined`、`Null`、`Boolean`、`Number`、`String`\n\n### 31 介绍js有哪些内置对象\n\n*   `Object` 是 `JavaScript` 中所有对象的父对象\n*   数据封装类对象：`Object`、`Array`、`Boolean`、`Number` 和 `String`\n*   其他对象：`Function`、`Arguments`、`Math`、`Date`、`RegExp`、`Error`\n\n### 32 说几条写JavaScript的基本规范\n\n*   不要在同一行声明多个变量\n*   请使用`===/!==`来比较`true/false`或者数值\n*   使用对象字面量替代`new Array`这种形式\n*   不要使用全局函数\n*   `Switch`语句必须带有`default`分支\n*   `If`语句必须使用大括号\n*   `for-in`循环中的变量 应该使用`var`关键字明确限定作用域，从而避免作用域污\n\n### 33 JavaScript有几种类型的值\n\n*   栈：原始数据类型（`Undefined`，`Null`，`Boolean`，`Number`、`String`）\n*   堆：引用数据类型（对象、数组和函数）\n*   两种类型的区别是：存储位置不同；\n*   原始数据类型直接存储在栈(`stack`)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n*   引用数据类型存储在堆(`heap`)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其\n*   在栈中的地址，取得地址后从堆中获得实体\n\n![](https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966)\n\n### 34 javascript创建对象的几种方式\n\n> `javascript`创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用`JSON`；但写法有很多种，也能混合使用\n\n*   对象字面量的方式\n\nperson={firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"};\n\n*   用`function`来模拟无参的构造函数\n\nfunction Person(){}\n var person=new Person();//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class\n        person.name=\"Mark\";\n        person.age=\"25\";\n        person.work=function(){\n        alert(person.name+\" hello...\");}person.work();\n\n*   用`function`来模拟参构造函数来实现（用`this`关键字定义构造的上下文属性）\n\nfunction Pet(name,age,hobby){\n       this.name=name;//this作用域：当前对象\n       this.age=age;\n       this.hobby=hobby;\n       this.eat=function(){\n           alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\");\n       }}var maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象maidou.eat();//调用eat方法\n\n*   用工厂方式来创建（内置对象）\n\nvar wcDog =new Object();\n     wcDog.name=\"旺财\";\n     wcDog.age=3;\n     wcDog.work=function(){\n       alert(\"我是\"+wcDog.name+\",汪汪汪......\");\n     }\n     wcDog.work();\n\n*   用原型方式来创建\n\nfunction Dog(){}Dog.prototype.name=\"旺财\";Dog.prototype.eat=function(){\n alert(this.name+\"是个吃货\");}var wangcai =new Dog();wangcai.eat();\n\n*   用混合方式来创建\n\n function Car(name,price){\n this.name=name;\n this.price=price;}Car.prototype.sell=function(){\n alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\");}var camry =new Car(\"凯美瑞\",27);camry.sell();\n\n### 35 eval是做什么的\n\n*   它的功能是把对应的字符串解析成`JS`代码并运行\n*   应该避免使用`eval`，不安全，非常耗性能（`2`次，一次解析成`js`语句，一次执行）\n*   由`JSON`字符串转换为JSON对象的时候可以用`eval，var obj =eval('('+ str +')')`\n\n### 36 null，undefined 的区别\n\n*   `undefined` 表示不存在这个值。\n*   `undefined` :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 `undefined`\n*   例如变量被声明了，但没有赋值时，就等于`undefined`\n*   `null` 表示一个对象被定义了，值为“空值”\n*   `null` : 是一个对象(空对象, 没有任何属性和方法)\n*   例如作为函数的参数，表示该函数的参数不是对象；\n*   在验证`null`时，一定要使用　`===` ，因为 `==`无法分别`null` 和　`undefined`\n\n### 37 \\[\"1\", \"2\", \"3\"\\].map(parseInt) 答案是多少\n\n*   `[1, NaN, NaN]`因为 `parseInt` 需要两个参数 `(val, radix)`，其中`radix` 表示解析时用的基数。\n*   `map`传了 `3`个`(element, index, array)`，对应的 `radix` 不合法导致解析失败。\n\n### 38 javascript 代码中的\"use strict\";是什么意思\n\n*   `use strict`是一种`ECMAscript 5` 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使`JS`编码更加规范化的模式,消除`Javascript`语法的一些不合理、不严谨之处，减少一些怪异行为\n\n### 39 JSON 的了解\n\n*   `JSON(JavaScript Object Notation)` 是一种轻量级的数据交换格式\n*   它是基于`JavaScript`的一个子集。数据格式简单, 易于读写, 占用带宽小\n*   `JSON`字符串转换为JSON对象:\n\nvar obj =eval('('+ str +')');var obj = str.parseJSON();var obj = JSON.parse(str);\n\n*   `JSON`对象转换为JSON字符串：\n\nvar last=obj.toJSONString();\nvar last=JSON.stringify(obj);\n\n### 40 js延迟加载的方式有哪些\n\n*   `defer`和`async`、动态创建`DOM`方式（用得最多）、按需异步载入`js`\n\n### 41 同步和异步的区别\n\n*   同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作\n*   异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容\n\n### 42 渐进增强和优雅降级\n\n*   渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n*   优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容\n\n### 43 defer和async\n\n*   `defer`并行加载`js`文件，会按照页面上`script`标签的顺序执行\n*   `async`并行加载`js`文件，下载完成立即执行，不会按照页面上`script`标签的顺序执行\n\n### 44 说说严格模式的限制\n\n*   变量必须声明后再使用\n*   函数的参数不能有同名属性，否则报错\n*   不能使用`with`语句\n*   禁止`this`指向全局对象\n\n### 45 attribute和property的区别是什么\n\n*   `attribute`是`dom`元素在文档中作为`html`标签拥有的属性；\n*   `property`就是`dom`元素在`js`中作为对象拥有的属性。\n*   对于`html`的标准属性来说，`attribute`和`property`是同步的，是会自动更新的\n*   但是对于自定义的属性来说，他们是不同步的\n\n### 46 谈谈你对ES6的理解\n\n*   新增模板字符串（为`JavaScript`提供了简单的字符串插值功能）\n*   箭头函数\n*   `for-of`（用来遍历数据—例如数组中的值。）\n*   `arguments`对象可被不定参数和默认参数完美代替。\n*   `ES6`将p`romise`对象纳入规范，提供了原生的`Promise`对象。\n*   增加了`let`和`const`命令，用来声明变量。\n*   增加了块级作用域。\n*   `let`命令实际上就增加了块级作用域。\n*   还有就是引入`module`模块的概念\n\n### 47 ECMAScript6 怎么写class么\n\n*   这个语法糖可以让有`OOP`基础的人更快上手`js`，至少是一个官方的实现了\n*   但对熟悉`js`的人来说，这个东西没啥大影响；一个`Object.creat()`搞定继承，比`class`简洁清晰的多\n\n### 48 什么是面向对象编程及面向过程编程，它们的异同和优缺点\n\n*   面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了\n*   面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为\n*   面向对象是以功能来划分问题，而不是步骤\n\n### 49 面向对象编程思想\n\n*   基本思想是使用对象，类，继承，封装等基本概念来进行程序设计\n*   优点\n    *   采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的\n    *   易维护\n    *   易扩展\n    *   开发工作的重用性、继承性高，降低重复工作量。\n    *   缩短了开发周期\n\n### 50 对web标准、可用性、可访问性的理解\n\n*   可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力\n*   可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性\n*   可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。\n\n### 51 如何通过JS判断一个数组\n\n*   `instanceof`方法\n    *   `instanceof` 运算符是用来测试一个对象是否在其原型链原型构造函数的属性\n\nvar arr = \\[\\];arr instanceof Array; // true\n\n*   `constructor`方法\n    *   `constructor`属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数\n\nvar arr = \\[\\];arr.constructor == Array; //true\n\n*   最简单的方法\n    *   这种写法，是 `jQuery` 正在使用的\n\nObject.prototype.toString.call(value) == '\\[object Array\\]'// 利用这个方法，可以写一个返回数据类型的方法var isType = function (obj) {\n     return Object.prototype.toString.call(obj).slice(8,-1);}\n\n*   `ES5`新增方法`isArray()`\n\nvar a = new Array(123);var b = new Date();console.log(Array.isArray(a)); //trueconsole.log(Array.isArray(b)); //false\n\n### 52 谈一谈let与var的区别\n\n*   `let`命令不存在变量提升，如果在`let`前使用，会导致报错\n*   如果块区中存在`let`和`const`命令，就会形成封闭作用域\n*   不允许重复声明，因此，不能在函数内部重新声明参数\n\n### 53 map与forEach的区别\n\n*   `forEach`方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容`item`、数组索引`index`、和当前遍历数组`Array`\n*   `map`方法，基本用法与`forEach`一致，但是不同的，它会返回一个新的数组，所以在callback需要有`return`值，如果没有，会返回`undefined`\n\n### 54 谈一谈你理解的函数式编程\n\n*   简单说，\"函数式编程\"是一种\"编程范式\"（programming paradigm），也就是如何编写程序的方法论\n*   它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是\"第一等公民\"、只用\"表达式\"\n\n### 55 谈一谈箭头函数与普通函数的区别？\n\n*   函数体内的`this`对象，就是定义时所在的对象，而不是使用时所在的对象\n*   不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误\n*   不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用`Rest`参数代替\n*   不可以使用`yield`命令，因此箭头函数不能用作`Generator`函数\n\n### 56 谈一谈函数中this的指向\n\n*   this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象\n*   《javascript语言精髓》中大概概括了4种调用方式：\n*   方法调用模式\n*   函数调用模式\n*   构造器调用模式\n\ngraph LRA-->B\n\n*   apply/call调用模式\n\n### 57 异步编程的实现方式\n\n*   回调函数\n    *   优点：简单、容易理解\n    *   缺点：不利于维护，代码耦合高\n*   事件监听(采用时间驱动模式，取决于某个事件是否发生)：\n    *   优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数\n    *   缺点：事件驱动型，流程不够清晰\n*   发布/订阅(观察者模式)\n    *   类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者\n*   Promise对象\n    *   优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；\n    *   缺点：编写和理解，相对比较难\n*   Generator函数\n    *   优点：函数体内外的数据交换、错误处理机制\n    *   缺点：流程管理不方便\n*   async函数\n    *   优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。\n    *   缺点：错误处理机制\n\n### 58 对原生Javascript了解程度\n\n*   数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、`RegExp`、`JSON`、`Ajax`、`DOM`、`BOM`、内存泄漏、跨域、异步装载、模板引擎、前端`MVC`、路由、模块化、`Canvas`、`ECMAScript`\n\n### 59 Js动画与CSS动画区别及相应实现\n\n*   `CSS3`的动画的优点\n    *   在性能上会稍微好一些，浏览器会对`CSS3`的动画做一些优化\n    *   代码相对简单\n*   缺点\n    *   在动画控制上不够灵活\n    *   兼容性不好\n*   `JavaScript`的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容`IE6`，并且功能强大。对于一些复杂控制的动画，使用`javascript`会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑`CSS`吧\n\n### 60 JS 数组和对象的遍历方式，以及几种方式的比较\n\n> 通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历\n\n*   `for in`循环\n*   `for`循环\n*   `forEach`\n    *   这里的 `forEach`回调中两个参数分别为 `value`，`index`\n    *   `forEach` 无法遍历对象\n    *   IE不支持该方法；`Firefox` 和 `chrome` 支持\n    *   `forEach` 无法使用 `break`，`continue` 跳出循环，且使用 `return` 是跳过本次循环\n*   这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题\n*   在方式一中，`for-in`需要分析出`array`的每个属性，这个操作性能开销很大。用在 `key` 已知的数组上是非常不划算的。所以尽量不要用`for-in`，除非你不清楚要处理哪些属性，例如 `JSON`对象这样的情况\n*   在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 `array` 里存放的都是 `DOM` 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低\n\n### 61 gulp是什么\n\n*   `gulp`是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成\n*   Gulp的核心概念：流\n*   流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向\n*   gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作\n*   Gulp的特点：\n    *   易于使用：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理\n    *   构建快速 利用 `Node.js` 流的威力，你可以快速构建项目并减少频繁的 `IO` 操作\n    *   易于学习 通过最少的 `API`，掌握 `gulp` 毫不费力，构建工作尽在掌握：如同一系列流管道\n\n### 62 说一下Vue的双向绑定数据的原理\n\n*   `vue.js` 则是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调\n\n### 63 事件的各个阶段\n\n*   1：捕获阶段 ---> 2：目标阶段 ---> 3：冒泡阶段\n*   `document` ---> `target`目标 ----> `document`\n*   由此，`addEventListener`的第三个参数设置为`true`和`false`的区别已经非常清晰了\n    *   `true`表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件\n    *   `false`表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件\n\n### 64 let var const\n\nlet\n\n*   允许你声明一个作用域被限制在块级中的变量、语句或者表达式\n*   let绑定不受变量提升的约束，这意味着let声明不会被提升到当前\n*   该变量处于从块开始到初始化处理的“暂存死区”\n\nvar\n\n*   声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的\n*   由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明\n\nconst\n\n*   声明创建一个值的只读引用 (即指针)\n*   基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 `const`申明基本数据类型时\n*   再将其值改变时，将会造成报错， 例如 `const a = 3` ; `a = 5`时 将会报错\n*   但是如果是复合类型时，如果只改变复合类型的其中某个`Value`项时， 将还是正常使用\n\n### 65 快速的让一个数组乱序\n\nvar arr = \\[1,2,3,4,5,6,7,8,9,10\\];arr.sort(function(){\n    return Math.random() - 0.5;})console.log(arr);\n\n### 66 如何渲染几万条数据并不卡住界面\n\n> 这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 `DOM`，那么就可以通过 `requestAnimationFrame` 来每 `16 ms` 刷新一次\n\n<!DOCTYPE html><html lang=\"en\"><head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n  <title>Document</title></head><body>\n  <ul>控件</ul>\n  <script>\n    setTimeout(() => {\n      // 插入十万条数据\n      const total = 100000\n      // 一次插入 20 条，如果觉得性能不好就减少\n      const once = 20\n      // 渲染数据总共需要几次\n      const loopCount = total / once      let countOfRender = 0\n      let ul = document.querySelector(\"ul\");\n      function add() {\n        // 优化性能，插入不会造成回流\n        const fragment = document.createDocumentFragment();\n        for (let i = 0; i < once; i++) {\n          const li = document.createElement(\"li\");\n          li.innerText = Math.floor(Math.random() * total);\n          fragment.appendChild(li);\n        }\n        ul.appendChild(fragment);\n        countOfRender += 1;\n        loop();\n      }\n      function loop() {\n        if (countOfRender < loopCount) {\n          window.requestAnimationFrame(add);\n        }\n      }\n      loop();\n    }, 0);\n  </script></body></html>\n\n### 67 希望获取到页面中所有的checkbox怎么做？\n\n> 不使用第三方框架\n\n var domList = document.getElementsByTagName(‘input’)\n var checkBoxList = \\[\\];\n var len = domList.length;　　//缓存到局部变量\n while (len--) {　　//使用while的效率会比for循环更高\n 　　if (domList\\[len\\].type == ‘checkbox’) {\n     　　checkBoxList.push(domList\\[len\\]);\n 　　}\n }\n\n### 68 怎样添加、移除、移动、复制、创建和查找节点\n\n创建新节点\n\ncreateDocumentFragment()    //创建一个DOM片段createElement()   //创建一个具体的元素createTextNode()   //创建一个文本节点\n\n添加、移除、替换、插入\n\nappendChild()      //添加removeChild()      //移除replaceChild()      //替换insertBefore()      //插入\n\n查找\n\ngetElementsByTagName()    //通过标签名称getElementsByName()     //通过元素的Name属性的值getElementById()        //通过元素Id，唯一性\n\n### 69 正则表达式\n\n> 正则表达式构造函数`var reg=new RegExp(“xxx”)`与正则表达字面量`var reg=//`有什么不同？匹配邮箱的正则表达式？\n\n*   当使用`RegExp()`构造函数的时候，不仅需要转义引号（即`\\`”表示”），并且还需要双反斜杠（即`\\\\`表示一个`\\`）。使用正则表达字面量的效率更高\n\n邮箱的正则匹配：\n\nvar regMail = /^(\\[a-zA-Z0-9_-\\])+@(\\[a-zA-Z0-9_-\\])+((.\\[a-zA-Z0-9_-\\]{2,3}){1,2})$/;\n\n### 70 Javascript中callee和caller的作用？\n\n*   `caller`是返回一个对函数的引用，该函数调用了当前函数；\n*   `callee`是返回正在被执行的`function`函数，也就是所指定的`function`对象的正文\n\n> 那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用`callee`完成）\n\nvar result=\\[\\];\n  function fn(n){  //典型的斐波那契数列\n     if(n==1){\n          return 1;\n     }else if(n==2){\n             return 1;\n     }else{\n          if(result\\[n\\]){\n                  return result\\[n\\];\n         }else{\n                 //argument.callee()表示fn()\n                 result\\[n\\]=arguments.callee(n-1)+arguments.callee(n-2);\n                 return result\\[n\\];\n         }\n    }\n }\n\n### 71 window.onload和$(document).ready\n\n> 原生`JS`的`window.onload`与`Jquery`的`$(document).ready(function(){})`有什么不同？如何用原生JS实现Jq的`ready`方法？\n\n*   `window.onload()`方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。\n*   `$(document).ready()`是`DOM`结构绘制完毕后就执行，不必等到加载完毕\n\nfunction ready(fn){\n      if(document.addEventListener) {        //标准浏览器\n          document.addEventListener('DOMContentLoaded', function() {\n              //注销事件, 避免反复触发\n              document.removeEventListener('DOMContentLoaded',arguments.callee, false);\n              fn();            //执行函数\n          }, false);\n      }else if(document.attachEvent) {        //IE\n          document.attachEvent('onreadystatechange', function() {\n             if(document.readyState == 'complete') {\n                 document.detachEvent('onreadystatechange', arguments.callee);\n                 fn();        //函数执行\n             }\n         });\n     }\n };\n\n### 72 addEventListener()和attachEvent()的区别\n\n*   `addEventListener()`是符合W3C规范的标准方法; `attachEvent()`是IE低版本的非标准方法\n*   `addEventListener()`支持事件冒泡和事件捕获; \\- 而`attachEvent()`只支持事件冒泡\n*   `addEventListener()`的第一个参数中,事件类型不需要添加`on`; `attachEvent()`需要添加`'on'`\n*   如果为同一个元素绑定多个事件, `addEventListener()`会按照事件绑定的顺序依次执行,`attachEvent()`会按照事件绑定的顺序倒序执行\n\n### 73 获取页面所有的checkbox\n\nvar resultArr= \\[\\];var input = document.querySelectorAll('input');for( var i = 0; i < input.length; i++ ) {\n    if( input\\[i\\].type == 'checkbox' ) {\n        resultArr.push( input\\[i\\] );\n    }}//resultArr即中获取到了页面中的所有checkbox\n\n### 74 数组去重方法总结\n\n方法一、利用ES6 Set去重（ES6中最常用）\n\nfunction unique (arr) {\n  return Array.from(new Set(arr))}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))\n //\\[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}\\]\n\n方法二、利用for嵌套for，然后splice去重（ES5中最常用）\n\nfunction unique(arr){            \n        for(var i=0; i<arr.length; i++){\n            for(var j=i+1; j<arr.length; j++){\n                if(arr\\[i\\]==arr\\[j\\]){         //第一个等同于第二个，splice方法删除第二个\n                    arr.splice(j,1);\n                    j--;\n                }\n            }\n        }\n return arr;}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))\n    //\\[1, \"true\", 15, false, undefined, NaN, NaN, \"NaN\", \"a\", {…}, {…}\\]     //NaN和{}没有去重，两个null直接消失了\n\n*   双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。\n*   想快速学习更多常用的`ES6`语法\n\n方法三、利用indexOf去重\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array = \\[\\];\n    for (var i = 0; i < arr.length; i++) {\n        if (array .indexOf(arr\\[i\\]) === -1) {\n            array .push(arr\\[i\\])\n        }\n    }\n    return array;}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))\n   // \\[1, \"true\", true, 15, false, undefined, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, {…}\\]  //NaN、{}没有去重\n\n> 新建一个空的结果数组，`for` 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则`push`进数组\n\n方法四、利用sort()\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return;\n    }\n    arr = arr.sort()\n    var arrry= \\[arr\\[0\\]\\];\n    for (var i = 1; i < arr.length; i++) {\n        if (arr\\[i\\] !== arr\\[i-1\\]) {\n            arrry.push(arr\\[i\\]);\n        }\n    }\n    return arrry;}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))// \\[0, 1, 15, \"NaN\", NaN, NaN, {…}, {…}, \"a\", false, null, true, \"true\", undefined\\]      //NaN、{}没有去重\n\n> 利用`sort()`排序方法，然后根据排序后的结果进行遍历及相邻元素比对\n\n方法五、利用对象的属性不能相同的特点进行去重\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var arrry= \\[\\];\n     var  obj = {};\n    for (var i = 0; i < arr.length; i++) {\n        if (!obj\\[arr\\[i\\]\\]) {\n            arrry.push(arr\\[i\\])\n            obj\\[arr\\[i\\]\\] = 1\n        } else {\n            obj\\[arr\\[i\\]\\]++\n        }\n    }\n    return arrry;}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))//\\[1, \"true\", 15, false, undefined, null, NaN, 0, \"a\", {…}\\]    //两个true直接去掉了，NaN和{}去重\n\n方法六、利用includes\n\nfunction unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array =\\[\\];\n    for(var i = 0; i < arr.length; i++) {\n            if( !array.includes( arr\\[i\\]) ) {//includes 检测数组是否有某个值\n                    array.push(arr\\[i\\]);\n              }\n    }\n    return array}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))\n    //\\[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}\\]     //{}没有去重\n\n方法七、利用hasOwnProperty\n\nfunction unique(arr) {\n    var obj = {};\n    return arr.filter(function(item, index, arr){\n        return obj.hasOwnProperty(typeof item + item) ? false : (obj\\[typeof item + item\\] = true)\n    })}\n    var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];\n        console.log(unique(arr))//\\[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}\\]   //所有的都去重了\n\n> 利用`hasOwnProperty` 判断是否存在对象属性\n\n方法八、利用filter\n\nfunction unique(arr) {\n  return arr.filter(function(item, index, arr) {\n    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素\n    return arr.indexOf(item, 0) === index;\n  });}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))//\\[1, \"true\", true, 15, false, undefined, null, \"NaN\", 0, \"a\", {…}, {…}\\]\n\n方法九、利用递归去重\n\nfunction unique(arr) {\n    var array= arr;\n    var len = array.length;\n\n array.sort(function(a,b){   //排序后更加方便去重\n return a - b;\n })\n\n function loop(index){\n        if(index >= 1){\n            if(array\\[index\\] === array\\[index-1\\]){\n            array.splice(index,1);\n            }\n            loop(index - 1);    //递归loop，然后数组去重\n        }\n }\n loop(len-1);\n return array;}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr))//\\[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined\\]\n\n方法十、利用Map数据结构去重\n\nfunction arrayNonRepeatfy(arr) {\n let map = new Map();\n let array = new Array();  // 数组用于返回结果\n for (let i = 0; i < arr.length; i++) {\n if(map .has(arr\\[i\\])) {  // 如果有该key值\n map .set(arr\\[i\\], true);\n } else {\n map .set(arr\\[i\\], false);   // 如果没有该key值\n array .push(arr\\[i\\]);\n }\n }\n return array ;}\n var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];\n    console.log(unique(arr))//\\[1, \"a\", \"true\", true, 15, false, 1, {…}, null, NaN, NaN, \"NaN\", 0, \"a\", {…}, undefined\\]\n\n> 创建一个空`Map`数据结构，遍历需要去重的数组，把数组的每一个元素作为`key`存到`Map`中。由于`Map`中不会出现相同的`key`值，所以最终得到的就是去重后的结果\n\n方法十一、利用reduce+includes\n\nfunction unique(arr){\n    return arr.reduce((prev,cur) => prev.includes(cur) ? prev : \\[...prev,cur\\],\\[\\]);}var arr = \\[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}\\];console.log(unique(arr));// \\[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}, {…}\\]\n\n方法十二、\\[...new Set(arr)\\]\n\n\\[...new Set(arr)\\]//代码就是这么少----（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）\n\n### 75 （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）\n\n*   给需要拖拽的节点绑定`mousedown`, `mousemove`, `mouseup`事件\n*   `mousedown`事件触发后，开始拖拽\n*   `mousemove`时，需要通过`event.clientX`和`clientY`获取拖拽位置，并实时更新位置\n*   `mouseup`时，拖拽结束\n*   需要注意浏览器边界的情况\n\n### 76 Javascript全局函数和全局变量\n\n全局变量\n\n*   `Infinity` 代表正的无穷大的数值。\n*   `NaN` 指示某个值是不是数字值。\n*   `undefined` 指示未定义的值。\n\n全局函数\n\n*   `decodeURI()` 解码某个编码的 `URI`。\n*   `decodeURIComponent()` 解码一个编码的 `URI` 组件。\n*   `encodeURI()` 把字符串编码为 URI。\n*   `encodeURIComponent()` 把字符串编码为 `URI` 组件。\n*   `escape()` 对字符串进行编码。\n*   `eval()` 计算 `JavaScript` 字符串，并把它作为脚本代码来执行。\n*   `isFinite()` 检查某个值是否为有穷大的数。\n*   `isNaN()` 检查某个值是否是数字。\n*   `Number()` 把对象的值转换为数字。\n*   `parseFloat()` 解析一个字符串并返回一个浮点数。\n*   `parseInt()` 解析一个字符串并返回一个整数。\n*   `String()` 把对象的值转换为字符串。\n*   `unescape()` 对由`escape()` 编码的字符串进行解码\n\n### 77 使用js实现一个持续的动画效果\n\n定时器思路\n\nvar e = document.getElementById('e')var flag = true;var left = 0;setInterval(() => {\n    left == 0 ? flag = true : left == 100 ? flag = false : ''\n    flag ? e.style.left = ` ${left++}px` : e.style.left = ` ${left--}px`}, 1000 / 60)\n\nrequestAnimationFrame\n\n//兼容性处理window.requestAnimFrame = (function(){\n    return window.requestAnimationFrame       ||\n           window.webkitRequestAnimationFrame ||\n           window.mozRequestAnimationFrame    ||\n           function(callback){\n                window.setTimeout(callback, 1000 / 60);\n           };})();var e = document.getElementById(\"e\");var flag = true;var left = 0;function render() {\n    left == 0 ? flag = true : left == 100 ? flag = false : '';\n    flag ? e.style.left = ` ${left++}px` :\n        e.style.left = ` ${left--}px`;}(function animloop() {\n    render();\n    requestAnimFrame(animloop);})();\n\n使用css实现一个持续的动画效果\n\nanimation:mymove 5s infinite;@keyframes mymove {\n    from {top:0px;}\n    to {top:200px;}}\n\n*   `animation-name` 规定需要绑定到选择器的 `keyframe`名称。\n*   `animation-duration` 规定完成动画所花费的时间，以秒或毫秒计。\n*   `animation-timing-function` 规定动画的速度曲线。\n*   `animation-delay` 规定在动画开始之前的延迟。\n*   `animation-iteration-count` 规定动画应该播放的次数。\n*   `animation-direction` 规定是否应该轮流反向播放动画\n\n### 78 封装一个函数，参数是定时器的时间，.then执行回调函数\n\nfunction sleep (time) {\n    return new Promise((resolve) => setTimeout(resolve, time));}\n\n### 79 怎么判断两个对象相等？\n\nobj={\n    a:1,\n    b:2}obj2={\n    a:1,\n    b:2}obj3={\n    a:1,\n    b:'2'}\n\n> 可以转换为字符串来判断\n\nJSON.stringify(obj)==JSON.stringify(obj2);//trueJSON.stringify(obj)==JSON.stringify(obj3);//false\n\n### 80 项目做过哪些性能优化？\n\n*   减少 `HTTP` 请求数\n*   减少 `DNS` 查询\n*   使用 `CDN`\n*   避免重定向\n*   图片懒加载\n*   减少 `DOM` 元素数量\n*   减少`DOM` 操作\n*   使用外部 `JavaScript` 和 `CSS`\n*   压缩 `JavaScript` 、 `CSS` 、字体、图片等\n*   优化 `CSS Sprite`\n*   使用 `iconfont`\n*   字体裁剪\n*   多域名分发划分内容到不同域名\n*   尽量减少 `iframe` 使用\n*   避免图片 `src` 为空\n*   把样式表放在`link` 中\n*   把`JavaScript`放在页面底部\n\n### 81 浏览器缓存\n\n> 浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下\n\n*   先根据这个资源的一些 `http header` 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；\n*   当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些`request header`验证这个资源是否命中协商缓存，称为`http`再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；\n*   强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。\n*   当协商缓存也没命中时，服务器就会将资源发送回客户端。\n*   当 `ctrl+f5` 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n*   当 `f5`刷新网页时，跳过强缓存，但是会检查协商缓存；\n\n强缓存\n\n*   `Expires`（该字段是 `http1.0` 时的规范，值为一个绝对时间的 `GMT` 格式的时间字符串，代表缓存资源的过期时间）\n*   `Cache-Control:max-age`（该字段是 `http1.1`的规范，强缓存利用其 `max-age` 值来判断缓存资源的最大生命周期，它的值单位为秒）\n\n协商缓存\n\n*   `Last-Modified`（值为资源最后更新时间，随服务器response返回）\n*   `If-Modified-Since`（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）\n*   `ETag`（表示资源内容的唯一标识，随服务器`response`返回）\n*   `If-None-Match`（服务器通过比较请求头部的`If-None-Match`与当前资源的`ETag`是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）\n\n### 82 WebSocket\n\n> 由于 `http` 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 `WebSocket`被发明出来\n\n> 相比与 `http` 具有以下有点\n\n*   支持双向通信，实时性更强；\n*   可以发送文本，也可以二进制文件；\n*   协议标识符是 `ws`，加密后是 `wss` ；\n*   较少的控制开销。连接创建后，`ws`客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有`2~10`字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而`HTTP`协议每次通信都需要携带完整的头部；\n*   支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）\n*   无跨域问题。\n\n> 实现比较简单，服务端库如 `socket.io`、`ws`，可以很好的帮助我们入门。而客户端也只需要参照 `api` 实现即可\n\n### 83 尽可能多的说出你对 Electron 的理解\n\n> 最最重要的一点，`electron` 实际上是一个套了 `Chrome` 的 `nodeJS`程序\n\n所以应该是从两个方面说开来\n\n*   `Chrome` （无各种兼容性问题）；\n*   `NodeJS`（`NodeJS` 能做的它也能做）\n\n### 84 深浅拷贝\n\n浅拷贝\n\n*   `Object.assign`\n*   或者展开运算符\n\n深拷贝\n\n*   可以通过 `JSON.parse(JSON.stringify(object))` 来解决\n\nlet a = {\n    age: 1,\n    jobs: {\n        first: 'FE'\n    }}let b = JSON.parse(JSON.stringify(a))a.jobs.first = 'native'console.log(b.jobs.first) // FE\n\n该方法也是有局限性的\n\n*   会忽略 `undefined`\n*   不能序列化函数\n*   不能解决循环引用的对象\n\n### 85 防抖/节流\n\n防抖\n\n> 在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现\n\n// 使用 underscore 的源码来解释防抖动/**\n * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行\n *\n * @param  {function} func        回调函数\n * @param  {number}   wait        表示时间窗口的间隔\n * @param  {boolean}  immediate   设置为ture时，是否立即调用函数\n * @return {function}             返回客户调用函数\n */_.debounce = function(func, wait, immediate) {\n    var timeout, args, context, timestamp, result;\n\n    var later = function() {\n      // 现在和上一次时间戳比较\n      var last = _.now() - timestamp;\n      // 如果当前间隔时间少于设定时间且大于0就重新设置定时器\n      if (last < wait && last >= 0) {\n        timeout = setTimeout(later, wait - last);\n      } else {\n        // 否则的话就是时间到了执行回调函数\n        timeout = null;\n        if (!immediate) {\n          result = func.apply(context, args);\n          if (!timeout) context = args = null;\n        }\n      }\n    };\n\n    return function() {\n      context = this;\n      args = arguments;\n      // 获得时间戳\n      timestamp = _.now();\n      // 如果定时器不存在且立即执行函数\n      var callNow = immediate && !timeout;\n      // 如果定时器不存在就创建一个\n      if (!timeout) timeout = setTimeout(later, wait);\n      if (callNow) {\n        // 如果需要立即执行函数的话 通过 apply 执行\n        result = func.apply(context, args);\n        context = args = null;\n      }\n\n      return result;\n    };\n  };\n\n> 整体函数实现\n\n对于按钮防点击来说的实现\n\n*   开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了\n*   对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数\n\n节流\n\n> 防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行\n\n/**\n * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait\n *\n * @param  {function}   func      回调函数\n * @param  {number}     wait      表示时间窗口的间隔\n * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。\n *                                如果想忽略结尾函数的调用，传入{trailing: false}\n *                                两者不能共存，否则函数不能执行\n * @return {function}             返回客户调用函数   \n */_.throttle = function(func, wait, options) {\n    var context, args, result;\n    var timeout = null;\n    // 之前的时间戳\n    var previous = 0;\n    // 如果 options 没传则设为空对象\n    if (!options) options = {};\n    // 定时器回调函数\n    var later = function() {\n      // 如果设置了 leading，就将 previous 设为 0\n      // 用于下面函数的第一个 if 判断\n      previous = options.leading === false ? 0 : _.now();\n      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断\n      timeout = null;\n      result = func.apply(context, args);\n      if (!timeout) context = args = null;\n    };\n    return function() {\n      // 获得当前时间戳\n      var now = _.now();\n      // 首次进入前者肯定为 true\n   // 如果需要第一次不执行函数\n   // 就将上次时间戳设为当前的\n      // 这样在接下来计算 remaining 的值时会大于0\n      if (!previous && options.leading === false) previous = now;\n      // 计算剩余时间\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      // 如果当前调用已经大于上次调用时间 + wait\n      // 或者用户手动调了时间\n    // 如果设置了 trailing，只会进入这个条件\n   // 如果没有设置 leading，那么第一次会进入这个条件\n   // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了\n   // 其实还是会进入的，因为定时器的延时\n   // 并不是准确的时间，很可能你设置了2秒\n   // 但是他需要2.2秒才触发，这时候就会进入这个条件\n      if (remaining <= 0 || remaining > wait) {\n        // 如果存在定时器就清理掉否则会调用二次回调\n        if (timeout) {\n          clearTimeout(timeout);\n          timeout = null;\n        }\n        previous = now;\n        result = func.apply(context, args);\n        if (!timeout) context = args = null;\n      } else if (!timeout && options.trailing !== false) {\n        // 判断是否设置了定时器和 trailing\n     // 没有的话就开启一个定时器\n        // 并且不能不能同时设置 leading 和 trailing\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n### 86 谈谈变量提升？\n\n> 当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境\n\n*   接下来让我们看一个老生常谈的例子，`var`\n\nb() // call bconsole.log(a) // undefinedvar a = 'Hello world'function b() {\n    console.log('call b')}\n\n变量提升 这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 `undefined`，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升\n\nb() // call b secondfunction b() {\n    console.log('call b fist')}function b() {\n    console.log('call b second')}var b = 'Hello world'\n\n> 复制代码`var` 会产生很多错误，所以在 `ES6`中引入了 `let`。`let` 不能在声明前使用，但是这并不是常说的 `let` 不会提升，`let` 提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用\n\n### 87 什么是单线程，和异步的关系\n\n*   单线程 \\- 只有一个线程，只能做一件事\n*   原因 \\- 避免 `DOM` 渲染的冲突\n    *   浏览器需要渲染 `DOM`\n    *   `JS` 可以修改 `DOM` 结构\n    *   `JS` 执行的时候，浏览器 `DOM` 渲染会暂停\n    *   两段 JS 也不能同时执行（都修改 `DOM` 就冲突了）\n    *   `webworker` 支持多线程，但是不能访问 `DOM`\n*   解决方案 \\- 异步\n\n### 88 是否用过 jQuery 的 Deferred\n\n![image.png](https://upload-images.jianshu.io/upload_images/1480597-77a330fbdcc1f1cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-6f79b726f5341f7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-82ac861eced36a45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-69092d725f2b1e79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-9d9b67a6859cf8cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-9970b83118b10829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-243444771c6b30ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) ![image.png](https://upload-images.jianshu.io/upload_images/1480597-d2db463132d1572a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-c589d6f7caf8b27c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)![image.png](https://upload-images.jianshu.io/upload_images/1480597-ab3b7f684e99e6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 89 前端面试之hybrid\n\n> [http://blog.poetries.top/2018/10/20/fe-interview-hybrid/](http://blog.poetries.top/2018/10/20/fe-interview-hybrid/)\n\n### 90 前端面试之组件化\n\n> [http://blog.poetries.top/2018/10/20/fe-interview-component/](http://blog.poetries.top/2018/10/20/fe-interview-component/)\n\n### 91 前端面试之MVVM浅析\n\n> [http://blog.poetries.top/2018/10/20/fe-interview-mvvm/](http://blog.poetries.top/2018/10/20/fe-interview-mvvm/)\n\n### 92 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置\n\nconst box = document.getElementById('box');function isIcon(target) {\n  return target.className.includes('icon');}box.onClick = function(e) {\n  e.stopPropagation();\n  const target = e.target;\n  if (isIcon(target)) {\n    target.style.border = '1px solid red';\n  }}const doc = document;doc.onclick = function(e) {\n  const children = box.children;\n  for(let i; i < children.length; i++) {\n    if (isIcon(children\\[i\\])) {\n      children\\[i\\].style.border = 'none';\n    }\n  }}\n\n### 93 请简单实现双向数据绑定`mvvm`\n\n<input id=\"input\"/>\n\nconst data = {};const input = document.getElementById('input');Object.defineProperty(data, 'text', {\n  set(value) {\n    input.value = value;\n    this.value = value;\n  }});input.onChange = function(e) {\n  data.text = e.target.value;}\n\n### 94 实现Storage，使得该对象为单例，并对`localStorage`进行封装设置值setItem(key,value)和getItem(key)\n\nvar instance = null;class Storage {\n  static getInstance() {\n    if (!instance) {\n      instance = new Storage();\n    }\n    return instance;\n  }\n  setItem = (key, value) => localStorage.setItem(key, value),\n  getItem = key => localStorage.getItem(key)}\n\n### 95 说说`event loop`\n\n> 首先，`js`是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应`DOM`的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被`push`进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步`HTTP`请求线程满足特定条件下的回调函数`push`到事件队列中，等待`js`引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务`microtask（promise）`，如果有那就优先执行微任务，如果没有，在去查找宏任务`macrotask（setTimeout、setInterval）`进行执行\n\n### 96 说说事件流\n\n事件流分为两种，捕获事件流和冒泡事件流\n\n*   捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点\n*   冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点\n\n> 事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段\n\n### 97 为什么`canvas`的图片为什么过有跨域问题\n\n### 98 我现在有一个`canvas`，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块\n\n> https://www.jianshu.com/p/f54d265f7aa4\n\n### 99 请手写实现一个`promise`\n\n> https://segmentfault.com/a/1190000013396601\n\n### 100 说说从输入URL到看到页面发生的全过程，越详细越好\n\n*   首先浏览器主进程接管，开了一个下载线程。\n*   然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。\n*   将下载完的内容转交给Renderer进程管理。\n*   Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。\n*   解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。\n*   css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。\n*   绘制结束后，关闭TCP连接，过程有四次挥手\n\n### 101 描述一下`this`\n\n> `this`，函数执行的上下文，可以通过`apply`，`call`，`bind`改变`this`的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，NodeJS为`global`），剩下的函数调用，那就是谁调用它，`this`就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，`this`就指向哪里\n\n### 102 说一下浏览器的缓存机制\n\n> 浏览器缓存机制有两种，一种为强缓存，一种为协商缓存\n\n*   对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。\n*   对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存\n\n协商缓存相关设置\n\n*   `Exprires`：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。`Exprires`的缺陷是必须保证服务端时间和客户端时间严格同步。\n*   `Cache-control：max-age`：表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题，\n*   `If-None-Match/ETag`：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回`If-None-Match`标识是否表示匹配。\n*   `Last-modified/If-Modified-Since`：第一次请求的时候服务端返回`Last-modified`表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头`If-Modified-Since`，表示资源上次的修改时间，服务端拿到这两个字段进行对比\n\n### 103 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？\n\n*   该组件需要提供`hook`指定渲染位置，默认渲染在body下面。\n*   然后改组件可以指定外层样式，如宽度等\n*   组件外层还需要一层`mask`来遮住底层内容，点击`mask`可以执行传进来的`onCancel`函数关闭`Dialog`。\n*   另外组件是可控的，需要外层传入`visible`表示是否可见。\n*   然后`Dialog`可能需要自定义头head和底部`footer`，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的`onOk`事件，然后取消按钮会执行外部传进来的`onCancel`事件。\n*   当组件的`visible`为`true`时候，设置`body`的`overflow`为`hidden`，隐藏`body`的滚动条，反之显示滚动条。\n*   组件高度可能大于页面高度，组件内部需要滚动条。\n*   只有组件的`visible`有变化且为`ture`时候，才重渲染组件内的所有内容\n\n### 104 `caller`和`callee`的区别\n\ncallee\n\n> `caller`返回一个函数的引用，这个函数调用了当前的函数。\n\n使用这个属性要注意\n\n*   这个属性只有当函数在执行时才有用\n*   如果在`javascript`程序中，函数是由顶层调用的，则返回`null`\n\n> `functionName.caller: functionName`是当前正在执行的函数。\n\nfunction a() {\n  console.log(a.caller)}\n\ncallee\n\n> `callee`放回正在执行的函数本身的引用，它是`arguments`的一个属性\n\n> 使用callee时要注意:\n\n*   这个属性只有在函数执行时才有效\n*   它有一个`length`属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较`arguments.length`是否等于`arguments.callee.length`\n*   它可以用来递归匿名函数。\n\nfunction a() {\n  console.log(arguments.callee)}\n\n### 105 ajax、axios、fetch区别\n\njQuery ajax\n\n$.ajax({\n   type: 'POST',\n   url: url,\n   data: data,\n   dataType: dataType,\n   success: function () {},\n   error: function () {}});\n\n优缺点：\n\n*   本身是针对`MVC`的编程,不符合现在前端`MVVM`的浪潮\n*   基于原生的`XHR`开发，`XHR`本身的架构不清晰，已经有了`fetch`的替代方案\n*   `JQuery`整个项目太大，单纯使用`ajax`却要引入整个`JQuery`非常的不合理（采取个性化打包的方案又不能享受CDN服务）\n\naxios\n\naxios({\n    method: 'post',\n    url: '/user/12345',\n    data: {\n        firstName: 'Fred',\n        lastName: 'Flintstone'\n    }}).then(function (response) {\n    console.log(response);}).catch(function (error) {\n    console.log(error);});\n\n优缺点：\n\n*   从浏览器中创建 `XMLHttpRequest`\n*   从 `node.js` 发出 `http` 请求\n*   支持 `Promise API`\n*   拦截请求和响应\n*   转换请求和响应数据\n*   取消请求\n*   自动转换`JSON`数据\n*   客户端支持防止`CSRF/XSRF`\n\nfetch\n\ntry {\n  let response = await fetch(url);\n  let data = response.json();\n  console.log(data);} catch(e) {\n  console.log(\"Oops, error\", e);}\n\n优缺点：\n\n*   `fetcht`只对网络请求报错，对`400`，`500`都当做成功的请求，需要封装去处理\n*   `fetch`默认不会带`cookie`，需要添加配置项\n*   `fetch`不支持`abort`，不支持超时控制，使用`setTimeout`及`Promise.reject`的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费\n*   `fetch`没有办法原生监测请求的进度，而XHR可以","slug":"2019-e6-9c-80-e6-96-b0-e5-89-8d-e7-ab-af-e7-9f-a5-e8-af-86-e6-a2-b3-e7-90-86javascript-e9-83-a8-e5-88-86-e9-9d-a2-e8-af-95-e5-ae-9d-e5-85-b8","published":1,"updated":"2019-09-12T03:00:04.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmp269gx0062c8gs8e05hepl","content":"<h2 id=\"三、JavaScript\"><a href=\"#三、JavaScript\" class=\"headerlink\" title=\"三、JavaScript\"></a>三、JavaScript</h2><h3 id=\"1-闭包\"><a href=\"#1-闭包\" class=\"headerlink\" title=\"1 闭包\"></a>1 闭包</h3><ul>\n<li>  闭包就是能够读取其他函数内部变量的函数</li>\n<li>  闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</li>\n<li>闭包的特性：<ul>\n<li>  函数内再嵌套函数</li>\n<li>  内部函数可以引用外层的参数和变量</li>\n<li>  参数和变量不会被垃圾回收机制回收</li>\n</ul>\n</li>\n</ul>\n<p>说说你对闭包的理解</p>\n<ul>\n<li>  使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</li>\n<li>  闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</li>\n<li>  闭包的另一个用处，是封装对象的私有属性和私有方法</li>\n<li>  好处：能够实现封装和缓存等；</li>\n<li>  坏处：就是消耗内存、不正当使用会造成内存溢出的问题</li>\n</ul>\n<p>使用闭包的注意点</p>\n<ul>\n<li>  由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露</li>\n<li>  解决方法是，在退出函数之前，将不使用的局部变量全部删除</li>\n</ul>\n<h3 id=\"2-说说你对作用域链的理解\"><a href=\"#2-说说你对作用域链的理解\" class=\"headerlink\" title=\"2 说说你对作用域链的理解\"></a>2 说说你对作用域链的理解</h3><ul>\n<li>  作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的</li>\n<li>  简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期</li>\n</ul>\n<h3 id=\"3-JavaScript原型，原型链-有什么特点？\"><a href=\"#3-JavaScript原型，原型链-有什么特点？\" class=\"headerlink\" title=\"3 JavaScript原型，原型链 ? 有什么特点？\"></a>3 JavaScript原型，原型链 ? 有什么特点？</h3><ul>\n<li>  每个对象都会在其内部初始化一个属性，就是<code>prototype</code>(原型)，当我们访问一个对象的属性时</li>\n<li>  如果这个对象内部不存在这个属性，那么他就会去<code>prototype</code>里找这个属性，这个<code>prototype</code>又会有自己的<code>prototype</code>，于是就这样一直找下去，也就是我们平时所说的原型链的概念</li>\n<li>  关系：<code>instance.constructor.prototype = instance.__proto__</code></li>\n<li>特点：<ul>\n<li>  <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</li>\n</ul>\n</li>\n<li>  当我们需要一个属性的时，<code>Javascript</code>引擎会先看当前对象中是否有这个属性， 如果没有的</li>\n<li>  就会查找他的<code>Prototype</code>对象是否有这个属性，如此递推下去，一直检索到 <code>Object</code> 内建对象</li>\n</ul>\n<h3 id=\"4-请解释什么是事件代理\"><a href=\"#4-请解释什么是事件代理\" class=\"headerlink\" title=\"4 请解释什么是事件代理\"></a>4 请解释什么是事件代理</h3><ul>\n<li>  事件代理（<code>Event Delegation</code>），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li>\n<li>  可以大量节省内存占用，减少事件注册，比如在<code>table</code>上代理所有<code>td</code>的<code>click</code>事件就非常棒</li>\n<li>  可以实现当新增子对象时无需再次对其绑定</li>\n</ul>\n<h3 id=\"5-Javascript如何实现继承？\"><a href=\"#5-Javascript如何实现继承？\" class=\"headerlink\" title=\"5 Javascript如何实现继承？\"></a>5 Javascript如何实现继承？</h3><ul>\n<li>  构造继承</li>\n<li>  原型继承</li>\n<li>  实例继承</li>\n<li>  拷贝继承</li>\n<li>  原型<code>prototype</code>机制或<code>apply</code>和<code>call</code>方法去实现较简单，建议使用构造函数与原型混合方式</li>\n</ul>\n<p>function Parent(){<br> this.name = ‘wang’;}function Child(){<br>        this.age = 28;}<br>    Child.prototype = new Parent();//继承了Parent，通过原型var demo = new Child();alert(demo.age);alert(demo.name);//得到被继承的属性</p>\n<h3 id=\"6-谈谈This对象的理解\"><a href=\"#6-谈谈This对象的理解\" class=\"headerlink\" title=\"6 谈谈This对象的理解\"></a>6 谈谈This对象的理解</h3><ul>\n<li>  <code>this</code>总是指向函数的直接调用者（而非间接调用者）</li>\n<li>  如果有<code>new</code>关键字，<code>this</code>指向<code>new</code>出来的那个对象</li>\n<li>  在事件中，<code>this</code>指向触发这个事件的对象，特殊的是，<code>IE</code>中的<code>attachEvent</code>中的<code>this</code>总是指向全局对象<code>Window</code></li>\n</ul>\n<h3 id=\"7-事件模型\"><a href=\"#7-事件模型\" class=\"headerlink\" title=\"7 事件模型\"></a>7 事件模型</h3><blockquote>\n<p><code>W3C</code>中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p>\n</blockquote>\n<ul>\n<li>  冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li>\n<li>  捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li>\n<li>  <code>DOM</code>事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li>\n<li>  阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation()</code>方法；在IE下设置<code>cancelBubble = true</code></li>\n<li>  阻止捕获：阻止事件的默认行为，例如<code>click - &lt;a&gt;</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault()</code>方法，在<code>IE</code>下设置<code>window.event.returnValue = false</code></li>\n</ul>\n<h3 id=\"8-new操作符具体干了什么呢\"><a href=\"#8-new操作符具体干了什么呢\" class=\"headerlink\" title=\"8 new操作符具体干了什么呢?\"></a>8 new操作符具体干了什么呢?</h3><ul>\n<li>  创建一个空对象，并且 <code>this</code> 变量引用该对象，同时还继承了该函数的原型</li>\n<li>  属性和方法被加入到 <code>this</code> 引用的对象中</li>\n<li>  新创建的对象由 <code>this</code> 所引用，并且最后隐式的返回 <code>this</code></li>\n</ul>\n<h3 id=\"9-Ajax原理\"><a href=\"#9-Ajax原理\" class=\"headerlink\" title=\"9 Ajax原理\"></a>9 Ajax原理</h3><ul>\n<li>  <code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层(<code>AJAX</code>引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascrip</code>t来操作<code>DOM</code>而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</li>\n<li>  <code>Ajax</code>的过程只涉及<code>JavaScript</code>、<code>XMLHttpRequest</code>和<code>DOM</code>。<code>XMLHttpRequest</code>是<code>aja</code>x的核心机制</li>\n</ul>\n<p>/** 1. 创建连接 <strong>/var xhr = null;xhr = new XMLHttpRequest()/</strong> 2. 连接服务器 <strong>/xhr.open(‘get’, url, true)/</strong> 3. 发送请求 <strong>/xhr.send(null);/</strong> 4. 接受请求 <strong>/xhr.onreadystatechange = function(){<br> if(xhr.readyState == 4){<br> if(xhr.status == 200){<br> success(xhr.responseText);<br> } else { <br> /</strong> false **/<br> fail &amp;&amp; fail(xhr.status);<br> }<br> }}</p>\n<p>ajax 有那些优缺点?</p>\n<ul>\n<li>优点：<ul>\n<li>  通过异步模式，提升了用户体验.</li>\n<li>  优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.</li>\n<li>  <code>Ajax</code>在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li>\n<li>  <code>Ajax</code>可以实现动态不刷新（局部刷新）</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>  安全问题 <code>AJAX</code>暴露了与服务器交互的细节。</li>\n<li>  对搜索引擎的支持比较弱。</li>\n<li>  不容易调试。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"10-如何解决跨域问题\"><a href=\"#10-如何解决跨域问题\" class=\"headerlink\" title=\"10 如何解决跨域问题?\"></a>10 如何解决跨域问题?</h3><blockquote>\n<p>首先了解下浏览器的同源策略 同源策略<code>/SOP（Same origin policy）</code>是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到<code>XSS</code>、<code>CSFR</code>等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源</p>\n</blockquote>\n<p>那么怎样解决跨域问题的呢？</p>\n<ul>\n<li>  通过jsonp跨域</li>\n</ul>\n<p>var script = document.createElement(‘script’);script.type = ‘text/javascript’;// 传参并指定回调执行函数为onBackscript.src = ‘<a href=\"http://www.....:8080/login?user=admin&amp;callback=onBack&#39;;document.head.appendChild(script);//\">http://www.....:8080/login?user=admin&amp;callback=onBack&#39;;document.head.appendChild(script);//</a> 回调执行函数function onBack(res) {<br>    alert(JSON.stringify(res));}</p>\n<ul>\n<li>  document.domain + iframe跨域</li>\n</ul>\n<blockquote>\n<p>此方案仅限主域相同，子域不同的跨域应用场景</p>\n</blockquote>\n<p>1.）父窗口：(<a href=\"http://www.domain.com/a.html\">http://www.domain.com/a.html</a>)</p>\n<p><iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe><script><br>    document.domain = 'domain.com';<br>    var user = 'admin';</script></p>\n<p>2.）子窗口：(<a href=\"http://child.domain.com/b.html\">http://child.domain.com/b.html</a>)</p>\n<p>document.domain = ‘domain.com’;// 获取父窗口中变量alert(‘get js data from parent —&gt; ‘ + window.parent.user);</p>\n<ul>\n<li>  nginx代理跨域</li>\n<li>  nodejs中间件代理跨域</li>\n<li>  后端在头部信息里面设置安全域名</li>\n</ul>\n<h3 id=\"11-模块化开发怎么做？\"><a href=\"#11-模块化开发怎么做？\" class=\"headerlink\" title=\"11 模块化开发怎么做？\"></a>11 模块化开发怎么做？</h3><ul>\n<li>  立即执行函数,不暴露私有成员</li>\n</ul>\n<p>var module1 = (function(){　　　　var _count = 0;　　　　var m1 = function(){　　　　　　//…　　　　};　　　　var m2 = function(){　　　　　　//…　　　　};　　　　return {　　　　　　m1 : m1,　　　　　　m2 : m2<br>　　　　};})();</p>\n<h3 id=\"12-异步加载JS的方式有哪些？\"><a href=\"#12-异步加载JS的方式有哪些？\" class=\"headerlink\" title=\"12 异步加载JS的方式有哪些？\"></a>12 异步加载JS的方式有哪些？</h3><ul>\n<li>  defer，只支持<code>IE</code></li>\n<li>  <code>async</code>：</li>\n<li>  创建<code>script</code>，插入到<code>DOM</code>中，加载完毕后<code>callBack</code></li>\n</ul>\n<h3 id=\"13-那些操作会造成内存泄漏？\"><a href=\"#13-那些操作会造成内存泄漏？\" class=\"headerlink\" title=\"13 那些操作会造成内存泄漏？\"></a>13 那些操作会造成内存泄漏？</h3><ul>\n<li>  内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>\n<li>  <code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>\n<li>  闭包使用不当</li>\n</ul>\n<h3 id=\"14-XML和JSON的区别？\"><a href=\"#14-XML和JSON的区别？\" class=\"headerlink\" title=\"14 XML和JSON的区别？\"></a>14 XML和JSON的区别？</h3><ul>\n<li>数据体积方面<ul>\n<li>  <code>JSON</code>相对<code>于XML</code>来讲，数据的体积小，传递的速度更快些。</li>\n</ul>\n</li>\n<li>数据交互方面<ul>\n<li>  <code>JSON</code>与<code>JavaScript</code>的交互更加方便，更容易解析处理，更好的数据交互</li>\n</ul>\n</li>\n<li>数据描述方面<ul>\n<li>  <code>JSON</code>对数据的描述性比<code>XML</code>较差</li>\n</ul>\n</li>\n<li>传输速度方面<ul>\n<li>  <code>JSON</code>的速度要远远快于<code>XML</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"15-谈谈你对webpack的看法\"><a href=\"#15-谈谈你对webpack的看法\" class=\"headerlink\" title=\"15 谈谈你对webpack的看法\"></a>15 谈谈你对webpack的看法</h3><ul>\n<li>  <code>WebPack</code> 是一个模块打包工具，你可以使用<code>WebPack</code>管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包<code>Web</code>开发中所用到的<code>HTML</code>、<code>Javascript</code>、<code>CSS</code>以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，<code>webpack</code>有对应的模块加载器。<code>webpack</code>模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源</li>\n</ul>\n<h3 id=\"16-说说你对AMD和Commonjs的理解\"><a href=\"#16-说说你对AMD和Commonjs的理解\" class=\"headerlink\" title=\"16 说说你对AMD和Commonjs的理解\"></a>16 说说你对AMD和Commonjs的理解</h3><ul>\n<li>  <code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li>\n<li>  <code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li>\n</ul>\n<h3 id=\"17-常见web安全及防护原理\"><a href=\"#17-常见web安全及防护原理\" class=\"headerlink\" title=\"17 常见web安全及防护原理\"></a>17 常见web安全及防护原理</h3><ul>\n<li><code>sql</code>注入原理<ul>\n<li>  就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</li>\n</ul>\n</li>\n<li>总的来说有以下几点<ul>\n<li>  永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<code>&quot;-&quot;</code>进行转换等</li>\n<li>  永远不要使用动态拼装SQL，可以使用参数化的<code>SQL</code>或者直接使用存储过程进行数据查询存取</li>\n<li>  永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li>\n<li>  不要把机密信息明文存放，请加密或者<code>hash</code>掉密码和敏感的信息</li>\n</ul>\n</li>\n</ul>\n<p>XSS原理及防范</p>\n<ul>\n<li>  <code>Xss(cross-site scripting)</code>攻击指的是攻击者往<code>Web</code>页面里插入恶意<code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点</li>\n</ul>\n<p>XSS防范方法</p>\n<ul>\n<li>  首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击</li>\n</ul>\n<p>XSS与CSRF有什么区别吗？</p>\n<ul>\n<li>  <code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤</li>\n<li>  登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code></li>\n<li>  在不登出<code>A</code>的情况下，访问危险网站<code>B</code></li>\n</ul>\n<p>CSRF的防御</p>\n<ul>\n<li>  服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数</li>\n<li>  通过验证码的方法</li>\n</ul>\n<h3 id=\"18-用过哪些设计模式？\"><a href=\"#18-用过哪些设计模式？\" class=\"headerlink\" title=\"18 用过哪些设计模式？\"></a>18 用过哪些设计模式？</h3><ul>\n<li>工厂模式：<ul>\n<li>  工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法</li>\n<li>  主要好处就是可以消除对象间的耦合，通过使用工程方法而不是<code>new</code>关键字</li>\n</ul>\n</li>\n<li>构造函数模式<ul>\n<li>  使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</li>\n<li>  直接将属性和方法赋值给 <code>this</code>对象;</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"19-为什么要有同源限制？\"><a href=\"#19-为什么要有同源限制？\" class=\"headerlink\" title=\"19 为什么要有同源限制？\"></a>19 为什么要有同源限制？</h3><ul>\n<li>  同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li>\n<li>  举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</li>\n</ul>\n<h3 id=\"20-offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别\"><a href=\"#20-offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别\" class=\"headerlink\" title=\"20 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别\"></a>20 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h3><ul>\n<li>  <code>offsetWidth/offsetHeight</code>返回值包含content + padding + border，效果与e.getBoundingClientRect()相同</li>\n<li>  <code>clientWidth/clientHeight</code>返回值只包含content + padding，如果有滚动条，也不包含滚动条</li>\n<li>  <code>scrollWidth/scrollHeight</code>返回值包含content + padding + 溢出内容的尺寸</li>\n</ul>\n<h3 id=\"21-javascript有哪些方法定义对象\"><a href=\"#21-javascript有哪些方法定义对象\" class=\"headerlink\" title=\"21 javascript有哪些方法定义对象\"></a>21 javascript有哪些方法定义对象</h3><ul>\n<li>  对象字面量： <code>var obj = &#123;&#125;;</code></li>\n<li>  构造函数： <code>var obj = new Object();</code></li>\n<li>  Object.create(): <code>var obj = Object.create(Object.prototype);</code></li>\n</ul>\n<h3 id=\"22-常见兼容性问题？\"><a href=\"#22-常见兼容性问题？\" class=\"headerlink\" title=\"22 常见兼容性问题？\"></a>22 常见兼容性问题？</h3><ul>\n<li>  <code>png24</code>位的图片在iE6浏览器上出现背景，解决方案是做成<code>PNG8</code></li>\n<li>  浏览器默认的<code>margin</code>和<code>padding</code>不同。解决方案是加一个全局的<code>*&#123;margin:0;padding:0;&#125;</code>来统一,，但是全局效率很低，一般是如下这样解决：</li>\n</ul>\n<p>body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p{margin:0;padding:0;}</p>\n<ul>\n<li>  <code>IE</code>下,<code>event</code>对象有<code>x</code>,<code>y</code>属性,但是没有<code>pageX</code>,<code>pageY</code>属性</li>\n<li>  <code>Firefox</code>下,<code>event</code>对象有<code>pageX</code>,<code>pageY</code>属性,但是没有<code>x,y</code>属性.</li>\n</ul>\n<h3 id=\"23-说说你对promise的了解\"><a href=\"#23-说说你对promise的了解\" class=\"headerlink\" title=\"23 说说你对promise的了解\"></a>23 说说你对promise的了解</h3><ul>\n<li>依照 <code>Promise/A+</code> 的定义，<code>Promise</code> 有四种状态：<ul>\n<li>  <code>pending:</code> 初始状态, 非 <code>fulfilled</code> 或 <code>rejected.</code></li>\n<li>  <code>fulfilled:</code> 成功的操作.</li>\n<li>  <code>rejected:</code> 失败的操作.</li>\n<li>  <code>settled: Promise</code>已被<code>fulfilled</code>或<code>rejected</code>，且不是<code>pending</code></li>\n</ul>\n</li>\n<li>  另外， <code>fulfilled</code>与 <code>rejected</code>一起合称 <code>settled</code></li>\n<li>  <code>Promise</code> 对象用来进行延迟(<code>deferred</code>) 和异步(<code>asynchronous</code>) 计算</li>\n</ul>\n<p>Promise 的构造函数</p>\n<ul>\n<li>  构造一个 <code>Promise</code>，最基本的用法如下：</li>\n</ul>\n<p>var promise = new Promise(function(resolve, reject) {</p>\n<p>        if (…) {  // succeed</p>\n<p>            resolve(result);</p>\n<p>        } else {   // fails</p>\n<p>            reject(Error(errMessage));</p>\n<p>        }<br>    });</p>\n<ul>\n<li>  <code>Promise</code> 实例拥有 <code>then</code> 方法（具有 <code>then</code> 方法的对象，通常被称为<code>thenable</code>）。它的使用方法如下：</li>\n</ul>\n<p>promise.then(onFulfilled, onRejected)</p>\n<ul>\n<li>  接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在<code>rejected</code>的时候被调用，接收参数就是 <code>future</code>，<code>onFulfilled</code> 对应<code>resolve</code>, <code>onRejected</code>对应 <code>reject</code></li>\n</ul>\n<h3 id=\"24-你觉得jQuery源码有哪些写的好的地方\"><a href=\"#24-你觉得jQuery源码有哪些写的好的地方\" class=\"headerlink\" title=\"24 你觉得jQuery源码有哪些写的好的地方\"></a>24 你觉得jQuery源码有哪些写的好的地方</h3><ul>\n<li>  <code>jquery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入<code>window</code>对象参数，可以使<code>window</code>对象作为局部变量使用，好处是当<code>jquery</code>中访问<code>window</code>对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入<code>undefined</code>参数，可以缩短查找<code>undefined</code>时的作用域链</li>\n<li>  <code>jquery</code>将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法</li>\n<li>  有一些数组或对象的方法经常能使用到，<code>jQuery</code>将其保存为局部变量以提高访问速度</li>\n<li>  <code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li>\n</ul>\n<h3 id=\"25-vue、react、angular\"><a href=\"#25-vue、react、angular\" class=\"headerlink\" title=\"25 vue、react、angular\"></a>25 vue、react、angular</h3><ul>\n<li>  <code>Vue.js</code> 一个用于创建 <code>web</code> 交互界面的库，是一个精简的 <code>MVVM</code>。它通过双向数据绑定把 <code>View</code>层和 <code>Model</code> 层连接了起来。实际的 <code>DOM</code> 封装和输出格式都被抽象为了<code>Directives</code> 和 <code>Filters</code></li>\n<li>  <code>AngularJS</code> 是一个比较完善的前端<code>MVVM</code>框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 <code>Angular</code>指令</li>\n<li>  <code>react</code> <code>React</code> 仅仅是 <code>VIEW</code> 层是<code>facebook</code>公司。推出的一个用于构建<code>UI</code>的一个库，能够实现服务器端的渲染。用了<code>virtual dom</code>，所以性能很好。</li>\n</ul>\n<h3 id=\"26-Node的应用场景\"><a href=\"#26-Node的应用场景\" class=\"headerlink\" title=\"26 Node的应用场景\"></a>26 Node的应用场景</h3><ul>\n<li>特点：<ul>\n<li>  1、它是一个<code>Javascript</code>运行环境</li>\n<li>  2、依赖于<code>Chrome V8</code>引擎进行代码解释</li>\n<li>  3、事件驱动</li>\n<li>  4、非阻塞<code>I/O</code></li>\n<li>  5、单进程，单线程</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>  高并发（最重要的优点）</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>  1、只支持单核<code>CPU</code>，不能充分利用<code>CPU</code></li>\n<li>  2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"27-谈谈你对AMD、CMD的理解\"><a href=\"#27-谈谈你对AMD、CMD的理解\" class=\"headerlink\" title=\"27 谈谈你对AMD、CMD的理解\"></a>27 谈谈你对AMD、CMD的理解</h3><ul>\n<li>  <code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li>\n<li>  <code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li>\n</ul>\n<p>es6模块 CommonJS、AMD、CMD</p>\n<ul>\n<li>  <code>CommonJS</code> 的规范中，每个 <code>JavaScript</code> 文件就是一个独立的模块上下文（<code>module context</code>），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。</li>\n<li>  <code>CommonJS</code>是同步加载模块,在浏览器中会出现堵塞情况，所以不适用</li>\n<li>  <code>AMD</code> 异步，需要定义回调<code>define</code>方式</li>\n<li>  <code>es6</code> 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量 <code>es6</code>还可以导出类、方法，自动适用严格模式</li>\n</ul>\n<h3 id=\"28-那些操作会造成内存泄漏\"><a href=\"#28-那些操作会造成内存泄漏\" class=\"headerlink\" title=\"28 那些操作会造成内存泄漏\"></a>28 那些操作会造成内存泄漏</h3><ul>\n<li>  内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>\n<li>  <code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>\n<li>  闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>\n</ul>\n<h3 id=\"29-web开发中会话跟踪的方法有哪些\"><a href=\"#29-web开发中会话跟踪的方法有哪些\" class=\"headerlink\" title=\"29 web开发中会话跟踪的方法有哪些\"></a>29 web开发中会话跟踪的方法有哪些</h3><ul>\n<li>  <code>cookie</code></li>\n<li>  <code>session</code></li>\n<li>  <code>url</code>重写</li>\n<li>  隐藏<code>input</code></li>\n<li>  <code>ip</code>地址</li>\n</ul>\n<h3 id=\"30-介绍js的基本数据类型\"><a href=\"#30-介绍js的基本数据类型\" class=\"headerlink\" title=\"30 介绍js的基本数据类型\"></a>30 介绍js的基本数据类型</h3><ul>\n<li>  <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code></li>\n</ul>\n<h3 id=\"31-介绍js有哪些内置对象\"><a href=\"#31-介绍js有哪些内置对象\" class=\"headerlink\" title=\"31 介绍js有哪些内置对象\"></a>31 介绍js有哪些内置对象</h3><ul>\n<li>  <code>Object</code> 是 <code>JavaScript</code> 中所有对象的父对象</li>\n<li>  数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code></li>\n<li>  其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li>\n</ul>\n<h3 id=\"32-说几条写JavaScript的基本规范\"><a href=\"#32-说几条写JavaScript的基本规范\" class=\"headerlink\" title=\"32 说几条写JavaScript的基本规范\"></a>32 说几条写JavaScript的基本规范</h3><ul>\n<li>  不要在同一行声明多个变量</li>\n<li>  请使用<code>===/!==</code>来比较<code>true/false</code>或者数值</li>\n<li>  使用对象字面量替代<code>new Array</code>这种形式</li>\n<li>  不要使用全局函数</li>\n<li>  <code>Switch</code>语句必须带有<code>default</code>分支</li>\n<li>  <code>If</code>语句必须使用大括号</li>\n<li>  <code>for-in</code>循环中的变量 应该使用<code>var</code>关键字明确限定作用域，从而避免作用域污</li>\n</ul>\n<h3 id=\"33-JavaScript有几种类型的值\"><a href=\"#33-JavaScript有几种类型的值\" class=\"headerlink\" title=\"33 JavaScript有几种类型的值\"></a>33 JavaScript有几种类型的值</h3><ul>\n<li>  栈：原始数据类型（<code>Undefined</code>，<code>Null</code>，<code>Boolean</code>，<code>Number</code>、<code>String</code>）</li>\n<li>  堆：引用数据类型（对象、数组和函数）</li>\n<li>  两种类型的区别是：存储位置不同；</li>\n<li>  原始数据类型直接存储在栈(<code>stack</code>)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>\n<li>  引用数据类型存储在堆(<code>heap</code>)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</li>\n<li>  在栈中的地址，取得地址后从堆中获得实体</li>\n</ul>\n<p><img src=\"https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966\"></p>\n<h3 id=\"34-javascript创建对象的几种方式\"><a href=\"#34-javascript创建对象的几种方式\" class=\"headerlink\" title=\"34 javascript创建对象的几种方式\"></a>34 javascript创建对象的几种方式</h3><blockquote>\n<p><code>javascript</code>创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用<code>JSON</code>；但写法有很多种，也能混合使用</p>\n</blockquote>\n<ul>\n<li>  对象字面量的方式</li>\n</ul>\n<p>person={firstname:”Mark”,lastname:”Yun”,age:25,eyecolor:”black”};</p>\n<ul>\n<li>  用<code>function</code>来模拟无参的构造函数</li>\n</ul>\n<p>function Person(){}<br> var person=new Person();//定义一个function，如果使用new”实例化”,该function可以看作是一个Class<br>        person.name=”Mark”;<br>        person.age=”25”;<br>        person.work=function(){<br>        alert(person.name+” hello…”);}person.work();</p>\n<ul>\n<li>  用<code>function</code>来模拟参构造函数来实现（用<code>this</code>关键字定义构造的上下文属性）</li>\n</ul>\n<p>function Pet(name,age,hobby){<br>       this.name=name;//this作用域：当前对象<br>       this.age=age;<br>       this.hobby=hobby;<br>       this.eat=function(){<br>           alert(“我叫”+this.name+”,我喜欢”+this.hobby+”,是个程序员”);<br>       }}var maidou =new Pet(“麦兜”,25,”coding”);//实例化、创建对象maidou.eat();//调用eat方法</p>\n<ul>\n<li>  用工厂方式来创建（内置对象）</li>\n</ul>\n<p>var wcDog =new Object();<br>     wcDog.name=”旺财”;<br>     wcDog.age=3;<br>     wcDog.work=function(){<br>       alert(“我是”+wcDog.name+”,汪汪汪……”);<br>     }<br>     wcDog.work();</p>\n<ul>\n<li>  用原型方式来创建</li>\n</ul>\n<p>function Dog(){}Dog.prototype.name=”旺财”;Dog.prototype.eat=function(){<br> alert(this.name+”是个吃货”);}var wangcai =new Dog();wangcai.eat();</p>\n<ul>\n<li>  用混合方式来创建</li>\n</ul>\n<p> function Car(name,price){<br> this.name=name;<br> this.price=price;}Car.prototype.sell=function(){<br> alert(“我是”+this.name+”，我现在卖”+this.price+”万元”);}var camry =new Car(“凯美瑞”,27);camry.sell();</p>\n<h3 id=\"35-eval是做什么的\"><a href=\"#35-eval是做什么的\" class=\"headerlink\" title=\"35 eval是做什么的\"></a>35 eval是做什么的</h3><ul>\n<li>  它的功能是把对应的字符串解析成<code>JS</code>代码并运行</li>\n<li>  应该避免使用<code>eval</code>，不安全，非常耗性能（<code>2</code>次，一次解析成<code>js</code>语句，一次执行）</li>\n<li>  由<code>JSON</code>字符串转换为JSON对象的时候可以用<code>eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;)</code></li>\n</ul>\n<h3 id=\"36-null，undefined-的区别\"><a href=\"#36-null，undefined-的区别\" class=\"headerlink\" title=\"36 null，undefined 的区别\"></a>36 null，undefined 的区别</h3><ul>\n<li>  <code>undefined</code> 表示不存在这个值。</li>\n<li>  <code>undefined</code> :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 <code>undefined</code></li>\n<li>  例如变量被声明了，但没有赋值时，就等于<code>undefined</code></li>\n<li>  <code>null</code> 表示一个对象被定义了，值为“空值”</li>\n<li>  <code>null</code> : 是一个对象(空对象, 没有任何属性和方法)</li>\n<li>  例如作为函数的参数，表示该函数的参数不是对象；</li>\n<li>  在验证<code>null</code>时，一定要使用　<code>===</code> ，因为 <code>==</code>无法分别<code>null</code> 和　<code>undefined</code></li>\n</ul>\n<h3 id=\"37-“1”-“2”-“3”-map-parseInt-答案是多少\"><a href=\"#37-“1”-“2”-“3”-map-parseInt-答案是多少\" class=\"headerlink\" title=\"37 [“1”, “2”, “3”].map(parseInt) 答案是多少\"></a>37 [“1”, “2”, “3”].map(parseInt) 答案是多少</h3><ul>\n<li>  <code>[1, NaN, NaN]</code>因为 <code>parseInt</code> 需要两个参数 <code>(val, radix)</code>，其中<code>radix</code> 表示解析时用的基数。</li>\n<li>  <code>map</code>传了 <code>3</code>个<code>(element, index, array)</code>，对应的 <code>radix</code> 不合法导致解析失败。</li>\n</ul>\n<h3 id=\"38-javascript-代码中的”use-strict”-是什么意思\"><a href=\"#38-javascript-代码中的”use-strict”-是什么意思\" class=\"headerlink\" title=\"38 javascript 代码中的”use strict”;是什么意思\"></a>38 javascript 代码中的”use strict”;是什么意思</h3><ul>\n<li>  <code>use strict</code>是一种<code>ECMAscript 5</code> 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使<code>JS</code>编码更加规范化的模式,消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为</li>\n</ul>\n<h3 id=\"39-JSON-的了解\"><a href=\"#39-JSON-的了解\" class=\"headerlink\" title=\"39 JSON 的了解\"></a>39 JSON 的了解</h3><ul>\n<li>  <code>JSON(JavaScript Object Notation)</code> 是一种轻量级的数据交换格式</li>\n<li>  它是基于<code>JavaScript</code>的一个子集。数据格式简单, 易于读写, 占用带宽小</li>\n<li>  <code>JSON</code>字符串转换为JSON对象:</li>\n</ul>\n<p>var obj =eval(‘(‘+ str +’)’);var obj = str.parseJSON();var obj = JSON.parse(str);</p>\n<ul>\n<li>  <code>JSON</code>对象转换为JSON字符串：</li>\n</ul>\n<p>var last=obj.toJSONString();<br>var last=JSON.stringify(obj);</p>\n<h3 id=\"40-js延迟加载的方式有哪些\"><a href=\"#40-js延迟加载的方式有哪些\" class=\"headerlink\" title=\"40 js延迟加载的方式有哪些\"></a>40 js延迟加载的方式有哪些</h3><ul>\n<li>  <code>defer</code>和<code>async</code>、动态创建<code>DOM</code>方式（用得最多）、按需异步载入<code>js</code></li>\n</ul>\n<h3 id=\"41-同步和异步的区别\"><a href=\"#41-同步和异步的区别\" class=\"headerlink\" title=\"41 同步和异步的区别\"></a>41 同步和异步的区别</h3><ul>\n<li>  同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>\n<li>  异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>\n</ul>\n<h3 id=\"42-渐进增强和优雅降级\"><a href=\"#42-渐进增强和优雅降级\" class=\"headerlink\" title=\"42 渐进增强和优雅降级\"></a>42 渐进增强和优雅降级</h3><ul>\n<li>  渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>\n<li>  优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</li>\n</ul>\n<h3 id=\"43-defer和async\"><a href=\"#43-defer和async\" class=\"headerlink\" title=\"43 defer和async\"></a>43 defer和async</h3><ul>\n<li>  <code>defer</code>并行加载<code>js</code>文件，会按照页面上<code>script</code>标签的顺序执行</li>\n<li>  <code>async</code>并行加载<code>js</code>文件，下载完成立即执行，不会按照页面上<code>script</code>标签的顺序执行</li>\n</ul>\n<h3 id=\"44-说说严格模式的限制\"><a href=\"#44-说说严格模式的限制\" class=\"headerlink\" title=\"44 说说严格模式的限制\"></a>44 说说严格模式的限制</h3><ul>\n<li>  变量必须声明后再使用</li>\n<li>  函数的参数不能有同名属性，否则报错</li>\n<li>  不能使用<code>with</code>语句</li>\n<li>  禁止<code>this</code>指向全局对象</li>\n</ul>\n<h3 id=\"45-attribute和property的区别是什么\"><a href=\"#45-attribute和property的区别是什么\" class=\"headerlink\" title=\"45 attribute和property的区别是什么\"></a>45 attribute和property的区别是什么</h3><ul>\n<li>  <code>attribute</code>是<code>dom</code>元素在文档中作为<code>html</code>标签拥有的属性；</li>\n<li>  <code>property</code>就是<code>dom</code>元素在<code>js</code>中作为对象拥有的属性。</li>\n<li>  对于<code>html</code>的标准属性来说，<code>attribute</code>和<code>property</code>是同步的，是会自动更新的</li>\n<li>  但是对于自定义的属性来说，他们是不同步的</li>\n</ul>\n<h3 id=\"46-谈谈你对ES6的理解\"><a href=\"#46-谈谈你对ES6的理解\" class=\"headerlink\" title=\"46 谈谈你对ES6的理解\"></a>46 谈谈你对ES6的理解</h3><ul>\n<li>  新增模板字符串（为<code>JavaScript</code>提供了简单的字符串插值功能）</li>\n<li>  箭头函数</li>\n<li>  <code>for-of</code>（用来遍历数据—例如数组中的值。）</li>\n<li>  <code>arguments</code>对象可被不定参数和默认参数完美代替。</li>\n<li>  <code>ES6</code>将p<code>romise</code>对象纳入规范，提供了原生的<code>Promise</code>对象。</li>\n<li>  增加了<code>let</code>和<code>const</code>命令，用来声明变量。</li>\n<li>  增加了块级作用域。</li>\n<li>  <code>let</code>命令实际上就增加了块级作用域。</li>\n<li>  还有就是引入<code>module</code>模块的概念</li>\n</ul>\n<h3 id=\"47-ECMAScript6-怎么写class么\"><a href=\"#47-ECMAScript6-怎么写class么\" class=\"headerlink\" title=\"47 ECMAScript6 怎么写class么\"></a>47 ECMAScript6 怎么写class么</h3><ul>\n<li>  这个语法糖可以让有<code>OOP</code>基础的人更快上手<code>js</code>，至少是一个官方的实现了</li>\n<li>  但对熟悉<code>js</code>的人来说，这个东西没啥大影响；一个<code>Object.creat()</code>搞定继承，比<code>class</code>简洁清晰的多</li>\n</ul>\n<h3 id=\"48-什么是面向对象编程及面向过程编程，它们的异同和优缺点\"><a href=\"#48-什么是面向对象编程及面向过程编程，它们的异同和优缺点\" class=\"headerlink\" title=\"48 什么是面向对象编程及面向过程编程，它们的异同和优缺点\"></a>48 什么是面向对象编程及面向过程编程，它们的异同和优缺点</h3><ul>\n<li>  面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了</li>\n<li>  面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为</li>\n<li>  面向对象是以功能来划分问题，而不是步骤</li>\n</ul>\n<h3 id=\"49-面向对象编程思想\"><a href=\"#49-面向对象编程思想\" class=\"headerlink\" title=\"49 面向对象编程思想\"></a>49 面向对象编程思想</h3><ul>\n<li>  基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li>\n<li>优点<ul>\n<li>  采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的</li>\n<li>  易维护</li>\n<li>  易扩展</li>\n<li>  开发工作的重用性、继承性高，降低重复工作量。</li>\n<li>  缩短了开发周期</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"50-对web标准、可用性、可访问性的理解\"><a href=\"#50-对web标准、可用性、可访问性的理解\" class=\"headerlink\" title=\"50 对web标准、可用性、可访问性的理解\"></a>50 对web标准、可用性、可访问性的理解</h3><ul>\n<li>  可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</li>\n<li>  可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性</li>\n<li>  可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。</li>\n</ul>\n<h3 id=\"51-如何通过JS判断一个数组\"><a href=\"#51-如何通过JS判断一个数组\" class=\"headerlink\" title=\"51 如何通过JS判断一个数组\"></a>51 如何通过JS判断一个数组</h3><ul>\n<li><code>instanceof</code>方法<ul>\n<li>  <code>instanceof</code> 运算符是用来测试一个对象是否在其原型链原型构造函数的属性</li>\n</ul>\n</li>\n</ul>\n<p>var arr = [];arr instanceof Array; // true</p>\n<ul>\n<li><code>constructor</code>方法<ul>\n<li>  <code>constructor</code>属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数</li>\n</ul>\n</li>\n</ul>\n<p>var arr = [];arr.constructor == Array; //true</p>\n<ul>\n<li>最简单的方法<ul>\n<li>  这种写法，是 <code>jQuery</code> 正在使用的</li>\n</ul>\n</li>\n</ul>\n<p>Object.prototype.toString.call(value) == ‘[object Array]‘// 利用这个方法，可以写一个返回数据类型的方法var isType = function (obj) {<br>     return Object.prototype.toString.call(obj).slice(8,-1);}</p>\n<ul>\n<li>  <code>ES5</code>新增方法<code>isArray()</code></li>\n</ul>\n<p>var a = new Array(123);var b = new Date();console.log(Array.isArray(a)); //trueconsole.log(Array.isArray(b)); //false</p>\n<h3 id=\"52-谈一谈let与var的区别\"><a href=\"#52-谈一谈let与var的区别\" class=\"headerlink\" title=\"52 谈一谈let与var的区别\"></a>52 谈一谈let与var的区别</h3><ul>\n<li>  <code>let</code>命令不存在变量提升，如果在<code>let</code>前使用，会导致报错</li>\n<li>  如果块区中存在<code>let</code>和<code>const</code>命令，就会形成封闭作用域</li>\n<li>  不允许重复声明，因此，不能在函数内部重新声明参数</li>\n</ul>\n<h3 id=\"53-map与forEach的区别\"><a href=\"#53-map与forEach的区别\" class=\"headerlink\" title=\"53 map与forEach的区别\"></a>53 map与forEach的区别</h3><ul>\n<li>  <code>forEach</code>方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容<code>item</code>、数组索引<code>index</code>、和当前遍历数组<code>Array</code></li>\n<li>  <code>map</code>方法，基本用法与<code>forEach</code>一致，但是不同的，它会返回一个新的数组，所以在callback需要有<code>return</code>值，如果没有，会返回<code>undefined</code></li>\n</ul>\n<h3 id=\"54-谈一谈你理解的函数式编程\"><a href=\"#54-谈一谈你理解的函数式编程\" class=\"headerlink\" title=\"54 谈一谈你理解的函数式编程\"></a>54 谈一谈你理解的函数式编程</h3><ul>\n<li>  简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论</li>\n<li>  它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”</li>\n</ul>\n<h3 id=\"55-谈一谈箭头函数与普通函数的区别？\"><a href=\"#55-谈一谈箭头函数与普通函数的区别？\" class=\"headerlink\" title=\"55 谈一谈箭头函数与普通函数的区别？\"></a>55 谈一谈箭头函数与普通函数的区别？</h3><ul>\n<li>  函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>\n<li>  不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>\n<li>  不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替</li>\n<li>  不可以使用<code>yield</code>命令，因此箭头函数不能用作<code>Generator</code>函数</li>\n</ul>\n<h3 id=\"56-谈一谈函数中this的指向\"><a href=\"#56-谈一谈函数中this的指向\" class=\"headerlink\" title=\"56 谈一谈函数中this的指向\"></a>56 谈一谈函数中this的指向</h3><ul>\n<li>  this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</li>\n<li>  《javascript语言精髓》中大概概括了4种调用方式：</li>\n<li>  方法调用模式</li>\n<li>  函数调用模式</li>\n<li>  构造器调用模式</li>\n</ul>\n<p>graph LRA–&gt;B</p>\n<ul>\n<li>  apply/call调用模式</li>\n</ul>\n<h3 id=\"57-异步编程的实现方式\"><a href=\"#57-异步编程的实现方式\" class=\"headerlink\" title=\"57 异步编程的实现方式\"></a>57 异步编程的实现方式</h3><ul>\n<li>回调函数<ul>\n<li>  优点：简单、容易理解</li>\n<li>  缺点：不利于维护，代码耦合高</li>\n</ul>\n</li>\n<li>事件监听(采用时间驱动模式，取决于某个事件是否发生)：<ul>\n<li>  优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li>\n<li>  缺点：事件驱动型，流程不够清晰</li>\n</ul>\n</li>\n<li>发布/订阅(观察者模式)<ul>\n<li>  类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</li>\n</ul>\n</li>\n<li>Promise对象<ul>\n<li>  优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；</li>\n<li>  缺点：编写和理解，相对比较难</li>\n</ul>\n</li>\n<li>Generator函数<ul>\n<li>  优点：函数体内外的数据交换、错误处理机制</li>\n<li>  缺点：流程管理不方便</li>\n</ul>\n</li>\n<li>async函数<ul>\n<li>  优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。</li>\n<li>  缺点：错误处理机制</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"58-对原生Javascript了解程度\"><a href=\"#58-对原生Javascript了解程度\" class=\"headerlink\" title=\"58 对原生Javascript了解程度\"></a>58 对原生Javascript了解程度</h3><ul>\n<li>  数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、<code>RegExp</code>、<code>JSON</code>、<code>Ajax</code>、<code>DOM</code>、<code>BOM</code>、内存泄漏、跨域、异步装载、模板引擎、前端<code>MVC</code>、路由、模块化、<code>Canvas</code>、<code>ECMAScript</code></li>\n</ul>\n<h3 id=\"59-Js动画与CSS动画区别及相应实现\"><a href=\"#59-Js动画与CSS动画区别及相应实现\" class=\"headerlink\" title=\"59 Js动画与CSS动画区别及相应实现\"></a>59 Js动画与CSS动画区别及相应实现</h3><ul>\n<li><code>CSS3</code>的动画的优点<ul>\n<li>  在性能上会稍微好一些，浏览器会对<code>CSS3</code>的动画做一些优化</li>\n<li>  代码相对简单</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>  在动画控制上不够灵活</li>\n<li>  兼容性不好</li>\n</ul>\n</li>\n<li>  <code>JavaScript</code>的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容<code>IE6</code>，并且功能强大。对于一些复杂控制的动画，使用<code>javascript</code>会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑<code>CSS</code>吧</li>\n</ul>\n<h3 id=\"60-JS-数组和对象的遍历方式，以及几种方式的比较\"><a href=\"#60-JS-数组和对象的遍历方式，以及几种方式的比较\" class=\"headerlink\" title=\"60 JS 数组和对象的遍历方式，以及几种方式的比较\"></a>60 JS 数组和对象的遍历方式，以及几种方式的比较</h3><blockquote>\n<p>通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历</p>\n</blockquote>\n<ul>\n<li>  <code>for in</code>循环</li>\n<li>  <code>for</code>循环</li>\n<li><code>forEach</code><ul>\n<li>  这里的 <code>forEach</code>回调中两个参数分别为 <code>value</code>，<code>index</code></li>\n<li>  <code>forEach</code> 无法遍历对象</li>\n<li>  IE不支持该方法；<code>Firefox</code> 和 <code>chrome</code> 支持</li>\n<li>  <code>forEach</code> 无法使用 <code>break</code>，<code>continue</code> 跳出循环，且使用 <code>return</code> 是跳过本次循环</li>\n</ul>\n</li>\n<li>  这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题</li>\n<li>  在方式一中，<code>for-in</code>需要分析出<code>array</code>的每个属性，这个操作性能开销很大。用在 <code>key</code> 已知的数组上是非常不划算的。所以尽量不要用<code>for-in</code>，除非你不清楚要处理哪些属性，例如 <code>JSON</code>对象这样的情况</li>\n<li>  在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 <code>array</code> 里存放的都是 <code>DOM</code> 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低</li>\n</ul>\n<h3 id=\"61-gulp是什么\"><a href=\"#61-gulp是什么\" class=\"headerlink\" title=\"61 gulp是什么\"></a>61 gulp是什么</h3><ul>\n<li>  <code>gulp</code>是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成</li>\n<li>  Gulp的核心概念：流</li>\n<li>  流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向</li>\n<li>  gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作</li>\n<li>Gulp的特点：<ul>\n<li>  易于使用：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理</li>\n<li>  构建快速 利用 <code>Node.js</code> 流的威力，你可以快速构建项目并减少频繁的 <code>IO</code> 操作</li>\n<li>  易于学习 通过最少的 <code>API</code>，掌握 <code>gulp</code> 毫不费力，构建工作尽在掌握：如同一系列流管道</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"62-说一下Vue的双向绑定数据的原理\"><a href=\"#62-说一下Vue的双向绑定数据的原理\" class=\"headerlink\" title=\"62 说一下Vue的双向绑定数据的原理\"></a>62 说一下Vue的双向绑定数据的原理</h3><ul>\n<li>  <code>vue.js</code> 则是采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调</li>\n</ul>\n<h3 id=\"63-事件的各个阶段\"><a href=\"#63-事件的各个阶段\" class=\"headerlink\" title=\"63 事件的各个阶段\"></a>63 事件的各个阶段</h3><ul>\n<li>  1：捕获阶段 —&gt; 2：目标阶段 —&gt; 3：冒泡阶段</li>\n<li>  <code>document</code> —&gt; <code>target</code>目标 —-&gt; <code>document</code></li>\n<li>由此，<code>addEventListener</code>的第三个参数设置为<code>true</code>和<code>false</code>的区别已经非常清晰了<ul>\n<li>  <code>true</code>表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件</li>\n<li>  <code>false</code>表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"64-let-var-const\"><a href=\"#64-let-var-const\" class=\"headerlink\" title=\"64 let var const\"></a>64 let var const</h3><p>let</p>\n<ul>\n<li>  允许你声明一个作用域被限制在块级中的变量、语句或者表达式</li>\n<li>  let绑定不受变量提升的约束，这意味着let声明不会被提升到当前</li>\n<li>  该变量处于从块开始到初始化处理的“暂存死区”</li>\n</ul>\n<p>var</p>\n<ul>\n<li>  声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的</li>\n<li>  由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明</li>\n</ul>\n<p>const</p>\n<ul>\n<li>  声明创建一个值的只读引用 (即指针)</li>\n<li>  基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 <code>const</code>申明基本数据类型时</li>\n<li>  再将其值改变时，将会造成报错， 例如 <code>const a = 3</code> ; <code>a = 5</code>时 将会报错</li>\n<li>  但是如果是复合类型时，如果只改变复合类型的其中某个<code>Value</code>项时， 将还是正常使用</li>\n</ul>\n<h3 id=\"65-快速的让一个数组乱序\"><a href=\"#65-快速的让一个数组乱序\" class=\"headerlink\" title=\"65 快速的让一个数组乱序\"></a>65 快速的让一个数组乱序</h3><p>var arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(function(){<br>    return Math.random() - 0.5;})console.log(arr);</p>\n<h3 id=\"66-如何渲染几万条数据并不卡住界面\"><a href=\"#66-如何渲染几万条数据并不卡住界面\" class=\"headerlink\" title=\"66 如何渲染几万条数据并不卡住界面\"></a>66 如何渲染几万条数据并不卡住界面</h3><blockquote>\n<p>这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 <code>DOM</code>，那么就可以通过 <code>requestAnimationFrame</code> 来每 <code>16 ms</code> 刷新一次</p>\n</blockquote>\n<!DOCTYPE html><p><html lang=\"en\"><head><br>  <meta charset=\"UTF-8\"><br>  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><br>  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"><br>  <title>Document</title></head><body><br>  <ul>控件</ul><br>  <script><br>    setTimeout(() => {<br>      // 插入十万条数据<br>      const total = 100000<br>      // 一次插入 20 条，如果觉得性能不好就减少<br>      const once = 20<br>      // 渲染数据总共需要几次<br>      const loopCount = total / once      let countOfRender = 0<br>      let ul = document.querySelector(\"ul\");<br>      function add() {<br>        // 优化性能，插入不会造成回流<br>        const fragment = document.createDocumentFragment();<br>        for (let i = 0; i < once; i++) {<br>          const li = document.createElement(\"li\");<br>          li.innerText = Math.floor(Math.random() * total);<br>          fragment.appendChild(li);<br>        }<br>        ul.appendChild(fragment);<br>        countOfRender += 1;<br>        loop();<br>      }<br>      function loop() {<br>        if (countOfRender < loopCount) {<br>          window.requestAnimationFrame(add);<br>        }<br>      }<br>      loop();<br>    }, 0);<br>  </script></body></html></p>\n<h3 id=\"67-希望获取到页面中所有的checkbox怎么做？\"><a href=\"#67-希望获取到页面中所有的checkbox怎么做？\" class=\"headerlink\" title=\"67 希望获取到页面中所有的checkbox怎么做？\"></a>67 希望获取到页面中所有的checkbox怎么做？</h3><blockquote>\n<p>不使用第三方框架</p>\n</blockquote>\n<p> var domList = document.getElementsByTagName(‘input’)<br> var checkBoxList = [];<br> var len = domList.length;　　//缓存到局部变量<br> while (len–) {　　//使用while的效率会比for循环更高<br> 　　if (domList[len].type == ‘checkbox’) {<br>     　　checkBoxList.push(domList[len]);<br> 　　}<br> }</p>\n<h3 id=\"68-怎样添加、移除、移动、复制、创建和查找节点\"><a href=\"#68-怎样添加、移除、移动、复制、创建和查找节点\" class=\"headerlink\" title=\"68 怎样添加、移除、移动、复制、创建和查找节点\"></a>68 怎样添加、移除、移动、复制、创建和查找节点</h3><p>创建新节点</p>\n<p>createDocumentFragment()    //创建一个DOM片段createElement()   //创建一个具体的元素createTextNode()   //创建一个文本节点</p>\n<p>添加、移除、替换、插入</p>\n<p>appendChild()      //添加removeChild()      //移除replaceChild()      //替换insertBefore()      //插入</p>\n<p>查找</p>\n<p>getElementsByTagName()    //通过标签名称getElementsByName()     //通过元素的Name属性的值getElementById()        //通过元素Id，唯一性</p>\n<h3 id=\"69-正则表达式\"><a href=\"#69-正则表达式\" class=\"headerlink\" title=\"69 正则表达式\"></a>69 正则表达式</h3><blockquote>\n<p>正则表达式构造函数<code>var reg=new RegExp(“xxx”)</code>与正则表达字面量<code>var reg=//</code>有什么不同？匹配邮箱的正则表达式？</p>\n</blockquote>\n<ul>\n<li>  当使用<code>RegExp()</code>构造函数的时候，不仅需要转义引号（即<code>\\</code>”表示”），并且还需要双反斜杠（即<code>\\\\</code>表示一个<code>\\</code>）。使用正则表达字面量的效率更高</li>\n</ul>\n<p>邮箱的正则匹配：</p>\n<p>var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/;</p>\n<h3 id=\"70-Javascript中callee和caller的作用？\"><a href=\"#70-Javascript中callee和caller的作用？\" class=\"headerlink\" title=\"70 Javascript中callee和caller的作用？\"></a>70 Javascript中callee和caller的作用？</h3><ul>\n<li>  <code>caller</code>是返回一个对函数的引用，该函数调用了当前函数；</li>\n<li>  <code>callee</code>是返回正在被执行的<code>function</code>函数，也就是所指定的<code>function</code>对象的正文</li>\n</ul>\n<blockquote>\n<p>那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用<code>callee</code>完成）</p>\n</blockquote>\n<p>var result=[];<br>  function fn(n){  //典型的斐波那契数列<br>     if(n==1){<br>          return 1;<br>     }else if(n==2){<br>             return 1;<br>     }else{<br>          if(result[n]){<br>                  return result[n];<br>         }else{<br>                 //argument.callee()表示fn()<br>                 result[n]=arguments.callee(n-1)+arguments.callee(n-2);<br>                 return result[n];<br>         }<br>    }<br> }</p>\n<h3 id=\"71-window-onload和-document-ready\"><a href=\"#71-window-onload和-document-ready\" class=\"headerlink\" title=\"71 window.onload和$(document).ready\"></a>71 window.onload和$(document).ready</h3><blockquote>\n<p>原生<code>JS</code>的<code>window.onload</code>与<code>Jquery</code>的<code>$(document).ready(function()&#123;&#125;)</code>有什么不同？如何用原生JS实现Jq的<code>ready</code>方法？</p>\n</blockquote>\n<ul>\n<li>  <code>window.onload()</code>方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。</li>\n<li>  <code>$(document).ready()</code>是<code>DOM</code>结构绘制完毕后就执行，不必等到加载完毕</li>\n</ul>\n<p>function ready(fn){<br>      if(document.addEventListener) {        //标准浏览器<br>          document.addEventListener(‘DOMContentLoaded’, function() {<br>              //注销事件, 避免反复触发<br>              document.removeEventListener(‘DOMContentLoaded’,arguments.callee, false);<br>              fn();            //执行函数<br>          }, false);<br>      }else if(document.attachEvent) {        //IE<br>          document.attachEvent(‘onreadystatechange’, function() {<br>             if(document.readyState == ‘complete’) {<br>                 document.detachEvent(‘onreadystatechange’, arguments.callee);<br>                 fn();        //函数执行<br>             }<br>         });<br>     }<br> };</p>\n<h3 id=\"72-addEventListener-和attachEvent-的区别\"><a href=\"#72-addEventListener-和attachEvent-的区别\" class=\"headerlink\" title=\"72 addEventListener()和attachEvent()的区别\"></a>72 addEventListener()和attachEvent()的区别</h3><ul>\n<li>  <code>addEventListener()</code>是符合W3C规范的标准方法; <code>attachEvent()</code>是IE低版本的非标准方法</li>\n<li>  <code>addEventListener()</code>支持事件冒泡和事件捕获; - 而<code>attachEvent()</code>只支持事件冒泡</li>\n<li>  <code>addEventListener()</code>的第一个参数中,事件类型不需要添加<code>on</code>; <code>attachEvent()</code>需要添加<code>&#39;on&#39;</code></li>\n<li>  如果为同一个元素绑定多个事件, <code>addEventListener()</code>会按照事件绑定的顺序依次执行,<code>attachEvent()</code>会按照事件绑定的顺序倒序执行</li>\n</ul>\n<h3 id=\"73-获取页面所有的checkbox\"><a href=\"#73-获取页面所有的checkbox\" class=\"headerlink\" title=\"73 获取页面所有的checkbox\"></a>73 获取页面所有的checkbox</h3><p>var resultArr= [];var input = document.querySelectorAll(‘input’);for( var i = 0; i &lt; input.length; i++ ) {<br>    if( input[i].type == ‘checkbox’ ) {<br>        resultArr.push( input[i] );<br>    }}//resultArr即中获取到了页面中的所有checkbox</p>\n<h3 id=\"74-数组去重方法总结\"><a href=\"#74-数组去重方法总结\" class=\"headerlink\" title=\"74 数组去重方法总结\"></a>74 数组去重方法总结</h3><p>方法一、利用ES6 Set去重（ES6中最常用）</p>\n<p>function unique (arr) {<br>  return Array.from(new Set(arr))}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))<br> //[1, “true”, true, 15, false, undefined, null, NaN, “NaN”, 0, “a”, {}, {}]</p>\n<p>方法二、利用for嵌套for，然后splice去重（ES5中最常用）</p>\n<p>function unique(arr){            <br>        for(var i=0; i&lt;arr.length; i++){<br>            for(var j=i+1; j&lt;arr.length; j++){<br>                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个<br>                    arr.splice(j,1);<br>                    j–;<br>                }<br>            }<br>        }<br> return arr;}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))<br>    //[1, “true”, 15, false, undefined, NaN, NaN, “NaN”, “a”, {…}, {…}]     //NaN和{}没有去重，两个null直接消失了</p>\n<ul>\n<li>  双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。</li>\n<li>  想快速学习更多常用的<code>ES6</code>语法</li>\n</ul>\n<p>方法三、利用indexOf去重</p>\n<p>function unique(arr) {<br>    if (!Array.isArray(arr)) {<br>        console.log(‘type error!’)<br>        return<br>    }<br>    var array = [];<br>    for (var i = 0; i &lt; arr.length; i++) {<br>        if (array .indexOf(arr[i]) === -1) {<br>            array .push(arr[i])<br>        }<br>    }<br>    return array;}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))<br>   // [1, “true”, true, 15, false, undefined, null, NaN, NaN, “NaN”, 0, “a”, {…}, {…}]  //NaN、{}没有去重</p>\n<blockquote>\n<p>新建一个空的结果数组，<code>for</code> 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则<code>push</code>进数组</p>\n</blockquote>\n<p>方法四、利用sort()</p>\n<p>function unique(arr) {<br>    if (!Array.isArray(arr)) {<br>        console.log(‘type error!’)<br>        return;<br>    }<br>    arr = arr.sort()<br>    var arrry= [arr[0]];<br>    for (var i = 1; i &lt; arr.length; i++) {<br>        if (arr[i] !== arr[i-1]) {<br>            arrry.push(arr[i]);<br>        }<br>    }<br>    return arrry;}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))// [0, 1, 15, “NaN”, NaN, NaN, {…}, {…}, “a”, false, null, true, “true”, undefined]      //NaN、{}没有去重</p>\n<blockquote>\n<p>利用<code>sort()</code>排序方法，然后根据排序后的结果进行遍历及相邻元素比对</p>\n</blockquote>\n<p>方法五、利用对象的属性不能相同的特点进行去重</p>\n<p>function unique(arr) {<br>    if (!Array.isArray(arr)) {<br>        console.log(‘type error!’)<br>        return<br>    }<br>    var arrry= [];<br>     var  obj = {};<br>    for (var i = 0; i &lt; arr.length; i++) {<br>        if (!obj[arr[i]]) {<br>            arrry.push(arr[i])<br>            obj[arr[i]] = 1<br>        } else {<br>            obj[arr[i]]++<br>        }<br>    }<br>    return arrry;}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))//[1, “true”, 15, false, undefined, null, NaN, 0, “a”, {…}]    //两个true直接去掉了，NaN和{}去重</p>\n<p>方法六、利用includes</p>\n<p>function unique(arr) {<br>    if (!Array.isArray(arr)) {<br>        console.log(‘type error!’)<br>        return<br>    }<br>    var array =[];<br>    for(var i = 0; i &lt; arr.length; i++) {<br>            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值<br>                    array.push(arr[i]);<br>              }<br>    }<br>    return array}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))<br>    //[1, “true”, true, 15, false, undefined, null, NaN, “NaN”, 0, “a”, {…}, {…}]     //{}没有去重</p>\n<p>方法七、利用hasOwnProperty</p>\n<p>function unique(arr) {<br>    var obj = {};<br>    return arr.filter(function(item, index, arr){<br>        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)<br>    })}<br>    var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];<br>        console.log(unique(arr))//[1, “true”, true, 15, false, undefined, null, NaN, “NaN”, 0, “a”, {…}]   //所有的都去重了</p>\n<blockquote>\n<p>利用<code>hasOwnProperty</code> 判断是否存在对象属性</p>\n</blockquote>\n<p>方法八、利用filter</p>\n<p>function unique(arr) {<br>  return arr.filter(function(item, index, arr) {<br>    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素<br>    return arr.indexOf(item, 0) === index;<br>  });}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))//[1, “true”, true, 15, false, undefined, null, “NaN”, 0, “a”, {…}, {…}]</p>\n<p>方法九、利用递归去重</p>\n<p>function unique(arr) {<br>    var array= arr;<br>    var len = array.length;</p>\n<p> array.sort(function(a,b){   //排序后更加方便去重<br> return a - b;<br> })</p>\n<p> function loop(index){<br>        if(index &gt;= 1){<br>            if(array[index] === array[index-1]){<br>            array.splice(index,1);<br>            }<br>            loop(index - 1);    //递归loop，然后数组去重<br>        }<br> }<br> loop(len-1);<br> return array;}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))//[1, “a”, “true”, true, 15, false, 1, {…}, null, NaN, NaN, “NaN”, 0, “a”, {…}, undefined]</p>\n<p>方法十、利用Map数据结构去重</p>\n<p>function arrayNonRepeatfy(arr) {<br> let map = new Map();<br> let array = new Array();  // 数组用于返回结果<br> for (let i = 0; i &lt; arr.length; i++) {<br> if(map .has(arr[i])) {  // 如果有该key值<br> map .set(arr[i], true);<br> } else {<br> map .set(arr[i], false);   // 如果没有该key值<br> array .push(arr[i]);<br> }<br> }<br> return array ;}<br> var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];<br>    console.log(unique(arr))//[1, “a”, “true”, true, 15, false, 1, {…}, null, NaN, NaN, “NaN”, 0, “a”, {…}, undefined]</p>\n<blockquote>\n<p>创建一个空<code>Map</code>数据结构，遍历需要去重的数组，把数组的每一个元素作为<code>key</code>存到<code>Map</code>中。由于<code>Map</code>中不会出现相同的<code>key</code>值，所以最终得到的就是去重后的结果</p>\n</blockquote>\n<p>方法十一、利用reduce+includes</p>\n<p>function unique(arr){<br>    return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : […prev,cur],[]);}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr));// [1, “true”, true, 15, false, undefined, null, NaN, “NaN”, 0, “a”, {…}, {…}]</p>\n<p>方法十二、[…new Set(arr)]</p>\n<p>[…new Set(arr)]//代码就是这么少—-（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</p>\n<h3 id=\"75-（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）\"><a href=\"#75-（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）\" class=\"headerlink\" title=\"75 （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）\"></a>75 （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）</h3><ul>\n<li>  给需要拖拽的节点绑定<code>mousedown</code>, <code>mousemove</code>, <code>mouseup</code>事件</li>\n<li>  <code>mousedown</code>事件触发后，开始拖拽</li>\n<li>  <code>mousemove</code>时，需要通过<code>event.clientX</code>和<code>clientY</code>获取拖拽位置，并实时更新位置</li>\n<li>  <code>mouseup</code>时，拖拽结束</li>\n<li>  需要注意浏览器边界的情况</li>\n</ul>\n<h3 id=\"76-Javascript全局函数和全局变量\"><a href=\"#76-Javascript全局函数和全局变量\" class=\"headerlink\" title=\"76 Javascript全局函数和全局变量\"></a>76 Javascript全局函数和全局变量</h3><p>全局变量</p>\n<ul>\n<li>  <code>Infinity</code> 代表正的无穷大的数值。</li>\n<li>  <code>NaN</code> 指示某个值是不是数字值。</li>\n<li>  <code>undefined</code> 指示未定义的值。</li>\n</ul>\n<p>全局函数</p>\n<ul>\n<li>  <code>decodeURI()</code> 解码某个编码的 <code>URI</code>。</li>\n<li>  <code>decodeURIComponent()</code> 解码一个编码的 <code>URI</code> 组件。</li>\n<li>  <code>encodeURI()</code> 把字符串编码为 URI。</li>\n<li>  <code>encodeURIComponent()</code> 把字符串编码为 <code>URI</code> 组件。</li>\n<li>  <code>escape()</code> 对字符串进行编码。</li>\n<li>  <code>eval()</code> 计算 <code>JavaScript</code> 字符串，并把它作为脚本代码来执行。</li>\n<li>  <code>isFinite()</code> 检查某个值是否为有穷大的数。</li>\n<li>  <code>isNaN()</code> 检查某个值是否是数字。</li>\n<li>  <code>Number()</code> 把对象的值转换为数字。</li>\n<li>  <code>parseFloat()</code> 解析一个字符串并返回一个浮点数。</li>\n<li>  <code>parseInt()</code> 解析一个字符串并返回一个整数。</li>\n<li>  <code>String()</code> 把对象的值转换为字符串。</li>\n<li>  <code>unescape()</code> 对由<code>escape()</code> 编码的字符串进行解码</li>\n</ul>\n<h3 id=\"77-使用js实现一个持续的动画效果\"><a href=\"#77-使用js实现一个持续的动画效果\" class=\"headerlink\" title=\"77 使用js实现一个持续的动画效果\"></a>77 使用js实现一个持续的动画效果</h3><p>定时器思路</p>\n<p>var e = document.getElementById(‘e’)var flag = true;var left = 0;setInterval(() =&gt; {<br>    left == 0 ? flag = true : left == 100 ? flag = false : ‘’<br>    flag ? e.style.left = <code> $&#123;left++&#125;px</code> : e.style.left = <code> $&#123;left--&#125;px</code>}, 1000 / 60)</p>\n<p>requestAnimationFrame</p>\n<p>//兼容性处理window.requestAnimFrame = (function(){<br>    return window.requestAnimationFrame       ||<br>           window.webkitRequestAnimationFrame ||<br>           window.mozRequestAnimationFrame    ||<br>           function(callback){<br>                window.setTimeout(callback, 1000 / 60);<br>           };})();var e = document.getElementById(“e”);var flag = true;var left = 0;function render() {<br>    left == 0 ? flag = true : left == 100 ? flag = false : ‘’;<br>    flag ? e.style.left = <code> $&#123;left++&#125;px</code> :<br>        e.style.left = <code> $&#123;left--&#125;px</code>;}(function animloop() {<br>    render();<br>    requestAnimFrame(animloop);})();</p>\n<p>使用css实现一个持续的动画效果</p>\n<p>animation:mymove 5s infinite;@keyframes mymove {<br>    from {top:0px;}<br>    to {top:200px;}}</p>\n<ul>\n<li>  <code>animation-name</code> 规定需要绑定到选择器的 <code>keyframe</code>名称。</li>\n<li>  <code>animation-duration</code> 规定完成动画所花费的时间，以秒或毫秒计。</li>\n<li>  <code>animation-timing-function</code> 规定动画的速度曲线。</li>\n<li>  <code>animation-delay</code> 规定在动画开始之前的延迟。</li>\n<li>  <code>animation-iteration-count</code> 规定动画应该播放的次数。</li>\n<li>  <code>animation-direction</code> 规定是否应该轮流反向播放动画</li>\n</ul>\n<h3 id=\"78-封装一个函数，参数是定时器的时间，-then执行回调函数\"><a href=\"#78-封装一个函数，参数是定时器的时间，-then执行回调函数\" class=\"headerlink\" title=\"78 封装一个函数，参数是定时器的时间，.then执行回调函数\"></a>78 封装一个函数，参数是定时器的时间，.then执行回调函数</h3><p>function sleep (time) {<br>    return new Promise((resolve) =&gt; setTimeout(resolve, time));}</p>\n<h3 id=\"79-怎么判断两个对象相等？\"><a href=\"#79-怎么判断两个对象相等？\" class=\"headerlink\" title=\"79 怎么判断两个对象相等？\"></a>79 怎么判断两个对象相等？</h3><p>obj={<br>    a:1,<br>    b:2}obj2={<br>    a:1,<br>    b:2}obj3={<br>    a:1,<br>    b:’2’}</p>\n<blockquote>\n<p>可以转换为字符串来判断</p>\n</blockquote>\n<p>JSON.stringify(obj)==JSON.stringify(obj2);//trueJSON.stringify(obj)==JSON.stringify(obj3);//false</p>\n<h3 id=\"80-项目做过哪些性能优化？\"><a href=\"#80-项目做过哪些性能优化？\" class=\"headerlink\" title=\"80 项目做过哪些性能优化？\"></a>80 项目做过哪些性能优化？</h3><ul>\n<li>  减少 <code>HTTP</code> 请求数</li>\n<li>  减少 <code>DNS</code> 查询</li>\n<li>  使用 <code>CDN</code></li>\n<li>  避免重定向</li>\n<li>  图片懒加载</li>\n<li>  减少 <code>DOM</code> 元素数量</li>\n<li>  减少<code>DOM</code> 操作</li>\n<li>  使用外部 <code>JavaScript</code> 和 <code>CSS</code></li>\n<li>  压缩 <code>JavaScript</code> 、 <code>CSS</code> 、字体、图片等</li>\n<li>  优化 <code>CSS Sprite</code></li>\n<li>  使用 <code>iconfont</code></li>\n<li>  字体裁剪</li>\n<li>  多域名分发划分内容到不同域名</li>\n<li>  尽量减少 <code>iframe</code> 使用</li>\n<li>  避免图片 <code>src</code> 为空</li>\n<li>  把样式表放在<code>link</code> 中</li>\n<li>  把<code>JavaScript</code>放在页面底部</li>\n</ul>\n<h3 id=\"81-浏览器缓存\"><a href=\"#81-浏览器缓存\" class=\"headerlink\" title=\"81 浏览器缓存\"></a>81 浏览器缓存</h3><blockquote>\n<p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下</p>\n</blockquote>\n<ul>\n<li>  先根据这个资源的一些 <code>http header</code> 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li>\n<li>  当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些<code>request header</code>验证这个资源是否命中协商缓存，称为<code>http</code>再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li>\n<li>  强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。</li>\n<li>  当协商缓存也没命中时，服务器就会将资源发送回客户端。</li>\n<li>  当 <code>ctrl+f5</code> 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>\n<li>  当 <code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存；</li>\n</ul>\n<p>强缓存</p>\n<ul>\n<li>  <code>Expires</code>（该字段是 <code>http1.0</code> 时的规范，值为一个绝对时间的 <code>GMT</code> 格式的时间字符串，代表缓存资源的过期时间）</li>\n<li>  <code>Cache-Control:max-age</code>（该字段是 <code>http1.1</code>的规范，强缓存利用其 <code>max-age</code> 值来判断缓存资源的最大生命周期，它的值单位为秒）</li>\n</ul>\n<p>协商缓存</p>\n<ul>\n<li>  <code>Last-Modified</code>（值为资源最后更新时间，随服务器response返回）</li>\n<li>  <code>If-Modified-Since</code>（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li>\n<li>  <code>ETag</code>（表示资源内容的唯一标识，随服务器<code>response</code>返回）</li>\n<li>  <code>If-None-Match</code>（服务器通过比较请求头部的<code>If-None-Match</code>与当前资源的<code>ETag</code>是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li>\n</ul>\n<h3 id=\"82-WebSocket\"><a href=\"#82-WebSocket\" class=\"headerlink\" title=\"82 WebSocket\"></a>82 WebSocket</h3><blockquote>\n<p>由于 <code>http</code> 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 <code>WebSocket</code>被发明出来</p>\n</blockquote>\n<blockquote>\n<p>相比与 <code>http</code> 具有以下有点</p>\n</blockquote>\n<ul>\n<li>  支持双向通信，实时性更强；</li>\n<li>  可以发送文本，也可以二进制文件；</li>\n<li>  协议标识符是 <code>ws</code>，加密后是 <code>wss</code> ；</li>\n<li>  较少的控制开销。连接创建后，<code>ws</code>客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有<code>2~10</code>字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而<code>HTTP</code>协议每次通信都需要携带完整的头部；</li>\n<li>  支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）</li>\n<li>  无跨域问题。</li>\n</ul>\n<blockquote>\n<p>实现比较简单，服务端库如 <code>socket.io</code>、<code>ws</code>，可以很好的帮助我们入门。而客户端也只需要参照 <code>api</code> 实现即可</p>\n</blockquote>\n<h3 id=\"83-尽可能多的说出你对-Electron-的理解\"><a href=\"#83-尽可能多的说出你对-Electron-的理解\" class=\"headerlink\" title=\"83 尽可能多的说出你对 Electron 的理解\"></a>83 尽可能多的说出你对 Electron 的理解</h3><blockquote>\n<p>最最重要的一点，<code>electron</code> 实际上是一个套了 <code>Chrome</code> 的 <code>nodeJS</code>程序</p>\n</blockquote>\n<p>所以应该是从两个方面说开来</p>\n<ul>\n<li>  <code>Chrome</code> （无各种兼容性问题）；</li>\n<li>  <code>NodeJS</code>（<code>NodeJS</code> 能做的它也能做）</li>\n</ul>\n<h3 id=\"84-深浅拷贝\"><a href=\"#84-深浅拷贝\" class=\"headerlink\" title=\"84 深浅拷贝\"></a>84 深浅拷贝</h3><p>浅拷贝</p>\n<ul>\n<li>  <code>Object.assign</code></li>\n<li>  或者展开运算符</li>\n</ul>\n<p>深拷贝</p>\n<ul>\n<li>  可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决</li>\n</ul>\n<p>let a = {<br>    age: 1,<br>    jobs: {<br>        first: ‘FE’<br>    }}let b = JSON.parse(JSON.stringify(a))a.jobs.first = ‘native’console.log(b.jobs.first) // FE</p>\n<p>该方法也是有局限性的</p>\n<ul>\n<li>  会忽略 <code>undefined</code></li>\n<li>  不能序列化函数</li>\n<li>  不能解决循环引用的对象</li>\n</ul>\n<h3 id=\"85-防抖-节流\"><a href=\"#85-防抖-节流\" class=\"headerlink\" title=\"85 防抖/节流\"></a>85 防抖/节流</h3><p>防抖</p>\n<blockquote>\n<p>在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现</p>\n</blockquote>\n<p>// 使用 underscore 的源码来解释防抖动/**<br> * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行<br> *<br> * @param  {function} func        回调函数<br> * @param  {number}   wait        表示时间窗口的间隔<br> * @param  {boolean}  immediate   设置为ture时，是否立即调用函数<br> * @return {function}             返回客户调用函数<br> */_.debounce = function(func, wait, immediate) {<br>    var timeout, args, context, timestamp, result;</p>\n<p>    var later = function() {<br>      // 现在和上一次时间戳比较<br>      var last = _.now() - timestamp;<br>      // 如果当前间隔时间少于设定时间且大于0就重新设置定时器<br>      if (last &lt; wait &amp;&amp; last &gt;= 0) {<br>        timeout = setTimeout(later, wait - last);<br>      } else {<br>        // 否则的话就是时间到了执行回调函数<br>        timeout = null;<br>        if (!immediate) {<br>          result = func.apply(context, args);<br>          if (!timeout) context = args = null;<br>        }<br>      }<br>    };</p>\n<p>    return function() {<br>      context = this;<br>      args = arguments;<br>      // 获得时间戳<br>      timestamp = _.now();<br>      // 如果定时器不存在且立即执行函数<br>      var callNow = immediate &amp;&amp; !timeout;<br>      // 如果定时器不存在就创建一个<br>      if (!timeout) timeout = setTimeout(later, wait);<br>      if (callNow) {<br>        // 如果需要立即执行函数的话 通过 apply 执行<br>        result = func.apply(context, args);<br>        context = args = null;<br>      }</p>\n<p>      return result;<br>    };<br>  };</p>\n<blockquote>\n<p>整体函数实现</p>\n</blockquote>\n<p>对于按钮防点击来说的实现</p>\n<ul>\n<li>  开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了</li>\n<li>  对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数</li>\n</ul>\n<p>节流</p>\n<blockquote>\n<p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p>\n</blockquote>\n<p>/**<br> * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait<br> *<br> * @param  {function}   func      回调函数<br> * @param  {number}     wait      表示时间窗口的间隔<br> * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。<br> *                                如果想忽略结尾函数的调用，传入{trailing: false}<br> *                                两者不能共存，否则函数不能执行<br> * @return {function}             返回客户调用函数   <br> */_.throttle = function(func, wait, options) {<br>    var context, args, result;<br>    var timeout = null;<br>    // 之前的时间戳<br>    var previous = 0;<br>    // 如果 options 没传则设为空对象<br>    if (!options) options = {};<br>    // 定时器回调函数<br>    var later = function() {<br>      // 如果设置了 leading，就将 previous 设为 0<br>      // 用于下面函数的第一个 if 判断<br>      previous = options.leading === false ? 0 : _.now();<br>      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断<br>      timeout = null;<br>      result = func.apply(context, args);<br>      if (!timeout) context = args = null;<br>    };<br>    return function() {<br>      // 获得当前时间戳<br>      var now = _.now();<br>      // 首次进入前者肯定为 true<br>   // 如果需要第一次不执行函数<br>   // 就将上次时间戳设为当前的<br>      // 这样在接下来计算 remaining 的值时会大于0<br>      if (!previous &amp;&amp; options.leading === false) previous = now;<br>      // 计算剩余时间<br>      var remaining = wait - (now - previous);<br>      context = this;<br>      args = arguments;<br>      // 如果当前调用已经大于上次调用时间 + wait<br>      // 或者用户手动调了时间<br>    // 如果设置了 trailing，只会进入这个条件<br>   // 如果没有设置 leading，那么第一次会进入这个条件<br>   // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了<br>   // 其实还是会进入的，因为定时器的延时<br>   // 并不是准确的时间，很可能你设置了2秒<br>   // 但是他需要2.2秒才触发，这时候就会进入这个条件<br>      if (remaining &lt;= 0 || remaining &gt; wait) {<br>        // 如果存在定时器就清理掉否则会调用二次回调<br>        if (timeout) {<br>          clearTimeout(timeout);<br>          timeout = null;<br>        }<br>        previous = now;<br>        result = func.apply(context, args);<br>        if (!timeout) context = args = null;<br>      } else if (!timeout &amp;&amp; options.trailing !== false) {<br>        // 判断是否设置了定时器和 trailing<br>     // 没有的话就开启一个定时器<br>        // 并且不能不能同时设置 leading 和 trailing<br>        timeout = setTimeout(later, remaining);<br>      }<br>      return result;<br>    };<br>  };</p>\n<h3 id=\"86-谈谈变量提升？\"><a href=\"#86-谈谈变量提升？\" class=\"headerlink\" title=\"86 谈谈变量提升？\"></a>86 谈谈变量提升？</h3><blockquote>\n<p>当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境</p>\n</blockquote>\n<ul>\n<li>  接下来让我们看一个老生常谈的例子，<code>var</code></li>\n</ul>\n<p>b() // call bconsole.log(a) // undefinedvar a = ‘Hello world’function b() {<br>    console.log(‘call b’)}</p>\n<p>变量提升 这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p>\n<p>b() // call b secondfunction b() {<br>    console.log(‘call b fist’)}function b() {<br>    console.log(‘call b second’)}var b = ‘Hello world’</p>\n<blockquote>\n<p>复制代码<code>var</code> 会产生很多错误，所以在 <code>ES6</code>中引入了 <code>let</code>。<code>let</code> 不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升，<code>let</code> 提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用</p>\n</blockquote>\n<h3 id=\"87-什么是单线程，和异步的关系\"><a href=\"#87-什么是单线程，和异步的关系\" class=\"headerlink\" title=\"87 什么是单线程，和异步的关系\"></a>87 什么是单线程，和异步的关系</h3><ul>\n<li>  单线程 - 只有一个线程，只能做一件事</li>\n<li>原因 - 避免 <code>DOM</code> 渲染的冲突<ul>\n<li>  浏览器需要渲染 <code>DOM</code></li>\n<li>  <code>JS</code> 可以修改 <code>DOM</code> 结构</li>\n<li>  <code>JS</code> 执行的时候，浏览器 <code>DOM</code> 渲染会暂停</li>\n<li>  两段 JS 也不能同时执行（都修改 <code>DOM</code> 就冲突了）</li>\n<li>  <code>webworker</code> 支持多线程，但是不能访问 <code>DOM</code></li>\n</ul>\n</li>\n<li>  解决方案 - 异步</li>\n</ul>\n<h3 id=\"88-是否用过-jQuery-的-Deferred\"><a href=\"#88-是否用过-jQuery-的-Deferred\" class=\"headerlink\" title=\"88 是否用过 jQuery 的 Deferred\"></a>88 是否用过 jQuery 的 Deferred</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/1480597-77a330fbdcc1f1cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-6f79b726f5341f7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-82ac861eced36a45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-69092d725f2b1e79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-9d9b67a6859cf8cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-9970b83118b10829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-243444771c6b30ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"> <img src=\"https://upload-images.jianshu.io/upload_images/1480597-d2db463132d1572a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-c589d6f7caf8b27c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-ab3b7f684e99e6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h3 id=\"89-前端面试之hybrid\"><a href=\"#89-前端面试之hybrid\" class=\"headerlink\" title=\"89 前端面试之hybrid\"></a>89 前端面试之hybrid</h3><blockquote>\n<p><a href=\"http://blog.poetries.top/2018/10/20/fe-interview-hybrid/\">http://blog.poetries.top/2018/10/20/fe-interview-hybrid/</a></p>\n</blockquote>\n<h3 id=\"90-前端面试之组件化\"><a href=\"#90-前端面试之组件化\" class=\"headerlink\" title=\"90 前端面试之组件化\"></a>90 前端面试之组件化</h3><blockquote>\n<p><a href=\"http://blog.poetries.top/2018/10/20/fe-interview-component/\">http://blog.poetries.top/2018/10/20/fe-interview-component/</a></p>\n</blockquote>\n<h3 id=\"91-前端面试之MVVM浅析\"><a href=\"#91-前端面试之MVVM浅析\" class=\"headerlink\" title=\"91 前端面试之MVVM浅析\"></a>91 前端面试之MVVM浅析</h3><blockquote>\n<p><a href=\"http://blog.poetries.top/2018/10/20/fe-interview-mvvm/\">http://blog.poetries.top/2018/10/20/fe-interview-mvvm/</a></p>\n</blockquote>\n<h3 id=\"92-实现效果，点击容器内的图标，图标边框变成border-1px-solid-red，点击空白处重置\"><a href=\"#92-实现效果，点击容器内的图标，图标边框变成border-1px-solid-red，点击空白处重置\" class=\"headerlink\" title=\"92 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置\"></a>92 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置</h3><p>const box = document.getElementById(‘box’);function isIcon(target) {<br>  return target.className.includes(‘icon’);}box.onClick = function(e) {<br>  e.stopPropagation();<br>  const target = e.target;<br>  if (isIcon(target)) {<br>    target.style.border = ‘1px solid red’;<br>  }}const doc = document;doc.onclick = function(e) {<br>  const children = box.children;<br>  for(let i; i &lt; children.length; i++) {<br>    if (isIcon(children[i])) {<br>      children[i].style.border = ‘none’;<br>    }<br>  }}</p>\n<h3 id=\"93-请简单实现双向数据绑定mvvm\"><a href=\"#93-请简单实现双向数据绑定mvvm\" class=\"headerlink\" title=\"93 请简单实现双向数据绑定mvvm\"></a>93 请简单实现双向数据绑定<code>mvvm</code></h3><p><input id=\"input\"/></p>\n<p>const data = {};const input = document.getElementById(‘input’);Object.defineProperty(data, ‘text’, {<br>  set(value) {<br>    input.value = value;<br>    this.value = value;<br>  }});input.onChange = function(e) {<br>  data.text = e.target.value;}</p>\n<h3 id=\"94-实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem-key-value-和getItem-key\"><a href=\"#94-实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem-key-value-和getItem-key\" class=\"headerlink\" title=\"94 实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem(key,value)和getItem(key)\"></a>94 实现Storage，使得该对象为单例，并对<code>localStorage</code>进行封装设置值setItem(key,value)和getItem(key)</h3><p>var instance = null;class Storage {<br>  static getInstance() {<br>    if (!instance) {<br>      instance = new Storage();<br>    }<br>    return instance;<br>  }<br>  setItem = (key, value) =&gt; localStorage.setItem(key, value),<br>  getItem = key =&gt; localStorage.getItem(key)}</p>\n<h3 id=\"95-说说event-loop\"><a href=\"#95-说说event-loop\" class=\"headerlink\" title=\"95 说说event loop\"></a>95 说说<code>event loop</code></h3><blockquote>\n<p>首先，<code>js</code>是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应<code>DOM</code>的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被<code>push</code>进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步<code>HTTP</code>请求线程满足特定条件下的回调函数<code>push</code>到事件队列中，等待<code>js</code>引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务<code>microtask（promise）</code>，如果有那就优先执行微任务，如果没有，在去查找宏任务<code>macrotask（setTimeout、setInterval）</code>进行执行</p>\n</blockquote>\n<h3 id=\"96-说说事件流\"><a href=\"#96-说说事件流\" class=\"headerlink\" title=\"96 说说事件流\"></a>96 说说事件流</h3><p>事件流分为两种，捕获事件流和冒泡事件流</p>\n<ul>\n<li>  捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点</li>\n<li>  冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点</li>\n</ul>\n<blockquote>\n<p>事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段</p>\n</blockquote>\n<h3 id=\"97-为什么canvas的图片为什么过有跨域问题\"><a href=\"#97-为什么canvas的图片为什么过有跨域问题\" class=\"headerlink\" title=\"97 为什么canvas的图片为什么过有跨域问题\"></a>97 为什么<code>canvas</code>的图片为什么过有跨域问题</h3><h3 id=\"98-我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块\"><a href=\"#98-我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块\" class=\"headerlink\" title=\"98 我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块\"></a>98 我现在有一个<code>canvas</code>，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块</h3><blockquote>\n<p><a href=\"https://www.jianshu.com/p/f54d265f7aa4\">https://www.jianshu.com/p/f54d265f7aa4</a></p>\n</blockquote>\n<h3 id=\"99-请手写实现一个promise\"><a href=\"#99-请手写实现一个promise\" class=\"headerlink\" title=\"99 请手写实现一个promise\"></a>99 请手写实现一个<code>promise</code></h3><blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000013396601\">https://segmentfault.com/a/1190000013396601</a></p>\n</blockquote>\n<h3 id=\"100-说说从输入URL到看到页面发生的全过程，越详细越好\"><a href=\"#100-说说从输入URL到看到页面发生的全过程，越详细越好\" class=\"headerlink\" title=\"100 说说从输入URL到看到页面发生的全过程，越详细越好\"></a>100 说说从输入URL到看到页面发生的全过程，越详细越好</h3><ul>\n<li>  首先浏览器主进程接管，开了一个下载线程。</li>\n<li>  然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。</li>\n<li>  将下载完的内容转交给Renderer进程管理。</li>\n<li>  Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。</li>\n<li>  解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。</li>\n<li>  css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。</li>\n<li>  绘制结束后，关闭TCP连接，过程有四次挥手</li>\n</ul>\n<h3 id=\"101-描述一下this\"><a href=\"#101-描述一下this\" class=\"headerlink\" title=\"101 描述一下this\"></a>101 描述一下<code>this</code></h3><blockquote>\n<p><code>this</code>，函数执行的上下文，可以通过<code>apply</code>，<code>call</code>，<code>bind</code>改变<code>this</code>的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，NodeJS为<code>global</code>），剩下的函数调用，那就是谁调用它，<code>this</code>就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，<code>this</code>就指向哪里</p>\n</blockquote>\n<h3 id=\"102-说一下浏览器的缓存机制\"><a href=\"#102-说一下浏览器的缓存机制\" class=\"headerlink\" title=\"102 说一下浏览器的缓存机制\"></a>102 说一下浏览器的缓存机制</h3><blockquote>\n<p>浏览器缓存机制有两种，一种为强缓存，一种为协商缓存</p>\n</blockquote>\n<ul>\n<li>  对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。</li>\n<li>  对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存</li>\n</ul>\n<p>协商缓存相关设置</p>\n<ul>\n<li>  <code>Exprires</code>：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。<code>Exprires</code>的缺陷是必须保证服务端时间和客户端时间严格同步。</li>\n<li>  <code>Cache-control：max-age</code>：表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题，</li>\n<li>  <code>If-None-Match/ETag</code>：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回<code>If-None-Match</code>标识是否表示匹配。</li>\n<li>  <code>Last-modified/If-Modified-Since</code>：第一次请求的时候服务端返回<code>Last-modified</code>表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头<code>If-Modified-Since</code>，表示资源上次的修改时间，服务端拿到这两个字段进行对比</li>\n</ul>\n<h3 id=\"103-现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？\"><a href=\"#103-现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？\" class=\"headerlink\" title=\"103 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？\"></a>103 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？</h3><ul>\n<li>  该组件需要提供<code>hook</code>指定渲染位置，默认渲染在body下面。</li>\n<li>  然后改组件可以指定外层样式，如宽度等</li>\n<li>  组件外层还需要一层<code>mask</code>来遮住底层内容，点击<code>mask</code>可以执行传进来的<code>onCancel</code>函数关闭<code>Dialog</code>。</li>\n<li>  另外组件是可控的，需要外层传入<code>visible</code>表示是否可见。</li>\n<li>  然后<code>Dialog</code>可能需要自定义头head和底部<code>footer</code>，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的<code>onOk</code>事件，然后取消按钮会执行外部传进来的<code>onCancel</code>事件。</li>\n<li>  当组件的<code>visible</code>为<code>true</code>时候，设置<code>body</code>的<code>overflow</code>为<code>hidden</code>，隐藏<code>body</code>的滚动条，反之显示滚动条。</li>\n<li>  组件高度可能大于页面高度，组件内部需要滚动条。</li>\n<li>  只有组件的<code>visible</code>有变化且为<code>ture</code>时候，才重渲染组件内的所有内容</li>\n</ul>\n<h3 id=\"104-caller和callee的区别\"><a href=\"#104-caller和callee的区别\" class=\"headerlink\" title=\"104 caller和callee的区别\"></a>104 <code>caller</code>和<code>callee</code>的区别</h3><p>callee</p>\n<blockquote>\n<p><code>caller</code>返回一个函数的引用，这个函数调用了当前的函数。</p>\n</blockquote>\n<p>使用这个属性要注意</p>\n<ul>\n<li>  这个属性只有当函数在执行时才有用</li>\n<li>  如果在<code>javascript</code>程序中，函数是由顶层调用的，则返回<code>null</code></li>\n</ul>\n<blockquote>\n<p><code>functionName.caller: functionName</code>是当前正在执行的函数。</p>\n</blockquote>\n<p>function a() {<br>  console.log(a.caller)}</p>\n<p>callee</p>\n<blockquote>\n<p><code>callee</code>放回正在执行的函数本身的引用，它是<code>arguments</code>的一个属性</p>\n</blockquote>\n<blockquote>\n<p>使用callee时要注意:</p>\n</blockquote>\n<ul>\n<li>  这个属性只有在函数执行时才有效</li>\n<li>  它有一个<code>length</code>属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较<code>arguments.length</code>是否等于<code>arguments.callee.length</code></li>\n<li>  它可以用来递归匿名函数。</li>\n</ul>\n<p>function a() {<br>  console.log(arguments.callee)}</p>\n<h3 id=\"105-ajax、axios、fetch区别\"><a href=\"#105-ajax、axios、fetch区别\" class=\"headerlink\" title=\"105 ajax、axios、fetch区别\"></a>105 ajax、axios、fetch区别</h3><p>jQuery ajax</p>\n<p>$.ajax({<br>   type: ‘POST’,<br>   url: url,<br>   data: data,<br>   dataType: dataType,<br>   success: function () {},<br>   error: function () {}});</p>\n<p>优缺点：</p>\n<ul>\n<li>  本身是针对<code>MVC</code>的编程,不符合现在前端<code>MVVM</code>的浪潮</li>\n<li>  基于原生的<code>XHR</code>开发，<code>XHR</code>本身的架构不清晰，已经有了<code>fetch</code>的替代方案</li>\n<li>  <code>JQuery</code>整个项目太大，单纯使用<code>ajax</code>却要引入整个<code>JQuery</code>非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n</ul>\n<p>axios</p>\n<p>axios({<br>    method: ‘post’,<br>    url: ‘/user/12345’,<br>    data: {<br>        firstName: ‘Fred’,<br>        lastName: ‘Flintstone’<br>    }}).then(function (response) {<br>    console.log(response);}).catch(function (error) {<br>    console.log(error);});</p>\n<p>优缺点：</p>\n<ul>\n<li>  从浏览器中创建 <code>XMLHttpRequest</code></li>\n<li>  从 <code>node.js</code> 发出 <code>http</code> 请求</li>\n<li>  支持 <code>Promise API</code></li>\n<li>  拦截请求和响应</li>\n<li>  转换请求和响应数据</li>\n<li>  取消请求</li>\n<li>  自动转换<code>JSON</code>数据</li>\n<li>  客户端支持防止<code>CSRF/XSRF</code></li>\n</ul>\n<p>fetch</p>\n<p>try {<br>  let response = await fetch(url);<br>  let data = response.json();<br>  console.log(data);} catch(e) {<br>  console.log(“Oops, error”, e);}</p>\n<p>优缺点：</p>\n<ul>\n<li>  <code>fetcht</code>只对网络请求报错，对<code>400</code>，<code>500</code>都当做成功的请求，需要封装去处理</li>\n<li>  <code>fetch</code>默认不会带<code>cookie</code>，需要添加配置项</li>\n<li>  <code>fetch</code>不支持<code>abort</code>，不支持超时控制，使用<code>setTimeout</code>及<code>Promise.reject</code>的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li>\n<li>  <code>fetch</code>没有办法原生监测请求的进度，而XHR可以</li>\n</ul>\n","site":{"data":{}},"cover":"https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/img/default.jpg","excerpt":"","more":"<h2 id=\"三、JavaScript\"><a href=\"#三、JavaScript\" class=\"headerlink\" title=\"三、JavaScript\"></a>三、JavaScript</h2><h3 id=\"1-闭包\"><a href=\"#1-闭包\" class=\"headerlink\" title=\"1 闭包\"></a>1 闭包</h3><ul>\n<li>  闭包就是能够读取其他函数内部变量的函数</li>\n<li>  闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</li>\n<li>闭包的特性：<ul>\n<li>  函数内再嵌套函数</li>\n<li>  内部函数可以引用外层的参数和变量</li>\n<li>  参数和变量不会被垃圾回收机制回收</li>\n</ul>\n</li>\n</ul>\n<p>说说你对闭包的理解</p>\n<ul>\n<li>  使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</li>\n<li>  闭包 的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中</li>\n<li>  闭包的另一个用处，是封装对象的私有属性和私有方法</li>\n<li>  好处：能够实现封装和缓存等；</li>\n<li>  坏处：就是消耗内存、不正当使用会造成内存溢出的问题</li>\n</ul>\n<p>使用闭包的注意点</p>\n<ul>\n<li>  由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露</li>\n<li>  解决方法是，在退出函数之前，将不使用的局部变量全部删除</li>\n</ul>\n<h3 id=\"2-说说你对作用域链的理解\"><a href=\"#2-说说你对作用域链的理解\" class=\"headerlink\" title=\"2 说说你对作用域链的理解\"></a>2 说说你对作用域链的理解</h3><ul>\n<li>  作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到<code>window</code>对象即被终止，作用域链向下访问变量是不被允许的</li>\n<li>  简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期</li>\n</ul>\n<h3 id=\"3-JavaScript原型，原型链-有什么特点？\"><a href=\"#3-JavaScript原型，原型链-有什么特点？\" class=\"headerlink\" title=\"3 JavaScript原型，原型链 ? 有什么特点？\"></a>3 JavaScript原型，原型链 ? 有什么特点？</h3><ul>\n<li>  每个对象都会在其内部初始化一个属性，就是<code>prototype</code>(原型)，当我们访问一个对象的属性时</li>\n<li>  如果这个对象内部不存在这个属性，那么他就会去<code>prototype</code>里找这个属性，这个<code>prototype</code>又会有自己的<code>prototype</code>，于是就这样一直找下去，也就是我们平时所说的原型链的概念</li>\n<li>  关系：<code>instance.constructor.prototype = instance.__proto__</code></li>\n<li>特点：<ul>\n<li>  <code>JavaScript</code>对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变</li>\n</ul>\n</li>\n<li>  当我们需要一个属性的时，<code>Javascript</code>引擎会先看当前对象中是否有这个属性， 如果没有的</li>\n<li>  就会查找他的<code>Prototype</code>对象是否有这个属性，如此递推下去，一直检索到 <code>Object</code> 内建对象</li>\n</ul>\n<h3 id=\"4-请解释什么是事件代理\"><a href=\"#4-请解释什么是事件代理\" class=\"headerlink\" title=\"4 请解释什么是事件代理\"></a>4 请解释什么是事件代理</h3><ul>\n<li>  事件代理（<code>Event Delegation</code>），又称之为事件委托。是 <code>JavaScript</code> 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li>\n<li>  可以大量节省内存占用，减少事件注册，比如在<code>table</code>上代理所有<code>td</code>的<code>click</code>事件就非常棒</li>\n<li>  可以实现当新增子对象时无需再次对其绑定</li>\n</ul>\n<h3 id=\"5-Javascript如何实现继承？\"><a href=\"#5-Javascript如何实现继承？\" class=\"headerlink\" title=\"5 Javascript如何实现继承？\"></a>5 Javascript如何实现继承？</h3><ul>\n<li>  构造继承</li>\n<li>  原型继承</li>\n<li>  实例继承</li>\n<li>  拷贝继承</li>\n<li>  原型<code>prototype</code>机制或<code>apply</code>和<code>call</code>方法去实现较简单，建议使用构造函数与原型混合方式</li>\n</ul>\n<p>function Parent(){<br> this.name = ‘wang’;}function Child(){<br>        this.age = 28;}<br>    Child.prototype = new Parent();//继承了Parent，通过原型var demo = new Child();alert(demo.age);alert(demo.name);//得到被继承的属性</p>\n<h3 id=\"6-谈谈This对象的理解\"><a href=\"#6-谈谈This对象的理解\" class=\"headerlink\" title=\"6 谈谈This对象的理解\"></a>6 谈谈This对象的理解</h3><ul>\n<li>  <code>this</code>总是指向函数的直接调用者（而非间接调用者）</li>\n<li>  如果有<code>new</code>关键字，<code>this</code>指向<code>new</code>出来的那个对象</li>\n<li>  在事件中，<code>this</code>指向触发这个事件的对象，特殊的是，<code>IE</code>中的<code>attachEvent</code>中的<code>this</code>总是指向全局对象<code>Window</code></li>\n</ul>\n<h3 id=\"7-事件模型\"><a href=\"#7-事件模型\" class=\"headerlink\" title=\"7 事件模型\"></a>7 事件模型</h3><blockquote>\n<p><code>W3C</code>中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p>\n</blockquote>\n<ul>\n<li>  冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li>\n<li>  捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li>\n<li>  <code>DOM</code>事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li>\n<li>  阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation()</code>方法；在IE下设置<code>cancelBubble = true</code></li>\n<li>  阻止捕获：阻止事件的默认行为，例如<code>click - &lt;a&gt;</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault()</code>方法，在<code>IE</code>下设置<code>window.event.returnValue = false</code></li>\n</ul>\n<h3 id=\"8-new操作符具体干了什么呢\"><a href=\"#8-new操作符具体干了什么呢\" class=\"headerlink\" title=\"8 new操作符具体干了什么呢?\"></a>8 new操作符具体干了什么呢?</h3><ul>\n<li>  创建一个空对象，并且 <code>this</code> 变量引用该对象，同时还继承了该函数的原型</li>\n<li>  属性和方法被加入到 <code>this</code> 引用的对象中</li>\n<li>  新创建的对象由 <code>this</code> 所引用，并且最后隐式的返回 <code>this</code></li>\n</ul>\n<h3 id=\"9-Ajax原理\"><a href=\"#9-Ajax原理\" class=\"headerlink\" title=\"9 Ajax原理\"></a>9 Ajax原理</h3><ul>\n<li>  <code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层(<code>AJAX</code>引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascrip</code>t来操作<code>DOM</code>而更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据</li>\n<li>  <code>Ajax</code>的过程只涉及<code>JavaScript</code>、<code>XMLHttpRequest</code>和<code>DOM</code>。<code>XMLHttpRequest</code>是<code>aja</code>x的核心机制</li>\n</ul>\n<p>/** 1. 创建连接 <strong>/var xhr = null;xhr = new XMLHttpRequest()/</strong> 2. 连接服务器 <strong>/xhr.open(‘get’, url, true)/</strong> 3. 发送请求 <strong>/xhr.send(null);/</strong> 4. 接受请求 <strong>/xhr.onreadystatechange = function(){<br> if(xhr.readyState == 4){<br> if(xhr.status == 200){<br> success(xhr.responseText);<br> } else { <br> /</strong> false **/<br> fail &amp;&amp; fail(xhr.status);<br> }<br> }}</p>\n<p>ajax 有那些优缺点?</p>\n<ul>\n<li>优点：<ul>\n<li>  通过异步模式，提升了用户体验.</li>\n<li>  优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.</li>\n<li>  <code>Ajax</code>在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li>\n<li>  <code>Ajax</code>可以实现动态不刷新（局部刷新）</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>  安全问题 <code>AJAX</code>暴露了与服务器交互的细节。</li>\n<li>  对搜索引擎的支持比较弱。</li>\n<li>  不容易调试。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"10-如何解决跨域问题\"><a href=\"#10-如何解决跨域问题\" class=\"headerlink\" title=\"10 如何解决跨域问题?\"></a>10 如何解决跨域问题?</h3><blockquote>\n<p>首先了解下浏览器的同源策略 同源策略<code>/SOP（Same origin policy）</code>是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到<code>XSS</code>、<code>CSFR</code>等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源</p>\n</blockquote>\n<p>那么怎样解决跨域问题的呢？</p>\n<ul>\n<li>  通过jsonp跨域</li>\n</ul>\n<p>var script = document.createElement(‘script’);script.type = ‘text/javascript’;// 传参并指定回调执行函数为onBackscript.src = ‘<a href=\"http://www.....:8080/login?user=admin&amp;callback=onBack&#39;;document.head.appendChild(script);//\">http://www.....:8080/login?user=admin&amp;callback=onBack&#39;;document.head.appendChild(script);//</a> 回调执行函数function onBack(res) {<br>    alert(JSON.stringify(res));}</p>\n<ul>\n<li>  document.domain + iframe跨域</li>\n</ul>\n<blockquote>\n<p>此方案仅限主域相同，子域不同的跨域应用场景</p>\n</blockquote>\n<p>1.）父窗口：(<a href=\"http://www.domain.com/a.html\">http://www.domain.com/a.html</a>)</p>\n<p><iframe id=\"iframe\" src=\"http://child.domain.com/b.html\"></iframe><script><br>    document.domain = 'domain.com';<br>    var user = 'admin';</script></p>\n<p>2.）子窗口：(<a href=\"http://child.domain.com/b.html\">http://child.domain.com/b.html</a>)</p>\n<p>document.domain = ‘domain.com’;// 获取父窗口中变量alert(‘get js data from parent —&gt; ‘ + window.parent.user);</p>\n<ul>\n<li>  nginx代理跨域</li>\n<li>  nodejs中间件代理跨域</li>\n<li>  后端在头部信息里面设置安全域名</li>\n</ul>\n<h3 id=\"11-模块化开发怎么做？\"><a href=\"#11-模块化开发怎么做？\" class=\"headerlink\" title=\"11 模块化开发怎么做？\"></a>11 模块化开发怎么做？</h3><ul>\n<li>  立即执行函数,不暴露私有成员</li>\n</ul>\n<p>var module1 = (function(){　　　　var _count = 0;　　　　var m1 = function(){　　　　　　//…　　　　};　　　　var m2 = function(){　　　　　　//…　　　　};　　　　return {　　　　　　m1 : m1,　　　　　　m2 : m2<br>　　　　};})();</p>\n<h3 id=\"12-异步加载JS的方式有哪些？\"><a href=\"#12-异步加载JS的方式有哪些？\" class=\"headerlink\" title=\"12 异步加载JS的方式有哪些？\"></a>12 异步加载JS的方式有哪些？</h3><ul>\n<li>  defer，只支持<code>IE</code></li>\n<li>  <code>async</code>：</li>\n<li>  创建<code>script</code>，插入到<code>DOM</code>中，加载完毕后<code>callBack</code></li>\n</ul>\n<h3 id=\"13-那些操作会造成内存泄漏？\"><a href=\"#13-那些操作会造成内存泄漏？\" class=\"headerlink\" title=\"13 那些操作会造成内存泄漏？\"></a>13 那些操作会造成内存泄漏？</h3><ul>\n<li>  内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>\n<li>  <code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>\n<li>  闭包使用不当</li>\n</ul>\n<h3 id=\"14-XML和JSON的区别？\"><a href=\"#14-XML和JSON的区别？\" class=\"headerlink\" title=\"14 XML和JSON的区别？\"></a>14 XML和JSON的区别？</h3><ul>\n<li>数据体积方面<ul>\n<li>  <code>JSON</code>相对<code>于XML</code>来讲，数据的体积小，传递的速度更快些。</li>\n</ul>\n</li>\n<li>数据交互方面<ul>\n<li>  <code>JSON</code>与<code>JavaScript</code>的交互更加方便，更容易解析处理，更好的数据交互</li>\n</ul>\n</li>\n<li>数据描述方面<ul>\n<li>  <code>JSON</code>对数据的描述性比<code>XML</code>较差</li>\n</ul>\n</li>\n<li>传输速度方面<ul>\n<li>  <code>JSON</code>的速度要远远快于<code>XML</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"15-谈谈你对webpack的看法\"><a href=\"#15-谈谈你对webpack的看法\" class=\"headerlink\" title=\"15 谈谈你对webpack的看法\"></a>15 谈谈你对webpack的看法</h3><ul>\n<li>  <code>WebPack</code> 是一个模块打包工具，你可以使用<code>WebPack</code>管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包<code>Web</code>开发中所用到的<code>HTML</code>、<code>Javascript</code>、<code>CSS</code>以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，<code>webpack</code>有对应的模块加载器。<code>webpack</code>模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源</li>\n</ul>\n<h3 id=\"16-说说你对AMD和Commonjs的理解\"><a href=\"#16-说说你对AMD和Commonjs的理解\" class=\"headerlink\" title=\"16 说说你对AMD和Commonjs的理解\"></a>16 说说你对AMD和Commonjs的理解</h3><ul>\n<li>  <code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li>\n<li>  <code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li>\n</ul>\n<h3 id=\"17-常见web安全及防护原理\"><a href=\"#17-常见web安全及防护原理\" class=\"headerlink\" title=\"17 常见web安全及防护原理\"></a>17 常见web安全及防护原理</h3><ul>\n<li><code>sql</code>注入原理<ul>\n<li>  就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</li>\n</ul>\n</li>\n<li>总的来说有以下几点<ul>\n<li>  永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<code>&quot;-&quot;</code>进行转换等</li>\n<li>  永远不要使用动态拼装SQL，可以使用参数化的<code>SQL</code>或者直接使用存储过程进行数据查询存取</li>\n<li>  永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li>\n<li>  不要把机密信息明文存放，请加密或者<code>hash</code>掉密码和敏感的信息</li>\n</ul>\n</li>\n</ul>\n<p>XSS原理及防范</p>\n<ul>\n<li>  <code>Xss(cross-site scripting)</code>攻击指的是攻击者往<code>Web</code>页面里插入恶意<code>html</code>标签或者<code>javascript</code>代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取<code>cookie</code>中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点</li>\n</ul>\n<p>XSS防范方法</p>\n<ul>\n<li>  首先代码里对用户输入的地方和变量都需要仔细检查长度和对<code>”&lt;”,”&gt;”,”;”,”’”</code>等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把<code>html tag</code> 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击</li>\n</ul>\n<p>XSS与CSRF有什么区别吗？</p>\n<ul>\n<li>  <code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。<code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤</li>\n<li>  登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code></li>\n<li>  在不登出<code>A</code>的情况下，访问危险网站<code>B</code></li>\n</ul>\n<p>CSRF的防御</p>\n<ul>\n<li>  服务端的<code>CSRF</code>方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数</li>\n<li>  通过验证码的方法</li>\n</ul>\n<h3 id=\"18-用过哪些设计模式？\"><a href=\"#18-用过哪些设计模式？\" class=\"headerlink\" title=\"18 用过哪些设计模式？\"></a>18 用过哪些设计模式？</h3><ul>\n<li>工厂模式：<ul>\n<li>  工厂模式解决了重复实例化的问题，但还有一个问题,那就是识别问题，因为根本无法</li>\n<li>  主要好处就是可以消除对象间的耦合，通过使用工程方法而不是<code>new</code>关键字</li>\n</ul>\n</li>\n<li>构造函数模式<ul>\n<li>  使用构造函数的方法，即解决了重复实例化的问题，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</li>\n<li>  直接将属性和方法赋值给 <code>this</code>对象;</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"19-为什么要有同源限制？\"><a href=\"#19-为什么要有同源限制？\" class=\"headerlink\" title=\"19 为什么要有同源限制？\"></a>19 为什么要有同源限制？</h3><ul>\n<li>  同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li>\n<li>  举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</li>\n</ul>\n<h3 id=\"20-offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别\"><a href=\"#20-offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别\" class=\"headerlink\" title=\"20 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别\"></a>20 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h3><ul>\n<li>  <code>offsetWidth/offsetHeight</code>返回值包含content + padding + border，效果与e.getBoundingClientRect()相同</li>\n<li>  <code>clientWidth/clientHeight</code>返回值只包含content + padding，如果有滚动条，也不包含滚动条</li>\n<li>  <code>scrollWidth/scrollHeight</code>返回值包含content + padding + 溢出内容的尺寸</li>\n</ul>\n<h3 id=\"21-javascript有哪些方法定义对象\"><a href=\"#21-javascript有哪些方法定义对象\" class=\"headerlink\" title=\"21 javascript有哪些方法定义对象\"></a>21 javascript有哪些方法定义对象</h3><ul>\n<li>  对象字面量： <code>var obj = &#123;&#125;;</code></li>\n<li>  构造函数： <code>var obj = new Object();</code></li>\n<li>  Object.create(): <code>var obj = Object.create(Object.prototype);</code></li>\n</ul>\n<h3 id=\"22-常见兼容性问题？\"><a href=\"#22-常见兼容性问题？\" class=\"headerlink\" title=\"22 常见兼容性问题？\"></a>22 常见兼容性问题？</h3><ul>\n<li>  <code>png24</code>位的图片在iE6浏览器上出现背景，解决方案是做成<code>PNG8</code></li>\n<li>  浏览器默认的<code>margin</code>和<code>padding</code>不同。解决方案是加一个全局的<code>*&#123;margin:0;padding:0;&#125;</code>来统一,，但是全局效率很低，一般是如下这样解决：</li>\n</ul>\n<p>body,ul,li,ol,dl,dt,dd,form,input,h1,h2,h3,h4,h5,h6,p{margin:0;padding:0;}</p>\n<ul>\n<li>  <code>IE</code>下,<code>event</code>对象有<code>x</code>,<code>y</code>属性,但是没有<code>pageX</code>,<code>pageY</code>属性</li>\n<li>  <code>Firefox</code>下,<code>event</code>对象有<code>pageX</code>,<code>pageY</code>属性,但是没有<code>x,y</code>属性.</li>\n</ul>\n<h3 id=\"23-说说你对promise的了解\"><a href=\"#23-说说你对promise的了解\" class=\"headerlink\" title=\"23 说说你对promise的了解\"></a>23 说说你对promise的了解</h3><ul>\n<li>依照 <code>Promise/A+</code> 的定义，<code>Promise</code> 有四种状态：<ul>\n<li>  <code>pending:</code> 初始状态, 非 <code>fulfilled</code> 或 <code>rejected.</code></li>\n<li>  <code>fulfilled:</code> 成功的操作.</li>\n<li>  <code>rejected:</code> 失败的操作.</li>\n<li>  <code>settled: Promise</code>已被<code>fulfilled</code>或<code>rejected</code>，且不是<code>pending</code></li>\n</ul>\n</li>\n<li>  另外， <code>fulfilled</code>与 <code>rejected</code>一起合称 <code>settled</code></li>\n<li>  <code>Promise</code> 对象用来进行延迟(<code>deferred</code>) 和异步(<code>asynchronous</code>) 计算</li>\n</ul>\n<p>Promise 的构造函数</p>\n<ul>\n<li>  构造一个 <code>Promise</code>，最基本的用法如下：</li>\n</ul>\n<p>var promise = new Promise(function(resolve, reject) {</p>\n<p>        if (…) {  // succeed</p>\n<p>            resolve(result);</p>\n<p>        } else {   // fails</p>\n<p>            reject(Error(errMessage));</p>\n<p>        }<br>    });</p>\n<ul>\n<li>  <code>Promise</code> 实例拥有 <code>then</code> 方法（具有 <code>then</code> 方法的对象，通常被称为<code>thenable</code>）。它的使用方法如下：</li>\n</ul>\n<p>promise.then(onFulfilled, onRejected)</p>\n<ul>\n<li>  接收两个函数作为参数，一个在 <code>fulfilled</code> 的时候被调用，一个在<code>rejected</code>的时候被调用，接收参数就是 <code>future</code>，<code>onFulfilled</code> 对应<code>resolve</code>, <code>onRejected</code>对应 <code>reject</code></li>\n</ul>\n<h3 id=\"24-你觉得jQuery源码有哪些写的好的地方\"><a href=\"#24-你觉得jQuery源码有哪些写的好的地方\" class=\"headerlink\" title=\"24 你觉得jQuery源码有哪些写的好的地方\"></a>24 你觉得jQuery源码有哪些写的好的地方</h3><ul>\n<li>  <code>jquery</code>源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入<code>window</code>对象参数，可以使<code>window</code>对象作为局部变量使用，好处是当<code>jquery</code>中访问<code>window</code>对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入<code>undefined</code>参数，可以缩短查找<code>undefined</code>时的作用域链</li>\n<li>  <code>jquery</code>将一些原型属性和方法封装在了<code>jquery.prototype</code>中，为了缩短名称，又赋值给了<code>jquery.fn</code>，这是很形象的写法</li>\n<li>  有一些数组或对象的方法经常能使用到，<code>jQuery</code>将其保存为局部变量以提高访问速度</li>\n<li>  <code>jquery</code>实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率</li>\n</ul>\n<h3 id=\"25-vue、react、angular\"><a href=\"#25-vue、react、angular\" class=\"headerlink\" title=\"25 vue、react、angular\"></a>25 vue、react、angular</h3><ul>\n<li>  <code>Vue.js</code> 一个用于创建 <code>web</code> 交互界面的库，是一个精简的 <code>MVVM</code>。它通过双向数据绑定把 <code>View</code>层和 <code>Model</code> 层连接了起来。实际的 <code>DOM</code> 封装和输出格式都被抽象为了<code>Directives</code> 和 <code>Filters</code></li>\n<li>  <code>AngularJS</code> 是一个比较完善的前端<code>MVVM</code>框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，自带了丰富的 <code>Angular</code>指令</li>\n<li>  <code>react</code> <code>React</code> 仅仅是 <code>VIEW</code> 层是<code>facebook</code>公司。推出的一个用于构建<code>UI</code>的一个库，能够实现服务器端的渲染。用了<code>virtual dom</code>，所以性能很好。</li>\n</ul>\n<h3 id=\"26-Node的应用场景\"><a href=\"#26-Node的应用场景\" class=\"headerlink\" title=\"26 Node的应用场景\"></a>26 Node的应用场景</h3><ul>\n<li>特点：<ul>\n<li>  1、它是一个<code>Javascript</code>运行环境</li>\n<li>  2、依赖于<code>Chrome V8</code>引擎进行代码解释</li>\n<li>  3、事件驱动</li>\n<li>  4、非阻塞<code>I/O</code></li>\n<li>  5、单进程，单线程</li>\n</ul>\n</li>\n<li>优点：<ul>\n<li>  高并发（最重要的优点）</li>\n</ul>\n</li>\n<li>缺点：<ul>\n<li>  1、只支持单核<code>CPU</code>，不能充分利用<code>CPU</code></li>\n<li>  2、可靠性低，一旦代码某个环节崩溃，整个系统都崩溃</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"27-谈谈你对AMD、CMD的理解\"><a href=\"#27-谈谈你对AMD、CMD的理解\" class=\"headerlink\" title=\"27 谈谈你对AMD、CMD的理解\"></a>27 谈谈你对AMD、CMD的理解</h3><ul>\n<li>  <code>CommonJS</code>是服务器端模块的规范，<code>Node.js</code>采用了这个规范。<code>CommonJS</code>规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。<code>AMD</code>规范则是非同步加载模块，允许指定回调函数</li>\n<li>  <code>AMD</code>推荐的风格通过返回一个对象做为模块对象，<code>CommonJS</code>的风格通过对<code>module.exports</code>或<code>exports</code>的属性赋值来达到暴露模块对象的目的</li>\n</ul>\n<p>es6模块 CommonJS、AMD、CMD</p>\n<ul>\n<li>  <code>CommonJS</code> 的规范中，每个 <code>JavaScript</code> 文件就是一个独立的模块上下文（<code>module context</code>），在这个上下文中默认创建的属性都是私有的。也就是说，在一个文件定义的变量（还包括函数和类），都是私有的，对其他文件是不可见的。</li>\n<li>  <code>CommonJS</code>是同步加载模块,在浏览器中会出现堵塞情况，所以不适用</li>\n<li>  <code>AMD</code> 异步，需要定义回调<code>define</code>方式</li>\n<li>  <code>es6</code> 一个模块就是一个独立的文件，该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量 <code>es6</code>还可以导出类、方法，自动适用严格模式</li>\n</ul>\n<h3 id=\"28-那些操作会造成内存泄漏\"><a href=\"#28-那些操作会造成内存泄漏\" class=\"headerlink\" title=\"28 那些操作会造成内存泄漏\"></a>28 那些操作会造成内存泄漏</h3><ul>\n<li>  内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li>\n<li>  <code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li>\n<li>  闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li>\n</ul>\n<h3 id=\"29-web开发中会话跟踪的方法有哪些\"><a href=\"#29-web开发中会话跟踪的方法有哪些\" class=\"headerlink\" title=\"29 web开发中会话跟踪的方法有哪些\"></a>29 web开发中会话跟踪的方法有哪些</h3><ul>\n<li>  <code>cookie</code></li>\n<li>  <code>session</code></li>\n<li>  <code>url</code>重写</li>\n<li>  隐藏<code>input</code></li>\n<li>  <code>ip</code>地址</li>\n</ul>\n<h3 id=\"30-介绍js的基本数据类型\"><a href=\"#30-介绍js的基本数据类型\" class=\"headerlink\" title=\"30 介绍js的基本数据类型\"></a>30 介绍js的基本数据类型</h3><ul>\n<li>  <code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code>、<code>String</code></li>\n</ul>\n<h3 id=\"31-介绍js有哪些内置对象\"><a href=\"#31-介绍js有哪些内置对象\" class=\"headerlink\" title=\"31 介绍js有哪些内置对象\"></a>31 介绍js有哪些内置对象</h3><ul>\n<li>  <code>Object</code> 是 <code>JavaScript</code> 中所有对象的父对象</li>\n<li>  数据封装类对象：<code>Object</code>、<code>Array</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code></li>\n<li>  其他对象：<code>Function</code>、<code>Arguments</code>、<code>Math</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code></li>\n</ul>\n<h3 id=\"32-说几条写JavaScript的基本规范\"><a href=\"#32-说几条写JavaScript的基本规范\" class=\"headerlink\" title=\"32 说几条写JavaScript的基本规范\"></a>32 说几条写JavaScript的基本规范</h3><ul>\n<li>  不要在同一行声明多个变量</li>\n<li>  请使用<code>===/!==</code>来比较<code>true/false</code>或者数值</li>\n<li>  使用对象字面量替代<code>new Array</code>这种形式</li>\n<li>  不要使用全局函数</li>\n<li>  <code>Switch</code>语句必须带有<code>default</code>分支</li>\n<li>  <code>If</code>语句必须使用大括号</li>\n<li>  <code>for-in</code>循环中的变量 应该使用<code>var</code>关键字明确限定作用域，从而避免作用域污</li>\n</ul>\n<h3 id=\"33-JavaScript有几种类型的值\"><a href=\"#33-JavaScript有几种类型的值\" class=\"headerlink\" title=\"33 JavaScript有几种类型的值\"></a>33 JavaScript有几种类型的值</h3><ul>\n<li>  栈：原始数据类型（<code>Undefined</code>，<code>Null</code>，<code>Boolean</code>，<code>Number</code>、<code>String</code>）</li>\n<li>  堆：引用数据类型（对象、数组和函数）</li>\n<li>  两种类型的区别是：存储位置不同；</li>\n<li>  原始数据类型直接存储在栈(<code>stack</code>)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>\n<li>  引用数据类型存储在堆(<code>heap</code>)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</li>\n<li>  在栈中的地址，取得地址后从堆中获得实体</li>\n</ul>\n<p><img src=\"https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966\"></p>\n<h3 id=\"34-javascript创建对象的几种方式\"><a href=\"#34-javascript创建对象的几种方式\" class=\"headerlink\" title=\"34 javascript创建对象的几种方式\"></a>34 javascript创建对象的几种方式</h3><blockquote>\n<p><code>javascript</code>创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用<code>JSON</code>；但写法有很多种，也能混合使用</p>\n</blockquote>\n<ul>\n<li>  对象字面量的方式</li>\n</ul>\n<p>person={firstname:”Mark”,lastname:”Yun”,age:25,eyecolor:”black”};</p>\n<ul>\n<li>  用<code>function</code>来模拟无参的构造函数</li>\n</ul>\n<p>function Person(){}<br> var person=new Person();//定义一个function，如果使用new”实例化”,该function可以看作是一个Class<br>        person.name=”Mark”;<br>        person.age=”25”;<br>        person.work=function(){<br>        alert(person.name+” hello…”);}person.work();</p>\n<ul>\n<li>  用<code>function</code>来模拟参构造函数来实现（用<code>this</code>关键字定义构造的上下文属性）</li>\n</ul>\n<p>function Pet(name,age,hobby){<br>       this.name=name;//this作用域：当前对象<br>       this.age=age;<br>       this.hobby=hobby;<br>       this.eat=function(){<br>           alert(“我叫”+this.name+”,我喜欢”+this.hobby+”,是个程序员”);<br>       }}var maidou =new Pet(“麦兜”,25,”coding”);//实例化、创建对象maidou.eat();//调用eat方法</p>\n<ul>\n<li>  用工厂方式来创建（内置对象）</li>\n</ul>\n<p>var wcDog =new Object();<br>     wcDog.name=”旺财”;<br>     wcDog.age=3;<br>     wcDog.work=function(){<br>       alert(“我是”+wcDog.name+”,汪汪汪……”);<br>     }<br>     wcDog.work();</p>\n<ul>\n<li>  用原型方式来创建</li>\n</ul>\n<p>function Dog(){}Dog.prototype.name=”旺财”;Dog.prototype.eat=function(){<br> alert(this.name+”是个吃货”);}var wangcai =new Dog();wangcai.eat();</p>\n<ul>\n<li>  用混合方式来创建</li>\n</ul>\n<p> function Car(name,price){<br> this.name=name;<br> this.price=price;}Car.prototype.sell=function(){<br> alert(“我是”+this.name+”，我现在卖”+this.price+”万元”);}var camry =new Car(“凯美瑞”,27);camry.sell();</p>\n<h3 id=\"35-eval是做什么的\"><a href=\"#35-eval是做什么的\" class=\"headerlink\" title=\"35 eval是做什么的\"></a>35 eval是做什么的</h3><ul>\n<li>  它的功能是把对应的字符串解析成<code>JS</code>代码并运行</li>\n<li>  应该避免使用<code>eval</code>，不安全，非常耗性能（<code>2</code>次，一次解析成<code>js</code>语句，一次执行）</li>\n<li>  由<code>JSON</code>字符串转换为JSON对象的时候可以用<code>eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;)</code></li>\n</ul>\n<h3 id=\"36-null，undefined-的区别\"><a href=\"#36-null，undefined-的区别\" class=\"headerlink\" title=\"36 null，undefined 的区别\"></a>36 null，undefined 的区别</h3><ul>\n<li>  <code>undefined</code> 表示不存在这个值。</li>\n<li>  <code>undefined</code> :是一个表示”无”的原始值或者说表示”缺少值”，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 <code>undefined</code></li>\n<li>  例如变量被声明了，但没有赋值时，就等于<code>undefined</code></li>\n<li>  <code>null</code> 表示一个对象被定义了，值为“空值”</li>\n<li>  <code>null</code> : 是一个对象(空对象, 没有任何属性和方法)</li>\n<li>  例如作为函数的参数，表示该函数的参数不是对象；</li>\n<li>  在验证<code>null</code>时，一定要使用　<code>===</code> ，因为 <code>==</code>无法分别<code>null</code> 和　<code>undefined</code></li>\n</ul>\n<h3 id=\"37-“1”-“2”-“3”-map-parseInt-答案是多少\"><a href=\"#37-“1”-“2”-“3”-map-parseInt-答案是多少\" class=\"headerlink\" title=\"37 [“1”, “2”, “3”].map(parseInt) 答案是多少\"></a>37 [“1”, “2”, “3”].map(parseInt) 答案是多少</h3><ul>\n<li>  <code>[1, NaN, NaN]</code>因为 <code>parseInt</code> 需要两个参数 <code>(val, radix)</code>，其中<code>radix</code> 表示解析时用的基数。</li>\n<li>  <code>map</code>传了 <code>3</code>个<code>(element, index, array)</code>，对应的 <code>radix</code> 不合法导致解析失败。</li>\n</ul>\n<h3 id=\"38-javascript-代码中的”use-strict”-是什么意思\"><a href=\"#38-javascript-代码中的”use-strict”-是什么意思\" class=\"headerlink\" title=\"38 javascript 代码中的”use strict”;是什么意思\"></a>38 javascript 代码中的”use strict”;是什么意思</h3><ul>\n<li>  <code>use strict</code>是一种<code>ECMAscript 5</code> 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使<code>JS</code>编码更加规范化的模式,消除<code>Javascript</code>语法的一些不合理、不严谨之处，减少一些怪异行为</li>\n</ul>\n<h3 id=\"39-JSON-的了解\"><a href=\"#39-JSON-的了解\" class=\"headerlink\" title=\"39 JSON 的了解\"></a>39 JSON 的了解</h3><ul>\n<li>  <code>JSON(JavaScript Object Notation)</code> 是一种轻量级的数据交换格式</li>\n<li>  它是基于<code>JavaScript</code>的一个子集。数据格式简单, 易于读写, 占用带宽小</li>\n<li>  <code>JSON</code>字符串转换为JSON对象:</li>\n</ul>\n<p>var obj =eval(‘(‘+ str +’)’);var obj = str.parseJSON();var obj = JSON.parse(str);</p>\n<ul>\n<li>  <code>JSON</code>对象转换为JSON字符串：</li>\n</ul>\n<p>var last=obj.toJSONString();<br>var last=JSON.stringify(obj);</p>\n<h3 id=\"40-js延迟加载的方式有哪些\"><a href=\"#40-js延迟加载的方式有哪些\" class=\"headerlink\" title=\"40 js延迟加载的方式有哪些\"></a>40 js延迟加载的方式有哪些</h3><ul>\n<li>  <code>defer</code>和<code>async</code>、动态创建<code>DOM</code>方式（用得最多）、按需异步载入<code>js</code></li>\n</ul>\n<h3 id=\"41-同步和异步的区别\"><a href=\"#41-同步和异步的区别\" class=\"headerlink\" title=\"41 同步和异步的区别\"></a>41 同步和异步的区别</h3><ul>\n<li>  同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li>\n<li>  异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li>\n</ul>\n<h3 id=\"42-渐进增强和优雅降级\"><a href=\"#42-渐进增强和优雅降级\" class=\"headerlink\" title=\"42 渐进增强和优雅降级\"></a>42 渐进增强和优雅降级</h3><ul>\n<li>  渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</li>\n<li>  优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</li>\n</ul>\n<h3 id=\"43-defer和async\"><a href=\"#43-defer和async\" class=\"headerlink\" title=\"43 defer和async\"></a>43 defer和async</h3><ul>\n<li>  <code>defer</code>并行加载<code>js</code>文件，会按照页面上<code>script</code>标签的顺序执行</li>\n<li>  <code>async</code>并行加载<code>js</code>文件，下载完成立即执行，不会按照页面上<code>script</code>标签的顺序执行</li>\n</ul>\n<h3 id=\"44-说说严格模式的限制\"><a href=\"#44-说说严格模式的限制\" class=\"headerlink\" title=\"44 说说严格模式的限制\"></a>44 说说严格模式的限制</h3><ul>\n<li>  变量必须声明后再使用</li>\n<li>  函数的参数不能有同名属性，否则报错</li>\n<li>  不能使用<code>with</code>语句</li>\n<li>  禁止<code>this</code>指向全局对象</li>\n</ul>\n<h3 id=\"45-attribute和property的区别是什么\"><a href=\"#45-attribute和property的区别是什么\" class=\"headerlink\" title=\"45 attribute和property的区别是什么\"></a>45 attribute和property的区别是什么</h3><ul>\n<li>  <code>attribute</code>是<code>dom</code>元素在文档中作为<code>html</code>标签拥有的属性；</li>\n<li>  <code>property</code>就是<code>dom</code>元素在<code>js</code>中作为对象拥有的属性。</li>\n<li>  对于<code>html</code>的标准属性来说，<code>attribute</code>和<code>property</code>是同步的，是会自动更新的</li>\n<li>  但是对于自定义的属性来说，他们是不同步的</li>\n</ul>\n<h3 id=\"46-谈谈你对ES6的理解\"><a href=\"#46-谈谈你对ES6的理解\" class=\"headerlink\" title=\"46 谈谈你对ES6的理解\"></a>46 谈谈你对ES6的理解</h3><ul>\n<li>  新增模板字符串（为<code>JavaScript</code>提供了简单的字符串插值功能）</li>\n<li>  箭头函数</li>\n<li>  <code>for-of</code>（用来遍历数据—例如数组中的值。）</li>\n<li>  <code>arguments</code>对象可被不定参数和默认参数完美代替。</li>\n<li>  <code>ES6</code>将p<code>romise</code>对象纳入规范，提供了原生的<code>Promise</code>对象。</li>\n<li>  增加了<code>let</code>和<code>const</code>命令，用来声明变量。</li>\n<li>  增加了块级作用域。</li>\n<li>  <code>let</code>命令实际上就增加了块级作用域。</li>\n<li>  还有就是引入<code>module</code>模块的概念</li>\n</ul>\n<h3 id=\"47-ECMAScript6-怎么写class么\"><a href=\"#47-ECMAScript6-怎么写class么\" class=\"headerlink\" title=\"47 ECMAScript6 怎么写class么\"></a>47 ECMAScript6 怎么写class么</h3><ul>\n<li>  这个语法糖可以让有<code>OOP</code>基础的人更快上手<code>js</code>，至少是一个官方的实现了</li>\n<li>  但对熟悉<code>js</code>的人来说，这个东西没啥大影响；一个<code>Object.creat()</code>搞定继承，比<code>class</code>简洁清晰的多</li>\n</ul>\n<h3 id=\"48-什么是面向对象编程及面向过程编程，它们的异同和优缺点\"><a href=\"#48-什么是面向对象编程及面向过程编程，它们的异同和优缺点\" class=\"headerlink\" title=\"48 什么是面向对象编程及面向过程编程，它们的异同和优缺点\"></a>48 什么是面向对象编程及面向过程编程，它们的异同和优缺点</h3><ul>\n<li>  面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了</li>\n<li>  面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为</li>\n<li>  面向对象是以功能来划分问题，而不是步骤</li>\n</ul>\n<h3 id=\"49-面向对象编程思想\"><a href=\"#49-面向对象编程思想\" class=\"headerlink\" title=\"49 面向对象编程思想\"></a>49 面向对象编程思想</h3><ul>\n<li>  基本思想是使用对象，类，继承，封装等基本概念来进行程序设计</li>\n<li>优点<ul>\n<li>  采用面向对象思想设计的结构，可读性高，由于继承的存在，即使改变需求，那么维护也只是在局部模块，所以维护起来是非常方便和较低成本的</li>\n<li>  易维护</li>\n<li>  易扩展</li>\n<li>  开发工作的重用性、继承性高，降低重复工作量。</li>\n<li>  缩短了开发周期</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"50-对web标准、可用性、可访问性的理解\"><a href=\"#50-对web标准、可用性、可访问性的理解\" class=\"headerlink\" title=\"50 对web标准、可用性、可访问性的理解\"></a>50 对web标准、可用性、可访问性的理解</h3><ul>\n<li>  可用性（Usability）：产品是否容易上手，用户能否完成任务，效率如何，以及这过程中用户的主观感受可好，是从用户的角度来看产品的质量。可用性好意味着产品质量高，是企业的核心竞争力</li>\n<li>  可访问性（Accessibility）：Web内容对于残障用户的可阅读和可理解性</li>\n<li>  可维护性（Maintainability）：一般包含两个层次，一是当系统出现问题时，快速定位并解决问题的成本，成本低则可维护性好。二是代码是否容易被人理解，是否容易修改和增强功能。</li>\n</ul>\n<h3 id=\"51-如何通过JS判断一个数组\"><a href=\"#51-如何通过JS判断一个数组\" class=\"headerlink\" title=\"51 如何通过JS判断一个数组\"></a>51 如何通过JS判断一个数组</h3><ul>\n<li><code>instanceof</code>方法<ul>\n<li>  <code>instanceof</code> 运算符是用来测试一个对象是否在其原型链原型构造函数的属性</li>\n</ul>\n</li>\n</ul>\n<p>var arr = [];arr instanceof Array; // true</p>\n<ul>\n<li><code>constructor</code>方法<ul>\n<li>  <code>constructor</code>属性返回对创建此对象的数组函数的引用，就是返回对象相对应的构造函数</li>\n</ul>\n</li>\n</ul>\n<p>var arr = [];arr.constructor == Array; //true</p>\n<ul>\n<li>最简单的方法<ul>\n<li>  这种写法，是 <code>jQuery</code> 正在使用的</li>\n</ul>\n</li>\n</ul>\n<p>Object.prototype.toString.call(value) == ‘[object Array]‘// 利用这个方法，可以写一个返回数据类型的方法var isType = function (obj) {<br>     return Object.prototype.toString.call(obj).slice(8,-1);}</p>\n<ul>\n<li>  <code>ES5</code>新增方法<code>isArray()</code></li>\n</ul>\n<p>var a = new Array(123);var b = new Date();console.log(Array.isArray(a)); //trueconsole.log(Array.isArray(b)); //false</p>\n<h3 id=\"52-谈一谈let与var的区别\"><a href=\"#52-谈一谈let与var的区别\" class=\"headerlink\" title=\"52 谈一谈let与var的区别\"></a>52 谈一谈let与var的区别</h3><ul>\n<li>  <code>let</code>命令不存在变量提升，如果在<code>let</code>前使用，会导致报错</li>\n<li>  如果块区中存在<code>let</code>和<code>const</code>命令，就会形成封闭作用域</li>\n<li>  不允许重复声明，因此，不能在函数内部重新声明参数</li>\n</ul>\n<h3 id=\"53-map与forEach的区别\"><a href=\"#53-map与forEach的区别\" class=\"headerlink\" title=\"53 map与forEach的区别\"></a>53 map与forEach的区别</h3><ul>\n<li>  <code>forEach</code>方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容<code>item</code>、数组索引<code>index</code>、和当前遍历数组<code>Array</code></li>\n<li>  <code>map</code>方法，基本用法与<code>forEach</code>一致，但是不同的，它会返回一个新的数组，所以在callback需要有<code>return</code>值，如果没有，会返回<code>undefined</code></li>\n</ul>\n<h3 id=\"54-谈一谈你理解的函数式编程\"><a href=\"#54-谈一谈你理解的函数式编程\" class=\"headerlink\" title=\"54 谈一谈你理解的函数式编程\"></a>54 谈一谈你理解的函数式编程</h3><ul>\n<li>  简单说，”函数式编程”是一种”编程范式”（programming paradigm），也就是如何编写程序的方法论</li>\n<li>  它具有以下特性：闭包和高阶函数、惰性计算、递归、函数是”第一等公民”、只用”表达式”</li>\n</ul>\n<h3 id=\"55-谈一谈箭头函数与普通函数的区别？\"><a href=\"#55-谈一谈箭头函数与普通函数的区别？\" class=\"headerlink\" title=\"55 谈一谈箭头函数与普通函数的区别？\"></a>55 谈一谈箭头函数与普通函数的区别？</h3><ul>\n<li>  函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象</li>\n<li>  不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误</li>\n<li>  不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用<code>Rest</code>参数代替</li>\n<li>  不可以使用<code>yield</code>命令，因此箭头函数不能用作<code>Generator</code>函数</li>\n</ul>\n<h3 id=\"56-谈一谈函数中this的指向\"><a href=\"#56-谈一谈函数中this的指向\" class=\"headerlink\" title=\"56 谈一谈函数中this的指向\"></a>56 谈一谈函数中this的指向</h3><ul>\n<li>  this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象</li>\n<li>  《javascript语言精髓》中大概概括了4种调用方式：</li>\n<li>  方法调用模式</li>\n<li>  函数调用模式</li>\n<li>  构造器调用模式</li>\n</ul>\n<p>graph LRA–&gt;B</p>\n<ul>\n<li>  apply/call调用模式</li>\n</ul>\n<h3 id=\"57-异步编程的实现方式\"><a href=\"#57-异步编程的实现方式\" class=\"headerlink\" title=\"57 异步编程的实现方式\"></a>57 异步编程的实现方式</h3><ul>\n<li>回调函数<ul>\n<li>  优点：简单、容易理解</li>\n<li>  缺点：不利于维护，代码耦合高</li>\n</ul>\n</li>\n<li>事件监听(采用时间驱动模式，取决于某个事件是否发生)：<ul>\n<li>  优点：容易理解，可以绑定多个事件，每个事件可以指定多个回调函数</li>\n<li>  缺点：事件驱动型，流程不够清晰</li>\n</ul>\n</li>\n<li>发布/订阅(观察者模式)<ul>\n<li>  类似于事件监听，但是可以通过‘消息中心’，了解现在有多少发布者，多少订阅者</li>\n</ul>\n</li>\n<li>Promise对象<ul>\n<li>  优点：可以利用then方法，进行链式写法；可以书写错误时的回调函数；</li>\n<li>  缺点：编写和理解，相对比较难</li>\n</ul>\n</li>\n<li>Generator函数<ul>\n<li>  优点：函数体内外的数据交换、错误处理机制</li>\n<li>  缺点：流程管理不方便</li>\n</ul>\n</li>\n<li>async函数<ul>\n<li>  优点：内置执行器、更好的语义、更广的适用性、返回的是Promise、结构清晰。</li>\n<li>  缺点：错误处理机制</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"58-对原生Javascript了解程度\"><a href=\"#58-对原生Javascript了解程度\" class=\"headerlink\" title=\"58 对原生Javascript了解程度\"></a>58 对原生Javascript了解程度</h3><ul>\n<li>  数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、<code>RegExp</code>、<code>JSON</code>、<code>Ajax</code>、<code>DOM</code>、<code>BOM</code>、内存泄漏、跨域、异步装载、模板引擎、前端<code>MVC</code>、路由、模块化、<code>Canvas</code>、<code>ECMAScript</code></li>\n</ul>\n<h3 id=\"59-Js动画与CSS动画区别及相应实现\"><a href=\"#59-Js动画与CSS动画区别及相应实现\" class=\"headerlink\" title=\"59 Js动画与CSS动画区别及相应实现\"></a>59 Js动画与CSS动画区别及相应实现</h3><ul>\n<li><code>CSS3</code>的动画的优点<ul>\n<li>  在性能上会稍微好一些，浏览器会对<code>CSS3</code>的动画做一些优化</li>\n<li>  代码相对简单</li>\n</ul>\n</li>\n<li>缺点<ul>\n<li>  在动画控制上不够灵活</li>\n<li>  兼容性不好</li>\n</ul>\n</li>\n<li>  <code>JavaScript</code>的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容<code>IE6</code>，并且功能强大。对于一些复杂控制的动画，使用<code>javascript</code>会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑<code>CSS</code>吧</li>\n</ul>\n<h3 id=\"60-JS-数组和对象的遍历方式，以及几种方式的比较\"><a href=\"#60-JS-数组和对象的遍历方式，以及几种方式的比较\" class=\"headerlink\" title=\"60 JS 数组和对象的遍历方式，以及几种方式的比较\"></a>60 JS 数组和对象的遍历方式，以及几种方式的比较</h3><blockquote>\n<p>通常我们会用循环的方式来遍历数组。但是循环是 导致js 性能问题的原因之一。一般我们会采用下几种方式来进行数组的遍历</p>\n</blockquote>\n<ul>\n<li>  <code>for in</code>循环</li>\n<li>  <code>for</code>循环</li>\n<li><code>forEach</code><ul>\n<li>  这里的 <code>forEach</code>回调中两个参数分别为 <code>value</code>，<code>index</code></li>\n<li>  <code>forEach</code> 无法遍历对象</li>\n<li>  IE不支持该方法；<code>Firefox</code> 和 <code>chrome</code> 支持</li>\n<li>  <code>forEach</code> 无法使用 <code>break</code>，<code>continue</code> 跳出循环，且使用 <code>return</code> 是跳过本次循环</li>\n</ul>\n</li>\n<li>  这两种方法应该非常常见且使用很频繁。但实际上，这两种方法都存在性能问题</li>\n<li>  在方式一中，<code>for-in</code>需要分析出<code>array</code>的每个属性，这个操作性能开销很大。用在 <code>key</code> 已知的数组上是非常不划算的。所以尽量不要用<code>for-in</code>，除非你不清楚要处理哪些属性，例如 <code>JSON</code>对象这样的情况</li>\n<li>  在方式2中，循环每进行一次，就要检查一下数组长度。读取属性（数组长度）要比读局部变量慢，尤其是当 <code>array</code> 里存放的都是 <code>DOM</code> 元素，因为每次读取都会扫描一遍页面上的选择器相关元素，速度会大大降低</li>\n</ul>\n<h3 id=\"61-gulp是什么\"><a href=\"#61-gulp是什么\" class=\"headerlink\" title=\"61 gulp是什么\"></a>61 gulp是什么</h3><ul>\n<li>  <code>gulp</code>是前端开发过程中一种基于流的代码构建工具，是自动化项目的构建利器；它不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成</li>\n<li>  Gulp的核心概念：流</li>\n<li>  流，简单来说就是建立在面向对象基础上的一种抽象的处理数据的工具。在流中，定义了一些处理数据的基本操作，如读取数据，写入数据等，程序员是对流进行所有操作的，而不用关心流的另一头数据的真正流向</li>\n<li>  gulp正是通过流和代码优于配置的策略来尽量简化任务编写的工作</li>\n<li>Gulp的特点：<ul>\n<li>  易于使用：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理</li>\n<li>  构建快速 利用 <code>Node.js</code> 流的威力，你可以快速构建项目并减少频繁的 <code>IO</code> 操作</li>\n<li>  易于学习 通过最少的 <code>API</code>，掌握 <code>gulp</code> 毫不费力，构建工作尽在掌握：如同一系列流管道</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"62-说一下Vue的双向绑定数据的原理\"><a href=\"#62-说一下Vue的双向绑定数据的原理\" class=\"headerlink\" title=\"62 说一下Vue的双向绑定数据的原理\"></a>62 说一下Vue的双向绑定数据的原理</h3><ul>\n<li>  <code>vue.js</code> 则是采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调</li>\n</ul>\n<h3 id=\"63-事件的各个阶段\"><a href=\"#63-事件的各个阶段\" class=\"headerlink\" title=\"63 事件的各个阶段\"></a>63 事件的各个阶段</h3><ul>\n<li>  1：捕获阶段 —&gt; 2：目标阶段 —&gt; 3：冒泡阶段</li>\n<li>  <code>document</code> —&gt; <code>target</code>目标 —-&gt; <code>document</code></li>\n<li>由此，<code>addEventListener</code>的第三个参数设置为<code>true</code>和<code>false</code>的区别已经非常清晰了<ul>\n<li>  <code>true</code>表示该元素在事件的“捕获阶段”（由外往内传递时）响应事件</li>\n<li>  <code>false</code>表示该元素在事件的“冒泡阶段”（由内向外传递时）响应事件</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"64-let-var-const\"><a href=\"#64-let-var-const\" class=\"headerlink\" title=\"64 let var const\"></a>64 let var const</h3><p>let</p>\n<ul>\n<li>  允许你声明一个作用域被限制在块级中的变量、语句或者表达式</li>\n<li>  let绑定不受变量提升的约束，这意味着let声明不会被提升到当前</li>\n<li>  该变量处于从块开始到初始化处理的“暂存死区”</li>\n</ul>\n<p>var</p>\n<ul>\n<li>  声明变量的作用域限制在其声明位置的上下文中，而非声明变量总是全局的</li>\n<li>  由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明</li>\n</ul>\n<p>const</p>\n<ul>\n<li>  声明创建一个值的只读引用 (即指针)</li>\n<li>  基本数据当值发生改变时，那么其对应的指针也将发生改变，故造成 <code>const</code>申明基本数据类型时</li>\n<li>  再将其值改变时，将会造成报错， 例如 <code>const a = 3</code> ; <code>a = 5</code>时 将会报错</li>\n<li>  但是如果是复合类型时，如果只改变复合类型的其中某个<code>Value</code>项时， 将还是正常使用</li>\n</ul>\n<h3 id=\"65-快速的让一个数组乱序\"><a href=\"#65-快速的让一个数组乱序\" class=\"headerlink\" title=\"65 快速的让一个数组乱序\"></a>65 快速的让一个数组乱序</h3><p>var arr = [1,2,3,4,5,6,7,8,9,10];arr.sort(function(){<br>    return Math.random() - 0.5;})console.log(arr);</p>\n<h3 id=\"66-如何渲染几万条数据并不卡住界面\"><a href=\"#66-如何渲染几万条数据并不卡住界面\" class=\"headerlink\" title=\"66 如何渲染几万条数据并不卡住界面\"></a>66 如何渲染几万条数据并不卡住界面</h3><blockquote>\n<p>这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 <code>DOM</code>，那么就可以通过 <code>requestAnimationFrame</code> 来每 <code>16 ms</code> 刷新一次</p>\n</blockquote>\n<!DOCTYPE html><p><html lang=\"en\"><head><br>  <meta charset=\"UTF-8\"><br>  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"><br>  <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"><br>  <title>Document</title></head><body><br>  <ul>控件</ul><br>  <script><br>    setTimeout(() => {<br>      // 插入十万条数据<br>      const total = 100000<br>      // 一次插入 20 条，如果觉得性能不好就减少<br>      const once = 20<br>      // 渲染数据总共需要几次<br>      const loopCount = total / once      let countOfRender = 0<br>      let ul = document.querySelector(\"ul\");<br>      function add() {<br>        // 优化性能，插入不会造成回流<br>        const fragment = document.createDocumentFragment();<br>        for (let i = 0; i < once; i++) {<br>          const li = document.createElement(\"li\");<br>          li.innerText = Math.floor(Math.random() * total);<br>          fragment.appendChild(li);<br>        }<br>        ul.appendChild(fragment);<br>        countOfRender += 1;<br>        loop();<br>      }<br>      function loop() {<br>        if (countOfRender < loopCount) {<br>          window.requestAnimationFrame(add);<br>        }<br>      }<br>      loop();<br>    }, 0);<br>  </script></body></html></p>\n<h3 id=\"67-希望获取到页面中所有的checkbox怎么做？\"><a href=\"#67-希望获取到页面中所有的checkbox怎么做？\" class=\"headerlink\" title=\"67 希望获取到页面中所有的checkbox怎么做？\"></a>67 希望获取到页面中所有的checkbox怎么做？</h3><blockquote>\n<p>不使用第三方框架</p>\n</blockquote>\n<p> var domList = document.getElementsByTagName(‘input’)<br> var checkBoxList = [];<br> var len = domList.length;　　//缓存到局部变量<br> while (len–) {　　//使用while的效率会比for循环更高<br> 　　if (domList[len].type == ‘checkbox’) {<br>     　　checkBoxList.push(domList[len]);<br> 　　}<br> }</p>\n<h3 id=\"68-怎样添加、移除、移动、复制、创建和查找节点\"><a href=\"#68-怎样添加、移除、移动、复制、创建和查找节点\" class=\"headerlink\" title=\"68 怎样添加、移除、移动、复制、创建和查找节点\"></a>68 怎样添加、移除、移动、复制、创建和查找节点</h3><p>创建新节点</p>\n<p>createDocumentFragment()    //创建一个DOM片段createElement()   //创建一个具体的元素createTextNode()   //创建一个文本节点</p>\n<p>添加、移除、替换、插入</p>\n<p>appendChild()      //添加removeChild()      //移除replaceChild()      //替换insertBefore()      //插入</p>\n<p>查找</p>\n<p>getElementsByTagName()    //通过标签名称getElementsByName()     //通过元素的Name属性的值getElementById()        //通过元素Id，唯一性</p>\n<h3 id=\"69-正则表达式\"><a href=\"#69-正则表达式\" class=\"headerlink\" title=\"69 正则表达式\"></a>69 正则表达式</h3><blockquote>\n<p>正则表达式构造函数<code>var reg=new RegExp(“xxx”)</code>与正则表达字面量<code>var reg=//</code>有什么不同？匹配邮箱的正则表达式？</p>\n</blockquote>\n<ul>\n<li>  当使用<code>RegExp()</code>构造函数的时候，不仅需要转义引号（即<code>\\</code>”表示”），并且还需要双反斜杠（即<code>\\\\</code>表示一个<code>\\</code>）。使用正则表达字面量的效率更高</li>\n</ul>\n<p>邮箱的正则匹配：</p>\n<p>var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/;</p>\n<h3 id=\"70-Javascript中callee和caller的作用？\"><a href=\"#70-Javascript中callee和caller的作用？\" class=\"headerlink\" title=\"70 Javascript中callee和caller的作用？\"></a>70 Javascript中callee和caller的作用？</h3><ul>\n<li>  <code>caller</code>是返回一个对函数的引用，该函数调用了当前函数；</li>\n<li>  <code>callee</code>是返回正在被执行的<code>function</code>函数，也就是所指定的<code>function</code>对象的正文</li>\n</ul>\n<blockquote>\n<p>那么问题来了？如果一对兔子每月生一对兔子；一对新生兔，从第二个月起就开始生兔子；假定每对兔子都是一雌一雄，试问一对兔子，第n个月能繁殖成多少对兔子？（使用<code>callee</code>完成）</p>\n</blockquote>\n<p>var result=[];<br>  function fn(n){  //典型的斐波那契数列<br>     if(n==1){<br>          return 1;<br>     }else if(n==2){<br>             return 1;<br>     }else{<br>          if(result[n]){<br>                  return result[n];<br>         }else{<br>                 //argument.callee()表示fn()<br>                 result[n]=arguments.callee(n-1)+arguments.callee(n-2);<br>                 return result[n];<br>         }<br>    }<br> }</p>\n<h3 id=\"71-window-onload和-document-ready\"><a href=\"#71-window-onload和-document-ready\" class=\"headerlink\" title=\"71 window.onload和$(document).ready\"></a>71 window.onload和$(document).ready</h3><blockquote>\n<p>原生<code>JS</code>的<code>window.onload</code>与<code>Jquery</code>的<code>$(document).ready(function()&#123;&#125;)</code>有什么不同？如何用原生JS实现Jq的<code>ready</code>方法？</p>\n</blockquote>\n<ul>\n<li>  <code>window.onload()</code>方法是必须等到页面内包括图片的所有元素加载完毕后才能执行。</li>\n<li>  <code>$(document).ready()</code>是<code>DOM</code>结构绘制完毕后就执行，不必等到加载完毕</li>\n</ul>\n<p>function ready(fn){<br>      if(document.addEventListener) {        //标准浏览器<br>          document.addEventListener(‘DOMContentLoaded’, function() {<br>              //注销事件, 避免反复触发<br>              document.removeEventListener(‘DOMContentLoaded’,arguments.callee, false);<br>              fn();            //执行函数<br>          }, false);<br>      }else if(document.attachEvent) {        //IE<br>          document.attachEvent(‘onreadystatechange’, function() {<br>             if(document.readyState == ‘complete’) {<br>                 document.detachEvent(‘onreadystatechange’, arguments.callee);<br>                 fn();        //函数执行<br>             }<br>         });<br>     }<br> };</p>\n<h3 id=\"72-addEventListener-和attachEvent-的区别\"><a href=\"#72-addEventListener-和attachEvent-的区别\" class=\"headerlink\" title=\"72 addEventListener()和attachEvent()的区别\"></a>72 addEventListener()和attachEvent()的区别</h3><ul>\n<li>  <code>addEventListener()</code>是符合W3C规范的标准方法; <code>attachEvent()</code>是IE低版本的非标准方法</li>\n<li>  <code>addEventListener()</code>支持事件冒泡和事件捕获; - 而<code>attachEvent()</code>只支持事件冒泡</li>\n<li>  <code>addEventListener()</code>的第一个参数中,事件类型不需要添加<code>on</code>; <code>attachEvent()</code>需要添加<code>&#39;on&#39;</code></li>\n<li>  如果为同一个元素绑定多个事件, <code>addEventListener()</code>会按照事件绑定的顺序依次执行,<code>attachEvent()</code>会按照事件绑定的顺序倒序执行</li>\n</ul>\n<h3 id=\"73-获取页面所有的checkbox\"><a href=\"#73-获取页面所有的checkbox\" class=\"headerlink\" title=\"73 获取页面所有的checkbox\"></a>73 获取页面所有的checkbox</h3><p>var resultArr= [];var input = document.querySelectorAll(‘input’);for( var i = 0; i &lt; input.length; i++ ) {<br>    if( input[i].type == ‘checkbox’ ) {<br>        resultArr.push( input[i] );<br>    }}//resultArr即中获取到了页面中的所有checkbox</p>\n<h3 id=\"74-数组去重方法总结\"><a href=\"#74-数组去重方法总结\" class=\"headerlink\" title=\"74 数组去重方法总结\"></a>74 数组去重方法总结</h3><p>方法一、利用ES6 Set去重（ES6中最常用）</p>\n<p>function unique (arr) {<br>  return Array.from(new Set(arr))}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))<br> //[1, “true”, true, 15, false, undefined, null, NaN, “NaN”, 0, “a”, {}, {}]</p>\n<p>方法二、利用for嵌套for，然后splice去重（ES5中最常用）</p>\n<p>function unique(arr){            <br>        for(var i=0; i&lt;arr.length; i++){<br>            for(var j=i+1; j&lt;arr.length; j++){<br>                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个<br>                    arr.splice(j,1);<br>                    j–;<br>                }<br>            }<br>        }<br> return arr;}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))<br>    //[1, “true”, 15, false, undefined, NaN, NaN, “NaN”, “a”, {…}, {…}]     //NaN和{}没有去重，两个null直接消失了</p>\n<ul>\n<li>  双层循环，外层循环元素，内层循环时比较值。值相同时，则删去这个值。</li>\n<li>  想快速学习更多常用的<code>ES6</code>语法</li>\n</ul>\n<p>方法三、利用indexOf去重</p>\n<p>function unique(arr) {<br>    if (!Array.isArray(arr)) {<br>        console.log(‘type error!’)<br>        return<br>    }<br>    var array = [];<br>    for (var i = 0; i &lt; arr.length; i++) {<br>        if (array .indexOf(arr[i]) === -1) {<br>            array .push(arr[i])<br>        }<br>    }<br>    return array;}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))<br>   // [1, “true”, true, 15, false, undefined, null, NaN, NaN, “NaN”, 0, “a”, {…}, {…}]  //NaN、{}没有去重</p>\n<blockquote>\n<p>新建一个空的结果数组，<code>for</code> 循环原数组，判断结果数组是否存在当前元素，如果有相同的值则跳过，不相同则<code>push</code>进数组</p>\n</blockquote>\n<p>方法四、利用sort()</p>\n<p>function unique(arr) {<br>    if (!Array.isArray(arr)) {<br>        console.log(‘type error!’)<br>        return;<br>    }<br>    arr = arr.sort()<br>    var arrry= [arr[0]];<br>    for (var i = 1; i &lt; arr.length; i++) {<br>        if (arr[i] !== arr[i-1]) {<br>            arrry.push(arr[i]);<br>        }<br>    }<br>    return arrry;}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))// [0, 1, 15, “NaN”, NaN, NaN, {…}, {…}, “a”, false, null, true, “true”, undefined]      //NaN、{}没有去重</p>\n<blockquote>\n<p>利用<code>sort()</code>排序方法，然后根据排序后的结果进行遍历及相邻元素比对</p>\n</blockquote>\n<p>方法五、利用对象的属性不能相同的特点进行去重</p>\n<p>function unique(arr) {<br>    if (!Array.isArray(arr)) {<br>        console.log(‘type error!’)<br>        return<br>    }<br>    var arrry= [];<br>     var  obj = {};<br>    for (var i = 0; i &lt; arr.length; i++) {<br>        if (!obj[arr[i]]) {<br>            arrry.push(arr[i])<br>            obj[arr[i]] = 1<br>        } else {<br>            obj[arr[i]]++<br>        }<br>    }<br>    return arrry;}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))//[1, “true”, 15, false, undefined, null, NaN, 0, “a”, {…}]    //两个true直接去掉了，NaN和{}去重</p>\n<p>方法六、利用includes</p>\n<p>function unique(arr) {<br>    if (!Array.isArray(arr)) {<br>        console.log(‘type error!’)<br>        return<br>    }<br>    var array =[];<br>    for(var i = 0; i &lt; arr.length; i++) {<br>            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值<br>                    array.push(arr[i]);<br>              }<br>    }<br>    return array}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))<br>    //[1, “true”, true, 15, false, undefined, null, NaN, “NaN”, 0, “a”, {…}, {…}]     //{}没有去重</p>\n<p>方法七、利用hasOwnProperty</p>\n<p>function unique(arr) {<br>    var obj = {};<br>    return arr.filter(function(item, index, arr){<br>        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)<br>    })}<br>    var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];<br>        console.log(unique(arr))//[1, “true”, true, 15, false, undefined, null, NaN, “NaN”, 0, “a”, {…}]   //所有的都去重了</p>\n<blockquote>\n<p>利用<code>hasOwnProperty</code> 判断是否存在对象属性</p>\n</blockquote>\n<p>方法八、利用filter</p>\n<p>function unique(arr) {<br>  return arr.filter(function(item, index, arr) {<br>    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素<br>    return arr.indexOf(item, 0) === index;<br>  });}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))//[1, “true”, true, 15, false, undefined, null, “NaN”, 0, “a”, {…}, {…}]</p>\n<p>方法九、利用递归去重</p>\n<p>function unique(arr) {<br>    var array= arr;<br>    var len = array.length;</p>\n<p> array.sort(function(a,b){   //排序后更加方便去重<br> return a - b;<br> })</p>\n<p> function loop(index){<br>        if(index &gt;= 1){<br>            if(array[index] === array[index-1]){<br>            array.splice(index,1);<br>            }<br>            loop(index - 1);    //递归loop，然后数组去重<br>        }<br> }<br> loop(len-1);<br> return array;}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr))//[1, “a”, “true”, true, 15, false, 1, {…}, null, NaN, NaN, “NaN”, 0, “a”, {…}, undefined]</p>\n<p>方法十、利用Map数据结构去重</p>\n<p>function arrayNonRepeatfy(arr) {<br> let map = new Map();<br> let array = new Array();  // 数组用于返回结果<br> for (let i = 0; i &lt; arr.length; i++) {<br> if(map .has(arr[i])) {  // 如果有该key值<br> map .set(arr[i], true);<br> } else {<br> map .set(arr[i], false);   // 如果没有该key值<br> array .push(arr[i]);<br> }<br> }<br> return array ;}<br> var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];<br>    console.log(unique(arr))//[1, “a”, “true”, true, 15, false, 1, {…}, null, NaN, NaN, “NaN”, 0, “a”, {…}, undefined]</p>\n<blockquote>\n<p>创建一个空<code>Map</code>数据结构，遍历需要去重的数组，把数组的每一个元素作为<code>key</code>存到<code>Map</code>中。由于<code>Map</code>中不会出现相同的<code>key</code>值，所以最终得到的就是去重后的结果</p>\n</blockquote>\n<p>方法十一、利用reduce+includes</p>\n<p>function unique(arr){<br>    return arr.reduce((prev,cur) =&gt; prev.includes(cur) ? prev : […prev,cur],[]);}var arr = [1,1,’true’,’true’,true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,’NaN’, 0, 0, ‘a’, ‘a’,{},{}];console.log(unique(arr));// [1, “true”, true, 15, false, undefined, null, NaN, “NaN”, 0, “a”, {…}, {…}]</p>\n<p>方法十二、[…new Set(arr)]</p>\n<p>[…new Set(arr)]//代码就是这么少—-（其实，严格来说并不算是一种，相对于第一种方法来说只是简化了代码）</p>\n<h3 id=\"75-（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）\"><a href=\"#75-（设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）\" class=\"headerlink\" title=\"75 （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）\"></a>75 （设计题）想实现一个对页面某个节点的拖曳？如何做？（使用原生JS）</h3><ul>\n<li>  给需要拖拽的节点绑定<code>mousedown</code>, <code>mousemove</code>, <code>mouseup</code>事件</li>\n<li>  <code>mousedown</code>事件触发后，开始拖拽</li>\n<li>  <code>mousemove</code>时，需要通过<code>event.clientX</code>和<code>clientY</code>获取拖拽位置，并实时更新位置</li>\n<li>  <code>mouseup</code>时，拖拽结束</li>\n<li>  需要注意浏览器边界的情况</li>\n</ul>\n<h3 id=\"76-Javascript全局函数和全局变量\"><a href=\"#76-Javascript全局函数和全局变量\" class=\"headerlink\" title=\"76 Javascript全局函数和全局变量\"></a>76 Javascript全局函数和全局变量</h3><p>全局变量</p>\n<ul>\n<li>  <code>Infinity</code> 代表正的无穷大的数值。</li>\n<li>  <code>NaN</code> 指示某个值是不是数字值。</li>\n<li>  <code>undefined</code> 指示未定义的值。</li>\n</ul>\n<p>全局函数</p>\n<ul>\n<li>  <code>decodeURI()</code> 解码某个编码的 <code>URI</code>。</li>\n<li>  <code>decodeURIComponent()</code> 解码一个编码的 <code>URI</code> 组件。</li>\n<li>  <code>encodeURI()</code> 把字符串编码为 URI。</li>\n<li>  <code>encodeURIComponent()</code> 把字符串编码为 <code>URI</code> 组件。</li>\n<li>  <code>escape()</code> 对字符串进行编码。</li>\n<li>  <code>eval()</code> 计算 <code>JavaScript</code> 字符串，并把它作为脚本代码来执行。</li>\n<li>  <code>isFinite()</code> 检查某个值是否为有穷大的数。</li>\n<li>  <code>isNaN()</code> 检查某个值是否是数字。</li>\n<li>  <code>Number()</code> 把对象的值转换为数字。</li>\n<li>  <code>parseFloat()</code> 解析一个字符串并返回一个浮点数。</li>\n<li>  <code>parseInt()</code> 解析一个字符串并返回一个整数。</li>\n<li>  <code>String()</code> 把对象的值转换为字符串。</li>\n<li>  <code>unescape()</code> 对由<code>escape()</code> 编码的字符串进行解码</li>\n</ul>\n<h3 id=\"77-使用js实现一个持续的动画效果\"><a href=\"#77-使用js实现一个持续的动画效果\" class=\"headerlink\" title=\"77 使用js实现一个持续的动画效果\"></a>77 使用js实现一个持续的动画效果</h3><p>定时器思路</p>\n<p>var e = document.getElementById(‘e’)var flag = true;var left = 0;setInterval(() =&gt; {<br>    left == 0 ? flag = true : left == 100 ? flag = false : ‘’<br>    flag ? e.style.left = <code> $&#123;left++&#125;px</code> : e.style.left = <code> $&#123;left--&#125;px</code>}, 1000 / 60)</p>\n<p>requestAnimationFrame</p>\n<p>//兼容性处理window.requestAnimFrame = (function(){<br>    return window.requestAnimationFrame       ||<br>           window.webkitRequestAnimationFrame ||<br>           window.mozRequestAnimationFrame    ||<br>           function(callback){<br>                window.setTimeout(callback, 1000 / 60);<br>           };})();var e = document.getElementById(“e”);var flag = true;var left = 0;function render() {<br>    left == 0 ? flag = true : left == 100 ? flag = false : ‘’;<br>    flag ? e.style.left = <code> $&#123;left++&#125;px</code> :<br>        e.style.left = <code> $&#123;left--&#125;px</code>;}(function animloop() {<br>    render();<br>    requestAnimFrame(animloop);})();</p>\n<p>使用css实现一个持续的动画效果</p>\n<p>animation:mymove 5s infinite;@keyframes mymove {<br>    from {top:0px;}<br>    to {top:200px;}}</p>\n<ul>\n<li>  <code>animation-name</code> 规定需要绑定到选择器的 <code>keyframe</code>名称。</li>\n<li>  <code>animation-duration</code> 规定完成动画所花费的时间，以秒或毫秒计。</li>\n<li>  <code>animation-timing-function</code> 规定动画的速度曲线。</li>\n<li>  <code>animation-delay</code> 规定在动画开始之前的延迟。</li>\n<li>  <code>animation-iteration-count</code> 规定动画应该播放的次数。</li>\n<li>  <code>animation-direction</code> 规定是否应该轮流反向播放动画</li>\n</ul>\n<h3 id=\"78-封装一个函数，参数是定时器的时间，-then执行回调函数\"><a href=\"#78-封装一个函数，参数是定时器的时间，-then执行回调函数\" class=\"headerlink\" title=\"78 封装一个函数，参数是定时器的时间，.then执行回调函数\"></a>78 封装一个函数，参数是定时器的时间，.then执行回调函数</h3><p>function sleep (time) {<br>    return new Promise((resolve) =&gt; setTimeout(resolve, time));}</p>\n<h3 id=\"79-怎么判断两个对象相等？\"><a href=\"#79-怎么判断两个对象相等？\" class=\"headerlink\" title=\"79 怎么判断两个对象相等？\"></a>79 怎么判断两个对象相等？</h3><p>obj={<br>    a:1,<br>    b:2}obj2={<br>    a:1,<br>    b:2}obj3={<br>    a:1,<br>    b:’2’}</p>\n<blockquote>\n<p>可以转换为字符串来判断</p>\n</blockquote>\n<p>JSON.stringify(obj)==JSON.stringify(obj2);//trueJSON.stringify(obj)==JSON.stringify(obj3);//false</p>\n<h3 id=\"80-项目做过哪些性能优化？\"><a href=\"#80-项目做过哪些性能优化？\" class=\"headerlink\" title=\"80 项目做过哪些性能优化？\"></a>80 项目做过哪些性能优化？</h3><ul>\n<li>  减少 <code>HTTP</code> 请求数</li>\n<li>  减少 <code>DNS</code> 查询</li>\n<li>  使用 <code>CDN</code></li>\n<li>  避免重定向</li>\n<li>  图片懒加载</li>\n<li>  减少 <code>DOM</code> 元素数量</li>\n<li>  减少<code>DOM</code> 操作</li>\n<li>  使用外部 <code>JavaScript</code> 和 <code>CSS</code></li>\n<li>  压缩 <code>JavaScript</code> 、 <code>CSS</code> 、字体、图片等</li>\n<li>  优化 <code>CSS Sprite</code></li>\n<li>  使用 <code>iconfont</code></li>\n<li>  字体裁剪</li>\n<li>  多域名分发划分内容到不同域名</li>\n<li>  尽量减少 <code>iframe</code> 使用</li>\n<li>  避免图片 <code>src</code> 为空</li>\n<li>  把样式表放在<code>link</code> 中</li>\n<li>  把<code>JavaScript</code>放在页面底部</li>\n</ul>\n<h3 id=\"81-浏览器缓存\"><a href=\"#81-浏览器缓存\" class=\"headerlink\" title=\"81 浏览器缓存\"></a>81 浏览器缓存</h3><blockquote>\n<p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下</p>\n</blockquote>\n<ul>\n<li>  先根据这个资源的一些 <code>http header</code> 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li>\n<li>  当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些<code>request header</code>验证这个资源是否命中协商缓存，称为<code>http</code>再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li>\n<li>  强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。</li>\n<li>  当协商缓存也没命中时，服务器就会将资源发送回客户端。</li>\n<li>  当 <code>ctrl+f5</code> 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>\n<li>  当 <code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存；</li>\n</ul>\n<p>强缓存</p>\n<ul>\n<li>  <code>Expires</code>（该字段是 <code>http1.0</code> 时的规范，值为一个绝对时间的 <code>GMT</code> 格式的时间字符串，代表缓存资源的过期时间）</li>\n<li>  <code>Cache-Control:max-age</code>（该字段是 <code>http1.1</code>的规范，强缓存利用其 <code>max-age</code> 值来判断缓存资源的最大生命周期，它的值单位为秒）</li>\n</ul>\n<p>协商缓存</p>\n<ul>\n<li>  <code>Last-Modified</code>（值为资源最后更新时间，随服务器response返回）</li>\n<li>  <code>If-Modified-Since</code>（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li>\n<li>  <code>ETag</code>（表示资源内容的唯一标识，随服务器<code>response</code>返回）</li>\n<li>  <code>If-None-Match</code>（服务器通过比较请求头部的<code>If-None-Match</code>与当前资源的<code>ETag</code>是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li>\n</ul>\n<h3 id=\"82-WebSocket\"><a href=\"#82-WebSocket\" class=\"headerlink\" title=\"82 WebSocket\"></a>82 WebSocket</h3><blockquote>\n<p>由于 <code>http</code> 存在一个明显的弊端（消息只能有客户端推送到服务器端，而服务器端不能主动推送到客户端），导致如果服务器如果有连续的变化，这时只能使用轮询，而轮询效率过低，并不适合。于是 <code>WebSocket</code>被发明出来</p>\n</blockquote>\n<blockquote>\n<p>相比与 <code>http</code> 具有以下有点</p>\n</blockquote>\n<ul>\n<li>  支持双向通信，实时性更强；</li>\n<li>  可以发送文本，也可以二进制文件；</li>\n<li>  协议标识符是 <code>ws</code>，加密后是 <code>wss</code> ；</li>\n<li>  较少的控制开销。连接创建后，<code>ws</code>客户端、服务端进行数据交换时，协议控制的数据包头部较小。在不包含头部的情况下，服务端到客户端的包头只有<code>2~10</code>字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。而<code>HTTP</code>协议每次通信都需要携带完整的头部；</li>\n<li>  支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）</li>\n<li>  无跨域问题。</li>\n</ul>\n<blockquote>\n<p>实现比较简单，服务端库如 <code>socket.io</code>、<code>ws</code>，可以很好的帮助我们入门。而客户端也只需要参照 <code>api</code> 实现即可</p>\n</blockquote>\n<h3 id=\"83-尽可能多的说出你对-Electron-的理解\"><a href=\"#83-尽可能多的说出你对-Electron-的理解\" class=\"headerlink\" title=\"83 尽可能多的说出你对 Electron 的理解\"></a>83 尽可能多的说出你对 Electron 的理解</h3><blockquote>\n<p>最最重要的一点，<code>electron</code> 实际上是一个套了 <code>Chrome</code> 的 <code>nodeJS</code>程序</p>\n</blockquote>\n<p>所以应该是从两个方面说开来</p>\n<ul>\n<li>  <code>Chrome</code> （无各种兼容性问题）；</li>\n<li>  <code>NodeJS</code>（<code>NodeJS</code> 能做的它也能做）</li>\n</ul>\n<h3 id=\"84-深浅拷贝\"><a href=\"#84-深浅拷贝\" class=\"headerlink\" title=\"84 深浅拷贝\"></a>84 深浅拷贝</h3><p>浅拷贝</p>\n<ul>\n<li>  <code>Object.assign</code></li>\n<li>  或者展开运算符</li>\n</ul>\n<p>深拷贝</p>\n<ul>\n<li>  可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决</li>\n</ul>\n<p>let a = {<br>    age: 1,<br>    jobs: {<br>        first: ‘FE’<br>    }}let b = JSON.parse(JSON.stringify(a))a.jobs.first = ‘native’console.log(b.jobs.first) // FE</p>\n<p>该方法也是有局限性的</p>\n<ul>\n<li>  会忽略 <code>undefined</code></li>\n<li>  不能序列化函数</li>\n<li>  不能解决循环引用的对象</li>\n</ul>\n<h3 id=\"85-防抖-节流\"><a href=\"#85-防抖-节流\" class=\"headerlink\" title=\"85 防抖/节流\"></a>85 防抖/节流</h3><p>防抖</p>\n<blockquote>\n<p>在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。可以通过函数防抖动来实现</p>\n</blockquote>\n<p>// 使用 underscore 的源码来解释防抖动/**<br> * underscore 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行<br> *<br> * @param  {function} func        回调函数<br> * @param  {number}   wait        表示时间窗口的间隔<br> * @param  {boolean}  immediate   设置为ture时，是否立即调用函数<br> * @return {function}             返回客户调用函数<br> */_.debounce = function(func, wait, immediate) {<br>    var timeout, args, context, timestamp, result;</p>\n<p>    var later = function() {<br>      // 现在和上一次时间戳比较<br>      var last = _.now() - timestamp;<br>      // 如果当前间隔时间少于设定时间且大于0就重新设置定时器<br>      if (last &lt; wait &amp;&amp; last &gt;= 0) {<br>        timeout = setTimeout(later, wait - last);<br>      } else {<br>        // 否则的话就是时间到了执行回调函数<br>        timeout = null;<br>        if (!immediate) {<br>          result = func.apply(context, args);<br>          if (!timeout) context = args = null;<br>        }<br>      }<br>    };</p>\n<p>    return function() {<br>      context = this;<br>      args = arguments;<br>      // 获得时间戳<br>      timestamp = _.now();<br>      // 如果定时器不存在且立即执行函数<br>      var callNow = immediate &amp;&amp; !timeout;<br>      // 如果定时器不存在就创建一个<br>      if (!timeout) timeout = setTimeout(later, wait);<br>      if (callNow) {<br>        // 如果需要立即执行函数的话 通过 apply 执行<br>        result = func.apply(context, args);<br>        context = args = null;<br>      }</p>\n<p>      return result;<br>    };<br>  };</p>\n<blockquote>\n<p>整体函数实现</p>\n</blockquote>\n<p>对于按钮防点击来说的实现</p>\n<ul>\n<li>  开始一个定时器，只要我定时器还在，不管你怎么点击都不会执行回调函数。一旦定时器结束并设置为 null，就可以再次点击了</li>\n<li>  对于延时执行函数来说的实现：每次调用防抖动函数都会判断本次调用和之前的时间间隔，如果小于需要的时间间隔，就会重新创建一个定时器，并且定时器的延时为设定时间减去之前的时间间隔。一旦时间到了，就会执行相应的回调函数</li>\n</ul>\n<p>节流</p>\n<blockquote>\n<p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行</p>\n</blockquote>\n<p>/**<br> * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 / wait<br> *<br> * @param  {function}   func      回调函数<br> * @param  {number}     wait      表示时间窗口的间隔<br> * @param  {object}     options   如果想忽略开始函数的的调用，传入{leading: false}。<br> *                                如果想忽略结尾函数的调用，传入{trailing: false}<br> *                                两者不能共存，否则函数不能执行<br> * @return {function}             返回客户调用函数   <br> */_.throttle = function(func, wait, options) {<br>    var context, args, result;<br>    var timeout = null;<br>    // 之前的时间戳<br>    var previous = 0;<br>    // 如果 options 没传则设为空对象<br>    if (!options) options = {};<br>    // 定时器回调函数<br>    var later = function() {<br>      // 如果设置了 leading，就将 previous 设为 0<br>      // 用于下面函数的第一个 if 判断<br>      previous = options.leading === false ? 0 : _.now();<br>      // 置空一是为了防止内存泄漏，二是为了下面的定时器判断<br>      timeout = null;<br>      result = func.apply(context, args);<br>      if (!timeout) context = args = null;<br>    };<br>    return function() {<br>      // 获得当前时间戳<br>      var now = _.now();<br>      // 首次进入前者肯定为 true<br>   // 如果需要第一次不执行函数<br>   // 就将上次时间戳设为当前的<br>      // 这样在接下来计算 remaining 的值时会大于0<br>      if (!previous &amp;&amp; options.leading === false) previous = now;<br>      // 计算剩余时间<br>      var remaining = wait - (now - previous);<br>      context = this;<br>      args = arguments;<br>      // 如果当前调用已经大于上次调用时间 + wait<br>      // 或者用户手动调了时间<br>    // 如果设置了 trailing，只会进入这个条件<br>   // 如果没有设置 leading，那么第一次会进入这个条件<br>   // 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了<br>   // 其实还是会进入的，因为定时器的延时<br>   // 并不是准确的时间，很可能你设置了2秒<br>   // 但是他需要2.2秒才触发，这时候就会进入这个条件<br>      if (remaining &lt;= 0 || remaining &gt; wait) {<br>        // 如果存在定时器就清理掉否则会调用二次回调<br>        if (timeout) {<br>          clearTimeout(timeout);<br>          timeout = null;<br>        }<br>        previous = now;<br>        result = func.apply(context, args);<br>        if (!timeout) context = args = null;<br>      } else if (!timeout &amp;&amp; options.trailing !== false) {<br>        // 判断是否设置了定时器和 trailing<br>     // 没有的话就开启一个定时器<br>        // 并且不能不能同时设置 leading 和 trailing<br>        timeout = setTimeout(later, remaining);<br>      }<br>      return result;<br>    };<br>  };</p>\n<h3 id=\"86-谈谈变量提升？\"><a href=\"#86-谈谈变量提升？\" class=\"headerlink\" title=\"86 谈谈变量提升？\"></a>86 谈谈变量提升？</h3><blockquote>\n<p>当执行 JS 代码时，会生成执行环境，只要代码不是写在函数中的，就是在全局执行环境中，函数中的代码会产生函数执行环境，只此两种执行环境</p>\n</blockquote>\n<ul>\n<li>  接下来让我们看一个老生常谈的例子，<code>var</code></li>\n</ul>\n<p>b() // call bconsole.log(a) // undefinedvar a = ‘Hello world’function b() {<br>    console.log(‘call b’)}</p>\n<p>变量提升 这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行环境时，会有两个阶段。第一个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code>，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用 在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p>\n<p>b() // call b secondfunction b() {<br>    console.log(‘call b fist’)}function b() {<br>    console.log(‘call b second’)}var b = ‘Hello world’</p>\n<blockquote>\n<p>复制代码<code>var</code> 会产生很多错误，所以在 <code>ES6</code>中引入了 <code>let</code>。<code>let</code> 不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升，<code>let</code> 提升了，在第一阶段内存也已经为他开辟好了空间，但是因为这个声明的特性导致了并不能在声明前使用</p>\n</blockquote>\n<h3 id=\"87-什么是单线程，和异步的关系\"><a href=\"#87-什么是单线程，和异步的关系\" class=\"headerlink\" title=\"87 什么是单线程，和异步的关系\"></a>87 什么是单线程，和异步的关系</h3><ul>\n<li>  单线程 - 只有一个线程，只能做一件事</li>\n<li>原因 - 避免 <code>DOM</code> 渲染的冲突<ul>\n<li>  浏览器需要渲染 <code>DOM</code></li>\n<li>  <code>JS</code> 可以修改 <code>DOM</code> 结构</li>\n<li>  <code>JS</code> 执行的时候，浏览器 <code>DOM</code> 渲染会暂停</li>\n<li>  两段 JS 也不能同时执行（都修改 <code>DOM</code> 就冲突了）</li>\n<li>  <code>webworker</code> 支持多线程，但是不能访问 <code>DOM</code></li>\n</ul>\n</li>\n<li>  解决方案 - 异步</li>\n</ul>\n<h3 id=\"88-是否用过-jQuery-的-Deferred\"><a href=\"#88-是否用过-jQuery-的-Deferred\" class=\"headerlink\" title=\"88 是否用过 jQuery 的 Deferred\"></a>88 是否用过 jQuery 的 Deferred</h3><p><img src=\"https://upload-images.jianshu.io/upload_images/1480597-77a330fbdcc1f1cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-6f79b726f5341f7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-82ac861eced36a45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-69092d725f2b1e79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-9d9b67a6859cf8cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-9970b83118b10829.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-243444771c6b30ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"> <img src=\"https://upload-images.jianshu.io/upload_images/1480597-d2db463132d1572a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-c589d6f7caf8b27c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"><img src=\"https://upload-images.jianshu.io/upload_images/1480597-ab3b7f684e99e6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"image.png\"></p>\n<h3 id=\"89-前端面试之hybrid\"><a href=\"#89-前端面试之hybrid\" class=\"headerlink\" title=\"89 前端面试之hybrid\"></a>89 前端面试之hybrid</h3><blockquote>\n<p><a href=\"http://blog.poetries.top/2018/10/20/fe-interview-hybrid/\">http://blog.poetries.top/2018/10/20/fe-interview-hybrid/</a></p>\n</blockquote>\n<h3 id=\"90-前端面试之组件化\"><a href=\"#90-前端面试之组件化\" class=\"headerlink\" title=\"90 前端面试之组件化\"></a>90 前端面试之组件化</h3><blockquote>\n<p><a href=\"http://blog.poetries.top/2018/10/20/fe-interview-component/\">http://blog.poetries.top/2018/10/20/fe-interview-component/</a></p>\n</blockquote>\n<h3 id=\"91-前端面试之MVVM浅析\"><a href=\"#91-前端面试之MVVM浅析\" class=\"headerlink\" title=\"91 前端面试之MVVM浅析\"></a>91 前端面试之MVVM浅析</h3><blockquote>\n<p><a href=\"http://blog.poetries.top/2018/10/20/fe-interview-mvvm/\">http://blog.poetries.top/2018/10/20/fe-interview-mvvm/</a></p>\n</blockquote>\n<h3 id=\"92-实现效果，点击容器内的图标，图标边框变成border-1px-solid-red，点击空白处重置\"><a href=\"#92-实现效果，点击容器内的图标，图标边框变成border-1px-solid-red，点击空白处重置\" class=\"headerlink\" title=\"92 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置\"></a>92 实现效果，点击容器内的图标，图标边框变成border 1px solid red，点击空白处重置</h3><p>const box = document.getElementById(‘box’);function isIcon(target) {<br>  return target.className.includes(‘icon’);}box.onClick = function(e) {<br>  e.stopPropagation();<br>  const target = e.target;<br>  if (isIcon(target)) {<br>    target.style.border = ‘1px solid red’;<br>  }}const doc = document;doc.onclick = function(e) {<br>  const children = box.children;<br>  for(let i; i &lt; children.length; i++) {<br>    if (isIcon(children[i])) {<br>      children[i].style.border = ‘none’;<br>    }<br>  }}</p>\n<h3 id=\"93-请简单实现双向数据绑定mvvm\"><a href=\"#93-请简单实现双向数据绑定mvvm\" class=\"headerlink\" title=\"93 请简单实现双向数据绑定mvvm\"></a>93 请简单实现双向数据绑定<code>mvvm</code></h3><p><input id=\"input\"/></p>\n<p>const data = {};const input = document.getElementById(‘input’);Object.defineProperty(data, ‘text’, {<br>  set(value) {<br>    input.value = value;<br>    this.value = value;<br>  }});input.onChange = function(e) {<br>  data.text = e.target.value;}</p>\n<h3 id=\"94-实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem-key-value-和getItem-key\"><a href=\"#94-实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem-key-value-和getItem-key\" class=\"headerlink\" title=\"94 实现Storage，使得该对象为单例，并对localStorage进行封装设置值setItem(key,value)和getItem(key)\"></a>94 实现Storage，使得该对象为单例，并对<code>localStorage</code>进行封装设置值setItem(key,value)和getItem(key)</h3><p>var instance = null;class Storage {<br>  static getInstance() {<br>    if (!instance) {<br>      instance = new Storage();<br>    }<br>    return instance;<br>  }<br>  setItem = (key, value) =&gt; localStorage.setItem(key, value),<br>  getItem = key =&gt; localStorage.getItem(key)}</p>\n<h3 id=\"95-说说event-loop\"><a href=\"#95-说说event-loop\" class=\"headerlink\" title=\"95 说说event loop\"></a>95 说说<code>event loop</code></h3><blockquote>\n<p>首先，<code>js</code>是单线程的，主要的任务是处理用户的交互，而用户的交互无非就是响应<code>DOM</code>的增删改，使用事件队列的形式，一次事件循环只处理一个事件响应，使得脚本执行相对连续，所以有了事件队列，用来储存待执行的事件，那么事件队列的事件从哪里被<code>push</code>进来的呢。那就是另外一个线程叫事件触发线程做的事情了，他的作用主要是在定时触发器线程、异步<code>HTTP</code>请求线程满足特定条件下的回调函数<code>push</code>到事件队列中，等待<code>js</code>引擎空闲的时候去执行，当然js引擎执行过程中有优先级之分，首先js引擎在一次事件循环中，会先执行js线程的主任务，然后会去查找是否有微任务<code>microtask（promise）</code>，如果有那就优先执行微任务，如果没有，在去查找宏任务<code>macrotask（setTimeout、setInterval）</code>进行执行</p>\n</blockquote>\n<h3 id=\"96-说说事件流\"><a href=\"#96-说说事件流\" class=\"headerlink\" title=\"96 说说事件流\"></a>96 说说事件流</h3><p>事件流分为两种，捕获事件流和冒泡事件流</p>\n<ul>\n<li>  捕获事件流从根节点开始执行，一直往子节点查找执行，直到查找执行到目标节点</li>\n<li>  冒泡事件流从目标节点开始执行，一直往父节点冒泡查找执行，直到查到到根节点</li>\n</ul>\n<blockquote>\n<p>事件流分为三个阶段，一个是捕获节点，一个是处于目标节点阶段，一个是冒泡阶段</p>\n</blockquote>\n<h3 id=\"97-为什么canvas的图片为什么过有跨域问题\"><a href=\"#97-为什么canvas的图片为什么过有跨域问题\" class=\"headerlink\" title=\"97 为什么canvas的图片为什么过有跨域问题\"></a>97 为什么<code>canvas</code>的图片为什么过有跨域问题</h3><h3 id=\"98-我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块\"><a href=\"#98-我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块\" class=\"headerlink\" title=\"98 我现在有一个canvas，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块\"></a>98 我现在有一个<code>canvas</code>，上面随机布着一些黑块，请实现方法，计算canvas上有多少个黑块</h3><blockquote>\n<p><a href=\"https://www.jianshu.com/p/f54d265f7aa4\">https://www.jianshu.com/p/f54d265f7aa4</a></p>\n</blockquote>\n<h3 id=\"99-请手写实现一个promise\"><a href=\"#99-请手写实现一个promise\" class=\"headerlink\" title=\"99 请手写实现一个promise\"></a>99 请手写实现一个<code>promise</code></h3><blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000013396601\">https://segmentfault.com/a/1190000013396601</a></p>\n</blockquote>\n<h3 id=\"100-说说从输入URL到看到页面发生的全过程，越详细越好\"><a href=\"#100-说说从输入URL到看到页面发生的全过程，越详细越好\" class=\"headerlink\" title=\"100 说说从输入URL到看到页面发生的全过程，越详细越好\"></a>100 说说从输入URL到看到页面发生的全过程，越详细越好</h3><ul>\n<li>  首先浏览器主进程接管，开了一个下载线程。</li>\n<li>  然后进行HTTP请求（DNS查询、IP寻址等等），中间会有三次捂手，等待响应，开始下载响应报文。</li>\n<li>  将下载完的内容转交给Renderer进程管理。</li>\n<li>  Renderer进程开始解析css rule tree和dom tree，这两个过程是并行的，所以一般我会把link标签放在页面顶部。</li>\n<li>  解析绘制过程中，当浏览器遇到link标签或者script、img等标签，浏览器会去下载这些内容，遇到时候缓存的使用缓存，不适用缓存的重新下载资源。</li>\n<li>  css rule tree和dom tree生成完了之后，开始合成render tree，这个时候浏览器会进行layout，开始计算每一个节点的位置，然后进行绘制。</li>\n<li>  绘制结束后，关闭TCP连接，过程有四次挥手</li>\n</ul>\n<h3 id=\"101-描述一下this\"><a href=\"#101-描述一下this\" class=\"headerlink\" title=\"101 描述一下this\"></a>101 描述一下<code>this</code></h3><blockquote>\n<p><code>this</code>，函数执行的上下文，可以通过<code>apply</code>，<code>call</code>，<code>bind</code>改变<code>this</code>的指向。对于匿名函数或者直接调用的函数来说，this指向全局上下文（浏览器为window，NodeJS为<code>global</code>），剩下的函数调用，那就是谁调用它，<code>this</code>就指向谁。当然还有es6的箭头函数，箭头函数的指向取决于该箭头函数声明的位置，在哪里声明，<code>this</code>就指向哪里</p>\n</blockquote>\n<h3 id=\"102-说一下浏览器的缓存机制\"><a href=\"#102-说一下浏览器的缓存机制\" class=\"headerlink\" title=\"102 说一下浏览器的缓存机制\"></a>102 说一下浏览器的缓存机制</h3><blockquote>\n<p>浏览器缓存机制有两种，一种为强缓存，一种为协商缓存</p>\n</blockquote>\n<ul>\n<li>  对于强缓存，浏览器在第一次请求的时候，会直接下载资源，然后缓存在本地，第二次请求的时候，直接使用缓存。</li>\n<li>  对于协商缓存，第一次请求缓存且保存缓存标识与时间，重复请求向服务器发送缓存标识和最后缓存时间，服务端进行校验，如果失效则使用缓存</li>\n</ul>\n<p>协商缓存相关设置</p>\n<ul>\n<li>  <code>Exprires</code>：服务端的响应头，第一次请求的时候，告诉客户端，该资源什么时候会过期。<code>Exprires</code>的缺陷是必须保证服务端时间和客户端时间严格同步。</li>\n<li>  <code>Cache-control：max-age</code>：表示该资源多少时间后过期，解决了客户端和服务端时间必须同步的问题，</li>\n<li>  <code>If-None-Match/ETag</code>：缓存标识，对比缓存时使用它来标识一个缓存，第一次请求的时候，服务端会返回该标识给客户端，客户端在第二次请求的时候会带上该标识与服务端进行对比并返回<code>If-None-Match</code>标识是否表示匹配。</li>\n<li>  <code>Last-modified/If-Modified-Since</code>：第一次请求的时候服务端返回<code>Last-modified</code>表明请求的资源上次的修改时间，第二次请求的时候客户端带上请求头<code>If-Modified-Since</code>，表示资源上次的修改时间，服务端拿到这两个字段进行对比</li>\n</ul>\n<h3 id=\"103-现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？\"><a href=\"#103-现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？\" class=\"headerlink\" title=\"103 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？\"></a>103 现在要你完成一个Dialog组件，说说你设计的思路？它应该有什么功能？</h3><ul>\n<li>  该组件需要提供<code>hook</code>指定渲染位置，默认渲染在body下面。</li>\n<li>  然后改组件可以指定外层样式，如宽度等</li>\n<li>  组件外层还需要一层<code>mask</code>来遮住底层内容，点击<code>mask</code>可以执行传进来的<code>onCancel</code>函数关闭<code>Dialog</code>。</li>\n<li>  另外组件是可控的，需要外层传入<code>visible</code>表示是否可见。</li>\n<li>  然后<code>Dialog</code>可能需要自定义头head和底部<code>footer</code>，默认有头部和底部，底部有一个确认按钮和取消按钮，确认按钮会执行外部传进来的<code>onOk</code>事件，然后取消按钮会执行外部传进来的<code>onCancel</code>事件。</li>\n<li>  当组件的<code>visible</code>为<code>true</code>时候，设置<code>body</code>的<code>overflow</code>为<code>hidden</code>，隐藏<code>body</code>的滚动条，反之显示滚动条。</li>\n<li>  组件高度可能大于页面高度，组件内部需要滚动条。</li>\n<li>  只有组件的<code>visible</code>有变化且为<code>ture</code>时候，才重渲染组件内的所有内容</li>\n</ul>\n<h3 id=\"104-caller和callee的区别\"><a href=\"#104-caller和callee的区别\" class=\"headerlink\" title=\"104 caller和callee的区别\"></a>104 <code>caller</code>和<code>callee</code>的区别</h3><p>callee</p>\n<blockquote>\n<p><code>caller</code>返回一个函数的引用，这个函数调用了当前的函数。</p>\n</blockquote>\n<p>使用这个属性要注意</p>\n<ul>\n<li>  这个属性只有当函数在执行时才有用</li>\n<li>  如果在<code>javascript</code>程序中，函数是由顶层调用的，则返回<code>null</code></li>\n</ul>\n<blockquote>\n<p><code>functionName.caller: functionName</code>是当前正在执行的函数。</p>\n</blockquote>\n<p>function a() {<br>  console.log(a.caller)}</p>\n<p>callee</p>\n<blockquote>\n<p><code>callee</code>放回正在执行的函数本身的引用，它是<code>arguments</code>的一个属性</p>\n</blockquote>\n<blockquote>\n<p>使用callee时要注意:</p>\n</blockquote>\n<ul>\n<li>  这个属性只有在函数执行时才有效</li>\n<li>  它有一个<code>length</code>属性，可以用来获得形参的个数，因此可以用来比较形参和实参个数是否一致，即比较<code>arguments.length</code>是否等于<code>arguments.callee.length</code></li>\n<li>  它可以用来递归匿名函数。</li>\n</ul>\n<p>function a() {<br>  console.log(arguments.callee)}</p>\n<h3 id=\"105-ajax、axios、fetch区别\"><a href=\"#105-ajax、axios、fetch区别\" class=\"headerlink\" title=\"105 ajax、axios、fetch区别\"></a>105 ajax、axios、fetch区别</h3><p>jQuery ajax</p>\n<p>$.ajax({<br>   type: ‘POST’,<br>   url: url,<br>   data: data,<br>   dataType: dataType,<br>   success: function () {},<br>   error: function () {}});</p>\n<p>优缺点：</p>\n<ul>\n<li>  本身是针对<code>MVC</code>的编程,不符合现在前端<code>MVVM</code>的浪潮</li>\n<li>  基于原生的<code>XHR</code>开发，<code>XHR</code>本身的架构不清晰，已经有了<code>fetch</code>的替代方案</li>\n<li>  <code>JQuery</code>整个项目太大，单纯使用<code>ajax</code>却要引入整个<code>JQuery</code>非常的不合理（采取个性化打包的方案又不能享受CDN服务）</li>\n</ul>\n<p>axios</p>\n<p>axios({<br>    method: ‘post’,<br>    url: ‘/user/12345’,<br>    data: {<br>        firstName: ‘Fred’,<br>        lastName: ‘Flintstone’<br>    }}).then(function (response) {<br>    console.log(response);}).catch(function (error) {<br>    console.log(error);});</p>\n<p>优缺点：</p>\n<ul>\n<li>  从浏览器中创建 <code>XMLHttpRequest</code></li>\n<li>  从 <code>node.js</code> 发出 <code>http</code> 请求</li>\n<li>  支持 <code>Promise API</code></li>\n<li>  拦截请求和响应</li>\n<li>  转换请求和响应数据</li>\n<li>  取消请求</li>\n<li>  自动转换<code>JSON</code>数据</li>\n<li>  客户端支持防止<code>CSRF/XSRF</code></li>\n</ul>\n<p>fetch</p>\n<p>try {<br>  let response = await fetch(url);<br>  let data = response.json();<br>  console.log(data);} catch(e) {<br>  console.log(“Oops, error”, e);}</p>\n<p>优缺点：</p>\n<ul>\n<li>  <code>fetcht</code>只对网络请求报错，对<code>400</code>，<code>500</code>都当做成功的请求，需要封装去处理</li>\n<li>  <code>fetch</code>默认不会带<code>cookie</code>，需要添加配置项</li>\n<li>  <code>fetch</code>不支持<code>abort</code>，不支持超时控制，使用<code>setTimeout</code>及<code>Promise.reject</code>的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li>\n<li>  <code>fetch</code>没有办法原生监测请求的进度，而XHR可以</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckmp2698z0000c8gsc1e52d11","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp2699m0006c8gs682ma05w"},{"post_id":"ckmp2699f0001c8gs47a25pe1","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp2699o0009c8gsdnsa67zc"},{"post_id":"ckmp2699j0003c8gs87jf4qq0","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp2699s000cc8gscvuy5y4k"},{"post_id":"ckmp2699l0005c8gsecdrb042","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp2699u000fc8gsenzegapt"},{"post_id":"ckmp2699n0008c8gsamks9en0","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp2699z000ic8gsawzv5cwj"},{"post_id":"ckmp2699q000bc8gs27b5g7w5","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269a1000lc8gsfplwbamw"},{"post_id":"ckmp2699t000ec8gs7qj07zpp","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269a3000oc8gsfujs51dj"},{"post_id":"ckmp2699v000hc8gs6j6xa69r","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269a4000qc8gsbd3a2pti"},{"post_id":"ckmp269a0000kc8gshj7n1vqn","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269a7000tc8gshcsdcu7n"},{"post_id":"ckmp269a2000nc8gsb44m7eib","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269ac000wc8gsh0ab3m3s"},{"post_id":"ckmp269a3000pc8gs63qh1hej","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269ae000zc8gshab2caca"},{"post_id":"ckmp269a6000sc8gs2gcr7ydm","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269ah0012c8gs5bj7eu16"},{"post_id":"ckmp269a8000vc8gs717m6xpp","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269ak0015c8gsbx6705vb"},{"post_id":"ckmp269ad000yc8gse3wteujx","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269am0018c8gs3lq3fike"},{"post_id":"ckmp269ag0011c8gs6tesdhk3","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp269b0001bc8gs8h7e0iw3"},{"post_id":"ckmp269ai0014c8gs0ss67kvs","category_id":"ckmozz5kn001g7jgs4rsl6d11","_id":"ckmp269b3001ec8gsgsid5grb"},{"post_id":"ckmp269ak0017c8gsemwt9h23","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp269b5001hc8gsbh9pb7bf"},{"post_id":"ckmp269an001ac8gshpqag94v","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269b7001kc8gs827c139y"},{"post_id":"ckmp269b0001dc8gsg2ro703j","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269bb001nc8gs87fs3wd3"},{"post_id":"ckmp269b3001gc8gs3ff6ba8i","category_id":"ckmozz5kn001g7jgs4rsl6d11","_id":"ckmp269bf001qc8gsbtcvcgqm"},{"post_id":"ckmp269b6001jc8gsb2g8etil","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp269bi001tc8gsg80xau78"},{"post_id":"ckmp269b7001mc8gsdbtzaxny","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp269bk001wc8gsbyge61m7"},{"post_id":"ckmp269bd001pc8gs0ctmemmy","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269bq001zc8gs30aaa7fq"},{"post_id":"ckmp269bg001sc8gs6plu6ng4","category_id":"ckmozz5kn001g7jgs4rsl6d11","_id":"ckmp269bu0021c8gs9alvad5i"},{"post_id":"ckmp269bj001vc8gs56b0e99i","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269bv0024c8gscnhe03w4"},{"post_id":"ckmp269bl001yc8gsbpd052gs","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269bx0027c8gs5sxw8h62"},{"post_id":"ckmp269bs0020c8gs3v7ta2jz","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269bz002ac8gseyfn0daz"},{"post_id":"ckmp269bu0023c8gs8gld6ine","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269cb002dc8gsdf4b6o90"},{"post_id":"ckmp269bw0026c8gsazrefb2l","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp269cc002gc8gsfouebkz6"},{"post_id":"ckmp269bx0029c8gs2qsv1hf5","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269ci002jc8gs236r7j6w"},{"post_id":"ckmp269c0002cc8gs6rrchqqg","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269cr002mc8gsembz491z"},{"post_id":"ckmp269cb002fc8gs43th8y6h","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269cv002pc8gsbb135bhg"},{"post_id":"ckmp269cf002ic8gsa0qh9xxh","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269cx002sc8gs2pkk8bnn"},{"post_id":"ckmp269cq002lc8gse06welvf","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269cy002vc8gsh4gt0uvb"},{"post_id":"ckmp269cs002oc8gsdgf288t8","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269da002yc8gscegma1qp"},{"post_id":"ckmp269cw002rc8gs5gqub2vw","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269dd0031c8gsg4px3dwb"},{"post_id":"ckmp269cy002uc8gs4d94evyn","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269df0034c8gsdatdgx5y"},{"post_id":"ckmp269cz002xc8gsfqr8gocn","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269dr0037c8gs0byx5dhk"},{"post_id":"ckmp269dc0030c8gs417p1plq","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269ds003ac8gs2qdk5ktq"},{"post_id":"ckmp269de0033c8gs7cwse9kt","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269du003dc8gs2qo94ett"},{"post_id":"ckmp269dg0036c8gs4lk5d0mu","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269e7003gc8gsf30s2snq"},{"post_id":"ckmp269dr0039c8gsatblhyir","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269ec003jc8gs3dee1dt5"},{"post_id":"ckmp269dt003cc8gs82csgpgv","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269ep003mc8gshhm1gwqv"},{"post_id":"ckmp269dv003fc8gsd06gb405","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269eq003pc8gs6164hvgt"},{"post_id":"ckmp269e9003ic8gseb161fy8","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269es003sc8gs9gowg0sh"},{"post_id":"ckmp269ec003lc8gsbura7m34","category_id":"ckmozz5kn001g7jgs4rsl6d11","_id":"ckmp269ez003vc8gsbxqfh9gv"},{"post_id":"ckmp269eq003oc8gs4c8j22e6","category_id":"ckmozz5kn001g7jgs4rsl6d11","_id":"ckmp269f1003yc8gs8bg2awpw"},{"post_id":"ckmp269er003rc8gs8tbqg1sa","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269f30041c8gs272h2qev"},{"post_id":"ckmp269et003uc8gs1gkggeml","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269f50044c8gs06c711fq"},{"post_id":"ckmp269ez003xc8gse69ogobn","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269f60047c8gsaeukf7zw"},{"post_id":"ckmp269f10040c8gs9ct9ee1m","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269f7004ac8gs5n2d96t8"},{"post_id":"ckmp269f40043c8gsgoly787g","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269f8004dc8gs74rl7su9"},{"post_id":"ckmp269f50046c8gsatrk6es9","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269fl004gc8gsch2k9r46"},{"post_id":"ckmp269f70049c8gsdjlb39md","category_id":"ckmozz5jt000j7jgsgrggedb3","_id":"ckmp269fm004jc8gscdgf4tz1"},{"post_id":"ckmp269f7004cc8gs04q7bh82","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269fn004mc8gs48kq8ny8"},{"post_id":"ckmp269fl004ic8gsgqo20ukf","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269fo004pc8gs91s4cyps"},{"post_id":"ckmp269fm004lc8gsb7prbmw7","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp269fq004rc8gs90vkej3w"},{"post_id":"ckmp269fn004nc8gsbtmybkit","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269fy004tc8gshumh2ybi"},{"post_id":"ckmp269fn004nc8gsbtmybkit","category_id":"ckmozz5nf004z7jgs90s8490t","_id":"ckmp269fz004wc8gsgifagfyf"},{"post_id":"ckmp269fo004oc8gsbi4jceop","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269g0004zc8gs1opwdtrq"},{"post_id":"ckmp269fo004oc8gsbi4jceop","category_id":"ckmozz5nf004z7jgs90s8490t","_id":"ckmp269g10052c8gsh6ojbn1h"},{"post_id":"ckmp269fq004qc8gs96y725vd","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269g10054c8gsgjnr7sf2"},{"post_id":"ckmp269fq004qc8gs96y725vd","category_id":"ckmozz5nm005c7jgshvpmdalu","_id":"ckmp269g10055c8gs2let2725"},{"post_id":"ckmp269fs004sc8gs1dibe0t8","category_id":"ckmozz5kn001g7jgs4rsl6d11","_id":"ckmp269g10056c8gs189dggjs"},{"post_id":"ckmp269fy004vc8gs96ffd9zs","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp269g20057c8gs1t6q8wgq"},{"post_id":"ckmp269fz004yc8gsev8x0gmy","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp269g20058c8gs9zclbuhz"},{"post_id":"ckmp269g00051c8gs573g3lvj","category_id":"ckmozz5j700027jgs55hegb32","_id":"ckmp269g20059c8gsa5ze25gu"},{"post_id":"ckmp269g5005ac8gsep10hthh","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269gg005gc8gsc1x01oxi"},{"post_id":"ckmp269g5005ac8gsep10hthh","category_id":"ckmozz5nf004z7jgs90s8490t","_id":"ckmp269gh005jc8gsgmykeun5"},{"post_id":"ckmp269g6005bc8gsh0tedv4i","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269gi005mc8gsgwb362zd"},{"post_id":"ckmp269g6005bc8gsh0tedv4i","category_id":"ckmozz5nf004z7jgs90s8490t","_id":"ckmp269gj005oc8gsblfh4q6w"},{"post_id":"ckmp269gd005dc8gsa3dgbo70","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269gj005qc8gs3c22glgl"},{"post_id":"ckmp269gd005dc8gsa3dgbo70","category_id":"ckmozz5nf004z7jgs90s8490t","_id":"ckmp269gj005sc8gs6a3thuak"},{"post_id":"ckmp269ge005fc8gs7panb3a2","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269gj005uc8gscnxqdkoe"},{"post_id":"ckmp269gg005ic8gs3mpy89os","category_id":"ckmozz5kj00197jgs38eeclab","_id":"ckmp269gj005vc8gs5t971t68"},{"post_id":"ckmp269gi005lc8gs79059zar","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269gk005wc8gsfqt80hck"},{"post_id":"ckmp269gn005xc8gsdp4x75sy","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269go0060c8gsap0422uq"},{"post_id":"ckmp269gn005xc8gsdp4x75sy","category_id":"ckmozz5nf004z7jgs90s8490t","_id":"ckmp269go0061c8gsf2tp0mz7"},{"post_id":"ckmp269gx0062c8gs8e05hepl","category_id":"ckmozz5jo000b7jgs8lftdzw0","_id":"ckmp269gy0065c8gs31ssf6eu"},{"post_id":"ckmp269gx0062c8gs8e05hepl","category_id":"ckmozz5nf004z7jgs90s8490t","_id":"ckmp269gy0066c8gs5prhadri"}],"PostTag":[{"post_id":"ckmp2698z0000c8gsc1e52d11","tag_id":"ckmozz5ja00037jgsadey4j3h","_id":"ckmp2699j0002c8gs3ffl10aj"},{"post_id":"ckmp2698z0000c8gsc1e52d11","tag_id":"ckmozz5jg00087jgs11m7c6zj","_id":"ckmp2699l0004c8gs765jc3j8"},{"post_id":"ckmp2699f0001c8gs47a25pe1","tag_id":"ckmozz5jo000d7jgs0nkghpvn","_id":"ckmp2699n0007c8gs9dis0n8d"},{"post_id":"ckmp2699j0003c8gs87jf4qq0","tag_id":"ckmozz5ju000k7jgsf1j40cj0","_id":"ckmp2699p000ac8gs6gjnhmiq"},{"post_id":"ckmp2699n0008c8gsamks9en0","tag_id":"ckmozz5jy000q7jgs6diebstt","_id":"ckmp2699t000dc8gsh4jfgabm"},{"post_id":"ckmp2699q000bc8gs27b5g7w5","tag_id":"ckmozz5ju000k7jgsf1j40cj0","_id":"ckmp2699v000gc8gs00pagcd0"},{"post_id":"ckmp2699q000bc8gs27b5g7w5","tag_id":"ckmozz5ke00167jgs4qh724qe","_id":"ckmp269a0000jc8gs1diu32rb"},{"post_id":"ckmp2699t000ec8gs7qj07zpp","tag_id":"ckmozz5kl001c7jgshhvgcmvt","_id":"ckmp269a2000mc8gs6juw6pcj"},{"post_id":"ckmp269a2000nc8gsb44m7eib","tag_id":"ckmozz5ko001k7jgs45wr3sk0","_id":"ckmp269a5000rc8gsgnah8efc"},{"post_id":"ckmp269a3000pc8gs63qh1hej","tag_id":"ckmozz5ks001r7jgs3gbe32bd","_id":"ckmp269a7000uc8gs55484x58"},{"post_id":"ckmp269a3000pc8gs63qh1hej","tag_id":"ckmozz5kv001z7jgsb32c6g99","_id":"ckmp269ac000xc8gs34q2ei0a"},{"post_id":"ckmp269a8000vc8gs717m6xpp","tag_id":"ckmozz5kz00247jgscs3kbl60","_id":"ckmp269af0010c8gs5ti30cu8"},{"post_id":"ckmp269ad000yc8gse3wteujx","tag_id":"ckmozz5kz00247jgscs3kbl60","_id":"ckmp269ah0013c8gsbtjm826d"},{"post_id":"ckmp269ag0011c8gs6tesdhk3","tag_id":"ckmozz5lj002h7jgsfegm25b7","_id":"ckmp269ak0016c8gsado5flld"},{"post_id":"ckmp269ag0011c8gs6tesdhk3","tag_id":"ckmozz5jg00087jgs11m7c6zj","_id":"ckmp269an0019c8gs0r792o0l"},{"post_id":"ckmp269ai0014c8gs0ss67kvs","tag_id":"ckmozz5ln002n7jgsb20fhom4","_id":"ckmp269b0001cc8gsgets3u5r"},{"post_id":"ckmp269ak0017c8gsemwt9h23","tag_id":"ckmozz5lr002w7jgs2f9s4e22","_id":"ckmp269b3001fc8gs6ht75tos"},{"post_id":"ckmp269ak0017c8gsemwt9h23","tag_id":"ckmozz5lu00327jgsg4os2nis","_id":"ckmp269b5001ic8gsaxwp6q8l"},{"post_id":"ckmp269b3001gc8gs3ff6ba8i","tag_id":"ckmozz5lw00377jgsakare9hm","_id":"ckmp269b7001lc8gs0cq90ody"},{"post_id":"ckmp269b6001jc8gsb2g8etil","tag_id":"ckmozz5m0003e7jgsg4sh3x51","_id":"ckmp269bb001oc8gs3sit4irq"},{"post_id":"ckmp269b6001jc8gsb2g8etil","tag_id":"ckmozz5ja00037jgsadey4j3h","_id":"ckmp269bf001rc8gs5igzfhu3"},{"post_id":"ckmp269b6001jc8gsb2g8etil","tag_id":"ckmozz5mc003m7jgs1tw45w84","_id":"ckmp269bj001uc8gs3self413"},{"post_id":"ckmp269b7001mc8gsdbtzaxny","tag_id":"ckmozz5lu00327jgsg4os2nis","_id":"ckmp269bl001xc8gsesfo1it6"},{"post_id":"ckmp269bl001yc8gsbpd052gs","tag_id":"ckmozz5mm003z7jgs6n9ue9cn","_id":"ckmp269bu0022c8gs66gn515x"},{"post_id":"ckmp269bs0020c8gs3v7ta2jz","tag_id":"ckmozz5ms00467jgsdgri7hje","_id":"ckmp269bv0025c8gscbq3hhx1"},{"post_id":"ckmp269bu0023c8gs8gld6ine","tag_id":"ckmozz5mx004c7jgs1xhf4nb5","_id":"ckmp269bx0028c8gs9uc16u6r"},{"post_id":"ckmp269bw0026c8gsazrefb2l","tag_id":"ckmozz5n4004k7jgs26l6a01k","_id":"ckmp269c0002bc8gs0g3cfgtg"},{"post_id":"ckmp269bw0026c8gsazrefb2l","tag_id":"ckmozz5jo000d7jgs0nkghpvn","_id":"ckmp269cb002ec8gs57wo2261"},{"post_id":"ckmp269c0002cc8gs6rrchqqg","tag_id":"ckmozz5n9004q7jgs00x73jhb","_id":"ckmp269cf002hc8gsey1z1hiv"},{"post_id":"ckmp269c0002cc8gs6rrchqqg","tag_id":"ckmozz5nd004x7jgs01otgn27","_id":"ckmp269cq002kc8gs1l9hdili"},{"post_id":"ckmp269c0002cc8gs6rrchqqg","tag_id":"ckmozz5nh00537jgsa9cp4awl","_id":"ckmp269cr002nc8gs5yzaf8w4"},{"post_id":"ckmp269c0002cc8gs6rrchqqg","tag_id":"ckmozz5nm005b7jgseiac3woj","_id":"ckmp269cw002qc8gs64653w2y"},{"post_id":"ckmp269cs002oc8gsdgf288t8","tag_id":"ckmozz5nn005f7jgsg64tadid","_id":"ckmp269cy002tc8gs8qni1hr3"},{"post_id":"ckmp269cs002oc8gsdgf288t8","tag_id":"ckmozz5np005k7jgs1q7rf43c","_id":"ckmp269cz002wc8gs94excziv"},{"post_id":"ckmp269cs002oc8gsdgf288t8","tag_id":"ckmozz5nq005p7jgsakj1gkrz","_id":"ckmp269db002zc8gsh4sx7swn"},{"post_id":"ckmp269cy002uc8gs4d94evyn","tag_id":"ckmozz5nq005t7jgs7wjhg6ov","_id":"ckmp269de0032c8gsdo7td5c5"},{"post_id":"ckmp269cy002uc8gs4d94evyn","tag_id":"ckmozz5nr005x7jgs060y1zan","_id":"ckmp269dg0035c8gsfc6mehbc"},{"post_id":"ckmp269cy002uc8gs4d94evyn","tag_id":"ckmozz5nr005z7jgs4z7t8ux8","_id":"ckmp269dr0038c8gscm8w6ozl"},{"post_id":"ckmp269cz002xc8gsfqr8gocn","tag_id":"ckmozz5ns00607jgs9y4s1syj","_id":"ckmp269dt003bc8gs5ngh6w2l"},{"post_id":"ckmp269cz002xc8gsfqr8gocn","tag_id":"ckmozz5nt00637jgs20od0gmq","_id":"ckmp269du003ec8gs8mzh1e7t"},{"post_id":"ckmp269dc0030c8gs417p1plq","tag_id":"ckmozz5nt00657jgs43jga1l4","_id":"ckmp269e8003hc8gs8ksdf525"},{"post_id":"ckmp269dc0030c8gs417p1plq","tag_id":"ckmozz5nu00687jgs6wk919ae","_id":"ckmp269ec003kc8gs697yedcv"},{"post_id":"ckmp269de0033c8gs7cwse9kt","tag_id":"ckmozz5nv00697jgsc1a4gpb2","_id":"ckmp269ep003nc8gsejlzctl4"},{"post_id":"ckmp269de0033c8gs7cwse9kt","tag_id":"ckmozz5nv006c7jgs8wnoetnc","_id":"ckmp269er003qc8gs71xzb4tl"},{"post_id":"ckmp269de0033c8gs7cwse9kt","tag_id":"ckmozz5nw006d7jgsdsmz5wem","_id":"ckmp269et003tc8gsgdw4a259"},{"post_id":"ckmp269dg0036c8gs4lk5d0mu","tag_id":"ckmozz5nw006e7jgs4ec3ex4a","_id":"ckmp269ez003wc8gs6h1x52xa"},{"post_id":"ckmp269dr0039c8gsatblhyir","tag_id":"ckmozz5nw006e7jgs4ec3ex4a","_id":"ckmp269f1003zc8gs1l0l1101"},{"post_id":"ckmp269dv003fc8gsd06gb405","tag_id":"ckmozz5nx006k7jgs1tqi4wsw","_id":"ckmp269f40042c8gs4xrn2lw0"},{"post_id":"ckmp269e9003ic8gseb161fy8","tag_id":"ckmozz5kz00247jgscs3kbl60","_id":"ckmp269f50045c8gsaaecbpq1"},{"post_id":"ckmp269et003uc8gs1gkggeml","tag_id":"ckmozz5ny006m7jgscldxcysw","_id":"ckmp269f60048c8gs2tqq0fir"},{"post_id":"ckmp269f10040c8gs9ct9ee1m","tag_id":"ckmozz5nz006o7jgsad99eipp","_id":"ckmp269f7004bc8gsfz5hequu"},{"post_id":"ckmp269f10040c8gs9ct9ee1m","tag_id":"ckmozz5o0006q7jgs12o9eouv","_id":"ckmp269fk004ec8gs6p0145rl"},{"post_id":"ckmp269f10040c8gs9ct9ee1m","tag_id":"ckmozz5o1006r7jgsh1or031m","_id":"ckmp269fl004hc8gsc7ut0xr3"},{"post_id":"ckmp269f70049c8gsdjlb39md","tag_id":"ckmozz5o2006s7jgs5xl1bbzc","_id":"ckmp269fm004kc8gsc88c4clp"},{"post_id":"ckmp269fq004qc8gs96y725vd","tag_id":"ckmozz5o3006v7jgs0aen813f","_id":"ckmp269fy004uc8gsavim2y8t"},{"post_id":"ckmp269fq004qc8gs96y725vd","tag_id":"ckmozz5o6006y7jgs0yh499ce","_id":"ckmp269fz004xc8gsee5x5cbm"},{"post_id":"ckmp269fy004vc8gs96ffd9zs","tag_id":"ckmozz5jg00087jgs11m7c6zj","_id":"ckmp269g00050c8gs0ycca0mb"},{"post_id":"ckmp269fy004vc8gs96ffd9zs","tag_id":"ckmozz5o6006z7jgs9b8m5huu","_id":"ckmp269g10053c8gs606rcps8"},{"post_id":"ckmp269g5005ac8gsep10hthh","tag_id":"ckmozz5oo00767jgsba3b7dk6","_id":"ckmp269gc005cc8gs0uwpb9yd"},{"post_id":"ckmp269g6005bc8gsh0tedv4i","tag_id":"ckmozz5ot007b7jgscjueamzz","_id":"ckmp269ge005ec8gs5osr023a"},{"post_id":"ckmp269g6005bc8gsh0tedv4i","tag_id":"ckmozz5oo00767jgsba3b7dk6","_id":"ckmp269gg005hc8gsczb65auy"},{"post_id":"ckmp269gd005dc8gsa3dgbo70","tag_id":"ckmozz5ov007k7jgs8678blpq","_id":"ckmp269gh005kc8gsgdem0m3g"},{"post_id":"ckmp269gd005dc8gsa3dgbo70","tag_id":"ckmozz5oo00767jgsba3b7dk6","_id":"ckmp269gj005nc8gs4u586qh2"},{"post_id":"ckmp269ge005fc8gs7panb3a2","tag_id":"ckmozz5ox007r7jgs2t8wc9aj","_id":"ckmp269gj005pc8gse1jh52cx"},{"post_id":"ckmp269ge005fc8gs7panb3a2","tag_id":"ckmozz5oy007u7jgsdhakb05i","_id":"ckmp269gj005rc8gsgi2feitv"},{"post_id":"ckmp269gg005ic8gs3mpy89os","tag_id":"ckmozz5oz007v7jgscm4wgnfd","_id":"ckmp269gj005tc8gs4s6efsuf"},{"post_id":"ckmp269gn005xc8gsdp4x75sy","tag_id":"ckmozz5ju000k7jgsf1j40cj0","_id":"ckmp269go005yc8gs42u7d967"},{"post_id":"ckmp269gn005xc8gsdp4x75sy","tag_id":"ckmozz5oo00767jgsba3b7dk6","_id":"ckmp269go005zc8gsf7qih5xm"},{"post_id":"ckmp269gx0062c8gs8e05hepl","tag_id":"ckmozz5ju000k7jgsf1j40cj0","_id":"ckmp269gy0063c8gsa5lg2lj1"},{"post_id":"ckmp269gx0062c8gs8e05hepl","tag_id":"ckmozz5oo00767jgsba3b7dk6","_id":"ckmp269gy0064c8gs95gvfuka"}],"Tag":[{"name":"电影","_id":"ckmozz5ja00037jgsadey4j3h"},{"name":"高清","_id":"ckmozz5jg00087jgs11m7c6zj"},{"name":"影视","_id":"ckmozz5jo000d7jgs0nkghpvn"},{"name":"JavaScript","_id":"ckmozz5ju000k7jgsf1j40cj0"},{"name":"学习资源","_id":"ckmozz5jy000q7jgs6diebstt"},{"name":"前端","_id":"ckmozz5ke00167jgs4qh724qe"},{"name":"前端，盗链","_id":"ckmozz5kl001c7jgshhvgcmvt"},{"name":"scss","_id":"ckmozz5ko001k7jgs45wr3sk0"},{"name":"小游戏","_id":"ckmozz5ks001r7jgs3gbe32bd"},{"name":"源码","_id":"ckmozz5kv001z7jgsb32c6g99"},{"name":"前端，JavaScript","_id":"ckmozz5kz00247jgscs3kbl60"},{"name":"热门影视","_id":"ckmozz5lj002h7jgsfegm25b7"},{"name":"CDN","_id":"ckmozz5ln002n7jgsb20fhom4"},{"name":"复仇者联盟","_id":"ckmozz5lr002w7jgs2f9s4e22"},{"name":"电影资源","_id":"ckmozz5lu00327jgsg4os2nis"},{"name":"Linux","_id":"ckmozz5lw00377jgsakare9hm"},{"name":"漫威","_id":"ckmozz5m0003e7jgsg4sh3x51"},{"name":"科幻","_id":"ckmozz5mc003m7jgs1tw45w84"},{"name":"游戏","_id":"ckmozz5mm003z7jgs6n9ue9cn"},{"name":"解析，免费VIP","_id":"ckmozz5ms00467jgsdgri7hje"},{"name":"发卡系统","_id":"ckmozz5mx004c7jgs1xhf4nb5"},{"name":"在线播放","_id":"ckmozz5n4004k7jgs26l6a01k"},{"name":"Chrome","_id":"ckmozz5n9004q7jgs00x73jhb"},{"name":"插件","_id":"ckmozz5nd004x7jgs01otgn27"},{"name":"破解","_id":"ckmozz5nh00537jgsa9cp4awl"},{"name":"资源","_id":"ckmozz5nm005b7jgseiac3woj"},{"name":"Maccms","_id":"ckmozz5nn005f7jgsg64tadid"},{"name":"V10","_id":"ckmozz5np005k7jgs1q7rf43c"},{"name":"解析接口","_id":"ckmozz5nq005p7jgsakj1gkrz"},{"name":"Vue","_id":"ckmozz5nq005t7jgs7wjhg6ov"},{"name":"vue-titles","_id":"ckmozz5nr005x7jgs060y1zan"},{"name":"开源","_id":"ckmozz5nr005z7jgs4z7t8ux8"},{"name":"BT","_id":"ckmozz5ns00607jgs9y4s1syj"},{"name":"种子","_id":"ckmozz5nt00637jgs20od0gmq"},{"name":"maccms10","_id":"ckmozz5nt00657jgs43jga1l4"},{"name":"模板","_id":"ckmozz5nu00687jgs6wk919ae"},{"name":"eslint","_id":"ckmozz5nv00697jgsc1a4gpb2"},{"name":"JavaScrip","_id":"ckmozz5nv006c7jgs8wnoetnc"},{"name":"vue-cli","_id":"ckmozz5nw006d7jgsdsmz5wem"},{"name":"Git","_id":"ckmozz5nw006e7jgs4ec3ex4a"},{"name":"技巧","_id":"ckmozz5nx006k7jgs1tqi4wsw"},{"name":"Microsoft office","_id":"ckmozz5ny006m7jgscldxcysw"},{"name":"player","_id":"ckmozz5nz006o7jgsad99eipp"},{"name":"video-player","_id":"ckmozz5o0006q7jgs12o9eouv"},{"name":"开源 GitHub Vue","_id":"ckmozz5o1006r7jgsh1or031m"},{"name":"WordPress","_id":"ckmozz5o2006s7jgs5xl1bbzc"},{"name":"微信小程序","_id":"ckmozz5o3006v7jgs0aen813f"},{"name":"云开发","_id":"ckmozz5o6006y7jgs0yh499ce"},{"name":"在线影视","_id":"ckmozz5o6006z7jgs9b8m5huu"},{"name":"面试题","_id":"ckmozz5oo00767jgsba3b7dk6"},{"name":"类库","_id":"ckmozz5ot007b7jgscjueamzz"},{"name":"CSS","_id":"ckmozz5ov007k7jgs8678blpq"},{"name":"前端架构","_id":"ckmozz5ox007r7jgs2t8wc9aj"},{"name":"大型前端发布架构","_id":"ckmozz5oy007u7jgsdhakb05i"},{"name":"iOS，软件更新","_id":"ckmozz5oz007v7jgscm4wgnfd"}]}}